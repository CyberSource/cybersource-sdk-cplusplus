/* soapC.cpp
   Generated by gSOAP 2.8.32 for CyberSourceTransaction_nvp_1.129.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.32 2016-10-25 09:00:31 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_ULONG64:
		return soap_in_ULONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_wsc__FaultCodeType:
		return soap_in_wsc__FaultCodeType(soap, NULL, NULL, "wsc:FaultCodeType");
	case SOAP_TYPE_wsse__FaultcodeEnum:
		return soap_in_wsse__FaultcodeEnum(soap, NULL, NULL, "wsse:FaultcodeEnum");
	case SOAP_TYPE_wsu__tTimestampFault:
		return soap_in_wsu__tTimestampFault(soap, NULL, NULL, "wsu:tTimestampFault");
	case SOAP_TYPE_ns2__issuer:
		return soap_in_ns2__issuer(soap, NULL, NULL, "ns2:issuer");
	case SOAP_TYPE_ns2__BinLookupReply:
		return soap_in_ns2__BinLookupReply(soap, NULL, NULL, "ns2:BinLookupReply");
	case SOAP_TYPE_ns2__BinLookupService:
		return soap_in_ns2__BinLookupService(soap, NULL, NULL, "ns2:BinLookupService");
	case SOAP_TYPE_ns2__EncryptPaymentDataReply:
		return soap_in_ns2__EncryptPaymentDataReply(soap, NULL, NULL, "ns2:EncryptPaymentDataReply");
	case SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply:
		return soap_in_ns2__DecryptVisaCheckoutDataReply(soap, NULL, NULL, "ns2:DecryptVisaCheckoutDataReply");
	case SOAP_TYPE_ns2__VCCustomData:
		return soap_in_ns2__VCCustomData(soap, NULL, NULL, "ns2:VCCustomData");
	case SOAP_TYPE_ns2__VCCardArt:
		return soap_in_ns2__VCCardArt(soap, NULL, NULL, "ns2:VCCardArt");
	case SOAP_TYPE_ns2__VCReply:
		return soap_in_ns2__VCReply(soap, NULL, NULL, "ns2:VCReply");
	case SOAP_TYPE_ns2__AutoRentalData:
		return soap_in_ns2__AutoRentalData(soap, NULL, NULL, "ns2:AutoRentalData");
	case SOAP_TYPE_ns2__HostedDataRetrieveReply:
		return soap_in_ns2__HostedDataRetrieveReply(soap, NULL, NULL, "ns2:HostedDataRetrieveReply");
	case SOAP_TYPE_ns2__HostedDataCreateReply:
		return soap_in_ns2__HostedDataCreateReply(soap, NULL, NULL, "ns2:HostedDataCreateReply");
	case SOAP_TYPE_ns2__HostedDataRetrieveService:
		return soap_in_ns2__HostedDataRetrieveService(soap, NULL, NULL, "ns2:HostedDataRetrieveService");
	case SOAP_TYPE_ns2__HostedDataCreateService:
		return soap_in_ns2__HostedDataCreateService(soap, NULL, NULL, "ns2:HostedDataCreateService");
	case SOAP_TYPE_ns2__OriginalTransaction:
		return soap_in_ns2__OriginalTransaction(soap, NULL, NULL, "ns2:OriginalTransaction");
	case SOAP_TYPE_ns2__EmvReply:
		return soap_in_ns2__EmvReply(soap, NULL, NULL, "ns2:EmvReply");
	case SOAP_TYPE_ns2__EmvRequest:
		return soap_in_ns2__EmvRequest(soap, NULL, NULL, "ns2:EmvRequest");
	case SOAP_TYPE_ns2__ServiceFee:
		return soap_in_ns2__ServiceFee(soap, NULL, NULL, "ns2:ServiceFee");
	case SOAP_TYPE_ns2__CCDCCUpdateService:
		return soap_in_ns2__CCDCCUpdateService(soap, NULL, NULL, "ns2:CCDCCUpdateService");
	case SOAP_TYPE_ns2__PaypalTransaction:
		return soap_in_ns2__PaypalTransaction(soap, NULL, NULL, "ns2:PaypalTransaction");
	case SOAP_TYPE_ns2__PayPalTransactionSearchReply:
		return soap_in_ns2__PayPalTransactionSearchReply(soap, NULL, NULL, "ns2:PayPalTransactionSearchReply");
	case SOAP_TYPE_ns2__PayPalGetTxnDetailsReply:
		return soap_in_ns2__PayPalGetTxnDetailsReply(soap, NULL, NULL, "ns2:PayPalGetTxnDetailsReply");
	case SOAP_TYPE_ns2__RequestReserved:
		return soap_in_ns2__RequestReserved(soap, NULL, NULL, "ns2:RequestReserved");
	case SOAP_TYPE_ns2__ReplyReserved:
		return soap_in_ns2__ReplyReserved(soap, NULL, NULL, "ns2:ReplyReserved");
	case SOAP_TYPE_ns2__MerchantSecureData:
		return soap_in_ns2__MerchantSecureData(soap, NULL, NULL, "ns2:MerchantSecureData");
	case SOAP_TYPE_ns2__MerchantDefinedData:
		return soap_in_ns2__MerchantDefinedData(soap, NULL, NULL, "ns2:MerchantDefinedData");
	case SOAP_TYPE_ns2__MDDField:
		return soap_in_ns2__MDDField(soap, NULL, NULL, "ns2:MDDField");
	case SOAP_TYPE_ns2__Installment:
		return soap_in_ns2__Installment(soap, NULL, NULL, "ns2:Installment");
	case SOAP_TYPE_ns2__EncryptedPayment:
		return soap_in_ns2__EncryptedPayment(soap, NULL, NULL, "ns2:EncryptedPayment");
	case SOAP_TYPE_ns2__Pos:
		return soap_in_ns2__Pos(soap, NULL, NULL, "ns2:Pos");
	case SOAP_TYPE_ns2__LodgingData:
		return soap_in_ns2__LodgingData(soap, NULL, NULL, "ns2:LodgingData");
	case SOAP_TYPE_ns2__Service:
		return soap_in_ns2__Service(soap, NULL, NULL, "ns2:Service");
	case SOAP_TYPE_ns2__AncillaryData:
		return soap_in_ns2__AncillaryData(soap, NULL, NULL, "ns2:AncillaryData");
	case SOAP_TYPE_ns2__Leg:
		return soap_in_ns2__Leg(soap, NULL, NULL, "ns2:Leg");
	case SOAP_TYPE_ns2__AirlineData:
		return soap_in_ns2__AirlineData(soap, NULL, NULL, "ns2:AirlineData");
	case SOAP_TYPE_ns2__FaultDetails:
		return soap_in_ns2__FaultDetails(soap, NULL, NULL, "ns2:FaultDetails");
	case SOAP_TYPE_ns2__ReplyMessage:
		return soap_in_ns2__ReplyMessage(soap, NULL, NULL, "ns2:ReplyMessage");
	case SOAP_TYPE_ns2__APConfirmPurchaseReply:
		return soap_in_ns2__APConfirmPurchaseReply(soap, NULL, NULL, "ns2:APConfirmPurchaseReply");
	case SOAP_TYPE_ns2__APTransactionDetailsReply:
		return soap_in_ns2__APTransactionDetailsReply(soap, NULL, NULL, "ns2:APTransactionDetailsReply");
	case SOAP_TYPE_ns2__APCheckOutDetailsReply:
		return soap_in_ns2__APCheckOutDetailsReply(soap, NULL, NULL, "ns2:APCheckOutDetailsReply");
	case SOAP_TYPE_ns2__APSaleReply:
		return soap_in_ns2__APSaleReply(soap, NULL, NULL, "ns2:APSaleReply");
	case SOAP_TYPE_ns2__APRefundReply:
		return soap_in_ns2__APRefundReply(soap, NULL, NULL, "ns2:APRefundReply");
	case SOAP_TYPE_ns2__APOptionsOption:
		return soap_in_ns2__APOptionsOption(soap, NULL, NULL, "ns2:APOptionsOption");
	case SOAP_TYPE_ns2__APOptionsReply:
		return soap_in_ns2__APOptionsReply(soap, NULL, NULL, "ns2:APOptionsReply");
	case SOAP_TYPE_ns2__APCaptureReply:
		return soap_in_ns2__APCaptureReply(soap, NULL, NULL, "ns2:APCaptureReply");
	case SOAP_TYPE_ns2__APAuthReversalReply:
		return soap_in_ns2__APAuthReversalReply(soap, NULL, NULL, "ns2:APAuthReversalReply");
	case SOAP_TYPE_ns2__APAuthReply:
		return soap_in_ns2__APAuthReply(soap, NULL, NULL, "ns2:APAuthReply");
	case SOAP_TYPE_ns2__APReply:
		return soap_in_ns2__APReply(soap, NULL, NULL, "ns2:APReply");
	case SOAP_TYPE_ns2__APCheckStatusReply:
		return soap_in_ns2__APCheckStatusReply(soap, NULL, NULL, "ns2:APCheckStatusReply");
	case SOAP_TYPE_ns2__APInitiateReply:
		return soap_in_ns2__APInitiateReply(soap, NULL, NULL, "ns2:APInitiateReply");
	case SOAP_TYPE_ns2__BoletoPaymentReply:
		return soap_in_ns2__BoletoPaymentReply(soap, NULL, NULL, "ns2:BoletoPaymentReply");
	case SOAP_TYPE_ns2__ChinaRefundReply:
		return soap_in_ns2__ChinaRefundReply(soap, NULL, NULL, "ns2:ChinaRefundReply");
	case SOAP_TYPE_ns2__ChinaPaymentReply:
		return soap_in_ns2__ChinaPaymentReply(soap, NULL, NULL, "ns2:ChinaPaymentReply");
	case SOAP_TYPE_ns2__CCDCCUpdateReply:
		return soap_in_ns2__CCDCCUpdateReply(soap, NULL, NULL, "ns2:CCDCCUpdateReply");
	case SOAP_TYPE_ns2__CCDCCReply:
		return soap_in_ns2__CCDCCReply(soap, NULL, NULL, "ns2:CCDCCReply");
	case SOAP_TYPE_ns2__ProfileReply:
		return soap_in_ns2__ProfileReply(soap, NULL, NULL, "ns2:ProfileReply");
	case SOAP_TYPE_ns2__DMEReply:
		return soap_in_ns2__DMEReply(soap, NULL, NULL, "ns2:DMEReply");
	case SOAP_TYPE_ns2__Field:
		return soap_in_ns2__Field(soap, NULL, NULL, "ns2:Field");
	case SOAP_TYPE_ns2__AdditionalFields:
		return soap_in_ns2__AdditionalFields(soap, NULL, NULL, "ns2:AdditionalFields");
	case SOAP_TYPE_ns2__DecisionReply:
		return soap_in_ns2__DecisionReply(soap, NULL, NULL, "ns2:DecisionReply");
	case SOAP_TYPE_ns2__RuleResultItems:
		return soap_in_ns2__RuleResultItems(soap, NULL, NULL, "ns2:RuleResultItems");
	case SOAP_TYPE_ns2__RuleResultItem:
		return soap_in_ns2__RuleResultItem(soap, NULL, NULL, "ns2:RuleResultItem");
	case SOAP_TYPE_ns2__CaseManagementActionReply:
		return soap_in_ns2__CaseManagementActionReply(soap, NULL, NULL, "ns2:CaseManagementActionReply");
	case SOAP_TYPE_ns2__FraudUpdateReply:
		return soap_in_ns2__FraudUpdateReply(soap, NULL, NULL, "ns2:FraudUpdateReply");
	case SOAP_TYPE_ns2__RiskUpdateReply:
		return soap_in_ns2__RiskUpdateReply(soap, NULL, NULL, "ns2:RiskUpdateReply");
	case SOAP_TYPE_ns2__PayPalDoRefTransactionReply:
		return soap_in_ns2__PayPalDoRefTransactionReply(soap, NULL, NULL, "ns2:PayPalDoRefTransactionReply");
	case SOAP_TYPE_ns2__PayPalCreateAgreementReply:
		return soap_in_ns2__PayPalCreateAgreementReply(soap, NULL, NULL, "ns2:PayPalCreateAgreementReply");
	case SOAP_TYPE_ns2__PayPalUpdateAgreementReply:
		return soap_in_ns2__PayPalUpdateAgreementReply(soap, NULL, NULL, "ns2:PayPalUpdateAgreementReply");
	case SOAP_TYPE_ns2__PayPalAuthorizationReply:
		return soap_in_ns2__PayPalAuthorizationReply(soap, NULL, NULL, "ns2:PayPalAuthorizationReply");
	case SOAP_TYPE_ns2__PayPalEcOrderSetupReply:
		return soap_in_ns2__PayPalEcOrderSetupReply(soap, NULL, NULL, "ns2:PayPalEcOrderSetupReply");
	case SOAP_TYPE_ns2__PayPalRefundReply:
		return soap_in_ns2__PayPalRefundReply(soap, NULL, NULL, "ns2:PayPalRefundReply");
	case SOAP_TYPE_ns2__PayPalAuthReversalReply:
		return soap_in_ns2__PayPalAuthReversalReply(soap, NULL, NULL, "ns2:PayPalAuthReversalReply");
	case SOAP_TYPE_ns2__PayPalDoCaptureReply:
		return soap_in_ns2__PayPalDoCaptureReply(soap, NULL, NULL, "ns2:PayPalDoCaptureReply");
	case SOAP_TYPE_ns2__PayPalEcDoPaymentReply:
		return soap_in_ns2__PayPalEcDoPaymentReply(soap, NULL, NULL, "ns2:PayPalEcDoPaymentReply");
	case SOAP_TYPE_ns2__PayPalEcGetDetailsReply:
		return soap_in_ns2__PayPalEcGetDetailsReply(soap, NULL, NULL, "ns2:PayPalEcGetDetailsReply");
	case SOAP_TYPE_ns2__PayPalEcSetReply:
		return soap_in_ns2__PayPalEcSetReply(soap, NULL, NULL, "ns2:PayPalEcSetReply");
	case SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply:
		return soap_in_ns2__PayPalPreapprovedUpdateReply(soap, NULL, NULL, "ns2:PayPalPreapprovedUpdateReply");
	case SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply:
		return soap_in_ns2__PayPalPreapprovedPaymentReply(soap, NULL, NULL, "ns2:PayPalPreapprovedPaymentReply");
	case SOAP_TYPE_ns2__PayPalButtonCreateReply:
		return soap_in_ns2__PayPalButtonCreateReply(soap, NULL, NULL, "ns2:PayPalButtonCreateReply");
	case SOAP_TYPE_ns2__PinlessDebitReversalReply:
		return soap_in_ns2__PinlessDebitReversalReply(soap, NULL, NULL, "ns2:PinlessDebitReversalReply");
	case SOAP_TYPE_ns2__PinlessDebitValidateReply:
		return soap_in_ns2__PinlessDebitValidateReply(soap, NULL, NULL, "ns2:PinlessDebitValidateReply");
	case SOAP_TYPE_ns2__PinlessDebitReply:
		return soap_in_ns2__PinlessDebitReply(soap, NULL, NULL, "ns2:PinlessDebitReply");
	case SOAP_TYPE_ns2__VoidReply:
		return soap_in_ns2__VoidReply(soap, NULL, NULL, "ns2:VoidReply");
	case SOAP_TYPE_ns2__PayPalCreditReply:
		return soap_in_ns2__PayPalCreditReply(soap, NULL, NULL, "ns2:PayPalCreditReply");
	case SOAP_TYPE_ns2__PayPalPaymentReply:
		return soap_in_ns2__PayPalPaymentReply(soap, NULL, NULL, "ns2:PayPalPaymentReply");
	case SOAP_TYPE_ns2__PaySubscriptionDeleteReply:
		return soap_in_ns2__PaySubscriptionDeleteReply(soap, NULL, NULL, "ns2:PaySubscriptionDeleteReply");
	case SOAP_TYPE_ns2__PaySubscriptionRetrieveReply:
		return soap_in_ns2__PaySubscriptionRetrieveReply(soap, NULL, NULL, "ns2:PaySubscriptionRetrieveReply");
	case SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply:
		return soap_in_ns2__PaySubscriptionEventUpdateReply(soap, NULL, NULL, "ns2:PaySubscriptionEventUpdateReply");
	case SOAP_TYPE_ns2__PaySubscriptionUpdateReply:
		return soap_in_ns2__PaySubscriptionUpdateReply(soap, NULL, NULL, "ns2:PaySubscriptionUpdateReply");
	case SOAP_TYPE_ns2__PaySubscriptionCreateReply:
		return soap_in_ns2__PaySubscriptionCreateReply(soap, NULL, NULL, "ns2:PaySubscriptionCreateReply");
	case SOAP_TYPE_ns2__DirectDebitRefundReply:
		return soap_in_ns2__DirectDebitRefundReply(soap, NULL, NULL, "ns2:DirectDebitRefundReply");
	case SOAP_TYPE_ns2__DirectDebitValidateReply:
		return soap_in_ns2__DirectDebitValidateReply(soap, NULL, NULL, "ns2:DirectDebitValidateReply");
	case SOAP_TYPE_ns2__DirectDebitReply:
		return soap_in_ns2__DirectDebitReply(soap, NULL, NULL, "ns2:DirectDebitReply");
	case SOAP_TYPE_ns2__BankTransferRefundReply:
		return soap_in_ns2__BankTransferRefundReply(soap, NULL, NULL, "ns2:BankTransferRefundReply");
	case SOAP_TYPE_ns2__DirectDebitMandateReply:
		return soap_in_ns2__DirectDebitMandateReply(soap, NULL, NULL, "ns2:DirectDebitMandateReply");
	case SOAP_TYPE_ns2__BankTransferRealTimeReply:
		return soap_in_ns2__BankTransferRealTimeReply(soap, NULL, NULL, "ns2:BankTransferRealTimeReply");
	case SOAP_TYPE_ns2__BankTransferReply:
		return soap_in_ns2__BankTransferReply(soap, NULL, NULL, "ns2:BankTransferReply");
	case SOAP_TYPE_ns2__FXRatesReply:
		return soap_in_ns2__FXRatesReply(soap, NULL, NULL, "ns2:FXRatesReply");
	case SOAP_TYPE_ns2__FXQuote:
		return soap_in_ns2__FXQuote(soap, NULL, NULL, "ns2:FXQuote");
	case SOAP_TYPE_ns2__ExportReply:
		return soap_in_ns2__ExportReply(soap, NULL, NULL, "ns2:ExportReply");
	case SOAP_TYPE_ns2__DeniedPartiesMatch:
		return soap_in_ns2__DeniedPartiesMatch(soap, NULL, NULL, "ns2:DeniedPartiesMatch");
	case SOAP_TYPE_ns2__DAVReply:
		return soap_in_ns2__DAVReply(soap, NULL, NULL, "ns2:DAVReply");
	case SOAP_TYPE_ns2__AFSReply:
		return soap_in_ns2__AFSReply(soap, NULL, NULL, "ns2:AFSReply");
	case SOAP_TYPE_ns2__DeviceFingerprint:
		return soap_in_ns2__DeviceFingerprint(soap, NULL, NULL, "ns2:DeviceFingerprint");
	case SOAP_TYPE_ns2__TaxReply:
		return soap_in_ns2__TaxReply(soap, NULL, NULL, "ns2:TaxReply");
	case SOAP_TYPE_ns2__TaxReplyItem:
		return soap_in_ns2__TaxReplyItem(soap, NULL, NULL, "ns2:TaxReplyItem");
	case SOAP_TYPE_ns2__PayerAuthValidateReply:
		return soap_in_ns2__PayerAuthValidateReply(soap, NULL, NULL, "ns2:PayerAuthValidateReply");
	case SOAP_TYPE_ns2__PayerAuthEnrollReply:
		return soap_in_ns2__PayerAuthEnrollReply(soap, NULL, NULL, "ns2:PayerAuthEnrollReply");
	case SOAP_TYPE_ns2__ECAuthenticateReply:
		return soap_in_ns2__ECAuthenticateReply(soap, NULL, NULL, "ns2:ECAuthenticateReply");
	case SOAP_TYPE_ns2__ECCreditReply:
		return soap_in_ns2__ECCreditReply(soap, NULL, NULL, "ns2:ECCreditReply");
	case SOAP_TYPE_ns2__ECDebitReply:
		return soap_in_ns2__ECDebitReply(soap, NULL, NULL, "ns2:ECDebitReply");
	case SOAP_TYPE_ns2__CCAutoAuthReversalReply:
		return soap_in_ns2__CCAutoAuthReversalReply(soap, NULL, NULL, "ns2:CCAutoAuthReversalReply");
	case SOAP_TYPE_ns2__CCAuthReversalReply:
		return soap_in_ns2__CCAuthReversalReply(soap, NULL, NULL, "ns2:CCAuthReversalReply");
	case SOAP_TYPE_ns2__PinDebitReversalReply:
		return soap_in_ns2__PinDebitReversalReply(soap, NULL, NULL, "ns2:PinDebitReversalReply");
	case SOAP_TYPE_ns2__PinDebitCreditReply:
		return soap_in_ns2__PinDebitCreditReply(soap, NULL, NULL, "ns2:PinDebitCreditReply");
	case SOAP_TYPE_ns2__PinDebitPurchaseReply:
		return soap_in_ns2__PinDebitPurchaseReply(soap, NULL, NULL, "ns2:PinDebitPurchaseReply");
	case SOAP_TYPE_ns2__CCCreditReply:
		return soap_in_ns2__CCCreditReply(soap, NULL, NULL, "ns2:CCCreditReply");
	case SOAP_TYPE_ns2__ServiceFeeCalculateReply:
		return soap_in_ns2__ServiceFeeCalculateReply(soap, NULL, NULL, "ns2:ServiceFeeCalculateReply");
	case SOAP_TYPE_ns2__CCCaptureReply:
		return soap_in_ns2__CCCaptureReply(soap, NULL, NULL, "ns2:CCCaptureReply");
	case SOAP_TYPE_ns2__CCIncrementalAuthReply:
		return soap_in_ns2__CCIncrementalAuthReply(soap, NULL, NULL, "ns2:CCIncrementalAuthReply");
	case SOAP_TYPE_ns2__CCSaleReversalReply:
		return soap_in_ns2__CCSaleReversalReply(soap, NULL, NULL, "ns2:CCSaleReversalReply");
	case SOAP_TYPE_ns2__CCSaleCreditReply:
		return soap_in_ns2__CCSaleCreditReply(soap, NULL, NULL, "ns2:CCSaleCreditReply");
	case SOAP_TYPE_ns2__CCSaleReply:
		return soap_in_ns2__CCSaleReply(soap, NULL, NULL, "ns2:CCSaleReply");
	case SOAP_TYPE_ns2__VerificationReply:
		return soap_in_ns2__VerificationReply(soap, NULL, NULL, "ns2:VerificationReply");
	case SOAP_TYPE_ns2__OCTReply:
		return soap_in_ns2__OCTReply(soap, NULL, NULL, "ns2:OCTReply");
	case SOAP_TYPE_ns2__CCAuthReply:
		return soap_in_ns2__CCAuthReply(soap, NULL, NULL, "ns2:CCAuthReply");
	case SOAP_TYPE_ns2__PromotionGroupReply:
		return soap_in_ns2__PromotionGroupReply(soap, NULL, NULL, "ns2:PromotionGroupReply");
	case SOAP_TYPE_ns2__PromotionGroup:
		return soap_in_ns2__PromotionGroup(soap, NULL, NULL, "ns2:PromotionGroup");
	case SOAP_TYPE_ns2__Promotion:
		return soap_in_ns2__Promotion(soap, NULL, NULL, "ns2:Promotion");
	case SOAP_TYPE_ns2__DCC:
		return soap_in_ns2__DCC(soap, NULL, NULL, "ns2:DCC");
	case SOAP_TYPE_ns2__DecryptVisaCheckoutDataService:
		return soap_in_ns2__DecryptVisaCheckoutDataService(soap, NULL, NULL, "ns2:DecryptVisaCheckoutDataService");
	case SOAP_TYPE_ns2__VC:
		return soap_in_ns2__VC(soap, NULL, NULL, "ns2:VC");
	case SOAP_TYPE_ns2__RequestMessage:
		return soap_in_ns2__RequestMessage(soap, NULL, NULL, "ns2:RequestMessage");
	case SOAP_TYPE_ns2__Sender:
		return soap_in_ns2__Sender(soap, NULL, NULL, "ns2:Sender");
	case SOAP_TYPE_ns2__Recipient:
		return soap_in_ns2__Recipient(soap, NULL, NULL, "ns2:Recipient");
	case SOAP_TYPE_ns2__PayPalTransactionSearchService:
		return soap_in_ns2__PayPalTransactionSearchService(soap, NULL, NULL, "ns2:PayPalTransactionSearchService");
	case SOAP_TYPE_ns2__PayPalGetTxnDetailsService:
		return soap_in_ns2__PayPalGetTxnDetailsService(soap, NULL, NULL, "ns2:PayPalGetTxnDetailsService");
	case SOAP_TYPE_ns2__APConfirmPurchaseService:
		return soap_in_ns2__APConfirmPurchaseService(soap, NULL, NULL, "ns2:APConfirmPurchaseService");
	case SOAP_TYPE_ns2__APTransactionDetailsService:
		return soap_in_ns2__APTransactionDetailsService(soap, NULL, NULL, "ns2:APTransactionDetailsService");
	case SOAP_TYPE_ns2__APCheckOutDetailsService:
		return soap_in_ns2__APCheckOutDetailsService(soap, NULL, NULL, "ns2:APCheckOutDetailsService");
	case SOAP_TYPE_ns2__APSaleService:
		return soap_in_ns2__APSaleService(soap, NULL, NULL, "ns2:APSaleService");
	case SOAP_TYPE_ns2__APRefundService:
		return soap_in_ns2__APRefundService(soap, NULL, NULL, "ns2:APRefundService");
	case SOAP_TYPE_ns2__APOptionsService:
		return soap_in_ns2__APOptionsService(soap, NULL, NULL, "ns2:APOptionsService");
	case SOAP_TYPE_ns2__APCaptureService:
		return soap_in_ns2__APCaptureService(soap, NULL, NULL, "ns2:APCaptureService");
	case SOAP_TYPE_ns2__APAuthReversalService:
		return soap_in_ns2__APAuthReversalService(soap, NULL, NULL, "ns2:APAuthReversalService");
	case SOAP_TYPE_ns2__APAuthService:
		return soap_in_ns2__APAuthService(soap, NULL, NULL, "ns2:APAuthService");
	case SOAP_TYPE_ns2__APDevice:
		return soap_in_ns2__APDevice(soap, NULL, NULL, "ns2:APDevice");
	case SOAP_TYPE_ns2__AP:
		return soap_in_ns2__AP(soap, NULL, NULL, "ns2:AP");
	case SOAP_TYPE_ns2__Token:
		return soap_in_ns2__Token(soap, NULL, NULL, "ns2:Token");
	case SOAP_TYPE_ns2__JPO:
		return soap_in_ns2__JPO(soap, NULL, NULL, "ns2:JPO");
	case SOAP_TYPE_ns2__PayPal:
		return soap_in_ns2__PayPal(soap, NULL, NULL, "ns2:PayPal");
	case SOAP_TYPE_ns2__Batch:
		return soap_in_ns2__Batch(soap, NULL, NULL, "ns2:Batch");
	case SOAP_TYPE_ns2__DecisionManagerTravelLeg:
		return soap_in_ns2__DecisionManagerTravelLeg(soap, NULL, NULL, "ns2:DecisionManagerTravelLeg");
	case SOAP_TYPE_ns2__DecisionManagerTravelData:
		return soap_in_ns2__DecisionManagerTravelData(soap, NULL, NULL, "ns2:DecisionManagerTravelData");
	case SOAP_TYPE_ns2__DecisionManager:
		return soap_in_ns2__DecisionManager(soap, NULL, NULL, "ns2:DecisionManager");
	case SOAP_TYPE_ns2__PaymentNetworkToken:
		return soap_in_ns2__PaymentNetworkToken(soap, NULL, NULL, "ns2:PaymentNetworkToken");
	case SOAP_TYPE_ns2__Subscription:
		return soap_in_ns2__Subscription(soap, NULL, NULL, "ns2:Subscription");
	case SOAP_TYPE_ns2__PaySubscriptionEvent:
		return soap_in_ns2__PaySubscriptionEvent(soap, NULL, NULL, "ns2:PaySubscriptionEvent");
	case SOAP_TYPE_ns2__RecurringSubscriptionInfo:
		return soap_in_ns2__RecurringSubscriptionInfo(soap, NULL, NULL, "ns2:RecurringSubscriptionInfo");
	case SOAP_TYPE_ns2__BankInfo:
		return soap_in_ns2__BankInfo(soap, NULL, NULL, "ns2:BankInfo");
	case SOAP_TYPE_ns2__FundTransfer:
		return soap_in_ns2__FundTransfer(soap, NULL, NULL, "ns2:FundTransfer");
	case SOAP_TYPE_ns2__UCAF:
		return soap_in_ns2__UCAF(soap, NULL, NULL, "ns2:UCAF");
	case SOAP_TYPE_ns2__GECC:
		return soap_in_ns2__GECC(soap, NULL, NULL, "ns2:GECC");
	case SOAP_TYPE_ns2__FundingTotals:
		return soap_in_ns2__FundingTotals(soap, NULL, NULL, "ns2:FundingTotals");
	case SOAP_TYPE_ns2__PurchaseTotals:
		return soap_in_ns2__PurchaseTotals(soap, NULL, NULL, "ns2:PurchaseTotals");
	case SOAP_TYPE_ns2__Wallet:
		return soap_in_ns2__Wallet(soap, NULL, NULL, "ns2:Wallet");
	case SOAP_TYPE_ns2__Aft:
		return soap_in_ns2__Aft(soap, NULL, NULL, "ns2:Aft");
	case SOAP_TYPE_ns2__OtherTax:
		return soap_in_ns2__OtherTax(soap, NULL, NULL, "ns2:OtherTax");
	case SOAP_TYPE_ns2__BML:
		return soap_in_ns2__BML(soap, NULL, NULL, "ns2:BML");
	case SOAP_TYPE_ns2__Check:
		return soap_in_ns2__Check(soap, NULL, NULL, "ns2:Check");
	case SOAP_TYPE_ns2__Card:
		return soap_in_ns2__Card(soap, NULL, NULL, "ns2:Card");
	case SOAP_TYPE_ns2__ShipFrom:
		return soap_in_ns2__ShipFrom(soap, NULL, NULL, "ns2:ShipFrom");
	case SOAP_TYPE_ns2__ShipTo:
		return soap_in_ns2__ShipTo(soap, NULL, NULL, "ns2:ShipTo");
	case SOAP_TYPE_ns2__BillTo:
		return soap_in_ns2__BillTo(soap, NULL, NULL, "ns2:BillTo");
	case SOAP_TYPE_ns2__BusinessRules:
		return soap_in_ns2__BusinessRules(soap, NULL, NULL, "ns2:BusinessRules");
	case SOAP_TYPE_ns2__InvoiceHeader:
		return soap_in_ns2__InvoiceHeader(soap, NULL, NULL, "ns2:InvoiceHeader");
	case SOAP_TYPE_ns2__EncryptPaymentDataService:
		return soap_in_ns2__EncryptPaymentDataService(soap, NULL, NULL, "ns2:EncryptPaymentDataService");
	case SOAP_TYPE_ns2__CaseManagementActionService:
		return soap_in_ns2__CaseManagementActionService(soap, NULL, NULL, "ns2:CaseManagementActionService");
	case SOAP_TYPE_ns2__FraudUpdateService:
		return soap_in_ns2__FraudUpdateService(soap, NULL, NULL, "ns2:FraudUpdateService");
	case SOAP_TYPE_ns2__RiskUpdateService:
		return soap_in_ns2__RiskUpdateService(soap, NULL, NULL, "ns2:RiskUpdateService");
	case SOAP_TYPE_ns2__APCheckStatusService:
		return soap_in_ns2__APCheckStatusService(soap, NULL, NULL, "ns2:APCheckStatusService");
	case SOAP_TYPE_ns2__APInitiateService:
		return soap_in_ns2__APInitiateService(soap, NULL, NULL, "ns2:APInitiateService");
	case SOAP_TYPE_ns2__Address:
		return soap_in_ns2__Address(soap, NULL, NULL, "ns2:Address");
	case SOAP_TYPE_ns2__PersonalId:
		return soap_in_ns2__PersonalId(soap, NULL, NULL, "ns2:PersonalId");
	case SOAP_TYPE_ns2__BoletoPaymentService:
		return soap_in_ns2__BoletoPaymentService(soap, NULL, NULL, "ns2:BoletoPaymentService");
	case SOAP_TYPE_ns2__ChinaRefundService:
		return soap_in_ns2__ChinaRefundService(soap, NULL, NULL, "ns2:ChinaRefundService");
	case SOAP_TYPE_ns2__ChinaPaymentService:
		return soap_in_ns2__ChinaPaymentService(soap, NULL, NULL, "ns2:ChinaPaymentService");
	case SOAP_TYPE_ns2__PayPalPreapprovedUpdateService:
		return soap_in_ns2__PayPalPreapprovedUpdateService(soap, NULL, NULL, "ns2:PayPalPreapprovedUpdateService");
	case SOAP_TYPE_ns2__PayPalPreapprovedPaymentService:
		return soap_in_ns2__PayPalPreapprovedPaymentService(soap, NULL, NULL, "ns2:PayPalPreapprovedPaymentService");
	case SOAP_TYPE_ns2__PayPalButtonCreateService:
		return soap_in_ns2__PayPalButtonCreateService(soap, NULL, NULL, "ns2:PayPalButtonCreateService");
	case SOAP_TYPE_ns2__PinDebitReversalService:
		return soap_in_ns2__PinDebitReversalService(soap, NULL, NULL, "ns2:PinDebitReversalService");
	case SOAP_TYPE_ns2__PinDebitCreditService:
		return soap_in_ns2__PinDebitCreditService(soap, NULL, NULL, "ns2:PinDebitCreditService");
	case SOAP_TYPE_ns2__PinDebitPurchaseService:
		return soap_in_ns2__PinDebitPurchaseService(soap, NULL, NULL, "ns2:PinDebitPurchaseService");
	case SOAP_TYPE_ns2__PinlessDebitReversalService:
		return soap_in_ns2__PinlessDebitReversalService(soap, NULL, NULL, "ns2:PinlessDebitReversalService");
	case SOAP_TYPE_ns2__PinlessDebitValidateService:
		return soap_in_ns2__PinlessDebitValidateService(soap, NULL, NULL, "ns2:PinlessDebitValidateService");
	case SOAP_TYPE_ns2__PinlessDebitService:
		return soap_in_ns2__PinlessDebitService(soap, NULL, NULL, "ns2:PinlessDebitService");
	case SOAP_TYPE_ns2__VoidService:
		return soap_in_ns2__VoidService(soap, NULL, NULL, "ns2:VoidService");
	case SOAP_TYPE_ns2__PayPalDoRefTransactionService:
		return soap_in_ns2__PayPalDoRefTransactionService(soap, NULL, NULL, "ns2:PayPalDoRefTransactionService");
	case SOAP_TYPE_ns2__PayPalCreateAgreementService:
		return soap_in_ns2__PayPalCreateAgreementService(soap, NULL, NULL, "ns2:PayPalCreateAgreementService");
	case SOAP_TYPE_ns2__PayPalUpdateAgreementService:
		return soap_in_ns2__PayPalUpdateAgreementService(soap, NULL, NULL, "ns2:PayPalUpdateAgreementService");
	case SOAP_TYPE_ns2__PayPalAuthorizationService:
		return soap_in_ns2__PayPalAuthorizationService(soap, NULL, NULL, "ns2:PayPalAuthorizationService");
	case SOAP_TYPE_ns2__PayPalEcOrderSetupService:
		return soap_in_ns2__PayPalEcOrderSetupService(soap, NULL, NULL, "ns2:PayPalEcOrderSetupService");
	case SOAP_TYPE_ns2__PayPalRefundService:
		return soap_in_ns2__PayPalRefundService(soap, NULL, NULL, "ns2:PayPalRefundService");
	case SOAP_TYPE_ns2__PayPalAuthReversalService:
		return soap_in_ns2__PayPalAuthReversalService(soap, NULL, NULL, "ns2:PayPalAuthReversalService");
	case SOAP_TYPE_ns2__PayPalDoCaptureService:
		return soap_in_ns2__PayPalDoCaptureService(soap, NULL, NULL, "ns2:PayPalDoCaptureService");
	case SOAP_TYPE_ns2__PayPalEcDoPaymentService:
		return soap_in_ns2__PayPalEcDoPaymentService(soap, NULL, NULL, "ns2:PayPalEcDoPaymentService");
	case SOAP_TYPE_ns2__PayPalEcGetDetailsService:
		return soap_in_ns2__PayPalEcGetDetailsService(soap, NULL, NULL, "ns2:PayPalEcGetDetailsService");
	case SOAP_TYPE_ns2__PayPalEcSetService:
		return soap_in_ns2__PayPalEcSetService(soap, NULL, NULL, "ns2:PayPalEcSetService");
	case SOAP_TYPE_ns2__PayPalCreditService:
		return soap_in_ns2__PayPalCreditService(soap, NULL, NULL, "ns2:PayPalCreditService");
	case SOAP_TYPE_ns2__PayPalPaymentService:
		return soap_in_ns2__PayPalPaymentService(soap, NULL, NULL, "ns2:PayPalPaymentService");
	case SOAP_TYPE_ns2__PaySubscriptionDeleteService:
		return soap_in_ns2__PaySubscriptionDeleteService(soap, NULL, NULL, "ns2:PaySubscriptionDeleteService");
	case SOAP_TYPE_ns2__PaySubscriptionRetrieveService:
		return soap_in_ns2__PaySubscriptionRetrieveService(soap, NULL, NULL, "ns2:PaySubscriptionRetrieveService");
	case SOAP_TYPE_ns2__PaySubscriptionEventUpdateService:
		return soap_in_ns2__PaySubscriptionEventUpdateService(soap, NULL, NULL, "ns2:PaySubscriptionEventUpdateService");
	case SOAP_TYPE_ns2__PaySubscriptionUpdateService:
		return soap_in_ns2__PaySubscriptionUpdateService(soap, NULL, NULL, "ns2:PaySubscriptionUpdateService");
	case SOAP_TYPE_ns2__PaySubscriptionCreateService:
		return soap_in_ns2__PaySubscriptionCreateService(soap, NULL, NULL, "ns2:PaySubscriptionCreateService");
	case SOAP_TYPE_ns2__DirectDebitValidateService:
		return soap_in_ns2__DirectDebitValidateService(soap, NULL, NULL, "ns2:DirectDebitValidateService");
	case SOAP_TYPE_ns2__DirectDebitRefundService:
		return soap_in_ns2__DirectDebitRefundService(soap, NULL, NULL, "ns2:DirectDebitRefundService");
	case SOAP_TYPE_ns2__DirectDebitService:
		return soap_in_ns2__DirectDebitService(soap, NULL, NULL, "ns2:DirectDebitService");
	case SOAP_TYPE_ns2__DirectDebitMandateService:
		return soap_in_ns2__DirectDebitMandateService(soap, NULL, NULL, "ns2:DirectDebitMandateService");
	case SOAP_TYPE_ns2__BankTransferRealTimeService:
		return soap_in_ns2__BankTransferRealTimeService(soap, NULL, NULL, "ns2:BankTransferRealTimeService");
	case SOAP_TYPE_ns2__BankTransferRefundService:
		return soap_in_ns2__BankTransferRefundService(soap, NULL, NULL, "ns2:BankTransferRefundService");
	case SOAP_TYPE_ns2__BankTransferService:
		return soap_in_ns2__BankTransferService(soap, NULL, NULL, "ns2:BankTransferService");
	case SOAP_TYPE_ns2__FXRatesService:
		return soap_in_ns2__FXRatesService(soap, NULL, NULL, "ns2:FXRatesService");
	case SOAP_TYPE_ns2__ExportService:
		return soap_in_ns2__ExportService(soap, NULL, NULL, "ns2:ExportService");
	case SOAP_TYPE_ns2__DAVService:
		return soap_in_ns2__DAVService(soap, NULL, NULL, "ns2:DAVService");
	case SOAP_TYPE_ns2__AFSService:
		return soap_in_ns2__AFSService(soap, NULL, NULL, "ns2:AFSService");
	case SOAP_TYPE_ns2__DMEService:
		return soap_in_ns2__DMEService(soap, NULL, NULL, "ns2:DMEService");
	case SOAP_TYPE_ns2__TaxService:
		return soap_in_ns2__TaxService(soap, NULL, NULL, "ns2:TaxService");
	case SOAP_TYPE_ns2__PayerAuthValidateService:
		return soap_in_ns2__PayerAuthValidateService(soap, NULL, NULL, "ns2:PayerAuthValidateService");
	case SOAP_TYPE_ns2__PayerAuthEnrollService:
		return soap_in_ns2__PayerAuthEnrollService(soap, NULL, NULL, "ns2:PayerAuthEnrollService");
	case SOAP_TYPE_ns2__ECAuthenticateService:
		return soap_in_ns2__ECAuthenticateService(soap, NULL, NULL, "ns2:ECAuthenticateService");
	case SOAP_TYPE_ns2__ECCreditService:
		return soap_in_ns2__ECCreditService(soap, NULL, NULL, "ns2:ECCreditService");
	case SOAP_TYPE_ns2__ECDebitService:
		return soap_in_ns2__ECDebitService(soap, NULL, NULL, "ns2:ECDebitService");
	case SOAP_TYPE_ns2__ServiceFeeCalculateService:
		return soap_in_ns2__ServiceFeeCalculateService(soap, NULL, NULL, "ns2:ServiceFeeCalculateService");
	case SOAP_TYPE_ns2__CCDCCService:
		return soap_in_ns2__CCDCCService(soap, NULL, NULL, "ns2:CCDCCService");
	case SOAP_TYPE_ns2__CCAutoAuthReversalService:
		return soap_in_ns2__CCAutoAuthReversalService(soap, NULL, NULL, "ns2:CCAutoAuthReversalService");
	case SOAP_TYPE_ns2__CCAuthReversalService:
		return soap_in_ns2__CCAuthReversalService(soap, NULL, NULL, "ns2:CCAuthReversalService");
	case SOAP_TYPE_ns2__CCCreditService:
		return soap_in_ns2__CCCreditService(soap, NULL, NULL, "ns2:CCCreditService");
	case SOAP_TYPE_ns2__CCCaptureService:
		return soap_in_ns2__CCCaptureService(soap, NULL, NULL, "ns2:CCCaptureService");
	case SOAP_TYPE_ns2__CCIncrementalAuthService:
		return soap_in_ns2__CCIncrementalAuthService(soap, NULL, NULL, "ns2:CCIncrementalAuthService");
	case SOAP_TYPE_ns2__CCSaleReversalService:
		return soap_in_ns2__CCSaleReversalService(soap, NULL, NULL, "ns2:CCSaleReversalService");
	case SOAP_TYPE_ns2__CCSaleCreditService:
		return soap_in_ns2__CCSaleCreditService(soap, NULL, NULL, "ns2:CCSaleCreditService");
	case SOAP_TYPE_ns2__CCSaleService:
		return soap_in_ns2__CCSaleService(soap, NULL, NULL, "ns2:CCSaleService");
	case SOAP_TYPE_ns2__VerificationService:
		return soap_in_ns2__VerificationService(soap, NULL, NULL, "ns2:VerificationService");
	case SOAP_TYPE_ns2__OCTService:
		return soap_in_ns2__OCTService(soap, NULL, NULL, "ns2:OCTService");
	case SOAP_TYPE_ns2__CCAuthService:
		return soap_in_ns2__CCAuthService(soap, NULL, NULL, "ns2:CCAuthService");
	case SOAP_TYPE_ns2__Item:
		return soap_in_ns2__Item(soap, NULL, NULL, "ns2:Item");
	case SOAP_TYPE_wsc__PropertiesType:
		return soap_in_wsc__PropertiesType(soap, NULL, NULL, "wsc:PropertiesType");
	case SOAP_TYPE_wsc__DerivedKeyTokenType:
		return soap_in_wsc__DerivedKeyTokenType(soap, NULL, NULL, "wsc:DerivedKeyTokenType");
	case SOAP_TYPE_wsc__SecurityContextTokenType:
		return soap_in_wsc__SecurityContextTokenType(soap, NULL, NULL, "wsc:SecurityContextTokenType");
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		return soap_in_xenc__EncryptionPropertyType(soap, NULL, NULL, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		return soap_in_xenc__EncryptionPropertiesType(soap, NULL, NULL, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_xenc__ReferenceType:
		return soap_in_xenc__ReferenceType(soap, NULL, NULL, "xenc:ReferenceType");
	case SOAP_TYPE_xenc__AgreementMethodType:
		return soap_in_xenc__AgreementMethodType(soap, NULL, NULL, "xenc:AgreementMethodType");
	case SOAP_TYPE_xenc__EncryptedKeyType:
		return soap_in_xenc__EncryptedKeyType(soap, NULL, NULL, "xenc:EncryptedKeyType");
	case SOAP_TYPE_xenc__EncryptedDataType:
		return soap_in_xenc__EncryptedDataType(soap, NULL, NULL, "xenc:EncryptedDataType");
	case SOAP_TYPE_xenc__TransformsType:
		return soap_in_xenc__TransformsType(soap, NULL, NULL, "xenc:TransformsType");
	case SOAP_TYPE_xenc__CipherReferenceType:
		return soap_in_xenc__CipherReferenceType(soap, NULL, NULL, "xenc:CipherReferenceType");
	case SOAP_TYPE_xenc__CipherDataType:
		return soap_in_xenc__CipherDataType(soap, NULL, NULL, "xenc:CipherDataType");
	case SOAP_TYPE_xenc__EncryptionMethodType:
		return soap_in_xenc__EncryptionMethodType(soap, NULL, NULL, "xenc:EncryptionMethodType");
	case SOAP_TYPE_xenc__EncryptedType:
		return soap_in_xenc__EncryptedType(soap, NULL, NULL, "xenc:EncryptedType");
	case SOAP_TYPE_ds__RSAKeyValueType:
		return soap_in_ds__RSAKeyValueType(soap, NULL, NULL, "ds:RSAKeyValueType");
	case SOAP_TYPE_ds__DSAKeyValueType:
		return soap_in_ds__DSAKeyValueType(soap, NULL, NULL, "ds:DSAKeyValueType");
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return soap_in_ds__X509IssuerSerialType(soap, NULL, NULL, "ds:X509IssuerSerialType");
	case SOAP_TYPE_ds__RetrievalMethodType:
		return soap_in_ds__RetrievalMethodType(soap, NULL, NULL, "ds:RetrievalMethodType");
	case SOAP_TYPE_ds__KeyValueType:
		return soap_in_ds__KeyValueType(soap, NULL, NULL, "ds:KeyValueType");
	case SOAP_TYPE_ds__DigestMethodType:
		return soap_in_ds__DigestMethodType(soap, NULL, NULL, "ds:DigestMethodType");
	case SOAP_TYPE_ds__TransformType:
		return soap_in_ds__TransformType(soap, NULL, NULL, "ds:TransformType");
	case SOAP_TYPE_ds__TransformsType:
		return soap_in_ds__TransformsType(soap, NULL, NULL, "ds:TransformsType");
	case SOAP_TYPE_ds__ReferenceType:
		return soap_in_ds__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_ds__SignatureMethodType:
		return soap_in_ds__SignatureMethodType(soap, NULL, NULL, "ds:SignatureMethodType");
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return soap_in_ds__CanonicalizationMethodType(soap, NULL, NULL, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_ds__KeyInfoType:
		return soap_in_ds__KeyInfoType(soap, NULL, NULL, "ds:KeyInfoType");
	case SOAP_TYPE_ds__SignedInfoType:
		return soap_in_ds__SignedInfoType(soap, NULL, NULL, "ds:SignedInfoType");
	case SOAP_TYPE_ds__SignatureType:
		return soap_in_ds__SignatureType(soap, NULL, NULL, "ds:SignatureType");
	case SOAP_TYPE_ds__X509DataType:
		return soap_in_ds__X509DataType(soap, NULL, NULL, "ds:X509DataType");
	case SOAP_TYPE_wsse__EncodedString:
		return soap_in_wsse__EncodedString(soap, NULL, NULL, "wsse:EncodedString");
	case SOAP_TYPE_PointerTons2__VCCustomData:
		return soap_in_PointerTons2__VCCustomData(soap, NULL, NULL, "ns2:VCCustomData");
	case SOAP_TYPE_PointerTons2__VCCardArt:
		return soap_in_PointerTons2__VCCardArt(soap, NULL, NULL, "ns2:VCCardArt");
	case SOAP_TYPE_PointerTons2__PaypalTransaction:
		return soap_in_PointerTons2__PaypalTransaction(soap, NULL, NULL, "ns2:PaypalTransaction");
	case SOAP_TYPE_PointerTons2__MDDField:
		return soap_in_PointerTons2__MDDField(soap, NULL, NULL, "ns2:MDDField");
	case SOAP_TYPE_PointerTons2__Service:
		return soap_in_PointerTons2__Service(soap, NULL, NULL, "ns2:Service");
	case SOAP_TYPE_PointerTons2__Leg:
		return soap_in_PointerTons2__Leg(soap, NULL, NULL, "ns2:Leg");
	case SOAP_TYPE_PointerTons2__ReplyReserved:
		return soap_in_PointerTons2__ReplyReserved(soap, NULL, NULL, "ns2:ReplyReserved");
	case SOAP_TYPE_PointerTons2__Token:
		return soap_in_PointerTons2__Token(soap, NULL, NULL, "ns2:Token");
	case SOAP_TYPE_PointerTons2__BinLookupReply:
		return soap_in_PointerTons2__BinLookupReply(soap, NULL, NULL, "ns2:BinLookupReply");
	case SOAP_TYPE_PointerTons2__DecryptVisaCheckoutDataReply:
		return soap_in_PointerTons2__DecryptVisaCheckoutDataReply(soap, NULL, NULL, "ns2:DecryptVisaCheckoutDataReply");
	case SOAP_TYPE_PointerTons2__VCReply:
		return soap_in_PointerTons2__VCReply(soap, NULL, NULL, "ns2:VCReply");
	case SOAP_TYPE_PointerTons2__HostedDataRetrieveReply:
		return soap_in_PointerTons2__HostedDataRetrieveReply(soap, NULL, NULL, "ns2:HostedDataRetrieveReply");
	case SOAP_TYPE_PointerTons2__HostedDataCreateReply:
		return soap_in_PointerTons2__HostedDataCreateReply(soap, NULL, NULL, "ns2:HostedDataCreateReply");
	case SOAP_TYPE_PointerTons2__OriginalTransaction:
		return soap_in_PointerTons2__OriginalTransaction(soap, NULL, NULL, "ns2:OriginalTransaction");
	case SOAP_TYPE_PointerTons2__EmvReply:
		return soap_in_PointerTons2__EmvReply(soap, NULL, NULL, "ns2:EmvReply");
	case SOAP_TYPE_PointerTons2__PayPalTransactionSearchReply:
		return soap_in_PointerTons2__PayPalTransactionSearchReply(soap, NULL, NULL, "ns2:PayPalTransactionSearchReply");
	case SOAP_TYPE_PointerTons2__PayPalGetTxnDetailsReply:
		return soap_in_PointerTons2__PayPalGetTxnDetailsReply(soap, NULL, NULL, "ns2:PayPalGetTxnDetailsReply");
	case SOAP_TYPE_PointerTons2__PromotionGroupReply:
		return soap_in_PointerTons2__PromotionGroupReply(soap, NULL, NULL, "ns2:PromotionGroupReply");
	case SOAP_TYPE_PointerTons2__Promotion:
		return soap_in_PointerTons2__Promotion(soap, NULL, NULL, "ns2:Promotion");
	case SOAP_TYPE_PointerTons2__APConfirmPurchaseReply:
		return soap_in_PointerTons2__APConfirmPurchaseReply(soap, NULL, NULL, "ns2:APConfirmPurchaseReply");
	case SOAP_TYPE_PointerTons2__APTransactionDetailsReply:
		return soap_in_PointerTons2__APTransactionDetailsReply(soap, NULL, NULL, "ns2:APTransactionDetailsReply");
	case SOAP_TYPE_PointerTons2__APCheckOutDetailsReply:
		return soap_in_PointerTons2__APCheckOutDetailsReply(soap, NULL, NULL, "ns2:APCheckOutDetailsReply");
	case SOAP_TYPE_PointerTons2__APSaleReply:
		return soap_in_PointerTons2__APSaleReply(soap, NULL, NULL, "ns2:APSaleReply");
	case SOAP_TYPE_PointerTons2__APRefundReply:
		return soap_in_PointerTons2__APRefundReply(soap, NULL, NULL, "ns2:APRefundReply");
	case SOAP_TYPE_PointerTons2__APOptionsReply:
		return soap_in_PointerTons2__APOptionsReply(soap, NULL, NULL, "ns2:APOptionsReply");
	case SOAP_TYPE_PointerTons2__APCaptureReply:
		return soap_in_PointerTons2__APCaptureReply(soap, NULL, NULL, "ns2:APCaptureReply");
	case SOAP_TYPE_PointerTons2__APAuthReversalReply:
		return soap_in_PointerTons2__APAuthReversalReply(soap, NULL, NULL, "ns2:APAuthReversalReply");
	case SOAP_TYPE_PointerTons2__APAuthReply:
		return soap_in_PointerTons2__APAuthReply(soap, NULL, NULL, "ns2:APAuthReply");
	case SOAP_TYPE_PointerTons2__APReply:
		return soap_in_PointerTons2__APReply(soap, NULL, NULL, "ns2:APReply");
	case SOAP_TYPE_PointerTons2__APCheckStatusReply:
		return soap_in_PointerTons2__APCheckStatusReply(soap, NULL, NULL, "ns2:APCheckStatusReply");
	case SOAP_TYPE_PointerTons2__APInitiateReply:
		return soap_in_PointerTons2__APInitiateReply(soap, NULL, NULL, "ns2:APInitiateReply");
	case SOAP_TYPE_PointerTons2__PinDebitReversalReply:
		return soap_in_PointerTons2__PinDebitReversalReply(soap, NULL, NULL, "ns2:PinDebitReversalReply");
	case SOAP_TYPE_PointerTons2__PinDebitCreditReply:
		return soap_in_PointerTons2__PinDebitCreditReply(soap, NULL, NULL, "ns2:PinDebitCreditReply");
	case SOAP_TYPE_PointerTons2__PinDebitPurchaseReply:
		return soap_in_PointerTons2__PinDebitPurchaseReply(soap, NULL, NULL, "ns2:PinDebitPurchaseReply");
	case SOAP_TYPE_PointerTons2__BoletoPaymentReply:
		return soap_in_PointerTons2__BoletoPaymentReply(soap, NULL, NULL, "ns2:BoletoPaymentReply");
	case SOAP_TYPE_PointerTons2__ChinaRefundReply:
		return soap_in_PointerTons2__ChinaRefundReply(soap, NULL, NULL, "ns2:ChinaRefundReply");
	case SOAP_TYPE_PointerTons2__ChinaPaymentReply:
		return soap_in_PointerTons2__ChinaPaymentReply(soap, NULL, NULL, "ns2:ChinaPaymentReply");
	case SOAP_TYPE_PointerTons2__PayPalDoRefTransactionReply:
		return soap_in_PointerTons2__PayPalDoRefTransactionReply(soap, NULL, NULL, "ns2:PayPalDoRefTransactionReply");
	case SOAP_TYPE_PointerTons2__PayPalCreateAgreementReply:
		return soap_in_PointerTons2__PayPalCreateAgreementReply(soap, NULL, NULL, "ns2:PayPalCreateAgreementReply");
	case SOAP_TYPE_PointerTons2__PayPalUpdateAgreementReply:
		return soap_in_PointerTons2__PayPalUpdateAgreementReply(soap, NULL, NULL, "ns2:PayPalUpdateAgreementReply");
	case SOAP_TYPE_PointerTons2__PayPalEcOrderSetupReply:
		return soap_in_PointerTons2__PayPalEcOrderSetupReply(soap, NULL, NULL, "ns2:PayPalEcOrderSetupReply");
	case SOAP_TYPE_PointerTons2__PayPalAuthorizationReply:
		return soap_in_PointerTons2__PayPalAuthorizationReply(soap, NULL, NULL, "ns2:PayPalAuthorizationReply");
	case SOAP_TYPE_PointerTons2__PayPalEcSetReply:
		return soap_in_PointerTons2__PayPalEcSetReply(soap, NULL, NULL, "ns2:PayPalEcSetReply");
	case SOAP_TYPE_PointerTons2__PayPalEcGetDetailsReply:
		return soap_in_PointerTons2__PayPalEcGetDetailsReply(soap, NULL, NULL, "ns2:PayPalEcGetDetailsReply");
	case SOAP_TYPE_PointerTons2__PayPalEcDoPaymentReply:
		return soap_in_PointerTons2__PayPalEcDoPaymentReply(soap, NULL, NULL, "ns2:PayPalEcDoPaymentReply");
	case SOAP_TYPE_PointerTons2__PayPalDoCaptureReply:
		return soap_in_PointerTons2__PayPalDoCaptureReply(soap, NULL, NULL, "ns2:PayPalDoCaptureReply");
	case SOAP_TYPE_PointerTons2__PayPalAuthReversalReply:
		return soap_in_PointerTons2__PayPalAuthReversalReply(soap, NULL, NULL, "ns2:PayPalAuthReversalReply");
	case SOAP_TYPE_PointerTons2__PayPalRefundReply:
		return soap_in_PointerTons2__PayPalRefundReply(soap, NULL, NULL, "ns2:PayPalRefundReply");
	case SOAP_TYPE_PointerTons2__DecisionReply:
		return soap_in_PointerTons2__DecisionReply(soap, NULL, NULL, "ns2:DecisionReply");
	case SOAP_TYPE_PointerTons2__CaseManagementActionReply:
		return soap_in_PointerTons2__CaseManagementActionReply(soap, NULL, NULL, "ns2:CaseManagementActionReply");
	case SOAP_TYPE_PointerTons2__FraudUpdateReply:
		return soap_in_PointerTons2__FraudUpdateReply(soap, NULL, NULL, "ns2:FraudUpdateReply");
	case SOAP_TYPE_PointerTons2__RiskUpdateReply:
		return soap_in_PointerTons2__RiskUpdateReply(soap, NULL, NULL, "ns2:RiskUpdateReply");
	case SOAP_TYPE_PointerTons2__PayPalPreapprovedUpdateReply:
		return soap_in_PointerTons2__PayPalPreapprovedUpdateReply(soap, NULL, NULL, "ns2:PayPalPreapprovedUpdateReply");
	case SOAP_TYPE_PointerTons2__PayPalPreapprovedPaymentReply:
		return soap_in_PointerTons2__PayPalPreapprovedPaymentReply(soap, NULL, NULL, "ns2:PayPalPreapprovedPaymentReply");
	case SOAP_TYPE_PointerTons2__PayPalButtonCreateReply:
		return soap_in_PointerTons2__PayPalButtonCreateReply(soap, NULL, NULL, "ns2:PayPalButtonCreateReply");
	case SOAP_TYPE_PointerTons2__PinlessDebitReversalReply:
		return soap_in_PointerTons2__PinlessDebitReversalReply(soap, NULL, NULL, "ns2:PinlessDebitReversalReply");
	case SOAP_TYPE_PointerTons2__PinlessDebitValidateReply:
		return soap_in_PointerTons2__PinlessDebitValidateReply(soap, NULL, NULL, "ns2:PinlessDebitValidateReply");
	case SOAP_TYPE_PointerTons2__PinlessDebitReply:
		return soap_in_PointerTons2__PinlessDebitReply(soap, NULL, NULL, "ns2:PinlessDebitReply");
	case SOAP_TYPE_PointerTons2__VoidReply:
		return soap_in_PointerTons2__VoidReply(soap, NULL, NULL, "ns2:VoidReply");
	case SOAP_TYPE_PointerTons2__PayPalCreditReply:
		return soap_in_PointerTons2__PayPalCreditReply(soap, NULL, NULL, "ns2:PayPalCreditReply");
	case SOAP_TYPE_PointerTons2__PayPalPaymentReply:
		return soap_in_PointerTons2__PayPalPaymentReply(soap, NULL, NULL, "ns2:PayPalPaymentReply");
	case SOAP_TYPE_PointerTons2__PaySubscriptionDeleteReply:
		return soap_in_PointerTons2__PaySubscriptionDeleteReply(soap, NULL, NULL, "ns2:PaySubscriptionDeleteReply");
	case SOAP_TYPE_PointerTons2__PaySubscriptionRetrieveReply:
		return soap_in_PointerTons2__PaySubscriptionRetrieveReply(soap, NULL, NULL, "ns2:PaySubscriptionRetrieveReply");
	case SOAP_TYPE_PointerTons2__PaySubscriptionEventUpdateReply:
		return soap_in_PointerTons2__PaySubscriptionEventUpdateReply(soap, NULL, NULL, "ns2:PaySubscriptionEventUpdateReply");
	case SOAP_TYPE_PointerTons2__PaySubscriptionUpdateReply:
		return soap_in_PointerTons2__PaySubscriptionUpdateReply(soap, NULL, NULL, "ns2:PaySubscriptionUpdateReply");
	case SOAP_TYPE_PointerTons2__PaySubscriptionCreateReply:
		return soap_in_PointerTons2__PaySubscriptionCreateReply(soap, NULL, NULL, "ns2:PaySubscriptionCreateReply");
	case SOAP_TYPE_PointerTons2__DirectDebitRefundReply:
		return soap_in_PointerTons2__DirectDebitRefundReply(soap, NULL, NULL, "ns2:DirectDebitRefundReply");
	case SOAP_TYPE_PointerTons2__DirectDebitValidateReply:
		return soap_in_PointerTons2__DirectDebitValidateReply(soap, NULL, NULL, "ns2:DirectDebitValidateReply");
	case SOAP_TYPE_PointerTons2__DirectDebitReply:
		return soap_in_PointerTons2__DirectDebitReply(soap, NULL, NULL, "ns2:DirectDebitReply");
	case SOAP_TYPE_PointerTons2__DirectDebitMandateReply:
		return soap_in_PointerTons2__DirectDebitMandateReply(soap, NULL, NULL, "ns2:DirectDebitMandateReply");
	case SOAP_TYPE_PointerTons2__BankTransferRealTimeReply:
		return soap_in_PointerTons2__BankTransferRealTimeReply(soap, NULL, NULL, "ns2:BankTransferRealTimeReply");
	case SOAP_TYPE_PointerTons2__BankTransferRefundReply:
		return soap_in_PointerTons2__BankTransferRefundReply(soap, NULL, NULL, "ns2:BankTransferRefundReply");
	case SOAP_TYPE_PointerTons2__BankTransferReply:
		return soap_in_PointerTons2__BankTransferReply(soap, NULL, NULL, "ns2:BankTransferReply");
	case SOAP_TYPE_PointerTons2__FXRatesReply:
		return soap_in_PointerTons2__FXRatesReply(soap, NULL, NULL, "ns2:FXRatesReply");
	case SOAP_TYPE_PointerTons2__ExportReply:
		return soap_in_PointerTons2__ExportReply(soap, NULL, NULL, "ns2:ExportReply");
	case SOAP_TYPE_PointerTons2__DAVReply:
		return soap_in_PointerTons2__DAVReply(soap, NULL, NULL, "ns2:DAVReply");
	case SOAP_TYPE_PointerTons2__AFSReply:
		return soap_in_PointerTons2__AFSReply(soap, NULL, NULL, "ns2:AFSReply");
	case SOAP_TYPE_PointerTons2__DMEReply:
		return soap_in_PointerTons2__DMEReply(soap, NULL, NULL, "ns2:DMEReply");
	case SOAP_TYPE_PointerTons2__EncryptPaymentDataReply:
		return soap_in_PointerTons2__EncryptPaymentDataReply(soap, NULL, NULL, "ns2:EncryptPaymentDataReply");
	case SOAP_TYPE_PointerTons2__TaxReply:
		return soap_in_PointerTons2__TaxReply(soap, NULL, NULL, "ns2:TaxReply");
	case SOAP_TYPE_PointerTons2__PayerAuthValidateReply:
		return soap_in_PointerTons2__PayerAuthValidateReply(soap, NULL, NULL, "ns2:PayerAuthValidateReply");
	case SOAP_TYPE_PointerTons2__PayerAuthEnrollReply:
		return soap_in_PointerTons2__PayerAuthEnrollReply(soap, NULL, NULL, "ns2:PayerAuthEnrollReply");
	case SOAP_TYPE_PointerTons2__ECAuthenticateReply:
		return soap_in_PointerTons2__ECAuthenticateReply(soap, NULL, NULL, "ns2:ECAuthenticateReply");
	case SOAP_TYPE_PointerTons2__ECCreditReply:
		return soap_in_PointerTons2__ECCreditReply(soap, NULL, NULL, "ns2:ECCreditReply");
	case SOAP_TYPE_PointerTons2__ECDebitReply:
		return soap_in_PointerTons2__ECDebitReply(soap, NULL, NULL, "ns2:ECDebitReply");
	case SOAP_TYPE_PointerTons2__CCDCCUpdateReply:
		return soap_in_PointerTons2__CCDCCUpdateReply(soap, NULL, NULL, "ns2:CCDCCUpdateReply");
	case SOAP_TYPE_PointerTons2__CCDCCReply:
		return soap_in_PointerTons2__CCDCCReply(soap, NULL, NULL, "ns2:CCDCCReply");
	case SOAP_TYPE_PointerTons2__CCAutoAuthReversalReply:
		return soap_in_PointerTons2__CCAutoAuthReversalReply(soap, NULL, NULL, "ns2:CCAutoAuthReversalReply");
	case SOAP_TYPE_PointerTons2__CCAuthReversalReply:
		return soap_in_PointerTons2__CCAuthReversalReply(soap, NULL, NULL, "ns2:CCAuthReversalReply");
	case SOAP_TYPE_PointerTons2__CCCreditReply:
		return soap_in_PointerTons2__CCCreditReply(soap, NULL, NULL, "ns2:CCCreditReply");
	case SOAP_TYPE_PointerTons2__CCCaptureReply:
		return soap_in_PointerTons2__CCCaptureReply(soap, NULL, NULL, "ns2:CCCaptureReply");
	case SOAP_TYPE_PointerTons2__ServiceFeeCalculateReply:
		return soap_in_PointerTons2__ServiceFeeCalculateReply(soap, NULL, NULL, "ns2:ServiceFeeCalculateReply");
	case SOAP_TYPE_PointerTons2__CCIncrementalAuthReply:
		return soap_in_PointerTons2__CCIncrementalAuthReply(soap, NULL, NULL, "ns2:CCIncrementalAuthReply");
	case SOAP_TYPE_PointerTons2__CCSaleReversalReply:
		return soap_in_PointerTons2__CCSaleReversalReply(soap, NULL, NULL, "ns2:CCSaleReversalReply");
	case SOAP_TYPE_PointerTons2__CCSaleCreditReply:
		return soap_in_PointerTons2__CCSaleCreditReply(soap, NULL, NULL, "ns2:CCSaleCreditReply");
	case SOAP_TYPE_PointerTons2__CCSaleReply:
		return soap_in_PointerTons2__CCSaleReply(soap, NULL, NULL, "ns2:CCSaleReply");
	case SOAP_TYPE_PointerTons2__VerificationReply:
		return soap_in_PointerTons2__VerificationReply(soap, NULL, NULL, "ns2:VerificationReply");
	case SOAP_TYPE_PointerTons2__OCTReply:
		return soap_in_PointerTons2__OCTReply(soap, NULL, NULL, "ns2:OCTReply");
	case SOAP_TYPE_PointerTons2__CCAuthReply:
		return soap_in_PointerTons2__CCAuthReply(soap, NULL, NULL, "ns2:CCAuthReply");
	case SOAP_TYPE_PointerTons2__DeniedPartiesMatch:
		return soap_in_PointerTons2__DeniedPartiesMatch(soap, NULL, NULL, "ns2:DeniedPartiesMatch");
	case SOAP_TYPE_PointerTons2__APOptionsOption:
		return soap_in_PointerTons2__APOptionsOption(soap, NULL, NULL, "ns2:APOptionsOption");
	case SOAP_TYPE_PointerTons2__RuleResultItems:
		return soap_in_PointerTons2__RuleResultItems(soap, NULL, NULL, "ns2:RuleResultItems");
	case SOAP_TYPE_PointerTons2__Field:
		return soap_in_PointerTons2__Field(soap, NULL, NULL, "ns2:Field");
	case SOAP_TYPE_PointerTons2__AdditionalFields:
		return soap_in_PointerTons2__AdditionalFields(soap, NULL, NULL, "ns2:AdditionalFields");
	case SOAP_TYPE_PointerTons2__ProfileReply:
		return soap_in_PointerTons2__ProfileReply(soap, NULL, NULL, "ns2:ProfileReply");
	case SOAP_TYPE_PointerTons2__RuleResultItem:
		return soap_in_PointerTons2__RuleResultItem(soap, NULL, NULL, "ns2:RuleResultItem");
	case SOAP_TYPE_PointerTons2__FXQuote:
		return soap_in_PointerTons2__FXQuote(soap, NULL, NULL, "ns2:FXQuote");
	case SOAP_TYPE_PointerTons2__DeviceFingerprint:
		return soap_in_PointerTons2__DeviceFingerprint(soap, NULL, NULL, "ns2:DeviceFingerprint");
	case SOAP_TYPE_PointerTons2__TaxReplyItem:
		return soap_in_PointerTons2__TaxReplyItem(soap, NULL, NULL, "ns2:TaxReplyItem");
	case SOAP_TYPE_PointerTons2__issuer:
		return soap_in_PointerTons2__issuer(soap, NULL, NULL, "ns2:issuer");
	case SOAP_TYPE_PointerTons2__BinLookupService:
		return soap_in_PointerTons2__BinLookupService(soap, NULL, NULL, "ns2:BinLookupService");
	case SOAP_TYPE_PointerTons2__EncryptPaymentDataService:
		return soap_in_PointerTons2__EncryptPaymentDataService(soap, NULL, NULL, "ns2:EncryptPaymentDataService");
	case SOAP_TYPE_PointerTons2__Aft:
		return soap_in_PointerTons2__Aft(soap, NULL, NULL, "ns2:Aft");
	case SOAP_TYPE_PointerTons2__Wallet:
		return soap_in_PointerTons2__Wallet(soap, NULL, NULL, "ns2:Wallet");
	case SOAP_TYPE_PointerTons2__PromotionGroup:
		return soap_in_PointerTons2__PromotionGroup(soap, NULL, NULL, "ns2:PromotionGroup");
	case SOAP_TYPE_PointerTons2__DecryptVisaCheckoutDataService:
		return soap_in_PointerTons2__DecryptVisaCheckoutDataService(soap, NULL, NULL, "ns2:DecryptVisaCheckoutDataService");
	case SOAP_TYPE_PointerTons2__VC:
		return soap_in_PointerTons2__VC(soap, NULL, NULL, "ns2:VC");
	case SOAP_TYPE_PointerTons2__AutoRentalData:
		return soap_in_PointerTons2__AutoRentalData(soap, NULL, NULL, "ns2:AutoRentalData");
	case SOAP_TYPE_PointerTons2__Sender:
		return soap_in_PointerTons2__Sender(soap, NULL, NULL, "ns2:Sender");
	case SOAP_TYPE_PointerTons2__Recipient:
		return soap_in_PointerTons2__Recipient(soap, NULL, NULL, "ns2:Recipient");
	case SOAP_TYPE_PointerTons2__PaymentNetworkToken:
		return soap_in_PointerTons2__PaymentNetworkToken(soap, NULL, NULL, "ns2:PaymentNetworkToken");
	case SOAP_TYPE_PointerTons2__HostedDataRetrieveService:
		return soap_in_PointerTons2__HostedDataRetrieveService(soap, NULL, NULL, "ns2:HostedDataRetrieveService");
	case SOAP_TYPE_PointerTons2__HostedDataCreateService:
		return soap_in_PointerTons2__HostedDataCreateService(soap, NULL, NULL, "ns2:HostedDataCreateService");
	case SOAP_TYPE_PointerTons2__EmvRequest:
		return soap_in_PointerTons2__EmvRequest(soap, NULL, NULL, "ns2:EmvRequest");
	case SOAP_TYPE_PointerTons2__CCDCCUpdateService:
		return soap_in_PointerTons2__CCDCCUpdateService(soap, NULL, NULL, "ns2:CCDCCUpdateService");
	case SOAP_TYPE_PointerTons2__PayPalTransactionSearchService:
		return soap_in_PointerTons2__PayPalTransactionSearchService(soap, NULL, NULL, "ns2:PayPalTransactionSearchService");
	case SOAP_TYPE_PointerTons2__PayPalGetTxnDetailsService:
		return soap_in_PointerTons2__PayPalGetTxnDetailsService(soap, NULL, NULL, "ns2:PayPalGetTxnDetailsService");
	case SOAP_TYPE_PointerTons2__APConfirmPurchaseService:
		return soap_in_PointerTons2__APConfirmPurchaseService(soap, NULL, NULL, "ns2:APConfirmPurchaseService");
	case SOAP_TYPE_PointerTons2__APTransactionDetailsService:
		return soap_in_PointerTons2__APTransactionDetailsService(soap, NULL, NULL, "ns2:APTransactionDetailsService");
	case SOAP_TYPE_PointerTons2__APCheckOutDetailsService:
		return soap_in_PointerTons2__APCheckOutDetailsService(soap, NULL, NULL, "ns2:APCheckOutDetailsService");
	case SOAP_TYPE_PointerTons2__APSaleService:
		return soap_in_PointerTons2__APSaleService(soap, NULL, NULL, "ns2:APSaleService");
	case SOAP_TYPE_PointerTons2__APRefundService:
		return soap_in_PointerTons2__APRefundService(soap, NULL, NULL, "ns2:APRefundService");
	case SOAP_TYPE_PointerTons2__APOptionsService:
		return soap_in_PointerTons2__APOptionsService(soap, NULL, NULL, "ns2:APOptionsService");
	case SOAP_TYPE_PointerTons2__APCaptureService:
		return soap_in_PointerTons2__APCaptureService(soap, NULL, NULL, "ns2:APCaptureService");
	case SOAP_TYPE_PointerTons2__APAuthReversalService:
		return soap_in_PointerTons2__APAuthReversalService(soap, NULL, NULL, "ns2:APAuthReversalService");
	case SOAP_TYPE_PointerTons2__APAuthService:
		return soap_in_PointerTons2__APAuthService(soap, NULL, NULL, "ns2:APAuthService");
	case SOAP_TYPE_PointerTons2__AP:
		return soap_in_PointerTons2__AP(soap, NULL, NULL, "ns2:AP");
	case SOAP_TYPE_PointerTons2__PinDebitReversalService:
		return soap_in_PointerTons2__PinDebitReversalService(soap, NULL, NULL, "ns2:PinDebitReversalService");
	case SOAP_TYPE_PointerTons2__PinDebitCreditService:
		return soap_in_PointerTons2__PinDebitCreditService(soap, NULL, NULL, "ns2:PinDebitCreditService");
	case SOAP_TYPE_PointerTons2__PinDebitPurchaseService:
		return soap_in_PointerTons2__PinDebitPurchaseService(soap, NULL, NULL, "ns2:PinDebitPurchaseService");
	case SOAP_TYPE_PointerTons2__APCheckStatusService:
		return soap_in_PointerTons2__APCheckStatusService(soap, NULL, NULL, "ns2:APCheckStatusService");
	case SOAP_TYPE_PointerTons2__APInitiateService:
		return soap_in_PointerTons2__APInitiateService(soap, NULL, NULL, "ns2:APInitiateService");
	case SOAP_TYPE_PointerTons2__BoletoPaymentService:
		return soap_in_PointerTons2__BoletoPaymentService(soap, NULL, NULL, "ns2:BoletoPaymentService");
	case SOAP_TYPE_PointerTons2__ChinaRefundService:
		return soap_in_PointerTons2__ChinaRefundService(soap, NULL, NULL, "ns2:ChinaRefundService");
	case SOAP_TYPE_PointerTons2__ChinaPaymentService:
		return soap_in_PointerTons2__ChinaPaymentService(soap, NULL, NULL, "ns2:ChinaPaymentService");
	case SOAP_TYPE_PointerTons2__PayPalDoRefTransactionService:
		return soap_in_PointerTons2__PayPalDoRefTransactionService(soap, NULL, NULL, "ns2:PayPalDoRefTransactionService");
	case SOAP_TYPE_PointerTons2__PayPalCreateAgreementService:
		return soap_in_PointerTons2__PayPalCreateAgreementService(soap, NULL, NULL, "ns2:PayPalCreateAgreementService");
	case SOAP_TYPE_PointerTons2__PayPalUpdateAgreementService:
		return soap_in_PointerTons2__PayPalUpdateAgreementService(soap, NULL, NULL, "ns2:PayPalUpdateAgreementService");
	case SOAP_TYPE_PointerTons2__PayPalAuthorizationService:
		return soap_in_PointerTons2__PayPalAuthorizationService(soap, NULL, NULL, "ns2:PayPalAuthorizationService");
	case SOAP_TYPE_PointerTons2__PayPalEcOrderSetupService:
		return soap_in_PointerTons2__PayPalEcOrderSetupService(soap, NULL, NULL, "ns2:PayPalEcOrderSetupService");
	case SOAP_TYPE_PointerTons2__PayPalEcSetService:
		return soap_in_PointerTons2__PayPalEcSetService(soap, NULL, NULL, "ns2:PayPalEcSetService");
	case SOAP_TYPE_PointerTons2__PayPalEcGetDetailsService:
		return soap_in_PointerTons2__PayPalEcGetDetailsService(soap, NULL, NULL, "ns2:PayPalEcGetDetailsService");
	case SOAP_TYPE_PointerTons2__PayPalEcDoPaymentService:
		return soap_in_PointerTons2__PayPalEcDoPaymentService(soap, NULL, NULL, "ns2:PayPalEcDoPaymentService");
	case SOAP_TYPE_PointerTons2__PayPalDoCaptureService:
		return soap_in_PointerTons2__PayPalDoCaptureService(soap, NULL, NULL, "ns2:PayPalDoCaptureService");
	case SOAP_TYPE_PointerTons2__PayPalAuthReversalService:
		return soap_in_PointerTons2__PayPalAuthReversalService(soap, NULL, NULL, "ns2:PayPalAuthReversalService");
	case SOAP_TYPE_PointerTons2__PayPalRefundService:
		return soap_in_PointerTons2__PayPalRefundService(soap, NULL, NULL, "ns2:PayPalRefundService");
	case SOAP_TYPE_PointerTons2__RequestReserved:
		return soap_in_PointerTons2__RequestReserved(soap, NULL, NULL, "ns2:RequestReserved");
	case SOAP_TYPE_PointerTons2__CaseManagementActionService:
		return soap_in_PointerTons2__CaseManagementActionService(soap, NULL, NULL, "ns2:CaseManagementActionService");
	case SOAP_TYPE_PointerTons2__FraudUpdateService:
		return soap_in_PointerTons2__FraudUpdateService(soap, NULL, NULL, "ns2:FraudUpdateService");
	case SOAP_TYPE_PointerTons2__RiskUpdateService:
		return soap_in_PointerTons2__RiskUpdateService(soap, NULL, NULL, "ns2:RiskUpdateService");
	case SOAP_TYPE_PointerTons2__PayPalPreapprovedUpdateService:
		return soap_in_PointerTons2__PayPalPreapprovedUpdateService(soap, NULL, NULL, "ns2:PayPalPreapprovedUpdateService");
	case SOAP_TYPE_PointerTons2__PayPalPreapprovedPaymentService:
		return soap_in_PointerTons2__PayPalPreapprovedPaymentService(soap, NULL, NULL, "ns2:PayPalPreapprovedPaymentService");
	case SOAP_TYPE_PointerTons2__PayPalButtonCreateService:
		return soap_in_PointerTons2__PayPalButtonCreateService(soap, NULL, NULL, "ns2:PayPalButtonCreateService");
	case SOAP_TYPE_PointerTons2__LodgingData:
		return soap_in_PointerTons2__LodgingData(soap, NULL, NULL, "ns2:LodgingData");
	case SOAP_TYPE_PointerTons2__AncillaryData:
		return soap_in_PointerTons2__AncillaryData(soap, NULL, NULL, "ns2:AncillaryData");
	case SOAP_TYPE_PointerTons2__AirlineData:
		return soap_in_PointerTons2__AirlineData(soap, NULL, NULL, "ns2:AirlineData");
	case SOAP_TYPE_PointerTons2__Batch:
		return soap_in_PointerTons2__Batch(soap, NULL, NULL, "ns2:Batch");
	case SOAP_TYPE_PointerTons2__PinlessDebitReversalService:
		return soap_in_PointerTons2__PinlessDebitReversalService(soap, NULL, NULL, "ns2:PinlessDebitReversalService");
	case SOAP_TYPE_PointerTons2__PinlessDebitValidateService:
		return soap_in_PointerTons2__PinlessDebitValidateService(soap, NULL, NULL, "ns2:PinlessDebitValidateService");
	case SOAP_TYPE_PointerTons2__PinlessDebitService:
		return soap_in_PointerTons2__PinlessDebitService(soap, NULL, NULL, "ns2:PinlessDebitService");
	case SOAP_TYPE_PointerTons2__BusinessRules:
		return soap_in_PointerTons2__BusinessRules(soap, NULL, NULL, "ns2:BusinessRules");
	case SOAP_TYPE_PointerTons2__VoidService:
		return soap_in_PointerTons2__VoidService(soap, NULL, NULL, "ns2:VoidService");
	case SOAP_TYPE_PointerTons2__PayPalCreditService:
		return soap_in_PointerTons2__PayPalCreditService(soap, NULL, NULL, "ns2:PayPalCreditService");
	case SOAP_TYPE_PointerTons2__PayPalPaymentService:
		return soap_in_PointerTons2__PayPalPaymentService(soap, NULL, NULL, "ns2:PayPalPaymentService");
	case SOAP_TYPE_PointerTons2__PaySubscriptionDeleteService:
		return soap_in_PointerTons2__PaySubscriptionDeleteService(soap, NULL, NULL, "ns2:PaySubscriptionDeleteService");
	case SOAP_TYPE_PointerTons2__PaySubscriptionRetrieveService:
		return soap_in_PointerTons2__PaySubscriptionRetrieveService(soap, NULL, NULL, "ns2:PaySubscriptionRetrieveService");
	case SOAP_TYPE_PointerTons2__PaySubscriptionEventUpdateService:
		return soap_in_PointerTons2__PaySubscriptionEventUpdateService(soap, NULL, NULL, "ns2:PaySubscriptionEventUpdateService");
	case SOAP_TYPE_PointerTons2__PaySubscriptionUpdateService:
		return soap_in_PointerTons2__PaySubscriptionUpdateService(soap, NULL, NULL, "ns2:PaySubscriptionUpdateService");
	case SOAP_TYPE_PointerTons2__PaySubscriptionCreateService:
		return soap_in_PointerTons2__PaySubscriptionCreateService(soap, NULL, NULL, "ns2:PaySubscriptionCreateService");
	case SOAP_TYPE_PointerTons2__DirectDebitValidateService:
		return soap_in_PointerTons2__DirectDebitValidateService(soap, NULL, NULL, "ns2:DirectDebitValidateService");
	case SOAP_TYPE_PointerTons2__DirectDebitRefundService:
		return soap_in_PointerTons2__DirectDebitRefundService(soap, NULL, NULL, "ns2:DirectDebitRefundService");
	case SOAP_TYPE_PointerTons2__DirectDebitService:
		return soap_in_PointerTons2__DirectDebitService(soap, NULL, NULL, "ns2:DirectDebitService");
	case SOAP_TYPE_PointerTons2__DirectDebitMandateService:
		return soap_in_PointerTons2__DirectDebitMandateService(soap, NULL, NULL, "ns2:DirectDebitMandateService");
	case SOAP_TYPE_PointerTons2__BankTransferRealTimeService:
		return soap_in_PointerTons2__BankTransferRealTimeService(soap, NULL, NULL, "ns2:BankTransferRealTimeService");
	case SOAP_TYPE_PointerTons2__BankTransferRefundService:
		return soap_in_PointerTons2__BankTransferRefundService(soap, NULL, NULL, "ns2:BankTransferRefundService");
	case SOAP_TYPE_PointerTons2__BankTransferService:
		return soap_in_PointerTons2__BankTransferService(soap, NULL, NULL, "ns2:BankTransferService");
	case SOAP_TYPE_PointerTons2__FXRatesService:
		return soap_in_PointerTons2__FXRatesService(soap, NULL, NULL, "ns2:FXRatesService");
	case SOAP_TYPE_PointerTons2__ExportService:
		return soap_in_PointerTons2__ExportService(soap, NULL, NULL, "ns2:ExportService");
	case SOAP_TYPE_PointerTons2__DAVService:
		return soap_in_PointerTons2__DAVService(soap, NULL, NULL, "ns2:DAVService");
	case SOAP_TYPE_PointerTons2__AFSService:
		return soap_in_PointerTons2__AFSService(soap, NULL, NULL, "ns2:AFSService");
	case SOAP_TYPE_PointerTons2__DMEService:
		return soap_in_PointerTons2__DMEService(soap, NULL, NULL, "ns2:DMEService");
	case SOAP_TYPE_PointerTons2__TaxService:
		return soap_in_PointerTons2__TaxService(soap, NULL, NULL, "ns2:TaxService");
	case SOAP_TYPE_PointerTons2__PayerAuthValidateService:
		return soap_in_PointerTons2__PayerAuthValidateService(soap, NULL, NULL, "ns2:PayerAuthValidateService");
	case SOAP_TYPE_PointerTons2__PayerAuthEnrollService:
		return soap_in_PointerTons2__PayerAuthEnrollService(soap, NULL, NULL, "ns2:PayerAuthEnrollService");
	case SOAP_TYPE_PointerTons2__ECAuthenticateService:
		return soap_in_PointerTons2__ECAuthenticateService(soap, NULL, NULL, "ns2:ECAuthenticateService");
	case SOAP_TYPE_PointerTons2__ECCreditService:
		return soap_in_PointerTons2__ECCreditService(soap, NULL, NULL, "ns2:ECCreditService");
	case SOAP_TYPE_PointerTons2__ECDebitService:
		return soap_in_PointerTons2__ECDebitService(soap, NULL, NULL, "ns2:ECDebitService");
	case SOAP_TYPE_PointerTons2__ServiceFeeCalculateService:
		return soap_in_PointerTons2__ServiceFeeCalculateService(soap, NULL, NULL, "ns2:ServiceFeeCalculateService");
	case SOAP_TYPE_PointerTons2__CCDCCService:
		return soap_in_PointerTons2__CCDCCService(soap, NULL, NULL, "ns2:CCDCCService");
	case SOAP_TYPE_PointerTons2__CCAutoAuthReversalService:
		return soap_in_PointerTons2__CCAutoAuthReversalService(soap, NULL, NULL, "ns2:CCAutoAuthReversalService");
	case SOAP_TYPE_PointerTons2__CCAuthReversalService:
		return soap_in_PointerTons2__CCAuthReversalService(soap, NULL, NULL, "ns2:CCAuthReversalService");
	case SOAP_TYPE_PointerTons2__CCCreditService:
		return soap_in_PointerTons2__CCCreditService(soap, NULL, NULL, "ns2:CCCreditService");
	case SOAP_TYPE_PointerTons2__CCCaptureService:
		return soap_in_PointerTons2__CCCaptureService(soap, NULL, NULL, "ns2:CCCaptureService");
	case SOAP_TYPE_PointerTons2__CCIncrementalAuthService:
		return soap_in_PointerTons2__CCIncrementalAuthService(soap, NULL, NULL, "ns2:CCIncrementalAuthService");
	case SOAP_TYPE_PointerTons2__CCSaleReversalService:
		return soap_in_PointerTons2__CCSaleReversalService(soap, NULL, NULL, "ns2:CCSaleReversalService");
	case SOAP_TYPE_PointerTons2__CCSaleCreditService:
		return soap_in_PointerTons2__CCSaleCreditService(soap, NULL, NULL, "ns2:CCSaleCreditService");
	case SOAP_TYPE_PointerTons2__CCSaleService:
		return soap_in_PointerTons2__CCSaleService(soap, NULL, NULL, "ns2:CCSaleService");
	case SOAP_TYPE_PointerTons2__VerificationService:
		return soap_in_PointerTons2__VerificationService(soap, NULL, NULL, "ns2:VerificationService");
	case SOAP_TYPE_PointerTons2__OCTService:
		return soap_in_PointerTons2__OCTService(soap, NULL, NULL, "ns2:OCTService");
	case SOAP_TYPE_PointerTons2__CCAuthService:
		return soap_in_PointerTons2__CCAuthService(soap, NULL, NULL, "ns2:CCAuthService");
	case SOAP_TYPE_PointerTons2__ServiceFee:
		return soap_in_PointerTons2__ServiceFee(soap, NULL, NULL, "ns2:ServiceFee");
	case SOAP_TYPE_PointerTons2__JPO:
		return soap_in_PointerTons2__JPO(soap, NULL, NULL, "ns2:JPO");
	case SOAP_TYPE_PointerTons2__MerchantSecureData:
		return soap_in_PointerTons2__MerchantSecureData(soap, NULL, NULL, "ns2:MerchantSecureData");
	case SOAP_TYPE_PointerTons2__MerchantDefinedData:
		return soap_in_PointerTons2__MerchantDefinedData(soap, NULL, NULL, "ns2:MerchantDefinedData");
	case SOAP_TYPE_PointerTons2__PayPal:
		return soap_in_PointerTons2__PayPal(soap, NULL, NULL, "ns2:PayPal");
	case SOAP_TYPE_PointerTons2__OtherTax:
		return soap_in_PointerTons2__OtherTax(soap, NULL, NULL, "ns2:OtherTax");
	case SOAP_TYPE_PointerTons2__DecisionManager:
		return soap_in_PointerTons2__DecisionManager(soap, NULL, NULL, "ns2:DecisionManager");
	case SOAP_TYPE_PointerTons2__RecurringSubscriptionInfo:
		return soap_in_PointerTons2__RecurringSubscriptionInfo(soap, NULL, NULL, "ns2:RecurringSubscriptionInfo");
	case SOAP_TYPE_PointerTons2__Subscription:
		return soap_in_PointerTons2__Subscription(soap, NULL, NULL, "ns2:Subscription");
	case SOAP_TYPE_PointerTons2__BankInfo:
		return soap_in_PointerTons2__BankInfo(soap, NULL, NULL, "ns2:BankInfo");
	case SOAP_TYPE_PointerTons2__FundTransfer:
		return soap_in_PointerTons2__FundTransfer(soap, NULL, NULL, "ns2:FundTransfer");
	case SOAP_TYPE_PointerTons2__UCAF:
		return soap_in_PointerTons2__UCAF(soap, NULL, NULL, "ns2:UCAF");
	case SOAP_TYPE_PointerTons2__GECC:
		return soap_in_PointerTons2__GECC(soap, NULL, NULL, "ns2:GECC");
	case SOAP_TYPE_PointerTons2__BML:
		return soap_in_PointerTons2__BML(soap, NULL, NULL, "ns2:BML");
	case SOAP_TYPE_PointerTons2__Check:
		return soap_in_PointerTons2__Check(soap, NULL, NULL, "ns2:Check");
	case SOAP_TYPE_PointerTons2__Card:
		return soap_in_PointerTons2__Card(soap, NULL, NULL, "ns2:Card");
	case SOAP_TYPE_PointerTons2__Installment:
		return soap_in_PointerTons2__Installment(soap, NULL, NULL, "ns2:Installment");
	case SOAP_TYPE_PointerTons2__EncryptedPayment:
		return soap_in_PointerTons2__EncryptedPayment(soap, NULL, NULL, "ns2:EncryptedPayment");
	case SOAP_TYPE_PointerTons2__Pos:
		return soap_in_PointerTons2__Pos(soap, NULL, NULL, "ns2:Pos");
	case SOAP_TYPE_PointerTons2__DCC:
		return soap_in_PointerTons2__DCC(soap, NULL, NULL, "ns2:DCC");
	case SOAP_TYPE_PointerTons2__FundingTotals:
		return soap_in_PointerTons2__FundingTotals(soap, NULL, NULL, "ns2:FundingTotals");
	case SOAP_TYPE_PointerTons2__PurchaseTotals:
		return soap_in_PointerTons2__PurchaseTotals(soap, NULL, NULL, "ns2:PurchaseTotals");
	case SOAP_TYPE_PointerTons2__Item:
		return soap_in_PointerTons2__Item(soap, NULL, NULL, "ns2:Item");
	case SOAP_TYPE_PointerTons2__ShipFrom:
		return soap_in_PointerTons2__ShipFrom(soap, NULL, NULL, "ns2:ShipFrom");
	case SOAP_TYPE_PointerTons2__PersonalId:
		return soap_in_PointerTons2__PersonalId(soap, NULL, NULL, "ns2:PersonalId");
	case SOAP_TYPE_PointerTons2__ShipTo:
		return soap_in_PointerTons2__ShipTo(soap, NULL, NULL, "ns2:ShipTo");
	case SOAP_TYPE_PointerTons2__BillTo:
		return soap_in_PointerTons2__BillTo(soap, NULL, NULL, "ns2:BillTo");
	case SOAP_TYPE_PointerTons2__InvoiceHeader:
		return soap_in_PointerTons2__InvoiceHeader(soap, NULL, NULL, "ns2:InvoiceHeader");
	case SOAP_TYPE_PointerTons2__APDevice:
		return soap_in_PointerTons2__APDevice(soap, NULL, NULL, "ns2:APDevice");
	case SOAP_TYPE_PointerTons2__DecisionManagerTravelLeg:
		return soap_in_PointerTons2__DecisionManagerTravelLeg(soap, NULL, NULL, "ns2:DecisionManagerTravelLeg");
	case SOAP_TYPE_PointerTons2__DecisionManagerTravelData:
		return soap_in_PointerTons2__DecisionManagerTravelData(soap, NULL, NULL, "ns2:DecisionManagerTravelData");
	case SOAP_TYPE_PointerTons2__PaySubscriptionEvent:
		return soap_in_PointerTons2__PaySubscriptionEvent(soap, NULL, NULL, "ns2:PaySubscriptionEvent");
	case SOAP_TYPE_PointerTons2__Address:
		return soap_in_PointerTons2__Address(soap, NULL, NULL, "ns2:Address");
	case SOAP_TYPE_PointerTons2__dateTime:
		return soap_in_PointerTons2__dateTime(soap, NULL, NULL, "ns2:dateTime");
	case SOAP_TYPE_PointerToxsd__integer:
		return soap_in_PointerToxsd__integer(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_PointerTons2__boolean:
		return soap_in_PointerTons2__boolean(soap, NULL, NULL, "ns2:boolean");
	case SOAP_TYPE_PointerTons2__amount:
		return soap_in_PointerTons2__amount(soap, NULL, NULL, "ns2:amount");
	case SOAP_TYPE_ns2__dateTime:
	{	wchar_t **s;
		s = soap_in_ns2__dateTime(soap, NULL, NULL, "ns2:dateTime");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns2__boolean:
	{	wchar_t **s;
		s = soap_in_ns2__boolean(soap, NULL, NULL, "ns2:boolean");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ns2__amount:
	{	wchar_t **s;
		s = soap_in_ns2__amount(soap, NULL, NULL, "ns2:amount");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_xsd__integer:
	{	wchar_t **s;
		s = soap_in_xsd__integer(soap, NULL, NULL, "xsd:integer");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wstring:
	{	wchar_t **s;
		s = soap_in_wstring(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTo_wsse__Security:
		return soap_in_PointerTo_wsse__Security(soap, NULL, NULL, "wsse:Security");
	case SOAP_TYPE_PointerTods__SignatureType:
		return soap_in_PointerTods__SignatureType(soap, NULL, NULL, "ds:SignatureType");
	case SOAP_TYPE_PointerTowsc__SecurityContextTokenType:
		return soap_in_PointerTowsc__SecurityContextTokenType(soap, NULL, NULL, "wsc:SecurityContextTokenType");
	case SOAP_TYPE_PointerToxenc__EncryptedKeyType:
		return soap_in_PointerToxenc__EncryptedKeyType(soap, NULL, NULL, "xenc:EncryptedKeyType");
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		return soap_in_PointerTo_wsse__BinarySecurityToken(soap, NULL, NULL, "wsse:BinarySecurityToken");
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		return soap_in_PointerTo_wsse__UsernameToken(soap, NULL, NULL, "wsse:UsernameToken");
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		return soap_in_PointerTo_wsu__Timestamp(soap, NULL, NULL, "wsu:Timestamp");
	case SOAP_TYPE_PointerToULONG64:
		return soap_in_PointerToULONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_PointerTowsc__PropertiesType:
		return soap_in_PointerTowsc__PropertiesType(soap, NULL, NULL, "wsc:PropertiesType");
	case SOAP_TYPE_wsc__FaultCodeOpenEnumType:
	{	char **s;
		s = soap_in_wsc__FaultCodeOpenEnumType(soap, NULL, NULL, "wsc:FaultCodeOpenEnumType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTo_xenc__ReferenceList:
		return soap_in_PointerTo_xenc__ReferenceList(soap, NULL, NULL, "xenc:ReferenceList");
	case SOAP_TYPE_PointerToxenc__ReferenceType:
		return soap_in_PointerToxenc__ReferenceType(soap, NULL, NULL, "xenc:ReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertyType:
		return soap_in_PointerToxenc__EncryptionPropertyType(soap, NULL, NULL, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_PointerToxenc__TransformsType:
		return soap_in_PointerToxenc__TransformsType(soap, NULL, NULL, "xenc:TransformsType");
	case SOAP_TYPE_PointerToxenc__CipherReferenceType:
		return soap_in_PointerToxenc__CipherReferenceType(soap, NULL, NULL, "xenc:CipherReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertiesType:
		return soap_in_PointerToxenc__EncryptionPropertiesType(soap, NULL, NULL, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_PointerToxenc__CipherDataType:
		return soap_in_PointerToxenc__CipherDataType(soap, NULL, NULL, "xenc:CipherDataType");
	case SOAP_TYPE_PointerTo_ds__KeyInfo:
		return soap_in_PointerTo_ds__KeyInfo(soap, NULL, NULL, "ds:KeyInfo");
	case SOAP_TYPE_PointerToxenc__EncryptionMethodType:
		return soap_in_PointerToxenc__EncryptionMethodType(soap, NULL, NULL, "xenc:EncryptionMethodType");
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		return soap_in_PointerTods__X509IssuerSerialType(soap, NULL, NULL, "ds:X509IssuerSerialType");
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		return soap_in_PointerTods__RSAKeyValueType(soap, NULL, NULL, "ds:RSAKeyValueType");
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		return soap_in_PointerTods__DSAKeyValueType(soap, NULL, NULL, "ds:DSAKeyValueType");
	case SOAP_TYPE_PointerTods__TransformType:
		return soap_in_PointerTods__TransformType(soap, NULL, NULL, "ds:TransformType");
	case SOAP_TYPE_PointerTods__DigestMethodType:
		return soap_in_PointerTods__DigestMethodType(soap, NULL, NULL, "ds:DigestMethodType");
	case SOAP_TYPE_PointerTods__TransformsType:
		return soap_in_PointerTods__TransformsType(soap, NULL, NULL, "ds:TransformsType");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		return soap_in_PointerToPointerTods__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__ReferenceType:
		return soap_in_PointerTods__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		return soap_in_PointerTods__SignatureMethodType(soap, NULL, NULL, "ds:SignatureMethodType");
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		return soap_in_PointerTods__CanonicalizationMethodType(soap, NULL, NULL, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		return soap_in_PointerTo_wsse__SecurityTokenReference(soap, NULL, NULL, "wsse:SecurityTokenReference");
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		return soap_in_PointerTods__RetrievalMethodType(soap, NULL, NULL, "ds:RetrievalMethodType");
	case SOAP_TYPE_PointerTods__KeyValueType:
		return soap_in_PointerTods__KeyValueType(soap, NULL, NULL, "ds:KeyValueType");
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		return soap_in_PointerTo_c14n__InclusiveNamespaces(soap, NULL, NULL, "c14n:InclusiveNamespaces");
	case SOAP_TYPE_PointerTods__KeyInfoType:
		return soap_in_PointerTods__KeyInfoType(soap, NULL, NULL, "ds:KeyInfoType");
	case SOAP_TYPE_PointerTods__SignedInfoType:
		return soap_in_PointerTods__SignedInfoType(soap, NULL, NULL, "ds:SignedInfoType");
	case SOAP_TYPE_PointerTods__X509DataType:
		return soap_in_PointerTods__X509DataType(soap, NULL, NULL, "ds:X509DataType");
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		return soap_in_PointerTo_wsse__Embedded(soap, NULL, NULL, "wsse:Embedded");
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		return soap_in_PointerTo_wsse__KeyIdentifier(soap, NULL, NULL, "wsse:KeyIdentifier");
	case SOAP_TYPE_PointerTo_wsse__Reference:
		return soap_in_PointerTo_wsse__Reference(soap, NULL, NULL, "wsse:Reference");
	case SOAP_TYPE_PointerTowsse__EncodedString:
		return soap_in_PointerTowsse__EncodedString(soap, NULL, NULL, "wsse:EncodedString");
	case SOAP_TYPE_PointerTo_wsse__Password:
		return soap_in_PointerTo_wsse__Password(soap, NULL, NULL, "wsse:Password");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns2:issuer"))
		{	*type = SOAP_TYPE_ns2__issuer;
			return soap_in_ns2__issuer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BinLookupReply"))
		{	*type = SOAP_TYPE_ns2__BinLookupReply;
			return soap_in_ns2__BinLookupReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BinLookupService"))
		{	*type = SOAP_TYPE_ns2__BinLookupService;
			return soap_in_ns2__BinLookupService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EncryptPaymentDataReply"))
		{	*type = SOAP_TYPE_ns2__EncryptPaymentDataReply;
			return soap_in_ns2__EncryptPaymentDataReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DecryptVisaCheckoutDataReply"))
		{	*type = SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply;
			return soap_in_ns2__DecryptVisaCheckoutDataReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VCCustomData"))
		{	*type = SOAP_TYPE_ns2__VCCustomData;
			return soap_in_ns2__VCCustomData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VCCardArt"))
		{	*type = SOAP_TYPE_ns2__VCCardArt;
			return soap_in_ns2__VCCardArt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VCReply"))
		{	*type = SOAP_TYPE_ns2__VCReply;
			return soap_in_ns2__VCReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AutoRentalData"))
		{	*type = SOAP_TYPE_ns2__AutoRentalData;
			return soap_in_ns2__AutoRentalData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:HostedDataRetrieveReply"))
		{	*type = SOAP_TYPE_ns2__HostedDataRetrieveReply;
			return soap_in_ns2__HostedDataRetrieveReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:HostedDataCreateReply"))
		{	*type = SOAP_TYPE_ns2__HostedDataCreateReply;
			return soap_in_ns2__HostedDataCreateReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:HostedDataRetrieveService"))
		{	*type = SOAP_TYPE_ns2__HostedDataRetrieveService;
			return soap_in_ns2__HostedDataRetrieveService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:HostedDataCreateService"))
		{	*type = SOAP_TYPE_ns2__HostedDataCreateService;
			return soap_in_ns2__HostedDataCreateService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OriginalTransaction"))
		{	*type = SOAP_TYPE_ns2__OriginalTransaction;
			return soap_in_ns2__OriginalTransaction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EmvReply"))
		{	*type = SOAP_TYPE_ns2__EmvReply;
			return soap_in_ns2__EmvReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EmvRequest"))
		{	*type = SOAP_TYPE_ns2__EmvRequest;
			return soap_in_ns2__EmvRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ServiceFee"))
		{	*type = SOAP_TYPE_ns2__ServiceFee;
			return soap_in_ns2__ServiceFee(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CCDCCUpdateService"))
		{	*type = SOAP_TYPE_ns2__CCDCCUpdateService;
			return soap_in_ns2__CCDCCUpdateService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PaypalTransaction"))
		{	*type = SOAP_TYPE_ns2__PaypalTransaction;
			return soap_in_ns2__PaypalTransaction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalTransactionSearchReply"))
		{	*type = SOAP_TYPE_ns2__PayPalTransactionSearchReply;
			return soap_in_ns2__PayPalTransactionSearchReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalGetTxnDetailsReply"))
		{	*type = SOAP_TYPE_ns2__PayPalGetTxnDetailsReply;
			return soap_in_ns2__PayPalGetTxnDetailsReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RequestReserved"))
		{	*type = SOAP_TYPE_ns2__RequestReserved;
			return soap_in_ns2__RequestReserved(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ReplyReserved"))
		{	*type = SOAP_TYPE_ns2__ReplyReserved;
			return soap_in_ns2__ReplyReserved(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MerchantSecureData"))
		{	*type = SOAP_TYPE_ns2__MerchantSecureData;
			return soap_in_ns2__MerchantSecureData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MerchantDefinedData"))
		{	*type = SOAP_TYPE_ns2__MerchantDefinedData;
			return soap_in_ns2__MerchantDefinedData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MDDField"))
		{	*type = SOAP_TYPE_ns2__MDDField;
			return soap_in_ns2__MDDField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Installment"))
		{	*type = SOAP_TYPE_ns2__Installment;
			return soap_in_ns2__Installment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EncryptedPayment"))
		{	*type = SOAP_TYPE_ns2__EncryptedPayment;
			return soap_in_ns2__EncryptedPayment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Pos"))
		{	*type = SOAP_TYPE_ns2__Pos;
			return soap_in_ns2__Pos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:LodgingData"))
		{	*type = SOAP_TYPE_ns2__LodgingData;
			return soap_in_ns2__LodgingData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Service"))
		{	*type = SOAP_TYPE_ns2__Service;
			return soap_in_ns2__Service(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AncillaryData"))
		{	*type = SOAP_TYPE_ns2__AncillaryData;
			return soap_in_ns2__AncillaryData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Leg"))
		{	*type = SOAP_TYPE_ns2__Leg;
			return soap_in_ns2__Leg(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AirlineData"))
		{	*type = SOAP_TYPE_ns2__AirlineData;
			return soap_in_ns2__AirlineData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FaultDetails"))
		{	*type = SOAP_TYPE_ns2__FaultDetails;
			return soap_in_ns2__FaultDetails(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ReplyMessage"))
		{	*type = SOAP_TYPE_ns2__ReplyMessage;
			return soap_in_ns2__ReplyMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APConfirmPurchaseReply"))
		{	*type = SOAP_TYPE_ns2__APConfirmPurchaseReply;
			return soap_in_ns2__APConfirmPurchaseReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APTransactionDetailsReply"))
		{	*type = SOAP_TYPE_ns2__APTransactionDetailsReply;
			return soap_in_ns2__APTransactionDetailsReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APCheckOutDetailsReply"))
		{	*type = SOAP_TYPE_ns2__APCheckOutDetailsReply;
			return soap_in_ns2__APCheckOutDetailsReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APSaleReply"))
		{	*type = SOAP_TYPE_ns2__APSaleReply;
			return soap_in_ns2__APSaleReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APRefundReply"))
		{	*type = SOAP_TYPE_ns2__APRefundReply;
			return soap_in_ns2__APRefundReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APOptionsOption"))
		{	*type = SOAP_TYPE_ns2__APOptionsOption;
			return soap_in_ns2__APOptionsOption(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APOptionsReply"))
		{	*type = SOAP_TYPE_ns2__APOptionsReply;
			return soap_in_ns2__APOptionsReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APCaptureReply"))
		{	*type = SOAP_TYPE_ns2__APCaptureReply;
			return soap_in_ns2__APCaptureReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APAuthReversalReply"))
		{	*type = SOAP_TYPE_ns2__APAuthReversalReply;
			return soap_in_ns2__APAuthReversalReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APAuthReply"))
		{	*type = SOAP_TYPE_ns2__APAuthReply;
			return soap_in_ns2__APAuthReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APReply"))
		{	*type = SOAP_TYPE_ns2__APReply;
			return soap_in_ns2__APReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APCheckStatusReply"))
		{	*type = SOAP_TYPE_ns2__APCheckStatusReply;
			return soap_in_ns2__APCheckStatusReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APInitiateReply"))
		{	*type = SOAP_TYPE_ns2__APInitiateReply;
			return soap_in_ns2__APInitiateReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BoletoPaymentReply"))
		{	*type = SOAP_TYPE_ns2__BoletoPaymentReply;
			return soap_in_ns2__BoletoPaymentReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ChinaRefundReply"))
		{	*type = SOAP_TYPE_ns2__ChinaRefundReply;
			return soap_in_ns2__ChinaRefundReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ChinaPaymentReply"))
		{	*type = SOAP_TYPE_ns2__ChinaPaymentReply;
			return soap_in_ns2__ChinaPaymentReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CCDCCUpdateReply"))
		{	*type = SOAP_TYPE_ns2__CCDCCUpdateReply;
			return soap_in_ns2__CCDCCUpdateReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CCDCCReply"))
		{	*type = SOAP_TYPE_ns2__CCDCCReply;
			return soap_in_ns2__CCDCCReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ProfileReply"))
		{	*type = SOAP_TYPE_ns2__ProfileReply;
			return soap_in_ns2__ProfileReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DMEReply"))
		{	*type = SOAP_TYPE_ns2__DMEReply;
			return soap_in_ns2__DMEReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Field"))
		{	*type = SOAP_TYPE_ns2__Field;
			return soap_in_ns2__Field(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AdditionalFields"))
		{	*type = SOAP_TYPE_ns2__AdditionalFields;
			return soap_in_ns2__AdditionalFields(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DecisionReply"))
		{	*type = SOAP_TYPE_ns2__DecisionReply;
			return soap_in_ns2__DecisionReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RuleResultItems"))
		{	*type = SOAP_TYPE_ns2__RuleResultItems;
			return soap_in_ns2__RuleResultItems(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RuleResultItem"))
		{	*type = SOAP_TYPE_ns2__RuleResultItem;
			return soap_in_ns2__RuleResultItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CaseManagementActionReply"))
		{	*type = SOAP_TYPE_ns2__CaseManagementActionReply;
			return soap_in_ns2__CaseManagementActionReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FraudUpdateReply"))
		{	*type = SOAP_TYPE_ns2__FraudUpdateReply;
			return soap_in_ns2__FraudUpdateReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RiskUpdateReply"))
		{	*type = SOAP_TYPE_ns2__RiskUpdateReply;
			return soap_in_ns2__RiskUpdateReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalDoRefTransactionReply"))
		{	*type = SOAP_TYPE_ns2__PayPalDoRefTransactionReply;
			return soap_in_ns2__PayPalDoRefTransactionReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalCreateAgreementReply"))
		{	*type = SOAP_TYPE_ns2__PayPalCreateAgreementReply;
			return soap_in_ns2__PayPalCreateAgreementReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalUpdateAgreementReply"))
		{	*type = SOAP_TYPE_ns2__PayPalUpdateAgreementReply;
			return soap_in_ns2__PayPalUpdateAgreementReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalAuthorizationReply"))
		{	*type = SOAP_TYPE_ns2__PayPalAuthorizationReply;
			return soap_in_ns2__PayPalAuthorizationReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalEcOrderSetupReply"))
		{	*type = SOAP_TYPE_ns2__PayPalEcOrderSetupReply;
			return soap_in_ns2__PayPalEcOrderSetupReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalRefundReply"))
		{	*type = SOAP_TYPE_ns2__PayPalRefundReply;
			return soap_in_ns2__PayPalRefundReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalAuthReversalReply"))
		{	*type = SOAP_TYPE_ns2__PayPalAuthReversalReply;
			return soap_in_ns2__PayPalAuthReversalReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalDoCaptureReply"))
		{	*type = SOAP_TYPE_ns2__PayPalDoCaptureReply;
			return soap_in_ns2__PayPalDoCaptureReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalEcDoPaymentReply"))
		{	*type = SOAP_TYPE_ns2__PayPalEcDoPaymentReply;
			return soap_in_ns2__PayPalEcDoPaymentReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalEcGetDetailsReply"))
		{	*type = SOAP_TYPE_ns2__PayPalEcGetDetailsReply;
			return soap_in_ns2__PayPalEcGetDetailsReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalEcSetReply"))
		{	*type = SOAP_TYPE_ns2__PayPalEcSetReply;
			return soap_in_ns2__PayPalEcSetReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalPreapprovedUpdateReply"))
		{	*type = SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply;
			return soap_in_ns2__PayPalPreapprovedUpdateReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalPreapprovedPaymentReply"))
		{	*type = SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply;
			return soap_in_ns2__PayPalPreapprovedPaymentReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalButtonCreateReply"))
		{	*type = SOAP_TYPE_ns2__PayPalButtonCreateReply;
			return soap_in_ns2__PayPalButtonCreateReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PinlessDebitReversalReply"))
		{	*type = SOAP_TYPE_ns2__PinlessDebitReversalReply;
			return soap_in_ns2__PinlessDebitReversalReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PinlessDebitValidateReply"))
		{	*type = SOAP_TYPE_ns2__PinlessDebitValidateReply;
			return soap_in_ns2__PinlessDebitValidateReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PinlessDebitReply"))
		{	*type = SOAP_TYPE_ns2__PinlessDebitReply;
			return soap_in_ns2__PinlessDebitReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VoidReply"))
		{	*type = SOAP_TYPE_ns2__VoidReply;
			return soap_in_ns2__VoidReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalCreditReply"))
		{	*type = SOAP_TYPE_ns2__PayPalCreditReply;
			return soap_in_ns2__PayPalCreditReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalPaymentReply"))
		{	*type = SOAP_TYPE_ns2__PayPalPaymentReply;
			return soap_in_ns2__PayPalPaymentReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PaySubscriptionDeleteReply"))
		{	*type = SOAP_TYPE_ns2__PaySubscriptionDeleteReply;
			return soap_in_ns2__PaySubscriptionDeleteReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PaySubscriptionRetrieveReply"))
		{	*type = SOAP_TYPE_ns2__PaySubscriptionRetrieveReply;
			return soap_in_ns2__PaySubscriptionRetrieveReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PaySubscriptionEventUpdateReply"))
		{	*type = SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply;
			return soap_in_ns2__PaySubscriptionEventUpdateReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PaySubscriptionUpdateReply"))
		{	*type = SOAP_TYPE_ns2__PaySubscriptionUpdateReply;
			return soap_in_ns2__PaySubscriptionUpdateReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PaySubscriptionCreateReply"))
		{	*type = SOAP_TYPE_ns2__PaySubscriptionCreateReply;
			return soap_in_ns2__PaySubscriptionCreateReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DirectDebitRefundReply"))
		{	*type = SOAP_TYPE_ns2__DirectDebitRefundReply;
			return soap_in_ns2__DirectDebitRefundReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DirectDebitValidateReply"))
		{	*type = SOAP_TYPE_ns2__DirectDebitValidateReply;
			return soap_in_ns2__DirectDebitValidateReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DirectDebitReply"))
		{	*type = SOAP_TYPE_ns2__DirectDebitReply;
			return soap_in_ns2__DirectDebitReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BankTransferRefundReply"))
		{	*type = SOAP_TYPE_ns2__BankTransferRefundReply;
			return soap_in_ns2__BankTransferRefundReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DirectDebitMandateReply"))
		{	*type = SOAP_TYPE_ns2__DirectDebitMandateReply;
			return soap_in_ns2__DirectDebitMandateReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BankTransferRealTimeReply"))
		{	*type = SOAP_TYPE_ns2__BankTransferRealTimeReply;
			return soap_in_ns2__BankTransferRealTimeReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BankTransferReply"))
		{	*type = SOAP_TYPE_ns2__BankTransferReply;
			return soap_in_ns2__BankTransferReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FXRatesReply"))
		{	*type = SOAP_TYPE_ns2__FXRatesReply;
			return soap_in_ns2__FXRatesReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FXQuote"))
		{	*type = SOAP_TYPE_ns2__FXQuote;
			return soap_in_ns2__FXQuote(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ExportReply"))
		{	*type = SOAP_TYPE_ns2__ExportReply;
			return soap_in_ns2__ExportReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DeniedPartiesMatch"))
		{	*type = SOAP_TYPE_ns2__DeniedPartiesMatch;
			return soap_in_ns2__DeniedPartiesMatch(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DAVReply"))
		{	*type = SOAP_TYPE_ns2__DAVReply;
			return soap_in_ns2__DAVReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AFSReply"))
		{	*type = SOAP_TYPE_ns2__AFSReply;
			return soap_in_ns2__AFSReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DeviceFingerprint"))
		{	*type = SOAP_TYPE_ns2__DeviceFingerprint;
			return soap_in_ns2__DeviceFingerprint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaxReply"))
		{	*type = SOAP_TYPE_ns2__TaxReply;
			return soap_in_ns2__TaxReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaxReplyItem"))
		{	*type = SOAP_TYPE_ns2__TaxReplyItem;
			return soap_in_ns2__TaxReplyItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayerAuthValidateReply"))
		{	*type = SOAP_TYPE_ns2__PayerAuthValidateReply;
			return soap_in_ns2__PayerAuthValidateReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayerAuthEnrollReply"))
		{	*type = SOAP_TYPE_ns2__PayerAuthEnrollReply;
			return soap_in_ns2__PayerAuthEnrollReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ECAuthenticateReply"))
		{	*type = SOAP_TYPE_ns2__ECAuthenticateReply;
			return soap_in_ns2__ECAuthenticateReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ECCreditReply"))
		{	*type = SOAP_TYPE_ns2__ECCreditReply;
			return soap_in_ns2__ECCreditReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ECDebitReply"))
		{	*type = SOAP_TYPE_ns2__ECDebitReply;
			return soap_in_ns2__ECDebitReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CCAutoAuthReversalReply"))
		{	*type = SOAP_TYPE_ns2__CCAutoAuthReversalReply;
			return soap_in_ns2__CCAutoAuthReversalReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CCAuthReversalReply"))
		{	*type = SOAP_TYPE_ns2__CCAuthReversalReply;
			return soap_in_ns2__CCAuthReversalReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PinDebitReversalReply"))
		{	*type = SOAP_TYPE_ns2__PinDebitReversalReply;
			return soap_in_ns2__PinDebitReversalReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PinDebitCreditReply"))
		{	*type = SOAP_TYPE_ns2__PinDebitCreditReply;
			return soap_in_ns2__PinDebitCreditReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PinDebitPurchaseReply"))
		{	*type = SOAP_TYPE_ns2__PinDebitPurchaseReply;
			return soap_in_ns2__PinDebitPurchaseReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CCCreditReply"))
		{	*type = SOAP_TYPE_ns2__CCCreditReply;
			return soap_in_ns2__CCCreditReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ServiceFeeCalculateReply"))
		{	*type = SOAP_TYPE_ns2__ServiceFeeCalculateReply;
			return soap_in_ns2__ServiceFeeCalculateReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CCCaptureReply"))
		{	*type = SOAP_TYPE_ns2__CCCaptureReply;
			return soap_in_ns2__CCCaptureReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CCIncrementalAuthReply"))
		{	*type = SOAP_TYPE_ns2__CCIncrementalAuthReply;
			return soap_in_ns2__CCIncrementalAuthReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CCSaleReversalReply"))
		{	*type = SOAP_TYPE_ns2__CCSaleReversalReply;
			return soap_in_ns2__CCSaleReversalReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CCSaleCreditReply"))
		{	*type = SOAP_TYPE_ns2__CCSaleCreditReply;
			return soap_in_ns2__CCSaleCreditReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CCSaleReply"))
		{	*type = SOAP_TYPE_ns2__CCSaleReply;
			return soap_in_ns2__CCSaleReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VerificationReply"))
		{	*type = SOAP_TYPE_ns2__VerificationReply;
			return soap_in_ns2__VerificationReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OCTReply"))
		{	*type = SOAP_TYPE_ns2__OCTReply;
			return soap_in_ns2__OCTReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CCAuthReply"))
		{	*type = SOAP_TYPE_ns2__CCAuthReply;
			return soap_in_ns2__CCAuthReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PromotionGroupReply"))
		{	*type = SOAP_TYPE_ns2__PromotionGroupReply;
			return soap_in_ns2__PromotionGroupReply(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PromotionGroup"))
		{	*type = SOAP_TYPE_ns2__PromotionGroup;
			return soap_in_ns2__PromotionGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Promotion"))
		{	*type = SOAP_TYPE_ns2__Promotion;
			return soap_in_ns2__Promotion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DCC"))
		{	*type = SOAP_TYPE_ns2__DCC;
			return soap_in_ns2__DCC(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DecryptVisaCheckoutDataService"))
		{	*type = SOAP_TYPE_ns2__DecryptVisaCheckoutDataService;
			return soap_in_ns2__DecryptVisaCheckoutDataService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VC"))
		{	*type = SOAP_TYPE_ns2__VC;
			return soap_in_ns2__VC(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RequestMessage"))
		{	*type = SOAP_TYPE_ns2__RequestMessage;
			return soap_in_ns2__RequestMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Sender"))
		{	*type = SOAP_TYPE_ns2__Sender;
			return soap_in_ns2__Sender(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Recipient"))
		{	*type = SOAP_TYPE_ns2__Recipient;
			return soap_in_ns2__Recipient(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalTransactionSearchService"))
		{	*type = SOAP_TYPE_ns2__PayPalTransactionSearchService;
			return soap_in_ns2__PayPalTransactionSearchService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalGetTxnDetailsService"))
		{	*type = SOAP_TYPE_ns2__PayPalGetTxnDetailsService;
			return soap_in_ns2__PayPalGetTxnDetailsService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APConfirmPurchaseService"))
		{	*type = SOAP_TYPE_ns2__APConfirmPurchaseService;
			return soap_in_ns2__APConfirmPurchaseService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APTransactionDetailsService"))
		{	*type = SOAP_TYPE_ns2__APTransactionDetailsService;
			return soap_in_ns2__APTransactionDetailsService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APCheckOutDetailsService"))
		{	*type = SOAP_TYPE_ns2__APCheckOutDetailsService;
			return soap_in_ns2__APCheckOutDetailsService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APSaleService"))
		{	*type = SOAP_TYPE_ns2__APSaleService;
			return soap_in_ns2__APSaleService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APRefundService"))
		{	*type = SOAP_TYPE_ns2__APRefundService;
			return soap_in_ns2__APRefundService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APOptionsService"))
		{	*type = SOAP_TYPE_ns2__APOptionsService;
			return soap_in_ns2__APOptionsService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APCaptureService"))
		{	*type = SOAP_TYPE_ns2__APCaptureService;
			return soap_in_ns2__APCaptureService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APAuthReversalService"))
		{	*type = SOAP_TYPE_ns2__APAuthReversalService;
			return soap_in_ns2__APAuthReversalService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APAuthService"))
		{	*type = SOAP_TYPE_ns2__APAuthService;
			return soap_in_ns2__APAuthService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APDevice"))
		{	*type = SOAP_TYPE_ns2__APDevice;
			return soap_in_ns2__APDevice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AP"))
		{	*type = SOAP_TYPE_ns2__AP;
			return soap_in_ns2__AP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Token"))
		{	*type = SOAP_TYPE_ns2__Token;
			return soap_in_ns2__Token(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:JPO"))
		{	*type = SOAP_TYPE_ns2__JPO;
			return soap_in_ns2__JPO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPal"))
		{	*type = SOAP_TYPE_ns2__PayPal;
			return soap_in_ns2__PayPal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Batch"))
		{	*type = SOAP_TYPE_ns2__Batch;
			return soap_in_ns2__Batch(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DecisionManagerTravelLeg"))
		{	*type = SOAP_TYPE_ns2__DecisionManagerTravelLeg;
			return soap_in_ns2__DecisionManagerTravelLeg(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DecisionManagerTravelData"))
		{	*type = SOAP_TYPE_ns2__DecisionManagerTravelData;
			return soap_in_ns2__DecisionManagerTravelData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DecisionManager"))
		{	*type = SOAP_TYPE_ns2__DecisionManager;
			return soap_in_ns2__DecisionManager(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PaymentNetworkToken"))
		{	*type = SOAP_TYPE_ns2__PaymentNetworkToken;
			return soap_in_ns2__PaymentNetworkToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Subscription"))
		{	*type = SOAP_TYPE_ns2__Subscription;
			return soap_in_ns2__Subscription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PaySubscriptionEvent"))
		{	*type = SOAP_TYPE_ns2__PaySubscriptionEvent;
			return soap_in_ns2__PaySubscriptionEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RecurringSubscriptionInfo"))
		{	*type = SOAP_TYPE_ns2__RecurringSubscriptionInfo;
			return soap_in_ns2__RecurringSubscriptionInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BankInfo"))
		{	*type = SOAP_TYPE_ns2__BankInfo;
			return soap_in_ns2__BankInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FundTransfer"))
		{	*type = SOAP_TYPE_ns2__FundTransfer;
			return soap_in_ns2__FundTransfer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UCAF"))
		{	*type = SOAP_TYPE_ns2__UCAF;
			return soap_in_ns2__UCAF(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GECC"))
		{	*type = SOAP_TYPE_ns2__GECC;
			return soap_in_ns2__GECC(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FundingTotals"))
		{	*type = SOAP_TYPE_ns2__FundingTotals;
			return soap_in_ns2__FundingTotals(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PurchaseTotals"))
		{	*type = SOAP_TYPE_ns2__PurchaseTotals;
			return soap_in_ns2__PurchaseTotals(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Wallet"))
		{	*type = SOAP_TYPE_ns2__Wallet;
			return soap_in_ns2__Wallet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Aft"))
		{	*type = SOAP_TYPE_ns2__Aft;
			return soap_in_ns2__Aft(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OtherTax"))
		{	*type = SOAP_TYPE_ns2__OtherTax;
			return soap_in_ns2__OtherTax(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BML"))
		{	*type = SOAP_TYPE_ns2__BML;
			return soap_in_ns2__BML(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Check"))
		{	*type = SOAP_TYPE_ns2__Check;
			return soap_in_ns2__Check(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Card"))
		{	*type = SOAP_TYPE_ns2__Card;
			return soap_in_ns2__Card(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ShipFrom"))
		{	*type = SOAP_TYPE_ns2__ShipFrom;
			return soap_in_ns2__ShipFrom(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ShipTo"))
		{	*type = SOAP_TYPE_ns2__ShipTo;
			return soap_in_ns2__ShipTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BillTo"))
		{	*type = SOAP_TYPE_ns2__BillTo;
			return soap_in_ns2__BillTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BusinessRules"))
		{	*type = SOAP_TYPE_ns2__BusinessRules;
			return soap_in_ns2__BusinessRules(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:InvoiceHeader"))
		{	*type = SOAP_TYPE_ns2__InvoiceHeader;
			return soap_in_ns2__InvoiceHeader(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EncryptPaymentDataService"))
		{	*type = SOAP_TYPE_ns2__EncryptPaymentDataService;
			return soap_in_ns2__EncryptPaymentDataService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CaseManagementActionService"))
		{	*type = SOAP_TYPE_ns2__CaseManagementActionService;
			return soap_in_ns2__CaseManagementActionService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FraudUpdateService"))
		{	*type = SOAP_TYPE_ns2__FraudUpdateService;
			return soap_in_ns2__FraudUpdateService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RiskUpdateService"))
		{	*type = SOAP_TYPE_ns2__RiskUpdateService;
			return soap_in_ns2__RiskUpdateService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APCheckStatusService"))
		{	*type = SOAP_TYPE_ns2__APCheckStatusService;
			return soap_in_ns2__APCheckStatusService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:APInitiateService"))
		{	*type = SOAP_TYPE_ns2__APInitiateService;
			return soap_in_ns2__APInitiateService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Address"))
		{	*type = SOAP_TYPE_ns2__Address;
			return soap_in_ns2__Address(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PersonalId"))
		{	*type = SOAP_TYPE_ns2__PersonalId;
			return soap_in_ns2__PersonalId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BoletoPaymentService"))
		{	*type = SOAP_TYPE_ns2__BoletoPaymentService;
			return soap_in_ns2__BoletoPaymentService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ChinaRefundService"))
		{	*type = SOAP_TYPE_ns2__ChinaRefundService;
			return soap_in_ns2__ChinaRefundService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ChinaPaymentService"))
		{	*type = SOAP_TYPE_ns2__ChinaPaymentService;
			return soap_in_ns2__ChinaPaymentService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalPreapprovedUpdateService"))
		{	*type = SOAP_TYPE_ns2__PayPalPreapprovedUpdateService;
			return soap_in_ns2__PayPalPreapprovedUpdateService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalPreapprovedPaymentService"))
		{	*type = SOAP_TYPE_ns2__PayPalPreapprovedPaymentService;
			return soap_in_ns2__PayPalPreapprovedPaymentService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalButtonCreateService"))
		{	*type = SOAP_TYPE_ns2__PayPalButtonCreateService;
			return soap_in_ns2__PayPalButtonCreateService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PinDebitReversalService"))
		{	*type = SOAP_TYPE_ns2__PinDebitReversalService;
			return soap_in_ns2__PinDebitReversalService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PinDebitCreditService"))
		{	*type = SOAP_TYPE_ns2__PinDebitCreditService;
			return soap_in_ns2__PinDebitCreditService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PinDebitPurchaseService"))
		{	*type = SOAP_TYPE_ns2__PinDebitPurchaseService;
			return soap_in_ns2__PinDebitPurchaseService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PinlessDebitReversalService"))
		{	*type = SOAP_TYPE_ns2__PinlessDebitReversalService;
			return soap_in_ns2__PinlessDebitReversalService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PinlessDebitValidateService"))
		{	*type = SOAP_TYPE_ns2__PinlessDebitValidateService;
			return soap_in_ns2__PinlessDebitValidateService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PinlessDebitService"))
		{	*type = SOAP_TYPE_ns2__PinlessDebitService;
			return soap_in_ns2__PinlessDebitService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VoidService"))
		{	*type = SOAP_TYPE_ns2__VoidService;
			return soap_in_ns2__VoidService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalDoRefTransactionService"))
		{	*type = SOAP_TYPE_ns2__PayPalDoRefTransactionService;
			return soap_in_ns2__PayPalDoRefTransactionService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalCreateAgreementService"))
		{	*type = SOAP_TYPE_ns2__PayPalCreateAgreementService;
			return soap_in_ns2__PayPalCreateAgreementService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalUpdateAgreementService"))
		{	*type = SOAP_TYPE_ns2__PayPalUpdateAgreementService;
			return soap_in_ns2__PayPalUpdateAgreementService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalAuthorizationService"))
		{	*type = SOAP_TYPE_ns2__PayPalAuthorizationService;
			return soap_in_ns2__PayPalAuthorizationService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalEcOrderSetupService"))
		{	*type = SOAP_TYPE_ns2__PayPalEcOrderSetupService;
			return soap_in_ns2__PayPalEcOrderSetupService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalRefundService"))
		{	*type = SOAP_TYPE_ns2__PayPalRefundService;
			return soap_in_ns2__PayPalRefundService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalAuthReversalService"))
		{	*type = SOAP_TYPE_ns2__PayPalAuthReversalService;
			return soap_in_ns2__PayPalAuthReversalService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalDoCaptureService"))
		{	*type = SOAP_TYPE_ns2__PayPalDoCaptureService;
			return soap_in_ns2__PayPalDoCaptureService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalEcDoPaymentService"))
		{	*type = SOAP_TYPE_ns2__PayPalEcDoPaymentService;
			return soap_in_ns2__PayPalEcDoPaymentService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalEcGetDetailsService"))
		{	*type = SOAP_TYPE_ns2__PayPalEcGetDetailsService;
			return soap_in_ns2__PayPalEcGetDetailsService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalEcSetService"))
		{	*type = SOAP_TYPE_ns2__PayPalEcSetService;
			return soap_in_ns2__PayPalEcSetService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalCreditService"))
		{	*type = SOAP_TYPE_ns2__PayPalCreditService;
			return soap_in_ns2__PayPalCreditService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayPalPaymentService"))
		{	*type = SOAP_TYPE_ns2__PayPalPaymentService;
			return soap_in_ns2__PayPalPaymentService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PaySubscriptionDeleteService"))
		{	*type = SOAP_TYPE_ns2__PaySubscriptionDeleteService;
			return soap_in_ns2__PaySubscriptionDeleteService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PaySubscriptionRetrieveService"))
		{	*type = SOAP_TYPE_ns2__PaySubscriptionRetrieveService;
			return soap_in_ns2__PaySubscriptionRetrieveService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PaySubscriptionEventUpdateService"))
		{	*type = SOAP_TYPE_ns2__PaySubscriptionEventUpdateService;
			return soap_in_ns2__PaySubscriptionEventUpdateService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PaySubscriptionUpdateService"))
		{	*type = SOAP_TYPE_ns2__PaySubscriptionUpdateService;
			return soap_in_ns2__PaySubscriptionUpdateService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PaySubscriptionCreateService"))
		{	*type = SOAP_TYPE_ns2__PaySubscriptionCreateService;
			return soap_in_ns2__PaySubscriptionCreateService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DirectDebitValidateService"))
		{	*type = SOAP_TYPE_ns2__DirectDebitValidateService;
			return soap_in_ns2__DirectDebitValidateService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DirectDebitRefundService"))
		{	*type = SOAP_TYPE_ns2__DirectDebitRefundService;
			return soap_in_ns2__DirectDebitRefundService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DirectDebitService"))
		{	*type = SOAP_TYPE_ns2__DirectDebitService;
			return soap_in_ns2__DirectDebitService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DirectDebitMandateService"))
		{	*type = SOAP_TYPE_ns2__DirectDebitMandateService;
			return soap_in_ns2__DirectDebitMandateService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BankTransferRealTimeService"))
		{	*type = SOAP_TYPE_ns2__BankTransferRealTimeService;
			return soap_in_ns2__BankTransferRealTimeService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BankTransferRefundService"))
		{	*type = SOAP_TYPE_ns2__BankTransferRefundService;
			return soap_in_ns2__BankTransferRefundService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:BankTransferService"))
		{	*type = SOAP_TYPE_ns2__BankTransferService;
			return soap_in_ns2__BankTransferService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FXRatesService"))
		{	*type = SOAP_TYPE_ns2__FXRatesService;
			return soap_in_ns2__FXRatesService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ExportService"))
		{	*type = SOAP_TYPE_ns2__ExportService;
			return soap_in_ns2__ExportService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DAVService"))
		{	*type = SOAP_TYPE_ns2__DAVService;
			return soap_in_ns2__DAVService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AFSService"))
		{	*type = SOAP_TYPE_ns2__AFSService;
			return soap_in_ns2__AFSService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DMEService"))
		{	*type = SOAP_TYPE_ns2__DMEService;
			return soap_in_ns2__DMEService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TaxService"))
		{	*type = SOAP_TYPE_ns2__TaxService;
			return soap_in_ns2__TaxService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayerAuthValidateService"))
		{	*type = SOAP_TYPE_ns2__PayerAuthValidateService;
			return soap_in_ns2__PayerAuthValidateService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayerAuthEnrollService"))
		{	*type = SOAP_TYPE_ns2__PayerAuthEnrollService;
			return soap_in_ns2__PayerAuthEnrollService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ECAuthenticateService"))
		{	*type = SOAP_TYPE_ns2__ECAuthenticateService;
			return soap_in_ns2__ECAuthenticateService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ECCreditService"))
		{	*type = SOAP_TYPE_ns2__ECCreditService;
			return soap_in_ns2__ECCreditService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ECDebitService"))
		{	*type = SOAP_TYPE_ns2__ECDebitService;
			return soap_in_ns2__ECDebitService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ServiceFeeCalculateService"))
		{	*type = SOAP_TYPE_ns2__ServiceFeeCalculateService;
			return soap_in_ns2__ServiceFeeCalculateService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CCDCCService"))
		{	*type = SOAP_TYPE_ns2__CCDCCService;
			return soap_in_ns2__CCDCCService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CCAutoAuthReversalService"))
		{	*type = SOAP_TYPE_ns2__CCAutoAuthReversalService;
			return soap_in_ns2__CCAutoAuthReversalService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CCAuthReversalService"))
		{	*type = SOAP_TYPE_ns2__CCAuthReversalService;
			return soap_in_ns2__CCAuthReversalService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CCCreditService"))
		{	*type = SOAP_TYPE_ns2__CCCreditService;
			return soap_in_ns2__CCCreditService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CCCaptureService"))
		{	*type = SOAP_TYPE_ns2__CCCaptureService;
			return soap_in_ns2__CCCaptureService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CCIncrementalAuthService"))
		{	*type = SOAP_TYPE_ns2__CCIncrementalAuthService;
			return soap_in_ns2__CCIncrementalAuthService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CCSaleReversalService"))
		{	*type = SOAP_TYPE_ns2__CCSaleReversalService;
			return soap_in_ns2__CCSaleReversalService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CCSaleCreditService"))
		{	*type = SOAP_TYPE_ns2__CCSaleCreditService;
			return soap_in_ns2__CCSaleCreditService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CCSaleService"))
		{	*type = SOAP_TYPE_ns2__CCSaleService;
			return soap_in_ns2__CCSaleService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:VerificationService"))
		{	*type = SOAP_TYPE_ns2__VerificationService;
			return soap_in_ns2__VerificationService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OCTService"))
		{	*type = SOAP_TYPE_ns2__OCTService;
			return soap_in_ns2__OCTService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CCAuthService"))
		{	*type = SOAP_TYPE_ns2__CCAuthService;
			return soap_in_ns2__CCAuthService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Item"))
		{	*type = SOAP_TYPE_ns2__Item;
			return soap_in_ns2__Item(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_ULONG64;
			return soap_in_ULONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsc:FaultCodeType"))
		{	*type = SOAP_TYPE_wsc__FaultCodeType;
			return soap_in_wsc__FaultCodeType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:FaultcodeEnum"))
		{	*type = SOAP_TYPE_wsse__FaultcodeEnum;
			return soap_in_wsse__FaultcodeEnum(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsu:tTimestampFault"))
		{	*type = SOAP_TYPE_wsu__tTimestampFault;
			return soap_in_wsu__tTimestampFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsc:PropertiesType"))
		{	*type = SOAP_TYPE_wsc__PropertiesType;
			return soap_in_wsc__PropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsc:DerivedKeyTokenType"))
		{	*type = SOAP_TYPE_wsc__DerivedKeyTokenType;
			return soap_in_wsc__DerivedKeyTokenType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsc:SecurityContextTokenType"))
		{	*type = SOAP_TYPE_wsc__SecurityContextTokenType;
			return soap_in_wsc__SecurityContextTokenType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptionPropertyType"))
		{	*type = SOAP_TYPE_xenc__EncryptionPropertyType;
			return soap_in_xenc__EncryptionPropertyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptionPropertiesType"))
		{	*type = SOAP_TYPE_xenc__EncryptionPropertiesType;
			return soap_in_xenc__EncryptionPropertiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:ReferenceType"))
		{	*type = SOAP_TYPE_xenc__ReferenceType;
			return soap_in_xenc__ReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:AgreementMethodType"))
		{	*type = SOAP_TYPE_xenc__AgreementMethodType;
			return soap_in_xenc__AgreementMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptedKeyType"))
		{	*type = SOAP_TYPE_xenc__EncryptedKeyType;
			return soap_in_xenc__EncryptedKeyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptedDataType"))
		{	*type = SOAP_TYPE_xenc__EncryptedDataType;
			return soap_in_xenc__EncryptedDataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:TransformsType"))
		{	*type = SOAP_TYPE_xenc__TransformsType;
			return soap_in_xenc__TransformsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:CipherReferenceType"))
		{	*type = SOAP_TYPE_xenc__CipherReferenceType;
			return soap_in_xenc__CipherReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:CipherDataType"))
		{	*type = SOAP_TYPE_xenc__CipherDataType;
			return soap_in_xenc__CipherDataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptionMethodType"))
		{	*type = SOAP_TYPE_xenc__EncryptionMethodType;
			return soap_in_xenc__EncryptionMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:EncryptedType"))
		{	*type = SOAP_TYPE_xenc__EncryptedType;
			return soap_in_xenc__EncryptedType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:RSAKeyValueType"))
		{	*type = SOAP_TYPE_ds__RSAKeyValueType;
			return soap_in_ds__RSAKeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:DSAKeyValueType"))
		{	*type = SOAP_TYPE_ds__DSAKeyValueType;
			return soap_in_ds__DSAKeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:X509IssuerSerialType"))
		{	*type = SOAP_TYPE_ds__X509IssuerSerialType;
			return soap_in_ds__X509IssuerSerialType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:RetrievalMethodType"))
		{	*type = SOAP_TYPE_ds__RetrievalMethodType;
			return soap_in_ds__RetrievalMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyValueType"))
		{	*type = SOAP_TYPE_ds__KeyValueType;
			return soap_in_ds__KeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:DigestMethodType"))
		{	*type = SOAP_TYPE_ds__DigestMethodType;
			return soap_in_ds__DigestMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:TransformType"))
		{	*type = SOAP_TYPE_ds__TransformType;
			return soap_in_ds__TransformType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:TransformsType"))
		{	*type = SOAP_TYPE_ds__TransformsType;
			return soap_in_ds__TransformsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:ReferenceType"))
		{	*type = SOAP_TYPE_ds__ReferenceType;
			return soap_in_ds__ReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureMethodType"))
		{	*type = SOAP_TYPE_ds__SignatureMethodType;
			return soap_in_ds__SignatureMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:CanonicalizationMethodType"))
		{	*type = SOAP_TYPE_ds__CanonicalizationMethodType;
			return soap_in_ds__CanonicalizationMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyInfoType"))
		{	*type = SOAP_TYPE_ds__KeyInfoType;
			return soap_in_ds__KeyInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignedInfoType"))
		{	*type = SOAP_TYPE_ds__SignedInfoType;
			return soap_in_ds__SignedInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureType"))
		{	*type = SOAP_TYPE_ds__SignatureType;
			return soap_in_ds__SignatureType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:X509DataType"))
		{	*type = SOAP_TYPE_ds__X509DataType;
			return soap_in_ds__X509DataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:EncodedString"))
		{	*type = SOAP_TYPE_wsse__EncodedString;
			return soap_in_wsse__EncodedString(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:dateTime"))
		{	wchar_t **s;
			*type = SOAP_TYPE_ns2__dateTime;
			s = soap_in_ns2__dateTime(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "ns2:boolean"))
		{	wchar_t **s;
			*type = SOAP_TYPE_ns2__boolean;
			s = soap_in_ns2__boolean(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "ns2:amount"))
		{	wchar_t **s;
			*type = SOAP_TYPE_ns2__amount;
			s = soap_in_ns2__amount(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	wchar_t **s;
			*type = SOAP_TYPE_xsd__integer;
			s = soap_in_xsd__integer(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	wchar_t **s;
			*type = SOAP_TYPE_wstring;
			s = soap_in_wstring(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsc:FaultCodeOpenEnumType"))
		{	char **s;
			*type = SOAP_TYPE_wsc__FaultCodeOpenEnumType;
			s = soap_in_wsc__FaultCodeOpenEnumType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "wsse:Security"))
		{	*type = SOAP_TYPE__wsse__Security;
			return soap_in__wsse__Security(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xenc:ReferenceList"))
		{	*type = SOAP_TYPE__xenc__ReferenceList;
			return soap_in__xenc__ReferenceList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyInfo"))
		{	*type = SOAP_TYPE__ds__KeyInfo;
			return soap_in__ds__KeyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:Transform"))
		{	*type = SOAP_TYPE__ds__Transform;
			return soap_in__ds__Transform(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "c14n:InclusiveNamespaces"))
		{	*type = SOAP_TYPE__c14n__InclusiveNamespaces;
			return soap_in__c14n__InclusiveNamespaces(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:Signature"))
		{	*type = SOAP_TYPE__ds__Signature;
			return soap_in__ds__Signature(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:SecurityTokenReference"))
		{	*type = SOAP_TYPE__wsse__SecurityTokenReference;
			return soap_in__wsse__SecurityTokenReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:KeyIdentifier"))
		{	*type = SOAP_TYPE__wsse__KeyIdentifier;
			return soap_in__wsse__KeyIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Embedded"))
		{	*type = SOAP_TYPE__wsse__Embedded;
			return soap_in__wsse__Embedded(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Reference"))
		{	*type = SOAP_TYPE__wsse__Reference;
			return soap_in__wsse__Reference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:BinarySecurityToken"))
		{	*type = SOAP_TYPE__wsse__BinarySecurityToken;
			return soap_in__wsse__BinarySecurityToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Password"))
		{	*type = SOAP_TYPE__wsse__Password;
			return soap_in__wsse__Password(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:UsernameToken"))
		{	*type = SOAP_TYPE__wsse__UsernameToken;
			return soap_in__wsse__UsernameToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsu:Timestamp"))
		{	*type = SOAP_TYPE__wsu__Timestamp;
			return soap_in__wsu__Timestamp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureValue"))
		{	char **s;
			*type = SOAP_TYPE__ds__SignatureValue;
			s = soap_in__ds__SignatureValue(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				if (soap_ignore(soap) || soap_element_end_in(soap, NULL))
					return soap->error;
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_ULONG64:
		return soap_out_ULONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_wsc__FaultCodeType:
		return soap_out_wsc__FaultCodeType(soap, tag, id, (const enum wsc__FaultCodeType *)ptr, "wsc:FaultCodeType");
	case SOAP_TYPE_wsse__FaultcodeEnum:
		return soap_out_wsse__FaultcodeEnum(soap, tag, id, (const enum wsse__FaultcodeEnum *)ptr, "wsse:FaultcodeEnum");
	case SOAP_TYPE_wsu__tTimestampFault:
		return soap_out_wsu__tTimestampFault(soap, tag, id, (const enum wsu__tTimestampFault *)ptr, "wsu:tTimestampFault");
	case SOAP_TYPE_ns2__issuer:
		return ((ns2__issuer *)ptr)->soap_out(soap, tag, id, "ns2:issuer");
	case SOAP_TYPE_ns2__BinLookupReply:
		return ((ns2__BinLookupReply *)ptr)->soap_out(soap, tag, id, "ns2:BinLookupReply");
	case SOAP_TYPE_ns2__BinLookupService:
		return ((ns2__BinLookupService *)ptr)->soap_out(soap, tag, id, "ns2:BinLookupService");
	case SOAP_TYPE_ns2__EncryptPaymentDataReply:
		return ((ns2__EncryptPaymentDataReply *)ptr)->soap_out(soap, tag, id, "ns2:EncryptPaymentDataReply");
	case SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply:
		return ((ns2__DecryptVisaCheckoutDataReply *)ptr)->soap_out(soap, tag, id, "ns2:DecryptVisaCheckoutDataReply");
	case SOAP_TYPE_ns2__VCCustomData:
		return ((ns2__VCCustomData *)ptr)->soap_out(soap, tag, id, "ns2:VCCustomData");
	case SOAP_TYPE_ns2__VCCardArt:
		return ((ns2__VCCardArt *)ptr)->soap_out(soap, tag, id, "ns2:VCCardArt");
	case SOAP_TYPE_ns2__VCReply:
		return ((ns2__VCReply *)ptr)->soap_out(soap, tag, id, "ns2:VCReply");
	case SOAP_TYPE_ns2__AutoRentalData:
		return ((ns2__AutoRentalData *)ptr)->soap_out(soap, tag, id, "ns2:AutoRentalData");
	case SOAP_TYPE_ns2__HostedDataRetrieveReply:
		return ((ns2__HostedDataRetrieveReply *)ptr)->soap_out(soap, tag, id, "ns2:HostedDataRetrieveReply");
	case SOAP_TYPE_ns2__HostedDataCreateReply:
		return ((ns2__HostedDataCreateReply *)ptr)->soap_out(soap, tag, id, "ns2:HostedDataCreateReply");
	case SOAP_TYPE_ns2__HostedDataRetrieveService:
		return ((ns2__HostedDataRetrieveService *)ptr)->soap_out(soap, tag, id, "ns2:HostedDataRetrieveService");
	case SOAP_TYPE_ns2__HostedDataCreateService:
		return ((ns2__HostedDataCreateService *)ptr)->soap_out(soap, tag, id, "ns2:HostedDataCreateService");
	case SOAP_TYPE_ns2__OriginalTransaction:
		return ((ns2__OriginalTransaction *)ptr)->soap_out(soap, tag, id, "ns2:OriginalTransaction");
	case SOAP_TYPE_ns2__EmvReply:
		return ((ns2__EmvReply *)ptr)->soap_out(soap, tag, id, "ns2:EmvReply");
	case SOAP_TYPE_ns2__EmvRequest:
		return ((ns2__EmvRequest *)ptr)->soap_out(soap, tag, id, "ns2:EmvRequest");
	case SOAP_TYPE_ns2__ServiceFee:
		return ((ns2__ServiceFee *)ptr)->soap_out(soap, tag, id, "ns2:ServiceFee");
	case SOAP_TYPE_ns2__CCDCCUpdateService:
		return ((ns2__CCDCCUpdateService *)ptr)->soap_out(soap, tag, id, "ns2:CCDCCUpdateService");
	case SOAP_TYPE_ns2__PaypalTransaction:
		return ((ns2__PaypalTransaction *)ptr)->soap_out(soap, tag, id, "ns2:PaypalTransaction");
	case SOAP_TYPE_ns2__PayPalTransactionSearchReply:
		return ((ns2__PayPalTransactionSearchReply *)ptr)->soap_out(soap, tag, id, "ns2:PayPalTransactionSearchReply");
	case SOAP_TYPE_ns2__PayPalGetTxnDetailsReply:
		return ((ns2__PayPalGetTxnDetailsReply *)ptr)->soap_out(soap, tag, id, "ns2:PayPalGetTxnDetailsReply");
	case SOAP_TYPE_ns2__RequestReserved:
		return ((ns2__RequestReserved *)ptr)->soap_out(soap, tag, id, "ns2:RequestReserved");
	case SOAP_TYPE_ns2__ReplyReserved:
		return ((ns2__ReplyReserved *)ptr)->soap_out(soap, tag, id, "ns2:ReplyReserved");
	case SOAP_TYPE_ns2__MerchantSecureData:
		return ((ns2__MerchantSecureData *)ptr)->soap_out(soap, tag, id, "ns2:MerchantSecureData");
	case SOAP_TYPE_ns2__MerchantDefinedData:
		return ((ns2__MerchantDefinedData *)ptr)->soap_out(soap, tag, id, "ns2:MerchantDefinedData");
	case SOAP_TYPE_ns2__MDDField:
		return ((ns2__MDDField *)ptr)->soap_out(soap, tag, id, "ns2:MDDField");
	case SOAP_TYPE_ns2__Installment:
		return ((ns2__Installment *)ptr)->soap_out(soap, tag, id, "ns2:Installment");
	case SOAP_TYPE_ns2__EncryptedPayment:
		return ((ns2__EncryptedPayment *)ptr)->soap_out(soap, tag, id, "ns2:EncryptedPayment");
	case SOAP_TYPE_ns2__Pos:
		return ((ns2__Pos *)ptr)->soap_out(soap, tag, id, "ns2:Pos");
	case SOAP_TYPE_ns2__LodgingData:
		return ((ns2__LodgingData *)ptr)->soap_out(soap, tag, id, "ns2:LodgingData");
	case SOAP_TYPE_ns2__Service:
		return ((ns2__Service *)ptr)->soap_out(soap, tag, id, "ns2:Service");
	case SOAP_TYPE_ns2__AncillaryData:
		return ((ns2__AncillaryData *)ptr)->soap_out(soap, tag, id, "ns2:AncillaryData");
	case SOAP_TYPE_ns2__Leg:
		return ((ns2__Leg *)ptr)->soap_out(soap, tag, id, "ns2:Leg");
	case SOAP_TYPE_ns2__AirlineData:
		return ((ns2__AirlineData *)ptr)->soap_out(soap, tag, id, "ns2:AirlineData");
	case SOAP_TYPE_ns2__FaultDetails:
		return ((ns2__FaultDetails *)ptr)->soap_out(soap, tag, id, "ns2:FaultDetails");
	case SOAP_TYPE_ns2__ReplyMessage:
		return ((ns2__ReplyMessage *)ptr)->soap_out(soap, tag, id, "ns2:ReplyMessage");
	case SOAP_TYPE_ns2__APConfirmPurchaseReply:
		return ((ns2__APConfirmPurchaseReply *)ptr)->soap_out(soap, tag, id, "ns2:APConfirmPurchaseReply");
	case SOAP_TYPE_ns2__APTransactionDetailsReply:
		return ((ns2__APTransactionDetailsReply *)ptr)->soap_out(soap, tag, id, "ns2:APTransactionDetailsReply");
	case SOAP_TYPE_ns2__APCheckOutDetailsReply:
		return ((ns2__APCheckOutDetailsReply *)ptr)->soap_out(soap, tag, id, "ns2:APCheckOutDetailsReply");
	case SOAP_TYPE_ns2__APSaleReply:
		return ((ns2__APSaleReply *)ptr)->soap_out(soap, tag, id, "ns2:APSaleReply");
	case SOAP_TYPE_ns2__APRefundReply:
		return ((ns2__APRefundReply *)ptr)->soap_out(soap, tag, id, "ns2:APRefundReply");
	case SOAP_TYPE_ns2__APOptionsOption:
		return ((ns2__APOptionsOption *)ptr)->soap_out(soap, tag, id, "ns2:APOptionsOption");
	case SOAP_TYPE_ns2__APOptionsReply:
		return ((ns2__APOptionsReply *)ptr)->soap_out(soap, tag, id, "ns2:APOptionsReply");
	case SOAP_TYPE_ns2__APCaptureReply:
		return ((ns2__APCaptureReply *)ptr)->soap_out(soap, tag, id, "ns2:APCaptureReply");
	case SOAP_TYPE_ns2__APAuthReversalReply:
		return ((ns2__APAuthReversalReply *)ptr)->soap_out(soap, tag, id, "ns2:APAuthReversalReply");
	case SOAP_TYPE_ns2__APAuthReply:
		return ((ns2__APAuthReply *)ptr)->soap_out(soap, tag, id, "ns2:APAuthReply");
	case SOAP_TYPE_ns2__APReply:
		return ((ns2__APReply *)ptr)->soap_out(soap, tag, id, "ns2:APReply");
	case SOAP_TYPE_ns2__APCheckStatusReply:
		return ((ns2__APCheckStatusReply *)ptr)->soap_out(soap, tag, id, "ns2:APCheckStatusReply");
	case SOAP_TYPE_ns2__APInitiateReply:
		return ((ns2__APInitiateReply *)ptr)->soap_out(soap, tag, id, "ns2:APInitiateReply");
	case SOAP_TYPE_ns2__BoletoPaymentReply:
		return ((ns2__BoletoPaymentReply *)ptr)->soap_out(soap, tag, id, "ns2:BoletoPaymentReply");
	case SOAP_TYPE_ns2__ChinaRefundReply:
		return ((ns2__ChinaRefundReply *)ptr)->soap_out(soap, tag, id, "ns2:ChinaRefundReply");
	case SOAP_TYPE_ns2__ChinaPaymentReply:
		return ((ns2__ChinaPaymentReply *)ptr)->soap_out(soap, tag, id, "ns2:ChinaPaymentReply");
	case SOAP_TYPE_ns2__CCDCCUpdateReply:
		return ((ns2__CCDCCUpdateReply *)ptr)->soap_out(soap, tag, id, "ns2:CCDCCUpdateReply");
	case SOAP_TYPE_ns2__CCDCCReply:
		return ((ns2__CCDCCReply *)ptr)->soap_out(soap, tag, id, "ns2:CCDCCReply");
	case SOAP_TYPE_ns2__ProfileReply:
		return ((ns2__ProfileReply *)ptr)->soap_out(soap, tag, id, "ns2:ProfileReply");
	case SOAP_TYPE_ns2__DMEReply:
		return ((ns2__DMEReply *)ptr)->soap_out(soap, tag, id, "ns2:DMEReply");
	case SOAP_TYPE_ns2__Field:
		return ((ns2__Field *)ptr)->soap_out(soap, tag, id, "ns2:Field");
	case SOAP_TYPE_ns2__AdditionalFields:
		return ((ns2__AdditionalFields *)ptr)->soap_out(soap, tag, id, "ns2:AdditionalFields");
	case SOAP_TYPE_ns2__DecisionReply:
		return ((ns2__DecisionReply *)ptr)->soap_out(soap, tag, id, "ns2:DecisionReply");
	case SOAP_TYPE_ns2__RuleResultItems:
		return ((ns2__RuleResultItems *)ptr)->soap_out(soap, tag, id, "ns2:RuleResultItems");
	case SOAP_TYPE_ns2__RuleResultItem:
		return ((ns2__RuleResultItem *)ptr)->soap_out(soap, tag, id, "ns2:RuleResultItem");
	case SOAP_TYPE_ns2__CaseManagementActionReply:
		return ((ns2__CaseManagementActionReply *)ptr)->soap_out(soap, tag, id, "ns2:CaseManagementActionReply");
	case SOAP_TYPE_ns2__FraudUpdateReply:
		return ((ns2__FraudUpdateReply *)ptr)->soap_out(soap, tag, id, "ns2:FraudUpdateReply");
	case SOAP_TYPE_ns2__RiskUpdateReply:
		return ((ns2__RiskUpdateReply *)ptr)->soap_out(soap, tag, id, "ns2:RiskUpdateReply");
	case SOAP_TYPE_ns2__PayPalDoRefTransactionReply:
		return ((ns2__PayPalDoRefTransactionReply *)ptr)->soap_out(soap, tag, id, "ns2:PayPalDoRefTransactionReply");
	case SOAP_TYPE_ns2__PayPalCreateAgreementReply:
		return ((ns2__PayPalCreateAgreementReply *)ptr)->soap_out(soap, tag, id, "ns2:PayPalCreateAgreementReply");
	case SOAP_TYPE_ns2__PayPalUpdateAgreementReply:
		return ((ns2__PayPalUpdateAgreementReply *)ptr)->soap_out(soap, tag, id, "ns2:PayPalUpdateAgreementReply");
	case SOAP_TYPE_ns2__PayPalAuthorizationReply:
		return ((ns2__PayPalAuthorizationReply *)ptr)->soap_out(soap, tag, id, "ns2:PayPalAuthorizationReply");
	case SOAP_TYPE_ns2__PayPalEcOrderSetupReply:
		return ((ns2__PayPalEcOrderSetupReply *)ptr)->soap_out(soap, tag, id, "ns2:PayPalEcOrderSetupReply");
	case SOAP_TYPE_ns2__PayPalRefundReply:
		return ((ns2__PayPalRefundReply *)ptr)->soap_out(soap, tag, id, "ns2:PayPalRefundReply");
	case SOAP_TYPE_ns2__PayPalAuthReversalReply:
		return ((ns2__PayPalAuthReversalReply *)ptr)->soap_out(soap, tag, id, "ns2:PayPalAuthReversalReply");
	case SOAP_TYPE_ns2__PayPalDoCaptureReply:
		return ((ns2__PayPalDoCaptureReply *)ptr)->soap_out(soap, tag, id, "ns2:PayPalDoCaptureReply");
	case SOAP_TYPE_ns2__PayPalEcDoPaymentReply:
		return ((ns2__PayPalEcDoPaymentReply *)ptr)->soap_out(soap, tag, id, "ns2:PayPalEcDoPaymentReply");
	case SOAP_TYPE_ns2__PayPalEcGetDetailsReply:
		return ((ns2__PayPalEcGetDetailsReply *)ptr)->soap_out(soap, tag, id, "ns2:PayPalEcGetDetailsReply");
	case SOAP_TYPE_ns2__PayPalEcSetReply:
		return ((ns2__PayPalEcSetReply *)ptr)->soap_out(soap, tag, id, "ns2:PayPalEcSetReply");
	case SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply:
		return ((ns2__PayPalPreapprovedUpdateReply *)ptr)->soap_out(soap, tag, id, "ns2:PayPalPreapprovedUpdateReply");
	case SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply:
		return ((ns2__PayPalPreapprovedPaymentReply *)ptr)->soap_out(soap, tag, id, "ns2:PayPalPreapprovedPaymentReply");
	case SOAP_TYPE_ns2__PayPalButtonCreateReply:
		return ((ns2__PayPalButtonCreateReply *)ptr)->soap_out(soap, tag, id, "ns2:PayPalButtonCreateReply");
	case SOAP_TYPE_ns2__PinlessDebitReversalReply:
		return ((ns2__PinlessDebitReversalReply *)ptr)->soap_out(soap, tag, id, "ns2:PinlessDebitReversalReply");
	case SOAP_TYPE_ns2__PinlessDebitValidateReply:
		return ((ns2__PinlessDebitValidateReply *)ptr)->soap_out(soap, tag, id, "ns2:PinlessDebitValidateReply");
	case SOAP_TYPE_ns2__PinlessDebitReply:
		return ((ns2__PinlessDebitReply *)ptr)->soap_out(soap, tag, id, "ns2:PinlessDebitReply");
	case SOAP_TYPE_ns2__VoidReply:
		return ((ns2__VoidReply *)ptr)->soap_out(soap, tag, id, "ns2:VoidReply");
	case SOAP_TYPE_ns2__PayPalCreditReply:
		return ((ns2__PayPalCreditReply *)ptr)->soap_out(soap, tag, id, "ns2:PayPalCreditReply");
	case SOAP_TYPE_ns2__PayPalPaymentReply:
		return ((ns2__PayPalPaymentReply *)ptr)->soap_out(soap, tag, id, "ns2:PayPalPaymentReply");
	case SOAP_TYPE_ns2__PaySubscriptionDeleteReply:
		return ((ns2__PaySubscriptionDeleteReply *)ptr)->soap_out(soap, tag, id, "ns2:PaySubscriptionDeleteReply");
	case SOAP_TYPE_ns2__PaySubscriptionRetrieveReply:
		return ((ns2__PaySubscriptionRetrieveReply *)ptr)->soap_out(soap, tag, id, "ns2:PaySubscriptionRetrieveReply");
	case SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply:
		return ((ns2__PaySubscriptionEventUpdateReply *)ptr)->soap_out(soap, tag, id, "ns2:PaySubscriptionEventUpdateReply");
	case SOAP_TYPE_ns2__PaySubscriptionUpdateReply:
		return ((ns2__PaySubscriptionUpdateReply *)ptr)->soap_out(soap, tag, id, "ns2:PaySubscriptionUpdateReply");
	case SOAP_TYPE_ns2__PaySubscriptionCreateReply:
		return ((ns2__PaySubscriptionCreateReply *)ptr)->soap_out(soap, tag, id, "ns2:PaySubscriptionCreateReply");
	case SOAP_TYPE_ns2__DirectDebitRefundReply:
		return ((ns2__DirectDebitRefundReply *)ptr)->soap_out(soap, tag, id, "ns2:DirectDebitRefundReply");
	case SOAP_TYPE_ns2__DirectDebitValidateReply:
		return ((ns2__DirectDebitValidateReply *)ptr)->soap_out(soap, tag, id, "ns2:DirectDebitValidateReply");
	case SOAP_TYPE_ns2__DirectDebitReply:
		return ((ns2__DirectDebitReply *)ptr)->soap_out(soap, tag, id, "ns2:DirectDebitReply");
	case SOAP_TYPE_ns2__BankTransferRefundReply:
		return ((ns2__BankTransferRefundReply *)ptr)->soap_out(soap, tag, id, "ns2:BankTransferRefundReply");
	case SOAP_TYPE_ns2__DirectDebitMandateReply:
		return ((ns2__DirectDebitMandateReply *)ptr)->soap_out(soap, tag, id, "ns2:DirectDebitMandateReply");
	case SOAP_TYPE_ns2__BankTransferRealTimeReply:
		return ((ns2__BankTransferRealTimeReply *)ptr)->soap_out(soap, tag, id, "ns2:BankTransferRealTimeReply");
	case SOAP_TYPE_ns2__BankTransferReply:
		return ((ns2__BankTransferReply *)ptr)->soap_out(soap, tag, id, "ns2:BankTransferReply");
	case SOAP_TYPE_ns2__FXRatesReply:
		return ((ns2__FXRatesReply *)ptr)->soap_out(soap, tag, id, "ns2:FXRatesReply");
	case SOAP_TYPE_ns2__FXQuote:
		return ((ns2__FXQuote *)ptr)->soap_out(soap, tag, id, "ns2:FXQuote");
	case SOAP_TYPE_ns2__ExportReply:
		return ((ns2__ExportReply *)ptr)->soap_out(soap, tag, id, "ns2:ExportReply");
	case SOAP_TYPE_ns2__DeniedPartiesMatch:
		return ((ns2__DeniedPartiesMatch *)ptr)->soap_out(soap, tag, id, "ns2:DeniedPartiesMatch");
	case SOAP_TYPE_ns2__DAVReply:
		return ((ns2__DAVReply *)ptr)->soap_out(soap, tag, id, "ns2:DAVReply");
	case SOAP_TYPE_ns2__AFSReply:
		return ((ns2__AFSReply *)ptr)->soap_out(soap, tag, id, "ns2:AFSReply");
	case SOAP_TYPE_ns2__DeviceFingerprint:
		return ((ns2__DeviceFingerprint *)ptr)->soap_out(soap, tag, id, "ns2:DeviceFingerprint");
	case SOAP_TYPE_ns2__TaxReply:
		return ((ns2__TaxReply *)ptr)->soap_out(soap, tag, id, "ns2:TaxReply");
	case SOAP_TYPE_ns2__TaxReplyItem:
		return ((ns2__TaxReplyItem *)ptr)->soap_out(soap, tag, id, "ns2:TaxReplyItem");
	case SOAP_TYPE_ns2__PayerAuthValidateReply:
		return ((ns2__PayerAuthValidateReply *)ptr)->soap_out(soap, tag, id, "ns2:PayerAuthValidateReply");
	case SOAP_TYPE_ns2__PayerAuthEnrollReply:
		return ((ns2__PayerAuthEnrollReply *)ptr)->soap_out(soap, tag, id, "ns2:PayerAuthEnrollReply");
	case SOAP_TYPE_ns2__ECAuthenticateReply:
		return ((ns2__ECAuthenticateReply *)ptr)->soap_out(soap, tag, id, "ns2:ECAuthenticateReply");
	case SOAP_TYPE_ns2__ECCreditReply:
		return ((ns2__ECCreditReply *)ptr)->soap_out(soap, tag, id, "ns2:ECCreditReply");
	case SOAP_TYPE_ns2__ECDebitReply:
		return ((ns2__ECDebitReply *)ptr)->soap_out(soap, tag, id, "ns2:ECDebitReply");
	case SOAP_TYPE_ns2__CCAutoAuthReversalReply:
		return ((ns2__CCAutoAuthReversalReply *)ptr)->soap_out(soap, tag, id, "ns2:CCAutoAuthReversalReply");
	case SOAP_TYPE_ns2__CCAuthReversalReply:
		return ((ns2__CCAuthReversalReply *)ptr)->soap_out(soap, tag, id, "ns2:CCAuthReversalReply");
	case SOAP_TYPE_ns2__PinDebitReversalReply:
		return ((ns2__PinDebitReversalReply *)ptr)->soap_out(soap, tag, id, "ns2:PinDebitReversalReply");
	case SOAP_TYPE_ns2__PinDebitCreditReply:
		return ((ns2__PinDebitCreditReply *)ptr)->soap_out(soap, tag, id, "ns2:PinDebitCreditReply");
	case SOAP_TYPE_ns2__PinDebitPurchaseReply:
		return ((ns2__PinDebitPurchaseReply *)ptr)->soap_out(soap, tag, id, "ns2:PinDebitPurchaseReply");
	case SOAP_TYPE_ns2__CCCreditReply:
		return ((ns2__CCCreditReply *)ptr)->soap_out(soap, tag, id, "ns2:CCCreditReply");
	case SOAP_TYPE_ns2__ServiceFeeCalculateReply:
		return ((ns2__ServiceFeeCalculateReply *)ptr)->soap_out(soap, tag, id, "ns2:ServiceFeeCalculateReply");
	case SOAP_TYPE_ns2__CCCaptureReply:
		return ((ns2__CCCaptureReply *)ptr)->soap_out(soap, tag, id, "ns2:CCCaptureReply");
	case SOAP_TYPE_ns2__CCIncrementalAuthReply:
		return ((ns2__CCIncrementalAuthReply *)ptr)->soap_out(soap, tag, id, "ns2:CCIncrementalAuthReply");
	case SOAP_TYPE_ns2__CCSaleReversalReply:
		return ((ns2__CCSaleReversalReply *)ptr)->soap_out(soap, tag, id, "ns2:CCSaleReversalReply");
	case SOAP_TYPE_ns2__CCSaleCreditReply:
		return ((ns2__CCSaleCreditReply *)ptr)->soap_out(soap, tag, id, "ns2:CCSaleCreditReply");
	case SOAP_TYPE_ns2__CCSaleReply:
		return ((ns2__CCSaleReply *)ptr)->soap_out(soap, tag, id, "ns2:CCSaleReply");
	case SOAP_TYPE_ns2__VerificationReply:
		return ((ns2__VerificationReply *)ptr)->soap_out(soap, tag, id, "ns2:VerificationReply");
	case SOAP_TYPE_ns2__OCTReply:
		return ((ns2__OCTReply *)ptr)->soap_out(soap, tag, id, "ns2:OCTReply");
	case SOAP_TYPE_ns2__CCAuthReply:
		return ((ns2__CCAuthReply *)ptr)->soap_out(soap, tag, id, "ns2:CCAuthReply");
	case SOAP_TYPE_ns2__PromotionGroupReply:
		return ((ns2__PromotionGroupReply *)ptr)->soap_out(soap, tag, id, "ns2:PromotionGroupReply");
	case SOAP_TYPE_ns2__PromotionGroup:
		return ((ns2__PromotionGroup *)ptr)->soap_out(soap, tag, id, "ns2:PromotionGroup");
	case SOAP_TYPE_ns2__Promotion:
		return ((ns2__Promotion *)ptr)->soap_out(soap, tag, id, "ns2:Promotion");
	case SOAP_TYPE_ns2__DCC:
		return ((ns2__DCC *)ptr)->soap_out(soap, tag, id, "ns2:DCC");
	case SOAP_TYPE_ns2__DecryptVisaCheckoutDataService:
		return ((ns2__DecryptVisaCheckoutDataService *)ptr)->soap_out(soap, tag, id, "ns2:DecryptVisaCheckoutDataService");
	case SOAP_TYPE_ns2__VC:
		return ((ns2__VC *)ptr)->soap_out(soap, tag, id, "ns2:VC");
	case SOAP_TYPE_ns2__RequestMessage:
		return ((ns2__RequestMessage *)ptr)->soap_out(soap, tag, id, "ns2:RequestMessage");
	case SOAP_TYPE_ns2__Sender:
		return ((ns2__Sender *)ptr)->soap_out(soap, tag, id, "ns2:Sender");
	case SOAP_TYPE_ns2__Recipient:
		return ((ns2__Recipient *)ptr)->soap_out(soap, tag, id, "ns2:Recipient");
	case SOAP_TYPE_ns2__PayPalTransactionSearchService:
		return ((ns2__PayPalTransactionSearchService *)ptr)->soap_out(soap, tag, id, "ns2:PayPalTransactionSearchService");
	case SOAP_TYPE_ns2__PayPalGetTxnDetailsService:
		return ((ns2__PayPalGetTxnDetailsService *)ptr)->soap_out(soap, tag, id, "ns2:PayPalGetTxnDetailsService");
	case SOAP_TYPE_ns2__APConfirmPurchaseService:
		return ((ns2__APConfirmPurchaseService *)ptr)->soap_out(soap, tag, id, "ns2:APConfirmPurchaseService");
	case SOAP_TYPE_ns2__APTransactionDetailsService:
		return ((ns2__APTransactionDetailsService *)ptr)->soap_out(soap, tag, id, "ns2:APTransactionDetailsService");
	case SOAP_TYPE_ns2__APCheckOutDetailsService:
		return ((ns2__APCheckOutDetailsService *)ptr)->soap_out(soap, tag, id, "ns2:APCheckOutDetailsService");
	case SOAP_TYPE_ns2__APSaleService:
		return ((ns2__APSaleService *)ptr)->soap_out(soap, tag, id, "ns2:APSaleService");
	case SOAP_TYPE_ns2__APRefundService:
		return ((ns2__APRefundService *)ptr)->soap_out(soap, tag, id, "ns2:APRefundService");
	case SOAP_TYPE_ns2__APOptionsService:
		return ((ns2__APOptionsService *)ptr)->soap_out(soap, tag, id, "ns2:APOptionsService");
	case SOAP_TYPE_ns2__APCaptureService:
		return ((ns2__APCaptureService *)ptr)->soap_out(soap, tag, id, "ns2:APCaptureService");
	case SOAP_TYPE_ns2__APAuthReversalService:
		return ((ns2__APAuthReversalService *)ptr)->soap_out(soap, tag, id, "ns2:APAuthReversalService");
	case SOAP_TYPE_ns2__APAuthService:
		return ((ns2__APAuthService *)ptr)->soap_out(soap, tag, id, "ns2:APAuthService");
	case SOAP_TYPE_ns2__APDevice:
		return ((ns2__APDevice *)ptr)->soap_out(soap, tag, id, "ns2:APDevice");
	case SOAP_TYPE_ns2__AP:
		return ((ns2__AP *)ptr)->soap_out(soap, tag, id, "ns2:AP");
	case SOAP_TYPE_ns2__Token:
		return ((ns2__Token *)ptr)->soap_out(soap, tag, id, "ns2:Token");
	case SOAP_TYPE_ns2__JPO:
		return ((ns2__JPO *)ptr)->soap_out(soap, tag, id, "ns2:JPO");
	case SOAP_TYPE_ns2__PayPal:
		return ((ns2__PayPal *)ptr)->soap_out(soap, tag, id, "ns2:PayPal");
	case SOAP_TYPE_ns2__Batch:
		return ((ns2__Batch *)ptr)->soap_out(soap, tag, id, "ns2:Batch");
	case SOAP_TYPE_ns2__DecisionManagerTravelLeg:
		return ((ns2__DecisionManagerTravelLeg *)ptr)->soap_out(soap, tag, id, "ns2:DecisionManagerTravelLeg");
	case SOAP_TYPE_ns2__DecisionManagerTravelData:
		return ((ns2__DecisionManagerTravelData *)ptr)->soap_out(soap, tag, id, "ns2:DecisionManagerTravelData");
	case SOAP_TYPE_ns2__DecisionManager:
		return ((ns2__DecisionManager *)ptr)->soap_out(soap, tag, id, "ns2:DecisionManager");
	case SOAP_TYPE_ns2__PaymentNetworkToken:
		return ((ns2__PaymentNetworkToken *)ptr)->soap_out(soap, tag, id, "ns2:PaymentNetworkToken");
	case SOAP_TYPE_ns2__Subscription:
		return ((ns2__Subscription *)ptr)->soap_out(soap, tag, id, "ns2:Subscription");
	case SOAP_TYPE_ns2__PaySubscriptionEvent:
		return ((ns2__PaySubscriptionEvent *)ptr)->soap_out(soap, tag, id, "ns2:PaySubscriptionEvent");
	case SOAP_TYPE_ns2__RecurringSubscriptionInfo:
		return ((ns2__RecurringSubscriptionInfo *)ptr)->soap_out(soap, tag, id, "ns2:RecurringSubscriptionInfo");
	case SOAP_TYPE_ns2__BankInfo:
		return ((ns2__BankInfo *)ptr)->soap_out(soap, tag, id, "ns2:BankInfo");
	case SOAP_TYPE_ns2__FundTransfer:
		return ((ns2__FundTransfer *)ptr)->soap_out(soap, tag, id, "ns2:FundTransfer");
	case SOAP_TYPE_ns2__UCAF:
		return ((ns2__UCAF *)ptr)->soap_out(soap, tag, id, "ns2:UCAF");
	case SOAP_TYPE_ns2__GECC:
		return ((ns2__GECC *)ptr)->soap_out(soap, tag, id, "ns2:GECC");
	case SOAP_TYPE_ns2__FundingTotals:
		return ((ns2__FundingTotals *)ptr)->soap_out(soap, tag, id, "ns2:FundingTotals");
	case SOAP_TYPE_ns2__PurchaseTotals:
		return ((ns2__PurchaseTotals *)ptr)->soap_out(soap, tag, id, "ns2:PurchaseTotals");
	case SOAP_TYPE_ns2__Wallet:
		return ((ns2__Wallet *)ptr)->soap_out(soap, tag, id, "ns2:Wallet");
	case SOAP_TYPE_ns2__Aft:
		return ((ns2__Aft *)ptr)->soap_out(soap, tag, id, "ns2:Aft");
	case SOAP_TYPE_ns2__OtherTax:
		return ((ns2__OtherTax *)ptr)->soap_out(soap, tag, id, "ns2:OtherTax");
	case SOAP_TYPE_ns2__BML:
		return ((ns2__BML *)ptr)->soap_out(soap, tag, id, "ns2:BML");
	case SOAP_TYPE_ns2__Check:
		return ((ns2__Check *)ptr)->soap_out(soap, tag, id, "ns2:Check");
	case SOAP_TYPE_ns2__Card:
		return ((ns2__Card *)ptr)->soap_out(soap, tag, id, "ns2:Card");
	case SOAP_TYPE_ns2__ShipFrom:
		return ((ns2__ShipFrom *)ptr)->soap_out(soap, tag, id, "ns2:ShipFrom");
	case SOAP_TYPE_ns2__ShipTo:
		return ((ns2__ShipTo *)ptr)->soap_out(soap, tag, id, "ns2:ShipTo");
	case SOAP_TYPE_ns2__BillTo:
		return ((ns2__BillTo *)ptr)->soap_out(soap, tag, id, "ns2:BillTo");
	case SOAP_TYPE_ns2__BusinessRules:
		return ((ns2__BusinessRules *)ptr)->soap_out(soap, tag, id, "ns2:BusinessRules");
	case SOAP_TYPE_ns2__InvoiceHeader:
		return ((ns2__InvoiceHeader *)ptr)->soap_out(soap, tag, id, "ns2:InvoiceHeader");
	case SOAP_TYPE_ns2__EncryptPaymentDataService:
		return ((ns2__EncryptPaymentDataService *)ptr)->soap_out(soap, tag, id, "ns2:EncryptPaymentDataService");
	case SOAP_TYPE_ns2__CaseManagementActionService:
		return ((ns2__CaseManagementActionService *)ptr)->soap_out(soap, tag, id, "ns2:CaseManagementActionService");
	case SOAP_TYPE_ns2__FraudUpdateService:
		return ((ns2__FraudUpdateService *)ptr)->soap_out(soap, tag, id, "ns2:FraudUpdateService");
	case SOAP_TYPE_ns2__RiskUpdateService:
		return ((ns2__RiskUpdateService *)ptr)->soap_out(soap, tag, id, "ns2:RiskUpdateService");
	case SOAP_TYPE_ns2__APCheckStatusService:
		return ((ns2__APCheckStatusService *)ptr)->soap_out(soap, tag, id, "ns2:APCheckStatusService");
	case SOAP_TYPE_ns2__APInitiateService:
		return ((ns2__APInitiateService *)ptr)->soap_out(soap, tag, id, "ns2:APInitiateService");
	case SOAP_TYPE_ns2__Address:
		return ((ns2__Address *)ptr)->soap_out(soap, tag, id, "ns2:Address");
	case SOAP_TYPE_ns2__PersonalId:
		return ((ns2__PersonalId *)ptr)->soap_out(soap, tag, id, "ns2:PersonalId");
	case SOAP_TYPE_ns2__BoletoPaymentService:
		return ((ns2__BoletoPaymentService *)ptr)->soap_out(soap, tag, id, "ns2:BoletoPaymentService");
	case SOAP_TYPE_ns2__ChinaRefundService:
		return ((ns2__ChinaRefundService *)ptr)->soap_out(soap, tag, id, "ns2:ChinaRefundService");
	case SOAP_TYPE_ns2__ChinaPaymentService:
		return ((ns2__ChinaPaymentService *)ptr)->soap_out(soap, tag, id, "ns2:ChinaPaymentService");
	case SOAP_TYPE_ns2__PayPalPreapprovedUpdateService:
		return ((ns2__PayPalPreapprovedUpdateService *)ptr)->soap_out(soap, tag, id, "ns2:PayPalPreapprovedUpdateService");
	case SOAP_TYPE_ns2__PayPalPreapprovedPaymentService:
		return ((ns2__PayPalPreapprovedPaymentService *)ptr)->soap_out(soap, tag, id, "ns2:PayPalPreapprovedPaymentService");
	case SOAP_TYPE_ns2__PayPalButtonCreateService:
		return ((ns2__PayPalButtonCreateService *)ptr)->soap_out(soap, tag, id, "ns2:PayPalButtonCreateService");
	case SOAP_TYPE_ns2__PinDebitReversalService:
		return ((ns2__PinDebitReversalService *)ptr)->soap_out(soap, tag, id, "ns2:PinDebitReversalService");
	case SOAP_TYPE_ns2__PinDebitCreditService:
		return ((ns2__PinDebitCreditService *)ptr)->soap_out(soap, tag, id, "ns2:PinDebitCreditService");
	case SOAP_TYPE_ns2__PinDebitPurchaseService:
		return ((ns2__PinDebitPurchaseService *)ptr)->soap_out(soap, tag, id, "ns2:PinDebitPurchaseService");
	case SOAP_TYPE_ns2__PinlessDebitReversalService:
		return ((ns2__PinlessDebitReversalService *)ptr)->soap_out(soap, tag, id, "ns2:PinlessDebitReversalService");
	case SOAP_TYPE_ns2__PinlessDebitValidateService:
		return ((ns2__PinlessDebitValidateService *)ptr)->soap_out(soap, tag, id, "ns2:PinlessDebitValidateService");
	case SOAP_TYPE_ns2__PinlessDebitService:
		return ((ns2__PinlessDebitService *)ptr)->soap_out(soap, tag, id, "ns2:PinlessDebitService");
	case SOAP_TYPE_ns2__VoidService:
		return ((ns2__VoidService *)ptr)->soap_out(soap, tag, id, "ns2:VoidService");
	case SOAP_TYPE_ns2__PayPalDoRefTransactionService:
		return ((ns2__PayPalDoRefTransactionService *)ptr)->soap_out(soap, tag, id, "ns2:PayPalDoRefTransactionService");
	case SOAP_TYPE_ns2__PayPalCreateAgreementService:
		return ((ns2__PayPalCreateAgreementService *)ptr)->soap_out(soap, tag, id, "ns2:PayPalCreateAgreementService");
	case SOAP_TYPE_ns2__PayPalUpdateAgreementService:
		return ((ns2__PayPalUpdateAgreementService *)ptr)->soap_out(soap, tag, id, "ns2:PayPalUpdateAgreementService");
	case SOAP_TYPE_ns2__PayPalAuthorizationService:
		return ((ns2__PayPalAuthorizationService *)ptr)->soap_out(soap, tag, id, "ns2:PayPalAuthorizationService");
	case SOAP_TYPE_ns2__PayPalEcOrderSetupService:
		return ((ns2__PayPalEcOrderSetupService *)ptr)->soap_out(soap, tag, id, "ns2:PayPalEcOrderSetupService");
	case SOAP_TYPE_ns2__PayPalRefundService:
		return ((ns2__PayPalRefundService *)ptr)->soap_out(soap, tag, id, "ns2:PayPalRefundService");
	case SOAP_TYPE_ns2__PayPalAuthReversalService:
		return ((ns2__PayPalAuthReversalService *)ptr)->soap_out(soap, tag, id, "ns2:PayPalAuthReversalService");
	case SOAP_TYPE_ns2__PayPalDoCaptureService:
		return ((ns2__PayPalDoCaptureService *)ptr)->soap_out(soap, tag, id, "ns2:PayPalDoCaptureService");
	case SOAP_TYPE_ns2__PayPalEcDoPaymentService:
		return ((ns2__PayPalEcDoPaymentService *)ptr)->soap_out(soap, tag, id, "ns2:PayPalEcDoPaymentService");
	case SOAP_TYPE_ns2__PayPalEcGetDetailsService:
		return ((ns2__PayPalEcGetDetailsService *)ptr)->soap_out(soap, tag, id, "ns2:PayPalEcGetDetailsService");
	case SOAP_TYPE_ns2__PayPalEcSetService:
		return ((ns2__PayPalEcSetService *)ptr)->soap_out(soap, tag, id, "ns2:PayPalEcSetService");
	case SOAP_TYPE_ns2__PayPalCreditService:
		return ((ns2__PayPalCreditService *)ptr)->soap_out(soap, tag, id, "ns2:PayPalCreditService");
	case SOAP_TYPE_ns2__PayPalPaymentService:
		return ((ns2__PayPalPaymentService *)ptr)->soap_out(soap, tag, id, "ns2:PayPalPaymentService");
	case SOAP_TYPE_ns2__PaySubscriptionDeleteService:
		return ((ns2__PaySubscriptionDeleteService *)ptr)->soap_out(soap, tag, id, "ns2:PaySubscriptionDeleteService");
	case SOAP_TYPE_ns2__PaySubscriptionRetrieveService:
		return ((ns2__PaySubscriptionRetrieveService *)ptr)->soap_out(soap, tag, id, "ns2:PaySubscriptionRetrieveService");
	case SOAP_TYPE_ns2__PaySubscriptionEventUpdateService:
		return ((ns2__PaySubscriptionEventUpdateService *)ptr)->soap_out(soap, tag, id, "ns2:PaySubscriptionEventUpdateService");
	case SOAP_TYPE_ns2__PaySubscriptionUpdateService:
		return ((ns2__PaySubscriptionUpdateService *)ptr)->soap_out(soap, tag, id, "ns2:PaySubscriptionUpdateService");
	case SOAP_TYPE_ns2__PaySubscriptionCreateService:
		return ((ns2__PaySubscriptionCreateService *)ptr)->soap_out(soap, tag, id, "ns2:PaySubscriptionCreateService");
	case SOAP_TYPE_ns2__DirectDebitValidateService:
		return ((ns2__DirectDebitValidateService *)ptr)->soap_out(soap, tag, id, "ns2:DirectDebitValidateService");
	case SOAP_TYPE_ns2__DirectDebitRefundService:
		return ((ns2__DirectDebitRefundService *)ptr)->soap_out(soap, tag, id, "ns2:DirectDebitRefundService");
	case SOAP_TYPE_ns2__DirectDebitService:
		return ((ns2__DirectDebitService *)ptr)->soap_out(soap, tag, id, "ns2:DirectDebitService");
	case SOAP_TYPE_ns2__DirectDebitMandateService:
		return ((ns2__DirectDebitMandateService *)ptr)->soap_out(soap, tag, id, "ns2:DirectDebitMandateService");
	case SOAP_TYPE_ns2__BankTransferRealTimeService:
		return ((ns2__BankTransferRealTimeService *)ptr)->soap_out(soap, tag, id, "ns2:BankTransferRealTimeService");
	case SOAP_TYPE_ns2__BankTransferRefundService:
		return ((ns2__BankTransferRefundService *)ptr)->soap_out(soap, tag, id, "ns2:BankTransferRefundService");
	case SOAP_TYPE_ns2__BankTransferService:
		return ((ns2__BankTransferService *)ptr)->soap_out(soap, tag, id, "ns2:BankTransferService");
	case SOAP_TYPE_ns2__FXRatesService:
		return ((ns2__FXRatesService *)ptr)->soap_out(soap, tag, id, "ns2:FXRatesService");
	case SOAP_TYPE_ns2__ExportService:
		return ((ns2__ExportService *)ptr)->soap_out(soap, tag, id, "ns2:ExportService");
	case SOAP_TYPE_ns2__DAVService:
		return ((ns2__DAVService *)ptr)->soap_out(soap, tag, id, "ns2:DAVService");
	case SOAP_TYPE_ns2__AFSService:
		return ((ns2__AFSService *)ptr)->soap_out(soap, tag, id, "ns2:AFSService");
	case SOAP_TYPE_ns2__DMEService:
		return ((ns2__DMEService *)ptr)->soap_out(soap, tag, id, "ns2:DMEService");
	case SOAP_TYPE_ns2__TaxService:
		return ((ns2__TaxService *)ptr)->soap_out(soap, tag, id, "ns2:TaxService");
	case SOAP_TYPE_ns2__PayerAuthValidateService:
		return ((ns2__PayerAuthValidateService *)ptr)->soap_out(soap, tag, id, "ns2:PayerAuthValidateService");
	case SOAP_TYPE_ns2__PayerAuthEnrollService:
		return ((ns2__PayerAuthEnrollService *)ptr)->soap_out(soap, tag, id, "ns2:PayerAuthEnrollService");
	case SOAP_TYPE_ns2__ECAuthenticateService:
		return ((ns2__ECAuthenticateService *)ptr)->soap_out(soap, tag, id, "ns2:ECAuthenticateService");
	case SOAP_TYPE_ns2__ECCreditService:
		return ((ns2__ECCreditService *)ptr)->soap_out(soap, tag, id, "ns2:ECCreditService");
	case SOAP_TYPE_ns2__ECDebitService:
		return ((ns2__ECDebitService *)ptr)->soap_out(soap, tag, id, "ns2:ECDebitService");
	case SOAP_TYPE_ns2__ServiceFeeCalculateService:
		return ((ns2__ServiceFeeCalculateService *)ptr)->soap_out(soap, tag, id, "ns2:ServiceFeeCalculateService");
	case SOAP_TYPE_ns2__CCDCCService:
		return ((ns2__CCDCCService *)ptr)->soap_out(soap, tag, id, "ns2:CCDCCService");
	case SOAP_TYPE_ns2__CCAutoAuthReversalService:
		return ((ns2__CCAutoAuthReversalService *)ptr)->soap_out(soap, tag, id, "ns2:CCAutoAuthReversalService");
	case SOAP_TYPE_ns2__CCAuthReversalService:
		return ((ns2__CCAuthReversalService *)ptr)->soap_out(soap, tag, id, "ns2:CCAuthReversalService");
	case SOAP_TYPE_ns2__CCCreditService:
		return ((ns2__CCCreditService *)ptr)->soap_out(soap, tag, id, "ns2:CCCreditService");
	case SOAP_TYPE_ns2__CCCaptureService:
		return ((ns2__CCCaptureService *)ptr)->soap_out(soap, tag, id, "ns2:CCCaptureService");
	case SOAP_TYPE_ns2__CCIncrementalAuthService:
		return ((ns2__CCIncrementalAuthService *)ptr)->soap_out(soap, tag, id, "ns2:CCIncrementalAuthService");
	case SOAP_TYPE_ns2__CCSaleReversalService:
		return ((ns2__CCSaleReversalService *)ptr)->soap_out(soap, tag, id, "ns2:CCSaleReversalService");
	case SOAP_TYPE_ns2__CCSaleCreditService:
		return ((ns2__CCSaleCreditService *)ptr)->soap_out(soap, tag, id, "ns2:CCSaleCreditService");
	case SOAP_TYPE_ns2__CCSaleService:
		return ((ns2__CCSaleService *)ptr)->soap_out(soap, tag, id, "ns2:CCSaleService");
	case SOAP_TYPE_ns2__VerificationService:
		return ((ns2__VerificationService *)ptr)->soap_out(soap, tag, id, "ns2:VerificationService");
	case SOAP_TYPE_ns2__OCTService:
		return ((ns2__OCTService *)ptr)->soap_out(soap, tag, id, "ns2:OCTService");
	case SOAP_TYPE_ns2__CCAuthService:
		return ((ns2__CCAuthService *)ptr)->soap_out(soap, tag, id, "ns2:CCAuthService");
	case SOAP_TYPE_ns2__Item:
		return ((ns2__Item *)ptr)->soap_out(soap, tag, id, "ns2:Item");
	case SOAP_TYPE__wsse__Security:
		return soap_out__wsse__Security(soap, "wsse:Security", id, (const struct _wsse__Security *)ptr, NULL);
	case SOAP_TYPE_wsc__PropertiesType:
		return soap_out_wsc__PropertiesType(soap, tag, id, (const struct wsc__PropertiesType *)ptr, "wsc:PropertiesType");
	case SOAP_TYPE_wsc__DerivedKeyTokenType:
		return soap_out_wsc__DerivedKeyTokenType(soap, tag, id, (const struct wsc__DerivedKeyTokenType *)ptr, "wsc:DerivedKeyTokenType");
	case SOAP_TYPE_wsc__SecurityContextTokenType:
		return soap_out_wsc__SecurityContextTokenType(soap, tag, id, (const struct wsc__SecurityContextTokenType *)ptr, "wsc:SecurityContextTokenType");
	case SOAP_TYPE__xenc__ReferenceList:
		return soap_out__xenc__ReferenceList(soap, "xenc:ReferenceList", id, (const struct _xenc__ReferenceList *)ptr, NULL);
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		return soap_out_xenc__EncryptionPropertyType(soap, tag, id, (const struct xenc__EncryptionPropertyType *)ptr, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		return soap_out_xenc__EncryptionPropertiesType(soap, tag, id, (const struct xenc__EncryptionPropertiesType *)ptr, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_xenc__ReferenceType:
		return soap_out_xenc__ReferenceType(soap, tag, id, (const struct xenc__ReferenceType *)ptr, "xenc:ReferenceType");
	case SOAP_TYPE_xenc__AgreementMethodType:
		return soap_out_xenc__AgreementMethodType(soap, tag, id, (const struct xenc__AgreementMethodType *)ptr, "xenc:AgreementMethodType");
	case SOAP_TYPE_xenc__EncryptedKeyType:
		return soap_out_xenc__EncryptedKeyType(soap, tag, id, (const struct xenc__EncryptedKeyType *)ptr, "xenc:EncryptedKeyType");
	case SOAP_TYPE_xenc__EncryptedDataType:
		return soap_out_xenc__EncryptedDataType(soap, tag, id, (const struct xenc__EncryptedDataType *)ptr, "xenc:EncryptedDataType");
	case SOAP_TYPE_xenc__TransformsType:
		return soap_out_xenc__TransformsType(soap, tag, id, (const struct xenc__TransformsType *)ptr, "xenc:TransformsType");
	case SOAP_TYPE_xenc__CipherReferenceType:
		return soap_out_xenc__CipherReferenceType(soap, tag, id, (const struct xenc__CipherReferenceType *)ptr, "xenc:CipherReferenceType");
	case SOAP_TYPE_xenc__CipherDataType:
		return soap_out_xenc__CipherDataType(soap, tag, id, (const struct xenc__CipherDataType *)ptr, "xenc:CipherDataType");
	case SOAP_TYPE_xenc__EncryptionMethodType:
		return soap_out_xenc__EncryptionMethodType(soap, tag, id, (const struct xenc__EncryptionMethodType *)ptr, "xenc:EncryptionMethodType");
	case SOAP_TYPE_xenc__EncryptedType:
		return soap_out_xenc__EncryptedType(soap, tag, id, (const struct xenc__EncryptedType *)ptr, "xenc:EncryptedType");
	case SOAP_TYPE_ds__RSAKeyValueType:
		return soap_out_ds__RSAKeyValueType(soap, tag, id, (const struct ds__RSAKeyValueType *)ptr, "ds:RSAKeyValueType");
	case SOAP_TYPE_ds__DSAKeyValueType:
		return soap_out_ds__DSAKeyValueType(soap, tag, id, (const struct ds__DSAKeyValueType *)ptr, "ds:DSAKeyValueType");
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return soap_out_ds__X509IssuerSerialType(soap, tag, id, (const struct ds__X509IssuerSerialType *)ptr, "ds:X509IssuerSerialType");
	case SOAP_TYPE__ds__KeyInfo:
		return soap_out__ds__KeyInfo(soap, "ds:KeyInfo", id, (const struct ds__KeyInfoType *)ptr, NULL);
	case SOAP_TYPE_ds__RetrievalMethodType:
		return soap_out_ds__RetrievalMethodType(soap, tag, id, (const struct ds__RetrievalMethodType *)ptr, "ds:RetrievalMethodType");
	case SOAP_TYPE_ds__KeyValueType:
		return soap_out_ds__KeyValueType(soap, tag, id, (const struct ds__KeyValueType *)ptr, "ds:KeyValueType");
	case SOAP_TYPE_ds__DigestMethodType:
		return soap_out_ds__DigestMethodType(soap, tag, id, (const struct ds__DigestMethodType *)ptr, "ds:DigestMethodType");
	case SOAP_TYPE__ds__Transform:
		return soap_out__ds__Transform(soap, "ds:Transform", id, (const struct ds__TransformType *)ptr, NULL);
	case SOAP_TYPE_ds__TransformType:
		return soap_out_ds__TransformType(soap, tag, id, (const struct ds__TransformType *)ptr, "ds:TransformType");
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		return soap_out__c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", id, (const struct _c14n__InclusiveNamespaces *)ptr, NULL);
	case SOAP_TYPE_ds__TransformsType:
		return soap_out_ds__TransformsType(soap, tag, id, (const struct ds__TransformsType *)ptr, "ds:TransformsType");
	case SOAP_TYPE_ds__ReferenceType:
		return soap_out_ds__ReferenceType(soap, tag, id, (const struct ds__ReferenceType *)ptr, "ds:ReferenceType");
	case SOAP_TYPE_ds__SignatureMethodType:
		return soap_out_ds__SignatureMethodType(soap, tag, id, (const struct ds__SignatureMethodType *)ptr, "ds:SignatureMethodType");
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return soap_out_ds__CanonicalizationMethodType(soap, tag, id, (const struct ds__CanonicalizationMethodType *)ptr, "ds:CanonicalizationMethodType");
	case SOAP_TYPE__ds__Signature:
		return soap_out__ds__Signature(soap, "ds:Signature", id, (const struct ds__SignatureType *)ptr, NULL);
	case SOAP_TYPE_ds__KeyInfoType:
		return soap_out_ds__KeyInfoType(soap, tag, id, (const struct ds__KeyInfoType *)ptr, "ds:KeyInfoType");
	case SOAP_TYPE_ds__SignedInfoType:
		return soap_out_ds__SignedInfoType(soap, tag, id, (const struct ds__SignedInfoType *)ptr, "ds:SignedInfoType");
	case SOAP_TYPE_ds__SignatureType:
		return soap_out_ds__SignatureType(soap, tag, id, (const struct ds__SignatureType *)ptr, "ds:SignatureType");
	case SOAP_TYPE_ds__X509DataType:
		return soap_out_ds__X509DataType(soap, tag, id, (const struct ds__X509DataType *)ptr, "ds:X509DataType");
	case SOAP_TYPE__wsse__SecurityTokenReference:
		return soap_out__wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", id, (const struct _wsse__SecurityTokenReference *)ptr, NULL);
	case SOAP_TYPE__wsse__KeyIdentifier:
		return soap_out__wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", id, (const struct _wsse__KeyIdentifier *)ptr, NULL);
	case SOAP_TYPE__wsse__Embedded:
		return soap_out__wsse__Embedded(soap, "wsse:Embedded", id, (const struct _wsse__Embedded *)ptr, NULL);
	case SOAP_TYPE__wsse__Reference:
		return soap_out__wsse__Reference(soap, "wsse:Reference", id, (const struct _wsse__Reference *)ptr, NULL);
	case SOAP_TYPE__wsse__BinarySecurityToken:
		return soap_out__wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", id, (const struct _wsse__BinarySecurityToken *)ptr, NULL);
	case SOAP_TYPE__wsse__Password:
		return soap_out__wsse__Password(soap, "wsse:Password", id, (const struct _wsse__Password *)ptr, NULL);
	case SOAP_TYPE__wsse__UsernameToken:
		return soap_out__wsse__UsernameToken(soap, "wsse:UsernameToken", id, (const struct _wsse__UsernameToken *)ptr, NULL);
	case SOAP_TYPE_wsse__EncodedString:
		return soap_out_wsse__EncodedString(soap, tag, id, (const struct wsse__EncodedString *)ptr, "wsse:EncodedString");
	case SOAP_TYPE__wsu__Timestamp:
		return soap_out__wsu__Timestamp(soap, "wsu:Timestamp", id, (const struct _wsu__Timestamp *)ptr, NULL);
	case SOAP_TYPE_PointerTons2__VCCustomData:
		return soap_out_PointerTons2__VCCustomData(soap, tag, id, (ns2__VCCustomData *const*)ptr, "ns2:VCCustomData");
	case SOAP_TYPE_PointerTons2__VCCardArt:
		return soap_out_PointerTons2__VCCardArt(soap, tag, id, (ns2__VCCardArt *const*)ptr, "ns2:VCCardArt");
	case SOAP_TYPE_PointerTons2__PaypalTransaction:
		return soap_out_PointerTons2__PaypalTransaction(soap, tag, id, (ns2__PaypalTransaction *const*)ptr, "ns2:PaypalTransaction");
	case SOAP_TYPE_PointerTons2__MDDField:
		return soap_out_PointerTons2__MDDField(soap, tag, id, (ns2__MDDField *const*)ptr, "ns2:MDDField");
	case SOAP_TYPE_PointerTons2__Service:
		return soap_out_PointerTons2__Service(soap, tag, id, (ns2__Service *const*)ptr, "ns2:Service");
	case SOAP_TYPE_PointerTons2__Leg:
		return soap_out_PointerTons2__Leg(soap, tag, id, (ns2__Leg *const*)ptr, "ns2:Leg");
	case SOAP_TYPE_PointerTons2__ReplyReserved:
		return soap_out_PointerTons2__ReplyReserved(soap, tag, id, (ns2__ReplyReserved *const*)ptr, "ns2:ReplyReserved");
	case SOAP_TYPE_PointerTons2__Token:
		return soap_out_PointerTons2__Token(soap, tag, id, (ns2__Token *const*)ptr, "ns2:Token");
	case SOAP_TYPE_PointerTons2__BinLookupReply:
		return soap_out_PointerTons2__BinLookupReply(soap, tag, id, (ns2__BinLookupReply *const*)ptr, "ns2:BinLookupReply");
	case SOAP_TYPE_PointerTons2__DecryptVisaCheckoutDataReply:
		return soap_out_PointerTons2__DecryptVisaCheckoutDataReply(soap, tag, id, (ns2__DecryptVisaCheckoutDataReply *const*)ptr, "ns2:DecryptVisaCheckoutDataReply");
	case SOAP_TYPE_PointerTons2__VCReply:
		return soap_out_PointerTons2__VCReply(soap, tag, id, (ns2__VCReply *const*)ptr, "ns2:VCReply");
	case SOAP_TYPE_PointerTons2__HostedDataRetrieveReply:
		return soap_out_PointerTons2__HostedDataRetrieveReply(soap, tag, id, (ns2__HostedDataRetrieveReply *const*)ptr, "ns2:HostedDataRetrieveReply");
	case SOAP_TYPE_PointerTons2__HostedDataCreateReply:
		return soap_out_PointerTons2__HostedDataCreateReply(soap, tag, id, (ns2__HostedDataCreateReply *const*)ptr, "ns2:HostedDataCreateReply");
	case SOAP_TYPE_PointerTons2__OriginalTransaction:
		return soap_out_PointerTons2__OriginalTransaction(soap, tag, id, (ns2__OriginalTransaction *const*)ptr, "ns2:OriginalTransaction");
	case SOAP_TYPE_PointerTons2__EmvReply:
		return soap_out_PointerTons2__EmvReply(soap, tag, id, (ns2__EmvReply *const*)ptr, "ns2:EmvReply");
	case SOAP_TYPE_PointerTons2__PayPalTransactionSearchReply:
		return soap_out_PointerTons2__PayPalTransactionSearchReply(soap, tag, id, (ns2__PayPalTransactionSearchReply *const*)ptr, "ns2:PayPalTransactionSearchReply");
	case SOAP_TYPE_PointerTons2__PayPalGetTxnDetailsReply:
		return soap_out_PointerTons2__PayPalGetTxnDetailsReply(soap, tag, id, (ns2__PayPalGetTxnDetailsReply *const*)ptr, "ns2:PayPalGetTxnDetailsReply");
	case SOAP_TYPE_PointerTons2__PromotionGroupReply:
		return soap_out_PointerTons2__PromotionGroupReply(soap, tag, id, (ns2__PromotionGroupReply *const*)ptr, "ns2:PromotionGroupReply");
	case SOAP_TYPE_PointerTons2__Promotion:
		return soap_out_PointerTons2__Promotion(soap, tag, id, (ns2__Promotion *const*)ptr, "ns2:Promotion");
	case SOAP_TYPE_PointerTons2__APConfirmPurchaseReply:
		return soap_out_PointerTons2__APConfirmPurchaseReply(soap, tag, id, (ns2__APConfirmPurchaseReply *const*)ptr, "ns2:APConfirmPurchaseReply");
	case SOAP_TYPE_PointerTons2__APTransactionDetailsReply:
		return soap_out_PointerTons2__APTransactionDetailsReply(soap, tag, id, (ns2__APTransactionDetailsReply *const*)ptr, "ns2:APTransactionDetailsReply");
	case SOAP_TYPE_PointerTons2__APCheckOutDetailsReply:
		return soap_out_PointerTons2__APCheckOutDetailsReply(soap, tag, id, (ns2__APCheckOutDetailsReply *const*)ptr, "ns2:APCheckOutDetailsReply");
	case SOAP_TYPE_PointerTons2__APSaleReply:
		return soap_out_PointerTons2__APSaleReply(soap, tag, id, (ns2__APSaleReply *const*)ptr, "ns2:APSaleReply");
	case SOAP_TYPE_PointerTons2__APRefundReply:
		return soap_out_PointerTons2__APRefundReply(soap, tag, id, (ns2__APRefundReply *const*)ptr, "ns2:APRefundReply");
	case SOAP_TYPE_PointerTons2__APOptionsReply:
		return soap_out_PointerTons2__APOptionsReply(soap, tag, id, (ns2__APOptionsReply *const*)ptr, "ns2:APOptionsReply");
	case SOAP_TYPE_PointerTons2__APCaptureReply:
		return soap_out_PointerTons2__APCaptureReply(soap, tag, id, (ns2__APCaptureReply *const*)ptr, "ns2:APCaptureReply");
	case SOAP_TYPE_PointerTons2__APAuthReversalReply:
		return soap_out_PointerTons2__APAuthReversalReply(soap, tag, id, (ns2__APAuthReversalReply *const*)ptr, "ns2:APAuthReversalReply");
	case SOAP_TYPE_PointerTons2__APAuthReply:
		return soap_out_PointerTons2__APAuthReply(soap, tag, id, (ns2__APAuthReply *const*)ptr, "ns2:APAuthReply");
	case SOAP_TYPE_PointerTons2__APReply:
		return soap_out_PointerTons2__APReply(soap, tag, id, (ns2__APReply *const*)ptr, "ns2:APReply");
	case SOAP_TYPE_PointerTons2__APCheckStatusReply:
		return soap_out_PointerTons2__APCheckStatusReply(soap, tag, id, (ns2__APCheckStatusReply *const*)ptr, "ns2:APCheckStatusReply");
	case SOAP_TYPE_PointerTons2__APInitiateReply:
		return soap_out_PointerTons2__APInitiateReply(soap, tag, id, (ns2__APInitiateReply *const*)ptr, "ns2:APInitiateReply");
	case SOAP_TYPE_PointerTons2__PinDebitReversalReply:
		return soap_out_PointerTons2__PinDebitReversalReply(soap, tag, id, (ns2__PinDebitReversalReply *const*)ptr, "ns2:PinDebitReversalReply");
	case SOAP_TYPE_PointerTons2__PinDebitCreditReply:
		return soap_out_PointerTons2__PinDebitCreditReply(soap, tag, id, (ns2__PinDebitCreditReply *const*)ptr, "ns2:PinDebitCreditReply");
	case SOAP_TYPE_PointerTons2__PinDebitPurchaseReply:
		return soap_out_PointerTons2__PinDebitPurchaseReply(soap, tag, id, (ns2__PinDebitPurchaseReply *const*)ptr, "ns2:PinDebitPurchaseReply");
	case SOAP_TYPE_PointerTons2__BoletoPaymentReply:
		return soap_out_PointerTons2__BoletoPaymentReply(soap, tag, id, (ns2__BoletoPaymentReply *const*)ptr, "ns2:BoletoPaymentReply");
	case SOAP_TYPE_PointerTons2__ChinaRefundReply:
		return soap_out_PointerTons2__ChinaRefundReply(soap, tag, id, (ns2__ChinaRefundReply *const*)ptr, "ns2:ChinaRefundReply");
	case SOAP_TYPE_PointerTons2__ChinaPaymentReply:
		return soap_out_PointerTons2__ChinaPaymentReply(soap, tag, id, (ns2__ChinaPaymentReply *const*)ptr, "ns2:ChinaPaymentReply");
	case SOAP_TYPE_PointerTons2__PayPalDoRefTransactionReply:
		return soap_out_PointerTons2__PayPalDoRefTransactionReply(soap, tag, id, (ns2__PayPalDoRefTransactionReply *const*)ptr, "ns2:PayPalDoRefTransactionReply");
	case SOAP_TYPE_PointerTons2__PayPalCreateAgreementReply:
		return soap_out_PointerTons2__PayPalCreateAgreementReply(soap, tag, id, (ns2__PayPalCreateAgreementReply *const*)ptr, "ns2:PayPalCreateAgreementReply");
	case SOAP_TYPE_PointerTons2__PayPalUpdateAgreementReply:
		return soap_out_PointerTons2__PayPalUpdateAgreementReply(soap, tag, id, (ns2__PayPalUpdateAgreementReply *const*)ptr, "ns2:PayPalUpdateAgreementReply");
	case SOAP_TYPE_PointerTons2__PayPalEcOrderSetupReply:
		return soap_out_PointerTons2__PayPalEcOrderSetupReply(soap, tag, id, (ns2__PayPalEcOrderSetupReply *const*)ptr, "ns2:PayPalEcOrderSetupReply");
	case SOAP_TYPE_PointerTons2__PayPalAuthorizationReply:
		return soap_out_PointerTons2__PayPalAuthorizationReply(soap, tag, id, (ns2__PayPalAuthorizationReply *const*)ptr, "ns2:PayPalAuthorizationReply");
	case SOAP_TYPE_PointerTons2__PayPalEcSetReply:
		return soap_out_PointerTons2__PayPalEcSetReply(soap, tag, id, (ns2__PayPalEcSetReply *const*)ptr, "ns2:PayPalEcSetReply");
	case SOAP_TYPE_PointerTons2__PayPalEcGetDetailsReply:
		return soap_out_PointerTons2__PayPalEcGetDetailsReply(soap, tag, id, (ns2__PayPalEcGetDetailsReply *const*)ptr, "ns2:PayPalEcGetDetailsReply");
	case SOAP_TYPE_PointerTons2__PayPalEcDoPaymentReply:
		return soap_out_PointerTons2__PayPalEcDoPaymentReply(soap, tag, id, (ns2__PayPalEcDoPaymentReply *const*)ptr, "ns2:PayPalEcDoPaymentReply");
	case SOAP_TYPE_PointerTons2__PayPalDoCaptureReply:
		return soap_out_PointerTons2__PayPalDoCaptureReply(soap, tag, id, (ns2__PayPalDoCaptureReply *const*)ptr, "ns2:PayPalDoCaptureReply");
	case SOAP_TYPE_PointerTons2__PayPalAuthReversalReply:
		return soap_out_PointerTons2__PayPalAuthReversalReply(soap, tag, id, (ns2__PayPalAuthReversalReply *const*)ptr, "ns2:PayPalAuthReversalReply");
	case SOAP_TYPE_PointerTons2__PayPalRefundReply:
		return soap_out_PointerTons2__PayPalRefundReply(soap, tag, id, (ns2__PayPalRefundReply *const*)ptr, "ns2:PayPalRefundReply");
	case SOAP_TYPE_PointerTons2__DecisionReply:
		return soap_out_PointerTons2__DecisionReply(soap, tag, id, (ns2__DecisionReply *const*)ptr, "ns2:DecisionReply");
	case SOAP_TYPE_PointerTons2__CaseManagementActionReply:
		return soap_out_PointerTons2__CaseManagementActionReply(soap, tag, id, (ns2__CaseManagementActionReply *const*)ptr, "ns2:CaseManagementActionReply");
	case SOAP_TYPE_PointerTons2__FraudUpdateReply:
		return soap_out_PointerTons2__FraudUpdateReply(soap, tag, id, (ns2__FraudUpdateReply *const*)ptr, "ns2:FraudUpdateReply");
	case SOAP_TYPE_PointerTons2__RiskUpdateReply:
		return soap_out_PointerTons2__RiskUpdateReply(soap, tag, id, (ns2__RiskUpdateReply *const*)ptr, "ns2:RiskUpdateReply");
	case SOAP_TYPE_PointerTons2__PayPalPreapprovedUpdateReply:
		return soap_out_PointerTons2__PayPalPreapprovedUpdateReply(soap, tag, id, (ns2__PayPalPreapprovedUpdateReply *const*)ptr, "ns2:PayPalPreapprovedUpdateReply");
	case SOAP_TYPE_PointerTons2__PayPalPreapprovedPaymentReply:
		return soap_out_PointerTons2__PayPalPreapprovedPaymentReply(soap, tag, id, (ns2__PayPalPreapprovedPaymentReply *const*)ptr, "ns2:PayPalPreapprovedPaymentReply");
	case SOAP_TYPE_PointerTons2__PayPalButtonCreateReply:
		return soap_out_PointerTons2__PayPalButtonCreateReply(soap, tag, id, (ns2__PayPalButtonCreateReply *const*)ptr, "ns2:PayPalButtonCreateReply");
	case SOAP_TYPE_PointerTons2__PinlessDebitReversalReply:
		return soap_out_PointerTons2__PinlessDebitReversalReply(soap, tag, id, (ns2__PinlessDebitReversalReply *const*)ptr, "ns2:PinlessDebitReversalReply");
	case SOAP_TYPE_PointerTons2__PinlessDebitValidateReply:
		return soap_out_PointerTons2__PinlessDebitValidateReply(soap, tag, id, (ns2__PinlessDebitValidateReply *const*)ptr, "ns2:PinlessDebitValidateReply");
	case SOAP_TYPE_PointerTons2__PinlessDebitReply:
		return soap_out_PointerTons2__PinlessDebitReply(soap, tag, id, (ns2__PinlessDebitReply *const*)ptr, "ns2:PinlessDebitReply");
	case SOAP_TYPE_PointerTons2__VoidReply:
		return soap_out_PointerTons2__VoidReply(soap, tag, id, (ns2__VoidReply *const*)ptr, "ns2:VoidReply");
	case SOAP_TYPE_PointerTons2__PayPalCreditReply:
		return soap_out_PointerTons2__PayPalCreditReply(soap, tag, id, (ns2__PayPalCreditReply *const*)ptr, "ns2:PayPalCreditReply");
	case SOAP_TYPE_PointerTons2__PayPalPaymentReply:
		return soap_out_PointerTons2__PayPalPaymentReply(soap, tag, id, (ns2__PayPalPaymentReply *const*)ptr, "ns2:PayPalPaymentReply");
	case SOAP_TYPE_PointerTons2__PaySubscriptionDeleteReply:
		return soap_out_PointerTons2__PaySubscriptionDeleteReply(soap, tag, id, (ns2__PaySubscriptionDeleteReply *const*)ptr, "ns2:PaySubscriptionDeleteReply");
	case SOAP_TYPE_PointerTons2__PaySubscriptionRetrieveReply:
		return soap_out_PointerTons2__PaySubscriptionRetrieveReply(soap, tag, id, (ns2__PaySubscriptionRetrieveReply *const*)ptr, "ns2:PaySubscriptionRetrieveReply");
	case SOAP_TYPE_PointerTons2__PaySubscriptionEventUpdateReply:
		return soap_out_PointerTons2__PaySubscriptionEventUpdateReply(soap, tag, id, (ns2__PaySubscriptionEventUpdateReply *const*)ptr, "ns2:PaySubscriptionEventUpdateReply");
	case SOAP_TYPE_PointerTons2__PaySubscriptionUpdateReply:
		return soap_out_PointerTons2__PaySubscriptionUpdateReply(soap, tag, id, (ns2__PaySubscriptionUpdateReply *const*)ptr, "ns2:PaySubscriptionUpdateReply");
	case SOAP_TYPE_PointerTons2__PaySubscriptionCreateReply:
		return soap_out_PointerTons2__PaySubscriptionCreateReply(soap, tag, id, (ns2__PaySubscriptionCreateReply *const*)ptr, "ns2:PaySubscriptionCreateReply");
	case SOAP_TYPE_PointerTons2__DirectDebitRefundReply:
		return soap_out_PointerTons2__DirectDebitRefundReply(soap, tag, id, (ns2__DirectDebitRefundReply *const*)ptr, "ns2:DirectDebitRefundReply");
	case SOAP_TYPE_PointerTons2__DirectDebitValidateReply:
		return soap_out_PointerTons2__DirectDebitValidateReply(soap, tag, id, (ns2__DirectDebitValidateReply *const*)ptr, "ns2:DirectDebitValidateReply");
	case SOAP_TYPE_PointerTons2__DirectDebitReply:
		return soap_out_PointerTons2__DirectDebitReply(soap, tag, id, (ns2__DirectDebitReply *const*)ptr, "ns2:DirectDebitReply");
	case SOAP_TYPE_PointerTons2__DirectDebitMandateReply:
		return soap_out_PointerTons2__DirectDebitMandateReply(soap, tag, id, (ns2__DirectDebitMandateReply *const*)ptr, "ns2:DirectDebitMandateReply");
	case SOAP_TYPE_PointerTons2__BankTransferRealTimeReply:
		return soap_out_PointerTons2__BankTransferRealTimeReply(soap, tag, id, (ns2__BankTransferRealTimeReply *const*)ptr, "ns2:BankTransferRealTimeReply");
	case SOAP_TYPE_PointerTons2__BankTransferRefundReply:
		return soap_out_PointerTons2__BankTransferRefundReply(soap, tag, id, (ns2__BankTransferRefundReply *const*)ptr, "ns2:BankTransferRefundReply");
	case SOAP_TYPE_PointerTons2__BankTransferReply:
		return soap_out_PointerTons2__BankTransferReply(soap, tag, id, (ns2__BankTransferReply *const*)ptr, "ns2:BankTransferReply");
	case SOAP_TYPE_PointerTons2__FXRatesReply:
		return soap_out_PointerTons2__FXRatesReply(soap, tag, id, (ns2__FXRatesReply *const*)ptr, "ns2:FXRatesReply");
	case SOAP_TYPE_PointerTons2__ExportReply:
		return soap_out_PointerTons2__ExportReply(soap, tag, id, (ns2__ExportReply *const*)ptr, "ns2:ExportReply");
	case SOAP_TYPE_PointerTons2__DAVReply:
		return soap_out_PointerTons2__DAVReply(soap, tag, id, (ns2__DAVReply *const*)ptr, "ns2:DAVReply");
	case SOAP_TYPE_PointerTons2__AFSReply:
		return soap_out_PointerTons2__AFSReply(soap, tag, id, (ns2__AFSReply *const*)ptr, "ns2:AFSReply");
	case SOAP_TYPE_PointerTons2__DMEReply:
		return soap_out_PointerTons2__DMEReply(soap, tag, id, (ns2__DMEReply *const*)ptr, "ns2:DMEReply");
	case SOAP_TYPE_PointerTons2__EncryptPaymentDataReply:
		return soap_out_PointerTons2__EncryptPaymentDataReply(soap, tag, id, (ns2__EncryptPaymentDataReply *const*)ptr, "ns2:EncryptPaymentDataReply");
	case SOAP_TYPE_PointerTons2__TaxReply:
		return soap_out_PointerTons2__TaxReply(soap, tag, id, (ns2__TaxReply *const*)ptr, "ns2:TaxReply");
	case SOAP_TYPE_PointerTons2__PayerAuthValidateReply:
		return soap_out_PointerTons2__PayerAuthValidateReply(soap, tag, id, (ns2__PayerAuthValidateReply *const*)ptr, "ns2:PayerAuthValidateReply");
	case SOAP_TYPE_PointerTons2__PayerAuthEnrollReply:
		return soap_out_PointerTons2__PayerAuthEnrollReply(soap, tag, id, (ns2__PayerAuthEnrollReply *const*)ptr, "ns2:PayerAuthEnrollReply");
	case SOAP_TYPE_PointerTons2__ECAuthenticateReply:
		return soap_out_PointerTons2__ECAuthenticateReply(soap, tag, id, (ns2__ECAuthenticateReply *const*)ptr, "ns2:ECAuthenticateReply");
	case SOAP_TYPE_PointerTons2__ECCreditReply:
		return soap_out_PointerTons2__ECCreditReply(soap, tag, id, (ns2__ECCreditReply *const*)ptr, "ns2:ECCreditReply");
	case SOAP_TYPE_PointerTons2__ECDebitReply:
		return soap_out_PointerTons2__ECDebitReply(soap, tag, id, (ns2__ECDebitReply *const*)ptr, "ns2:ECDebitReply");
	case SOAP_TYPE_PointerTons2__CCDCCUpdateReply:
		return soap_out_PointerTons2__CCDCCUpdateReply(soap, tag, id, (ns2__CCDCCUpdateReply *const*)ptr, "ns2:CCDCCUpdateReply");
	case SOAP_TYPE_PointerTons2__CCDCCReply:
		return soap_out_PointerTons2__CCDCCReply(soap, tag, id, (ns2__CCDCCReply *const*)ptr, "ns2:CCDCCReply");
	case SOAP_TYPE_PointerTons2__CCAutoAuthReversalReply:
		return soap_out_PointerTons2__CCAutoAuthReversalReply(soap, tag, id, (ns2__CCAutoAuthReversalReply *const*)ptr, "ns2:CCAutoAuthReversalReply");
	case SOAP_TYPE_PointerTons2__CCAuthReversalReply:
		return soap_out_PointerTons2__CCAuthReversalReply(soap, tag, id, (ns2__CCAuthReversalReply *const*)ptr, "ns2:CCAuthReversalReply");
	case SOAP_TYPE_PointerTons2__CCCreditReply:
		return soap_out_PointerTons2__CCCreditReply(soap, tag, id, (ns2__CCCreditReply *const*)ptr, "ns2:CCCreditReply");
	case SOAP_TYPE_PointerTons2__CCCaptureReply:
		return soap_out_PointerTons2__CCCaptureReply(soap, tag, id, (ns2__CCCaptureReply *const*)ptr, "ns2:CCCaptureReply");
	case SOAP_TYPE_PointerTons2__ServiceFeeCalculateReply:
		return soap_out_PointerTons2__ServiceFeeCalculateReply(soap, tag, id, (ns2__ServiceFeeCalculateReply *const*)ptr, "ns2:ServiceFeeCalculateReply");
	case SOAP_TYPE_PointerTons2__CCIncrementalAuthReply:
		return soap_out_PointerTons2__CCIncrementalAuthReply(soap, tag, id, (ns2__CCIncrementalAuthReply *const*)ptr, "ns2:CCIncrementalAuthReply");
	case SOAP_TYPE_PointerTons2__CCSaleReversalReply:
		return soap_out_PointerTons2__CCSaleReversalReply(soap, tag, id, (ns2__CCSaleReversalReply *const*)ptr, "ns2:CCSaleReversalReply");
	case SOAP_TYPE_PointerTons2__CCSaleCreditReply:
		return soap_out_PointerTons2__CCSaleCreditReply(soap, tag, id, (ns2__CCSaleCreditReply *const*)ptr, "ns2:CCSaleCreditReply");
	case SOAP_TYPE_PointerTons2__CCSaleReply:
		return soap_out_PointerTons2__CCSaleReply(soap, tag, id, (ns2__CCSaleReply *const*)ptr, "ns2:CCSaleReply");
	case SOAP_TYPE_PointerTons2__VerificationReply:
		return soap_out_PointerTons2__VerificationReply(soap, tag, id, (ns2__VerificationReply *const*)ptr, "ns2:VerificationReply");
	case SOAP_TYPE_PointerTons2__OCTReply:
		return soap_out_PointerTons2__OCTReply(soap, tag, id, (ns2__OCTReply *const*)ptr, "ns2:OCTReply");
	case SOAP_TYPE_PointerTons2__CCAuthReply:
		return soap_out_PointerTons2__CCAuthReply(soap, tag, id, (ns2__CCAuthReply *const*)ptr, "ns2:CCAuthReply");
	case SOAP_TYPE_PointerTons2__DeniedPartiesMatch:
		return soap_out_PointerTons2__DeniedPartiesMatch(soap, tag, id, (ns2__DeniedPartiesMatch *const*)ptr, "ns2:DeniedPartiesMatch");
	case SOAP_TYPE_PointerTons2__APOptionsOption:
		return soap_out_PointerTons2__APOptionsOption(soap, tag, id, (ns2__APOptionsOption *const*)ptr, "ns2:APOptionsOption");
	case SOAP_TYPE_PointerTons2__RuleResultItems:
		return soap_out_PointerTons2__RuleResultItems(soap, tag, id, (ns2__RuleResultItems *const*)ptr, "ns2:RuleResultItems");
	case SOAP_TYPE_PointerTons2__Field:
		return soap_out_PointerTons2__Field(soap, tag, id, (ns2__Field *const*)ptr, "ns2:Field");
	case SOAP_TYPE_PointerTons2__AdditionalFields:
		return soap_out_PointerTons2__AdditionalFields(soap, tag, id, (ns2__AdditionalFields *const*)ptr, "ns2:AdditionalFields");
	case SOAP_TYPE_PointerTons2__ProfileReply:
		return soap_out_PointerTons2__ProfileReply(soap, tag, id, (ns2__ProfileReply *const*)ptr, "ns2:ProfileReply");
	case SOAP_TYPE_PointerTons2__RuleResultItem:
		return soap_out_PointerTons2__RuleResultItem(soap, tag, id, (ns2__RuleResultItem *const*)ptr, "ns2:RuleResultItem");
	case SOAP_TYPE_PointerTons2__FXQuote:
		return soap_out_PointerTons2__FXQuote(soap, tag, id, (ns2__FXQuote *const*)ptr, "ns2:FXQuote");
	case SOAP_TYPE_PointerTons2__DeviceFingerprint:
		return soap_out_PointerTons2__DeviceFingerprint(soap, tag, id, (ns2__DeviceFingerprint *const*)ptr, "ns2:DeviceFingerprint");
	case SOAP_TYPE_PointerTons2__TaxReplyItem:
		return soap_out_PointerTons2__TaxReplyItem(soap, tag, id, (ns2__TaxReplyItem *const*)ptr, "ns2:TaxReplyItem");
	case SOAP_TYPE_PointerTons2__issuer:
		return soap_out_PointerTons2__issuer(soap, tag, id, (ns2__issuer *const*)ptr, "ns2:issuer");
	case SOAP_TYPE_PointerTons2__BinLookupService:
		return soap_out_PointerTons2__BinLookupService(soap, tag, id, (ns2__BinLookupService *const*)ptr, "ns2:BinLookupService");
	case SOAP_TYPE_PointerTons2__EncryptPaymentDataService:
		return soap_out_PointerTons2__EncryptPaymentDataService(soap, tag, id, (ns2__EncryptPaymentDataService *const*)ptr, "ns2:EncryptPaymentDataService");
	case SOAP_TYPE_PointerTons2__Aft:
		return soap_out_PointerTons2__Aft(soap, tag, id, (ns2__Aft *const*)ptr, "ns2:Aft");
	case SOAP_TYPE_PointerTons2__Wallet:
		return soap_out_PointerTons2__Wallet(soap, tag, id, (ns2__Wallet *const*)ptr, "ns2:Wallet");
	case SOAP_TYPE_PointerTons2__PromotionGroup:
		return soap_out_PointerTons2__PromotionGroup(soap, tag, id, (ns2__PromotionGroup *const*)ptr, "ns2:PromotionGroup");
	case SOAP_TYPE_PointerTons2__DecryptVisaCheckoutDataService:
		return soap_out_PointerTons2__DecryptVisaCheckoutDataService(soap, tag, id, (ns2__DecryptVisaCheckoutDataService *const*)ptr, "ns2:DecryptVisaCheckoutDataService");
	case SOAP_TYPE_PointerTons2__VC:
		return soap_out_PointerTons2__VC(soap, tag, id, (ns2__VC *const*)ptr, "ns2:VC");
	case SOAP_TYPE_PointerTons2__AutoRentalData:
		return soap_out_PointerTons2__AutoRentalData(soap, tag, id, (ns2__AutoRentalData *const*)ptr, "ns2:AutoRentalData");
	case SOAP_TYPE_PointerTons2__Sender:
		return soap_out_PointerTons2__Sender(soap, tag, id, (ns2__Sender *const*)ptr, "ns2:Sender");
	case SOAP_TYPE_PointerTons2__Recipient:
		return soap_out_PointerTons2__Recipient(soap, tag, id, (ns2__Recipient *const*)ptr, "ns2:Recipient");
	case SOAP_TYPE_PointerTons2__PaymentNetworkToken:
		return soap_out_PointerTons2__PaymentNetworkToken(soap, tag, id, (ns2__PaymentNetworkToken *const*)ptr, "ns2:PaymentNetworkToken");
	case SOAP_TYPE_PointerTons2__HostedDataRetrieveService:
		return soap_out_PointerTons2__HostedDataRetrieveService(soap, tag, id, (ns2__HostedDataRetrieveService *const*)ptr, "ns2:HostedDataRetrieveService");
	case SOAP_TYPE_PointerTons2__HostedDataCreateService:
		return soap_out_PointerTons2__HostedDataCreateService(soap, tag, id, (ns2__HostedDataCreateService *const*)ptr, "ns2:HostedDataCreateService");
	case SOAP_TYPE_PointerTons2__EmvRequest:
		return soap_out_PointerTons2__EmvRequest(soap, tag, id, (ns2__EmvRequest *const*)ptr, "ns2:EmvRequest");
	case SOAP_TYPE_PointerTons2__CCDCCUpdateService:
		return soap_out_PointerTons2__CCDCCUpdateService(soap, tag, id, (ns2__CCDCCUpdateService *const*)ptr, "ns2:CCDCCUpdateService");
	case SOAP_TYPE_PointerTons2__PayPalTransactionSearchService:
		return soap_out_PointerTons2__PayPalTransactionSearchService(soap, tag, id, (ns2__PayPalTransactionSearchService *const*)ptr, "ns2:PayPalTransactionSearchService");
	case SOAP_TYPE_PointerTons2__PayPalGetTxnDetailsService:
		return soap_out_PointerTons2__PayPalGetTxnDetailsService(soap, tag, id, (ns2__PayPalGetTxnDetailsService *const*)ptr, "ns2:PayPalGetTxnDetailsService");
	case SOAP_TYPE_PointerTons2__APConfirmPurchaseService:
		return soap_out_PointerTons2__APConfirmPurchaseService(soap, tag, id, (ns2__APConfirmPurchaseService *const*)ptr, "ns2:APConfirmPurchaseService");
	case SOAP_TYPE_PointerTons2__APTransactionDetailsService:
		return soap_out_PointerTons2__APTransactionDetailsService(soap, tag, id, (ns2__APTransactionDetailsService *const*)ptr, "ns2:APTransactionDetailsService");
	case SOAP_TYPE_PointerTons2__APCheckOutDetailsService:
		return soap_out_PointerTons2__APCheckOutDetailsService(soap, tag, id, (ns2__APCheckOutDetailsService *const*)ptr, "ns2:APCheckOutDetailsService");
	case SOAP_TYPE_PointerTons2__APSaleService:
		return soap_out_PointerTons2__APSaleService(soap, tag, id, (ns2__APSaleService *const*)ptr, "ns2:APSaleService");
	case SOAP_TYPE_PointerTons2__APRefundService:
		return soap_out_PointerTons2__APRefundService(soap, tag, id, (ns2__APRefundService *const*)ptr, "ns2:APRefundService");
	case SOAP_TYPE_PointerTons2__APOptionsService:
		return soap_out_PointerTons2__APOptionsService(soap, tag, id, (ns2__APOptionsService *const*)ptr, "ns2:APOptionsService");
	case SOAP_TYPE_PointerTons2__APCaptureService:
		return soap_out_PointerTons2__APCaptureService(soap, tag, id, (ns2__APCaptureService *const*)ptr, "ns2:APCaptureService");
	case SOAP_TYPE_PointerTons2__APAuthReversalService:
		return soap_out_PointerTons2__APAuthReversalService(soap, tag, id, (ns2__APAuthReversalService *const*)ptr, "ns2:APAuthReversalService");
	case SOAP_TYPE_PointerTons2__APAuthService:
		return soap_out_PointerTons2__APAuthService(soap, tag, id, (ns2__APAuthService *const*)ptr, "ns2:APAuthService");
	case SOAP_TYPE_PointerTons2__AP:
		return soap_out_PointerTons2__AP(soap, tag, id, (ns2__AP *const*)ptr, "ns2:AP");
	case SOAP_TYPE_PointerTons2__PinDebitReversalService:
		return soap_out_PointerTons2__PinDebitReversalService(soap, tag, id, (ns2__PinDebitReversalService *const*)ptr, "ns2:PinDebitReversalService");
	case SOAP_TYPE_PointerTons2__PinDebitCreditService:
		return soap_out_PointerTons2__PinDebitCreditService(soap, tag, id, (ns2__PinDebitCreditService *const*)ptr, "ns2:PinDebitCreditService");
	case SOAP_TYPE_PointerTons2__PinDebitPurchaseService:
		return soap_out_PointerTons2__PinDebitPurchaseService(soap, tag, id, (ns2__PinDebitPurchaseService *const*)ptr, "ns2:PinDebitPurchaseService");
	case SOAP_TYPE_PointerTons2__APCheckStatusService:
		return soap_out_PointerTons2__APCheckStatusService(soap, tag, id, (ns2__APCheckStatusService *const*)ptr, "ns2:APCheckStatusService");
	case SOAP_TYPE_PointerTons2__APInitiateService:
		return soap_out_PointerTons2__APInitiateService(soap, tag, id, (ns2__APInitiateService *const*)ptr, "ns2:APInitiateService");
	case SOAP_TYPE_PointerTons2__BoletoPaymentService:
		return soap_out_PointerTons2__BoletoPaymentService(soap, tag, id, (ns2__BoletoPaymentService *const*)ptr, "ns2:BoletoPaymentService");
	case SOAP_TYPE_PointerTons2__ChinaRefundService:
		return soap_out_PointerTons2__ChinaRefundService(soap, tag, id, (ns2__ChinaRefundService *const*)ptr, "ns2:ChinaRefundService");
	case SOAP_TYPE_PointerTons2__ChinaPaymentService:
		return soap_out_PointerTons2__ChinaPaymentService(soap, tag, id, (ns2__ChinaPaymentService *const*)ptr, "ns2:ChinaPaymentService");
	case SOAP_TYPE_PointerTons2__PayPalDoRefTransactionService:
		return soap_out_PointerTons2__PayPalDoRefTransactionService(soap, tag, id, (ns2__PayPalDoRefTransactionService *const*)ptr, "ns2:PayPalDoRefTransactionService");
	case SOAP_TYPE_PointerTons2__PayPalCreateAgreementService:
		return soap_out_PointerTons2__PayPalCreateAgreementService(soap, tag, id, (ns2__PayPalCreateAgreementService *const*)ptr, "ns2:PayPalCreateAgreementService");
	case SOAP_TYPE_PointerTons2__PayPalUpdateAgreementService:
		return soap_out_PointerTons2__PayPalUpdateAgreementService(soap, tag, id, (ns2__PayPalUpdateAgreementService *const*)ptr, "ns2:PayPalUpdateAgreementService");
	case SOAP_TYPE_PointerTons2__PayPalAuthorizationService:
		return soap_out_PointerTons2__PayPalAuthorizationService(soap, tag, id, (ns2__PayPalAuthorizationService *const*)ptr, "ns2:PayPalAuthorizationService");
	case SOAP_TYPE_PointerTons2__PayPalEcOrderSetupService:
		return soap_out_PointerTons2__PayPalEcOrderSetupService(soap, tag, id, (ns2__PayPalEcOrderSetupService *const*)ptr, "ns2:PayPalEcOrderSetupService");
	case SOAP_TYPE_PointerTons2__PayPalEcSetService:
		return soap_out_PointerTons2__PayPalEcSetService(soap, tag, id, (ns2__PayPalEcSetService *const*)ptr, "ns2:PayPalEcSetService");
	case SOAP_TYPE_PointerTons2__PayPalEcGetDetailsService:
		return soap_out_PointerTons2__PayPalEcGetDetailsService(soap, tag, id, (ns2__PayPalEcGetDetailsService *const*)ptr, "ns2:PayPalEcGetDetailsService");
	case SOAP_TYPE_PointerTons2__PayPalEcDoPaymentService:
		return soap_out_PointerTons2__PayPalEcDoPaymentService(soap, tag, id, (ns2__PayPalEcDoPaymentService *const*)ptr, "ns2:PayPalEcDoPaymentService");
	case SOAP_TYPE_PointerTons2__PayPalDoCaptureService:
		return soap_out_PointerTons2__PayPalDoCaptureService(soap, tag, id, (ns2__PayPalDoCaptureService *const*)ptr, "ns2:PayPalDoCaptureService");
	case SOAP_TYPE_PointerTons2__PayPalAuthReversalService:
		return soap_out_PointerTons2__PayPalAuthReversalService(soap, tag, id, (ns2__PayPalAuthReversalService *const*)ptr, "ns2:PayPalAuthReversalService");
	case SOAP_TYPE_PointerTons2__PayPalRefundService:
		return soap_out_PointerTons2__PayPalRefundService(soap, tag, id, (ns2__PayPalRefundService *const*)ptr, "ns2:PayPalRefundService");
	case SOAP_TYPE_PointerTons2__RequestReserved:
		return soap_out_PointerTons2__RequestReserved(soap, tag, id, (ns2__RequestReserved *const*)ptr, "ns2:RequestReserved");
	case SOAP_TYPE_PointerTons2__CaseManagementActionService:
		return soap_out_PointerTons2__CaseManagementActionService(soap, tag, id, (ns2__CaseManagementActionService *const*)ptr, "ns2:CaseManagementActionService");
	case SOAP_TYPE_PointerTons2__FraudUpdateService:
		return soap_out_PointerTons2__FraudUpdateService(soap, tag, id, (ns2__FraudUpdateService *const*)ptr, "ns2:FraudUpdateService");
	case SOAP_TYPE_PointerTons2__RiskUpdateService:
		return soap_out_PointerTons2__RiskUpdateService(soap, tag, id, (ns2__RiskUpdateService *const*)ptr, "ns2:RiskUpdateService");
	case SOAP_TYPE_PointerTons2__PayPalPreapprovedUpdateService:
		return soap_out_PointerTons2__PayPalPreapprovedUpdateService(soap, tag, id, (ns2__PayPalPreapprovedUpdateService *const*)ptr, "ns2:PayPalPreapprovedUpdateService");
	case SOAP_TYPE_PointerTons2__PayPalPreapprovedPaymentService:
		return soap_out_PointerTons2__PayPalPreapprovedPaymentService(soap, tag, id, (ns2__PayPalPreapprovedPaymentService *const*)ptr, "ns2:PayPalPreapprovedPaymentService");
	case SOAP_TYPE_PointerTons2__PayPalButtonCreateService:
		return soap_out_PointerTons2__PayPalButtonCreateService(soap, tag, id, (ns2__PayPalButtonCreateService *const*)ptr, "ns2:PayPalButtonCreateService");
	case SOAP_TYPE_PointerTons2__LodgingData:
		return soap_out_PointerTons2__LodgingData(soap, tag, id, (ns2__LodgingData *const*)ptr, "ns2:LodgingData");
	case SOAP_TYPE_PointerTons2__AncillaryData:
		return soap_out_PointerTons2__AncillaryData(soap, tag, id, (ns2__AncillaryData *const*)ptr, "ns2:AncillaryData");
	case SOAP_TYPE_PointerTons2__AirlineData:
		return soap_out_PointerTons2__AirlineData(soap, tag, id, (ns2__AirlineData *const*)ptr, "ns2:AirlineData");
	case SOAP_TYPE_PointerTons2__Batch:
		return soap_out_PointerTons2__Batch(soap, tag, id, (ns2__Batch *const*)ptr, "ns2:Batch");
	case SOAP_TYPE_PointerTons2__PinlessDebitReversalService:
		return soap_out_PointerTons2__PinlessDebitReversalService(soap, tag, id, (ns2__PinlessDebitReversalService *const*)ptr, "ns2:PinlessDebitReversalService");
	case SOAP_TYPE_PointerTons2__PinlessDebitValidateService:
		return soap_out_PointerTons2__PinlessDebitValidateService(soap, tag, id, (ns2__PinlessDebitValidateService *const*)ptr, "ns2:PinlessDebitValidateService");
	case SOAP_TYPE_PointerTons2__PinlessDebitService:
		return soap_out_PointerTons2__PinlessDebitService(soap, tag, id, (ns2__PinlessDebitService *const*)ptr, "ns2:PinlessDebitService");
	case SOAP_TYPE_PointerTons2__BusinessRules:
		return soap_out_PointerTons2__BusinessRules(soap, tag, id, (ns2__BusinessRules *const*)ptr, "ns2:BusinessRules");
	case SOAP_TYPE_PointerTons2__VoidService:
		return soap_out_PointerTons2__VoidService(soap, tag, id, (ns2__VoidService *const*)ptr, "ns2:VoidService");
	case SOAP_TYPE_PointerTons2__PayPalCreditService:
		return soap_out_PointerTons2__PayPalCreditService(soap, tag, id, (ns2__PayPalCreditService *const*)ptr, "ns2:PayPalCreditService");
	case SOAP_TYPE_PointerTons2__PayPalPaymentService:
		return soap_out_PointerTons2__PayPalPaymentService(soap, tag, id, (ns2__PayPalPaymentService *const*)ptr, "ns2:PayPalPaymentService");
	case SOAP_TYPE_PointerTons2__PaySubscriptionDeleteService:
		return soap_out_PointerTons2__PaySubscriptionDeleteService(soap, tag, id, (ns2__PaySubscriptionDeleteService *const*)ptr, "ns2:PaySubscriptionDeleteService");
	case SOAP_TYPE_PointerTons2__PaySubscriptionRetrieveService:
		return soap_out_PointerTons2__PaySubscriptionRetrieveService(soap, tag, id, (ns2__PaySubscriptionRetrieveService *const*)ptr, "ns2:PaySubscriptionRetrieveService");
	case SOAP_TYPE_PointerTons2__PaySubscriptionEventUpdateService:
		return soap_out_PointerTons2__PaySubscriptionEventUpdateService(soap, tag, id, (ns2__PaySubscriptionEventUpdateService *const*)ptr, "ns2:PaySubscriptionEventUpdateService");
	case SOAP_TYPE_PointerTons2__PaySubscriptionUpdateService:
		return soap_out_PointerTons2__PaySubscriptionUpdateService(soap, tag, id, (ns2__PaySubscriptionUpdateService *const*)ptr, "ns2:PaySubscriptionUpdateService");
	case SOAP_TYPE_PointerTons2__PaySubscriptionCreateService:
		return soap_out_PointerTons2__PaySubscriptionCreateService(soap, tag, id, (ns2__PaySubscriptionCreateService *const*)ptr, "ns2:PaySubscriptionCreateService");
	case SOAP_TYPE_PointerTons2__DirectDebitValidateService:
		return soap_out_PointerTons2__DirectDebitValidateService(soap, tag, id, (ns2__DirectDebitValidateService *const*)ptr, "ns2:DirectDebitValidateService");
	case SOAP_TYPE_PointerTons2__DirectDebitRefundService:
		return soap_out_PointerTons2__DirectDebitRefundService(soap, tag, id, (ns2__DirectDebitRefundService *const*)ptr, "ns2:DirectDebitRefundService");
	case SOAP_TYPE_PointerTons2__DirectDebitService:
		return soap_out_PointerTons2__DirectDebitService(soap, tag, id, (ns2__DirectDebitService *const*)ptr, "ns2:DirectDebitService");
	case SOAP_TYPE_PointerTons2__DirectDebitMandateService:
		return soap_out_PointerTons2__DirectDebitMandateService(soap, tag, id, (ns2__DirectDebitMandateService *const*)ptr, "ns2:DirectDebitMandateService");
	case SOAP_TYPE_PointerTons2__BankTransferRealTimeService:
		return soap_out_PointerTons2__BankTransferRealTimeService(soap, tag, id, (ns2__BankTransferRealTimeService *const*)ptr, "ns2:BankTransferRealTimeService");
	case SOAP_TYPE_PointerTons2__BankTransferRefundService:
		return soap_out_PointerTons2__BankTransferRefundService(soap, tag, id, (ns2__BankTransferRefundService *const*)ptr, "ns2:BankTransferRefundService");
	case SOAP_TYPE_PointerTons2__BankTransferService:
		return soap_out_PointerTons2__BankTransferService(soap, tag, id, (ns2__BankTransferService *const*)ptr, "ns2:BankTransferService");
	case SOAP_TYPE_PointerTons2__FXRatesService:
		return soap_out_PointerTons2__FXRatesService(soap, tag, id, (ns2__FXRatesService *const*)ptr, "ns2:FXRatesService");
	case SOAP_TYPE_PointerTons2__ExportService:
		return soap_out_PointerTons2__ExportService(soap, tag, id, (ns2__ExportService *const*)ptr, "ns2:ExportService");
	case SOAP_TYPE_PointerTons2__DAVService:
		return soap_out_PointerTons2__DAVService(soap, tag, id, (ns2__DAVService *const*)ptr, "ns2:DAVService");
	case SOAP_TYPE_PointerTons2__AFSService:
		return soap_out_PointerTons2__AFSService(soap, tag, id, (ns2__AFSService *const*)ptr, "ns2:AFSService");
	case SOAP_TYPE_PointerTons2__DMEService:
		return soap_out_PointerTons2__DMEService(soap, tag, id, (ns2__DMEService *const*)ptr, "ns2:DMEService");
	case SOAP_TYPE_PointerTons2__TaxService:
		return soap_out_PointerTons2__TaxService(soap, tag, id, (ns2__TaxService *const*)ptr, "ns2:TaxService");
	case SOAP_TYPE_PointerTons2__PayerAuthValidateService:
		return soap_out_PointerTons2__PayerAuthValidateService(soap, tag, id, (ns2__PayerAuthValidateService *const*)ptr, "ns2:PayerAuthValidateService");
	case SOAP_TYPE_PointerTons2__PayerAuthEnrollService:
		return soap_out_PointerTons2__PayerAuthEnrollService(soap, tag, id, (ns2__PayerAuthEnrollService *const*)ptr, "ns2:PayerAuthEnrollService");
	case SOAP_TYPE_PointerTons2__ECAuthenticateService:
		return soap_out_PointerTons2__ECAuthenticateService(soap, tag, id, (ns2__ECAuthenticateService *const*)ptr, "ns2:ECAuthenticateService");
	case SOAP_TYPE_PointerTons2__ECCreditService:
		return soap_out_PointerTons2__ECCreditService(soap, tag, id, (ns2__ECCreditService *const*)ptr, "ns2:ECCreditService");
	case SOAP_TYPE_PointerTons2__ECDebitService:
		return soap_out_PointerTons2__ECDebitService(soap, tag, id, (ns2__ECDebitService *const*)ptr, "ns2:ECDebitService");
	case SOAP_TYPE_PointerTons2__ServiceFeeCalculateService:
		return soap_out_PointerTons2__ServiceFeeCalculateService(soap, tag, id, (ns2__ServiceFeeCalculateService *const*)ptr, "ns2:ServiceFeeCalculateService");
	case SOAP_TYPE_PointerTons2__CCDCCService:
		return soap_out_PointerTons2__CCDCCService(soap, tag, id, (ns2__CCDCCService *const*)ptr, "ns2:CCDCCService");
	case SOAP_TYPE_PointerTons2__CCAutoAuthReversalService:
		return soap_out_PointerTons2__CCAutoAuthReversalService(soap, tag, id, (ns2__CCAutoAuthReversalService *const*)ptr, "ns2:CCAutoAuthReversalService");
	case SOAP_TYPE_PointerTons2__CCAuthReversalService:
		return soap_out_PointerTons2__CCAuthReversalService(soap, tag, id, (ns2__CCAuthReversalService *const*)ptr, "ns2:CCAuthReversalService");
	case SOAP_TYPE_PointerTons2__CCCreditService:
		return soap_out_PointerTons2__CCCreditService(soap, tag, id, (ns2__CCCreditService *const*)ptr, "ns2:CCCreditService");
	case SOAP_TYPE_PointerTons2__CCCaptureService:
		return soap_out_PointerTons2__CCCaptureService(soap, tag, id, (ns2__CCCaptureService *const*)ptr, "ns2:CCCaptureService");
	case SOAP_TYPE_PointerTons2__CCIncrementalAuthService:
		return soap_out_PointerTons2__CCIncrementalAuthService(soap, tag, id, (ns2__CCIncrementalAuthService *const*)ptr, "ns2:CCIncrementalAuthService");
	case SOAP_TYPE_PointerTons2__CCSaleReversalService:
		return soap_out_PointerTons2__CCSaleReversalService(soap, tag, id, (ns2__CCSaleReversalService *const*)ptr, "ns2:CCSaleReversalService");
	case SOAP_TYPE_PointerTons2__CCSaleCreditService:
		return soap_out_PointerTons2__CCSaleCreditService(soap, tag, id, (ns2__CCSaleCreditService *const*)ptr, "ns2:CCSaleCreditService");
	case SOAP_TYPE_PointerTons2__CCSaleService:
		return soap_out_PointerTons2__CCSaleService(soap, tag, id, (ns2__CCSaleService *const*)ptr, "ns2:CCSaleService");
	case SOAP_TYPE_PointerTons2__VerificationService:
		return soap_out_PointerTons2__VerificationService(soap, tag, id, (ns2__VerificationService *const*)ptr, "ns2:VerificationService");
	case SOAP_TYPE_PointerTons2__OCTService:
		return soap_out_PointerTons2__OCTService(soap, tag, id, (ns2__OCTService *const*)ptr, "ns2:OCTService");
	case SOAP_TYPE_PointerTons2__CCAuthService:
		return soap_out_PointerTons2__CCAuthService(soap, tag, id, (ns2__CCAuthService *const*)ptr, "ns2:CCAuthService");
	case SOAP_TYPE_PointerTons2__ServiceFee:
		return soap_out_PointerTons2__ServiceFee(soap, tag, id, (ns2__ServiceFee *const*)ptr, "ns2:ServiceFee");
	case SOAP_TYPE_PointerTons2__JPO:
		return soap_out_PointerTons2__JPO(soap, tag, id, (ns2__JPO *const*)ptr, "ns2:JPO");
	case SOAP_TYPE_PointerTons2__MerchantSecureData:
		return soap_out_PointerTons2__MerchantSecureData(soap, tag, id, (ns2__MerchantSecureData *const*)ptr, "ns2:MerchantSecureData");
	case SOAP_TYPE_PointerTons2__MerchantDefinedData:
		return soap_out_PointerTons2__MerchantDefinedData(soap, tag, id, (ns2__MerchantDefinedData *const*)ptr, "ns2:MerchantDefinedData");
	case SOAP_TYPE_PointerTons2__PayPal:
		return soap_out_PointerTons2__PayPal(soap, tag, id, (ns2__PayPal *const*)ptr, "ns2:PayPal");
	case SOAP_TYPE_PointerTons2__OtherTax:
		return soap_out_PointerTons2__OtherTax(soap, tag, id, (ns2__OtherTax *const*)ptr, "ns2:OtherTax");
	case SOAP_TYPE_PointerTons2__DecisionManager:
		return soap_out_PointerTons2__DecisionManager(soap, tag, id, (ns2__DecisionManager *const*)ptr, "ns2:DecisionManager");
	case SOAP_TYPE_PointerTons2__RecurringSubscriptionInfo:
		return soap_out_PointerTons2__RecurringSubscriptionInfo(soap, tag, id, (ns2__RecurringSubscriptionInfo *const*)ptr, "ns2:RecurringSubscriptionInfo");
	case SOAP_TYPE_PointerTons2__Subscription:
		return soap_out_PointerTons2__Subscription(soap, tag, id, (ns2__Subscription *const*)ptr, "ns2:Subscription");
	case SOAP_TYPE_PointerTons2__BankInfo:
		return soap_out_PointerTons2__BankInfo(soap, tag, id, (ns2__BankInfo *const*)ptr, "ns2:BankInfo");
	case SOAP_TYPE_PointerTons2__FundTransfer:
		return soap_out_PointerTons2__FundTransfer(soap, tag, id, (ns2__FundTransfer *const*)ptr, "ns2:FundTransfer");
	case SOAP_TYPE_PointerTons2__UCAF:
		return soap_out_PointerTons2__UCAF(soap, tag, id, (ns2__UCAF *const*)ptr, "ns2:UCAF");
	case SOAP_TYPE_PointerTons2__GECC:
		return soap_out_PointerTons2__GECC(soap, tag, id, (ns2__GECC *const*)ptr, "ns2:GECC");
	case SOAP_TYPE_PointerTons2__BML:
		return soap_out_PointerTons2__BML(soap, tag, id, (ns2__BML *const*)ptr, "ns2:BML");
	case SOAP_TYPE_PointerTons2__Check:
		return soap_out_PointerTons2__Check(soap, tag, id, (ns2__Check *const*)ptr, "ns2:Check");
	case SOAP_TYPE_PointerTons2__Card:
		return soap_out_PointerTons2__Card(soap, tag, id, (ns2__Card *const*)ptr, "ns2:Card");
	case SOAP_TYPE_PointerTons2__Installment:
		return soap_out_PointerTons2__Installment(soap, tag, id, (ns2__Installment *const*)ptr, "ns2:Installment");
	case SOAP_TYPE_PointerTons2__EncryptedPayment:
		return soap_out_PointerTons2__EncryptedPayment(soap, tag, id, (ns2__EncryptedPayment *const*)ptr, "ns2:EncryptedPayment");
	case SOAP_TYPE_PointerTons2__Pos:
		return soap_out_PointerTons2__Pos(soap, tag, id, (ns2__Pos *const*)ptr, "ns2:Pos");
	case SOAP_TYPE_PointerTons2__DCC:
		return soap_out_PointerTons2__DCC(soap, tag, id, (ns2__DCC *const*)ptr, "ns2:DCC");
	case SOAP_TYPE_PointerTons2__FundingTotals:
		return soap_out_PointerTons2__FundingTotals(soap, tag, id, (ns2__FundingTotals *const*)ptr, "ns2:FundingTotals");
	case SOAP_TYPE_PointerTons2__PurchaseTotals:
		return soap_out_PointerTons2__PurchaseTotals(soap, tag, id, (ns2__PurchaseTotals *const*)ptr, "ns2:PurchaseTotals");
	case SOAP_TYPE_PointerTons2__Item:
		return soap_out_PointerTons2__Item(soap, tag, id, (ns2__Item *const*)ptr, "ns2:Item");
	case SOAP_TYPE_PointerTons2__ShipFrom:
		return soap_out_PointerTons2__ShipFrom(soap, tag, id, (ns2__ShipFrom *const*)ptr, "ns2:ShipFrom");
	case SOAP_TYPE_PointerTons2__PersonalId:
		return soap_out_PointerTons2__PersonalId(soap, tag, id, (ns2__PersonalId *const*)ptr, "ns2:PersonalId");
	case SOAP_TYPE_PointerTons2__ShipTo:
		return soap_out_PointerTons2__ShipTo(soap, tag, id, (ns2__ShipTo *const*)ptr, "ns2:ShipTo");
	case SOAP_TYPE_PointerTons2__BillTo:
		return soap_out_PointerTons2__BillTo(soap, tag, id, (ns2__BillTo *const*)ptr, "ns2:BillTo");
	case SOAP_TYPE_PointerTons2__InvoiceHeader:
		return soap_out_PointerTons2__InvoiceHeader(soap, tag, id, (ns2__InvoiceHeader *const*)ptr, "ns2:InvoiceHeader");
	case SOAP_TYPE_PointerTons2__APDevice:
		return soap_out_PointerTons2__APDevice(soap, tag, id, (ns2__APDevice *const*)ptr, "ns2:APDevice");
	case SOAP_TYPE_PointerTons2__DecisionManagerTravelLeg:
		return soap_out_PointerTons2__DecisionManagerTravelLeg(soap, tag, id, (ns2__DecisionManagerTravelLeg *const*)ptr, "ns2:DecisionManagerTravelLeg");
	case SOAP_TYPE_PointerTons2__DecisionManagerTravelData:
		return soap_out_PointerTons2__DecisionManagerTravelData(soap, tag, id, (ns2__DecisionManagerTravelData *const*)ptr, "ns2:DecisionManagerTravelData");
	case SOAP_TYPE_PointerTons2__PaySubscriptionEvent:
		return soap_out_PointerTons2__PaySubscriptionEvent(soap, tag, id, (ns2__PaySubscriptionEvent *const*)ptr, "ns2:PaySubscriptionEvent");
	case SOAP_TYPE_PointerTons2__Address:
		return soap_out_PointerTons2__Address(soap, tag, id, (ns2__Address *const*)ptr, "ns2:Address");
	case SOAP_TYPE_PointerTons2__dateTime:
		return soap_out_PointerTons2__dateTime(soap, tag, id, (wchar_t **const*)ptr, "ns2:dateTime");
	case SOAP_TYPE_PointerToxsd__integer:
		return soap_out_PointerToxsd__integer(soap, tag, id, (wchar_t **const*)ptr, "xsd:integer");
	case SOAP_TYPE_PointerTons2__boolean:
		return soap_out_PointerTons2__boolean(soap, tag, id, (wchar_t **const*)ptr, "ns2:boolean");
	case SOAP_TYPE_PointerTons2__amount:
		return soap_out_PointerTons2__amount(soap, tag, id, (wchar_t **const*)ptr, "ns2:amount");
	case SOAP_TYPE_ns2__dateTime:
		return soap_out_wstring(soap, tag, id, (wchar_t*const*)(void*)&ptr, "ns2:dateTime");
	case SOAP_TYPE_ns2__boolean:
		return soap_out_wstring(soap, tag, id, (wchar_t*const*)(void*)&ptr, "ns2:boolean");
	case SOAP_TYPE_ns2__amount:
		return soap_out_wstring(soap, tag, id, (wchar_t*const*)(void*)&ptr, "ns2:amount");
	case SOAP_TYPE_xsd__integer:
		return soap_out_wstring(soap, tag, id, (wchar_t*const*)(void*)&ptr, "xsd:integer");
	case SOAP_TYPE_wstring:
		return soap_out_wstring(soap, tag, id, (wchar_t*const*)(void*)&ptr, "xsd:string");
	case SOAP_TYPE_PointerTo_wsse__Security:
		return soap_out_PointerTo_wsse__Security(soap, tag, id, (struct _wsse__Security *const*)ptr, "wsse:Security");
	case SOAP_TYPE_PointerTods__SignatureType:
		return soap_out_PointerTods__SignatureType(soap, tag, id, (struct ds__SignatureType *const*)ptr, "ds:SignatureType");
	case SOAP_TYPE_PointerTowsc__SecurityContextTokenType:
		return soap_out_PointerTowsc__SecurityContextTokenType(soap, tag, id, (struct wsc__SecurityContextTokenType *const*)ptr, "wsc:SecurityContextTokenType");
	case SOAP_TYPE_PointerToxenc__EncryptedKeyType:
		return soap_out_PointerToxenc__EncryptedKeyType(soap, tag, id, (struct xenc__EncryptedKeyType *const*)ptr, "xenc:EncryptedKeyType");
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		return soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag, id, (struct _wsse__BinarySecurityToken *const*)ptr, "wsse:BinarySecurityToken");
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		return soap_out_PointerTo_wsse__UsernameToken(soap, tag, id, (struct _wsse__UsernameToken *const*)ptr, "wsse:UsernameToken");
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		return soap_out_PointerTo_wsu__Timestamp(soap, tag, id, (struct _wsu__Timestamp *const*)ptr, "wsu:Timestamp");
	case SOAP_TYPE_PointerToULONG64:
		return soap_out_PointerToULONG64(soap, tag, id, (ULONG64 *const*)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_PointerTowsc__PropertiesType:
		return soap_out_PointerTowsc__PropertiesType(soap, tag, id, (struct wsc__PropertiesType *const*)ptr, "wsc:PropertiesType");
	case SOAP_TYPE_wsc__FaultCodeOpenEnumType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsc:FaultCodeOpenEnumType");
	case SOAP_TYPE_PointerTo_xenc__ReferenceList:
		return soap_out_PointerTo_xenc__ReferenceList(soap, tag, id, (struct _xenc__ReferenceList *const*)ptr, "xenc:ReferenceList");
	case SOAP_TYPE_PointerToxenc__ReferenceType:
		return soap_out_PointerToxenc__ReferenceType(soap, tag, id, (struct xenc__ReferenceType *const*)ptr, "xenc:ReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertyType:
		return soap_out_PointerToxenc__EncryptionPropertyType(soap, tag, id, (struct xenc__EncryptionPropertyType *const*)ptr, "xenc:EncryptionPropertyType");
	case SOAP_TYPE_PointerToxenc__TransformsType:
		return soap_out_PointerToxenc__TransformsType(soap, tag, id, (struct xenc__TransformsType *const*)ptr, "xenc:TransformsType");
	case SOAP_TYPE_PointerToxenc__CipherReferenceType:
		return soap_out_PointerToxenc__CipherReferenceType(soap, tag, id, (struct xenc__CipherReferenceType *const*)ptr, "xenc:CipherReferenceType");
	case SOAP_TYPE_PointerToxenc__EncryptionPropertiesType:
		return soap_out_PointerToxenc__EncryptionPropertiesType(soap, tag, id, (struct xenc__EncryptionPropertiesType *const*)ptr, "xenc:EncryptionPropertiesType");
	case SOAP_TYPE_PointerToxenc__CipherDataType:
		return soap_out_PointerToxenc__CipherDataType(soap, tag, id, (struct xenc__CipherDataType *const*)ptr, "xenc:CipherDataType");
	case SOAP_TYPE_PointerTo_ds__KeyInfo:
		return soap_out_PointerTo_ds__KeyInfo(soap, tag, id, (struct ds__KeyInfoType *const*)ptr, "ds:KeyInfo");
	case SOAP_TYPE_PointerToxenc__EncryptionMethodType:
		return soap_out_PointerToxenc__EncryptionMethodType(soap, tag, id, (struct xenc__EncryptionMethodType *const*)ptr, "xenc:EncryptionMethodType");
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		return soap_out_PointerTods__X509IssuerSerialType(soap, tag, id, (struct ds__X509IssuerSerialType *const*)ptr, "ds:X509IssuerSerialType");
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		return soap_out_PointerTods__RSAKeyValueType(soap, tag, id, (struct ds__RSAKeyValueType *const*)ptr, "ds:RSAKeyValueType");
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		return soap_out_PointerTods__DSAKeyValueType(soap, tag, id, (struct ds__DSAKeyValueType *const*)ptr, "ds:DSAKeyValueType");
	case SOAP_TYPE_PointerTods__TransformType:
		return soap_out_PointerTods__TransformType(soap, tag, id, (struct ds__TransformType *const*)ptr, "ds:TransformType");
	case SOAP_TYPE_PointerTods__DigestMethodType:
		return soap_out_PointerTods__DigestMethodType(soap, tag, id, (struct ds__DigestMethodType *const*)ptr, "ds:DigestMethodType");
	case SOAP_TYPE_PointerTods__TransformsType:
		return soap_out_PointerTods__TransformsType(soap, tag, id, (struct ds__TransformsType *const*)ptr, "ds:TransformsType");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		return soap_out_PointerToPointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType **const*)ptr, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__ReferenceType:
		return soap_out_PointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType *const*)ptr, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		return soap_out_PointerTods__SignatureMethodType(soap, tag, id, (struct ds__SignatureMethodType *const*)ptr, "ds:SignatureMethodType");
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		return soap_out_PointerTods__CanonicalizationMethodType(soap, tag, id, (struct ds__CanonicalizationMethodType *const*)ptr, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		return soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag, id, (struct _wsse__SecurityTokenReference *const*)ptr, "wsse:SecurityTokenReference");
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		return soap_out_PointerTods__RetrievalMethodType(soap, tag, id, (struct ds__RetrievalMethodType *const*)ptr, "ds:RetrievalMethodType");
	case SOAP_TYPE_PointerTods__KeyValueType:
		return soap_out_PointerTods__KeyValueType(soap, tag, id, (struct ds__KeyValueType *const*)ptr, "ds:KeyValueType");
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		return soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag, id, (struct _c14n__InclusiveNamespaces *const*)ptr, "c14n:InclusiveNamespaces");
	case SOAP_TYPE_PointerTods__KeyInfoType:
		return soap_out_PointerTods__KeyInfoType(soap, tag, id, (struct ds__KeyInfoType *const*)ptr, "ds:KeyInfoType");
	case SOAP_TYPE_PointerTods__SignedInfoType:
		return soap_out_PointerTods__SignedInfoType(soap, tag, id, (struct ds__SignedInfoType *const*)ptr, "ds:SignedInfoType");
	case SOAP_TYPE__ds__SignatureValue:
		return soap_out_string(soap, "ds:SignatureValue", id, (char*const*)(void*)&ptr, NULL);
	case SOAP_TYPE_PointerTods__X509DataType:
		return soap_out_PointerTods__X509DataType(soap, tag, id, (struct ds__X509DataType *const*)ptr, "ds:X509DataType");
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		return soap_out_PointerTo_wsse__Embedded(soap, tag, id, (struct _wsse__Embedded *const*)ptr, "wsse:Embedded");
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		return soap_out_PointerTo_wsse__KeyIdentifier(soap, tag, id, (struct _wsse__KeyIdentifier *const*)ptr, "wsse:KeyIdentifier");
	case SOAP_TYPE_PointerTo_wsse__Reference:
		return soap_out_PointerTo_wsse__Reference(soap, tag, id, (struct _wsse__Reference *const*)ptr, "wsse:Reference");
	case SOAP_TYPE_PointerTowsse__EncodedString:
		return soap_out_PointerTowsse__EncodedString(soap, tag, id, (struct wsse__EncodedString *const*)ptr, "wsse:EncodedString");
	case SOAP_TYPE_PointerTo_wsse__Password:
		return soap_out_PointerTo_wsse__Password(soap, tag, id, (struct _wsse__Password *const*)ptr, "wsse:Password");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns2__issuer:
		((ns2__issuer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__BinLookupReply:
		((ns2__BinLookupReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__BinLookupService:
		((ns2__BinLookupService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__EncryptPaymentDataReply:
		((ns2__EncryptPaymentDataReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply:
		((ns2__DecryptVisaCheckoutDataReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__VCCustomData:
		((ns2__VCCustomData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__VCCardArt:
		((ns2__VCCardArt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__VCReply:
		((ns2__VCReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AutoRentalData:
		((ns2__AutoRentalData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__HostedDataRetrieveReply:
		((ns2__HostedDataRetrieveReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__HostedDataCreateReply:
		((ns2__HostedDataCreateReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__HostedDataRetrieveService:
		((ns2__HostedDataRetrieveService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__HostedDataCreateService:
		((ns2__HostedDataCreateService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__OriginalTransaction:
		((ns2__OriginalTransaction *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__EmvReply:
		((ns2__EmvReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__EmvRequest:
		((ns2__EmvRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ServiceFee:
		((ns2__ServiceFee *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CCDCCUpdateService:
		((ns2__CCDCCUpdateService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PaypalTransaction:
		((ns2__PaypalTransaction *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalTransactionSearchReply:
		((ns2__PayPalTransactionSearchReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalGetTxnDetailsReply:
		((ns2__PayPalGetTxnDetailsReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RequestReserved:
		((ns2__RequestReserved *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ReplyReserved:
		((ns2__ReplyReserved *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MerchantSecureData:
		((ns2__MerchantSecureData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MerchantDefinedData:
		((ns2__MerchantDefinedData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MDDField:
		((ns2__MDDField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Installment:
		((ns2__Installment *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__EncryptedPayment:
		((ns2__EncryptedPayment *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Pos:
		((ns2__Pos *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__LodgingData:
		((ns2__LodgingData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Service:
		((ns2__Service *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AncillaryData:
		((ns2__AncillaryData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Leg:
		((ns2__Leg *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AirlineData:
		((ns2__AirlineData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FaultDetails:
		((ns2__FaultDetails *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ReplyMessage:
		((ns2__ReplyMessage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APConfirmPurchaseReply:
		((ns2__APConfirmPurchaseReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APTransactionDetailsReply:
		((ns2__APTransactionDetailsReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APCheckOutDetailsReply:
		((ns2__APCheckOutDetailsReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APSaleReply:
		((ns2__APSaleReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APRefundReply:
		((ns2__APRefundReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APOptionsOption:
		((ns2__APOptionsOption *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APOptionsReply:
		((ns2__APOptionsReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APCaptureReply:
		((ns2__APCaptureReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APAuthReversalReply:
		((ns2__APAuthReversalReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APAuthReply:
		((ns2__APAuthReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APReply:
		((ns2__APReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APCheckStatusReply:
		((ns2__APCheckStatusReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APInitiateReply:
		((ns2__APInitiateReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__BoletoPaymentReply:
		((ns2__BoletoPaymentReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ChinaRefundReply:
		((ns2__ChinaRefundReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ChinaPaymentReply:
		((ns2__ChinaPaymentReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CCDCCUpdateReply:
		((ns2__CCDCCUpdateReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CCDCCReply:
		((ns2__CCDCCReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ProfileReply:
		((ns2__ProfileReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DMEReply:
		((ns2__DMEReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Field:
		((ns2__Field *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AdditionalFields:
		((ns2__AdditionalFields *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DecisionReply:
		((ns2__DecisionReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RuleResultItems:
		((ns2__RuleResultItems *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RuleResultItem:
		((ns2__RuleResultItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CaseManagementActionReply:
		((ns2__CaseManagementActionReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FraudUpdateReply:
		((ns2__FraudUpdateReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RiskUpdateReply:
		((ns2__RiskUpdateReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalDoRefTransactionReply:
		((ns2__PayPalDoRefTransactionReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalCreateAgreementReply:
		((ns2__PayPalCreateAgreementReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalUpdateAgreementReply:
		((ns2__PayPalUpdateAgreementReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalAuthorizationReply:
		((ns2__PayPalAuthorizationReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalEcOrderSetupReply:
		((ns2__PayPalEcOrderSetupReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalRefundReply:
		((ns2__PayPalRefundReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalAuthReversalReply:
		((ns2__PayPalAuthReversalReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalDoCaptureReply:
		((ns2__PayPalDoCaptureReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalEcDoPaymentReply:
		((ns2__PayPalEcDoPaymentReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalEcGetDetailsReply:
		((ns2__PayPalEcGetDetailsReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalEcSetReply:
		((ns2__PayPalEcSetReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply:
		((ns2__PayPalPreapprovedUpdateReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply:
		((ns2__PayPalPreapprovedPaymentReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalButtonCreateReply:
		((ns2__PayPalButtonCreateReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PinlessDebitReversalReply:
		((ns2__PinlessDebitReversalReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PinlessDebitValidateReply:
		((ns2__PinlessDebitValidateReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PinlessDebitReply:
		((ns2__PinlessDebitReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__VoidReply:
		((ns2__VoidReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalCreditReply:
		((ns2__PayPalCreditReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalPaymentReply:
		((ns2__PayPalPaymentReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PaySubscriptionDeleteReply:
		((ns2__PaySubscriptionDeleteReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PaySubscriptionRetrieveReply:
		((ns2__PaySubscriptionRetrieveReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply:
		((ns2__PaySubscriptionEventUpdateReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PaySubscriptionUpdateReply:
		((ns2__PaySubscriptionUpdateReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PaySubscriptionCreateReply:
		((ns2__PaySubscriptionCreateReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DirectDebitRefundReply:
		((ns2__DirectDebitRefundReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DirectDebitValidateReply:
		((ns2__DirectDebitValidateReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DirectDebitReply:
		((ns2__DirectDebitReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__BankTransferRefundReply:
		((ns2__BankTransferRefundReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DirectDebitMandateReply:
		((ns2__DirectDebitMandateReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__BankTransferRealTimeReply:
		((ns2__BankTransferRealTimeReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__BankTransferReply:
		((ns2__BankTransferReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FXRatesReply:
		((ns2__FXRatesReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FXQuote:
		((ns2__FXQuote *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ExportReply:
		((ns2__ExportReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DeniedPartiesMatch:
		((ns2__DeniedPartiesMatch *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DAVReply:
		((ns2__DAVReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AFSReply:
		((ns2__AFSReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DeviceFingerprint:
		((ns2__DeviceFingerprint *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaxReply:
		((ns2__TaxReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaxReplyItem:
		((ns2__TaxReplyItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayerAuthValidateReply:
		((ns2__PayerAuthValidateReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayerAuthEnrollReply:
		((ns2__PayerAuthEnrollReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ECAuthenticateReply:
		((ns2__ECAuthenticateReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ECCreditReply:
		((ns2__ECCreditReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ECDebitReply:
		((ns2__ECDebitReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CCAutoAuthReversalReply:
		((ns2__CCAutoAuthReversalReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CCAuthReversalReply:
		((ns2__CCAuthReversalReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PinDebitReversalReply:
		((ns2__PinDebitReversalReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PinDebitCreditReply:
		((ns2__PinDebitCreditReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PinDebitPurchaseReply:
		((ns2__PinDebitPurchaseReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CCCreditReply:
		((ns2__CCCreditReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ServiceFeeCalculateReply:
		((ns2__ServiceFeeCalculateReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CCCaptureReply:
		((ns2__CCCaptureReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CCIncrementalAuthReply:
		((ns2__CCIncrementalAuthReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CCSaleReversalReply:
		((ns2__CCSaleReversalReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CCSaleCreditReply:
		((ns2__CCSaleCreditReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CCSaleReply:
		((ns2__CCSaleReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__VerificationReply:
		((ns2__VerificationReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__OCTReply:
		((ns2__OCTReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CCAuthReply:
		((ns2__CCAuthReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PromotionGroupReply:
		((ns2__PromotionGroupReply *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PromotionGroup:
		((ns2__PromotionGroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Promotion:
		((ns2__Promotion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DCC:
		((ns2__DCC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DecryptVisaCheckoutDataService:
		((ns2__DecryptVisaCheckoutDataService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__VC:
		((ns2__VC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RequestMessage:
		((ns2__RequestMessage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Sender:
		((ns2__Sender *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Recipient:
		((ns2__Recipient *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalTransactionSearchService:
		((ns2__PayPalTransactionSearchService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalGetTxnDetailsService:
		((ns2__PayPalGetTxnDetailsService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APConfirmPurchaseService:
		((ns2__APConfirmPurchaseService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APTransactionDetailsService:
		((ns2__APTransactionDetailsService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APCheckOutDetailsService:
		((ns2__APCheckOutDetailsService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APSaleService:
		((ns2__APSaleService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APRefundService:
		((ns2__APRefundService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APOptionsService:
		((ns2__APOptionsService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APCaptureService:
		((ns2__APCaptureService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APAuthReversalService:
		((ns2__APAuthReversalService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APAuthService:
		((ns2__APAuthService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APDevice:
		((ns2__APDevice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AP:
		((ns2__AP *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Token:
		((ns2__Token *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__JPO:
		((ns2__JPO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPal:
		((ns2__PayPal *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Batch:
		((ns2__Batch *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DecisionManagerTravelLeg:
		((ns2__DecisionManagerTravelLeg *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DecisionManagerTravelData:
		((ns2__DecisionManagerTravelData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DecisionManager:
		((ns2__DecisionManager *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PaymentNetworkToken:
		((ns2__PaymentNetworkToken *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Subscription:
		((ns2__Subscription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PaySubscriptionEvent:
		((ns2__PaySubscriptionEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RecurringSubscriptionInfo:
		((ns2__RecurringSubscriptionInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__BankInfo:
		((ns2__BankInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FundTransfer:
		((ns2__FundTransfer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__UCAF:
		((ns2__UCAF *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__GECC:
		((ns2__GECC *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FundingTotals:
		((ns2__FundingTotals *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PurchaseTotals:
		((ns2__PurchaseTotals *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Wallet:
		((ns2__Wallet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Aft:
		((ns2__Aft *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__OtherTax:
		((ns2__OtherTax *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__BML:
		((ns2__BML *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Check:
		((ns2__Check *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Card:
		((ns2__Card *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ShipFrom:
		((ns2__ShipFrom *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ShipTo:
		((ns2__ShipTo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__BillTo:
		((ns2__BillTo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__BusinessRules:
		((ns2__BusinessRules *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__InvoiceHeader:
		((ns2__InvoiceHeader *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__EncryptPaymentDataService:
		((ns2__EncryptPaymentDataService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CaseManagementActionService:
		((ns2__CaseManagementActionService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FraudUpdateService:
		((ns2__FraudUpdateService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RiskUpdateService:
		((ns2__RiskUpdateService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APCheckStatusService:
		((ns2__APCheckStatusService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__APInitiateService:
		((ns2__APInitiateService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Address:
		((ns2__Address *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PersonalId:
		((ns2__PersonalId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__BoletoPaymentService:
		((ns2__BoletoPaymentService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ChinaRefundService:
		((ns2__ChinaRefundService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ChinaPaymentService:
		((ns2__ChinaPaymentService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalPreapprovedUpdateService:
		((ns2__PayPalPreapprovedUpdateService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalPreapprovedPaymentService:
		((ns2__PayPalPreapprovedPaymentService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalButtonCreateService:
		((ns2__PayPalButtonCreateService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PinDebitReversalService:
		((ns2__PinDebitReversalService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PinDebitCreditService:
		((ns2__PinDebitCreditService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PinDebitPurchaseService:
		((ns2__PinDebitPurchaseService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PinlessDebitReversalService:
		((ns2__PinlessDebitReversalService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PinlessDebitValidateService:
		((ns2__PinlessDebitValidateService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PinlessDebitService:
		((ns2__PinlessDebitService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__VoidService:
		((ns2__VoidService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalDoRefTransactionService:
		((ns2__PayPalDoRefTransactionService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalCreateAgreementService:
		((ns2__PayPalCreateAgreementService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalUpdateAgreementService:
		((ns2__PayPalUpdateAgreementService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalAuthorizationService:
		((ns2__PayPalAuthorizationService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalEcOrderSetupService:
		((ns2__PayPalEcOrderSetupService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalRefundService:
		((ns2__PayPalRefundService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalAuthReversalService:
		((ns2__PayPalAuthReversalService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalDoCaptureService:
		((ns2__PayPalDoCaptureService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalEcDoPaymentService:
		((ns2__PayPalEcDoPaymentService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalEcGetDetailsService:
		((ns2__PayPalEcGetDetailsService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalEcSetService:
		((ns2__PayPalEcSetService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalCreditService:
		((ns2__PayPalCreditService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayPalPaymentService:
		((ns2__PayPalPaymentService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PaySubscriptionDeleteService:
		((ns2__PaySubscriptionDeleteService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PaySubscriptionRetrieveService:
		((ns2__PaySubscriptionRetrieveService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PaySubscriptionEventUpdateService:
		((ns2__PaySubscriptionEventUpdateService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PaySubscriptionUpdateService:
		((ns2__PaySubscriptionUpdateService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PaySubscriptionCreateService:
		((ns2__PaySubscriptionCreateService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DirectDebitValidateService:
		((ns2__DirectDebitValidateService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DirectDebitRefundService:
		((ns2__DirectDebitRefundService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DirectDebitService:
		((ns2__DirectDebitService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DirectDebitMandateService:
		((ns2__DirectDebitMandateService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__BankTransferRealTimeService:
		((ns2__BankTransferRealTimeService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__BankTransferRefundService:
		((ns2__BankTransferRefundService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__BankTransferService:
		((ns2__BankTransferService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FXRatesService:
		((ns2__FXRatesService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ExportService:
		((ns2__ExportService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DAVService:
		((ns2__DAVService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AFSService:
		((ns2__AFSService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DMEService:
		((ns2__DMEService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TaxService:
		((ns2__TaxService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayerAuthValidateService:
		((ns2__PayerAuthValidateService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayerAuthEnrollService:
		((ns2__PayerAuthEnrollService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ECAuthenticateService:
		((ns2__ECAuthenticateService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ECCreditService:
		((ns2__ECCreditService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ECDebitService:
		((ns2__ECDebitService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ServiceFeeCalculateService:
		((ns2__ServiceFeeCalculateService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CCDCCService:
		((ns2__CCDCCService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CCAutoAuthReversalService:
		((ns2__CCAutoAuthReversalService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CCAuthReversalService:
		((ns2__CCAuthReversalService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CCCreditService:
		((ns2__CCCreditService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CCCaptureService:
		((ns2__CCCaptureService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CCIncrementalAuthService:
		((ns2__CCIncrementalAuthService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CCSaleReversalService:
		((ns2__CCSaleReversalService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CCSaleCreditService:
		((ns2__CCSaleCreditService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CCSaleService:
		((ns2__CCSaleService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__VerificationService:
		((ns2__VerificationService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__OCTService:
		((ns2__OCTService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CCAuthService:
		((ns2__CCAuthService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Item:
		((ns2__Item *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__runTransaction:
		soap_serialize___ns1__runTransaction(soap, (const struct __ns1__runTransaction *)ptr);
		break;
	case SOAP_TYPE___ns1__runTransactionResponse:
		soap_serialize___ns1__runTransactionResponse(soap, (const struct __ns1__runTransactionResponse *)ptr);
		break;
	case SOAP_TYPE__wsse__Security:
		soap_serialize__wsse__Security(soap, (const struct _wsse__Security *)ptr);
		break;
	case SOAP_TYPE___wsc__DerivedKeyTokenType_sequence:
		soap_serialize___wsc__DerivedKeyTokenType_sequence(soap, (const struct __wsc__DerivedKeyTokenType_sequence *)ptr);
		break;
	case SOAP_TYPE_wsc__PropertiesType:
		soap_serialize_wsc__PropertiesType(soap, (const struct wsc__PropertiesType *)ptr);
		break;
	case SOAP_TYPE_wsc__DerivedKeyTokenType:
		soap_serialize_wsc__DerivedKeyTokenType(soap, (const struct wsc__DerivedKeyTokenType *)ptr);
		break;
	case SOAP_TYPE_wsc__SecurityContextTokenType:
		soap_serialize_wsc__SecurityContextTokenType(soap, (const struct wsc__SecurityContextTokenType *)ptr);
		break;
	case SOAP_TYPE___xenc__union_ReferenceList:
		soap_serialize___xenc__union_ReferenceList(soap, (const struct __xenc__union_ReferenceList *)ptr);
		break;
	case SOAP_TYPE__xenc__ReferenceList:
		soap_serialize__xenc__ReferenceList(soap, (const struct _xenc__ReferenceList *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		soap_serialize_xenc__EncryptionPropertyType(soap, (const struct xenc__EncryptionPropertyType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		soap_serialize_xenc__EncryptionPropertiesType(soap, (const struct xenc__EncryptionPropertiesType *)ptr);
		break;
	case SOAP_TYPE_xenc__ReferenceType:
		soap_serialize_xenc__ReferenceType(soap, (const struct xenc__ReferenceType *)ptr);
		break;
	case SOAP_TYPE_xenc__AgreementMethodType:
		soap_serialize_xenc__AgreementMethodType(soap, (const struct xenc__AgreementMethodType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptedKeyType:
		soap_serialize_xenc__EncryptedKeyType(soap, (const struct xenc__EncryptedKeyType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptedDataType:
		soap_serialize_xenc__EncryptedDataType(soap, (const struct xenc__EncryptedDataType *)ptr);
		break;
	case SOAP_TYPE_xenc__TransformsType:
		soap_serialize_xenc__TransformsType(soap, (const struct xenc__TransformsType *)ptr);
		break;
	case SOAP_TYPE_xenc__CipherReferenceType:
		soap_serialize_xenc__CipherReferenceType(soap, (const struct xenc__CipherReferenceType *)ptr);
		break;
	case SOAP_TYPE_xenc__CipherDataType:
		soap_serialize_xenc__CipherDataType(soap, (const struct xenc__CipherDataType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptionMethodType:
		soap_serialize_xenc__EncryptionMethodType(soap, (const struct xenc__EncryptionMethodType *)ptr);
		break;
	case SOAP_TYPE_xenc__EncryptedType:
		soap_serialize_xenc__EncryptedType(soap, (const struct xenc__EncryptedType *)ptr);
		break;
	case SOAP_TYPE_ds__RSAKeyValueType:
		soap_serialize_ds__RSAKeyValueType(soap, (const struct ds__RSAKeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__DSAKeyValueType:
		soap_serialize_ds__DSAKeyValueType(soap, (const struct ds__DSAKeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__X509IssuerSerialType:
		soap_serialize_ds__X509IssuerSerialType(soap, (const struct ds__X509IssuerSerialType *)ptr);
		break;
	case SOAP_TYPE__ds__KeyInfo:
		soap_serialize__ds__KeyInfo(soap, (const struct ds__KeyInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__RetrievalMethodType:
		soap_serialize_ds__RetrievalMethodType(soap, (const struct ds__RetrievalMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__KeyValueType:
		soap_serialize_ds__KeyValueType(soap, (const struct ds__KeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__DigestMethodType:
		soap_serialize_ds__DigestMethodType(soap, (const struct ds__DigestMethodType *)ptr);
		break;
	case SOAP_TYPE__ds__Transform:
		soap_serialize__ds__Transform(soap, (const struct ds__TransformType *)ptr);
		break;
	case SOAP_TYPE_ds__TransformType:
		soap_serialize_ds__TransformType(soap, (const struct ds__TransformType *)ptr);
		break;
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		soap_serialize__c14n__InclusiveNamespaces(soap, (const struct _c14n__InclusiveNamespaces *)ptr);
		break;
	case SOAP_TYPE_ds__TransformsType:
		soap_serialize_ds__TransformsType(soap, (const struct ds__TransformsType *)ptr);
		break;
	case SOAP_TYPE_ds__ReferenceType:
		soap_serialize_ds__ReferenceType(soap, (const struct ds__ReferenceType *)ptr);
		break;
	case SOAP_TYPE_ds__SignatureMethodType:
		soap_serialize_ds__SignatureMethodType(soap, (const struct ds__SignatureMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		soap_serialize_ds__CanonicalizationMethodType(soap, (const struct ds__CanonicalizationMethodType *)ptr);
		break;
	case SOAP_TYPE__ds__Signature:
		soap_serialize__ds__Signature(soap, (const struct ds__SignatureType *)ptr);
		break;
	case SOAP_TYPE_ds__KeyInfoType:
		soap_serialize_ds__KeyInfoType(soap, (const struct ds__KeyInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__SignedInfoType:
		soap_serialize_ds__SignedInfoType(soap, (const struct ds__SignedInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__SignatureType:
		soap_serialize_ds__SignatureType(soap, (const struct ds__SignatureType *)ptr);
		break;
	case SOAP_TYPE_ds__X509DataType:
		soap_serialize_ds__X509DataType(soap, (const struct ds__X509DataType *)ptr);
		break;
	case SOAP_TYPE__wsse__SecurityTokenReference:
		soap_serialize__wsse__SecurityTokenReference(soap, (const struct _wsse__SecurityTokenReference *)ptr);
		break;
	case SOAP_TYPE__wsse__KeyIdentifier:
		soap_serialize__wsse__KeyIdentifier(soap, (const struct _wsse__KeyIdentifier *)ptr);
		break;
	case SOAP_TYPE__wsse__Embedded:
		soap_serialize__wsse__Embedded(soap, (const struct _wsse__Embedded *)ptr);
		break;
	case SOAP_TYPE__wsse__Reference:
		soap_serialize__wsse__Reference(soap, (const struct _wsse__Reference *)ptr);
		break;
	case SOAP_TYPE__wsse__BinarySecurityToken:
		soap_serialize__wsse__BinarySecurityToken(soap, (const struct _wsse__BinarySecurityToken *)ptr);
		break;
	case SOAP_TYPE__wsse__Password:
		soap_serialize__wsse__Password(soap, (const struct _wsse__Password *)ptr);
		break;
	case SOAP_TYPE__wsse__UsernameToken:
		soap_serialize__wsse__UsernameToken(soap, (const struct _wsse__UsernameToken *)ptr);
		break;
	case SOAP_TYPE_wsse__EncodedString:
		soap_serialize_wsse__EncodedString(soap, (const struct wsse__EncodedString *)ptr);
		break;
	case SOAP_TYPE__wsu__Timestamp:
		soap_serialize__wsu__Timestamp(soap, (const struct _wsu__Timestamp *)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VCCustomData:
		soap_serialize_PointerTons2__VCCustomData(soap, (ns2__VCCustomData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VCCardArt:
		soap_serialize_PointerTons2__VCCardArt(soap, (ns2__VCCardArt *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PaypalTransaction:
		soap_serialize_PointerTons2__PaypalTransaction(soap, (ns2__PaypalTransaction *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MDDField:
		soap_serialize_PointerTons2__MDDField(soap, (ns2__MDDField *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Service:
		soap_serialize_PointerTons2__Service(soap, (ns2__Service *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Leg:
		soap_serialize_PointerTons2__Leg(soap, (ns2__Leg *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ReplyReserved:
		soap_serialize_PointerTons2__ReplyReserved(soap, (ns2__ReplyReserved *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Token:
		soap_serialize_PointerTons2__Token(soap, (ns2__Token *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BinLookupReply:
		soap_serialize_PointerTons2__BinLookupReply(soap, (ns2__BinLookupReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DecryptVisaCheckoutDataReply:
		soap_serialize_PointerTons2__DecryptVisaCheckoutDataReply(soap, (ns2__DecryptVisaCheckoutDataReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VCReply:
		soap_serialize_PointerTons2__VCReply(soap, (ns2__VCReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__HostedDataRetrieveReply:
		soap_serialize_PointerTons2__HostedDataRetrieveReply(soap, (ns2__HostedDataRetrieveReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__HostedDataCreateReply:
		soap_serialize_PointerTons2__HostedDataCreateReply(soap, (ns2__HostedDataCreateReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OriginalTransaction:
		soap_serialize_PointerTons2__OriginalTransaction(soap, (ns2__OriginalTransaction *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__EmvReply:
		soap_serialize_PointerTons2__EmvReply(soap, (ns2__EmvReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalTransactionSearchReply:
		soap_serialize_PointerTons2__PayPalTransactionSearchReply(soap, (ns2__PayPalTransactionSearchReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalGetTxnDetailsReply:
		soap_serialize_PointerTons2__PayPalGetTxnDetailsReply(soap, (ns2__PayPalGetTxnDetailsReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PromotionGroupReply:
		soap_serialize_PointerTons2__PromotionGroupReply(soap, (ns2__PromotionGroupReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Promotion:
		soap_serialize_PointerTons2__Promotion(soap, (ns2__Promotion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APConfirmPurchaseReply:
		soap_serialize_PointerTons2__APConfirmPurchaseReply(soap, (ns2__APConfirmPurchaseReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APTransactionDetailsReply:
		soap_serialize_PointerTons2__APTransactionDetailsReply(soap, (ns2__APTransactionDetailsReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APCheckOutDetailsReply:
		soap_serialize_PointerTons2__APCheckOutDetailsReply(soap, (ns2__APCheckOutDetailsReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APSaleReply:
		soap_serialize_PointerTons2__APSaleReply(soap, (ns2__APSaleReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APRefundReply:
		soap_serialize_PointerTons2__APRefundReply(soap, (ns2__APRefundReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APOptionsReply:
		soap_serialize_PointerTons2__APOptionsReply(soap, (ns2__APOptionsReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APCaptureReply:
		soap_serialize_PointerTons2__APCaptureReply(soap, (ns2__APCaptureReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APAuthReversalReply:
		soap_serialize_PointerTons2__APAuthReversalReply(soap, (ns2__APAuthReversalReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APAuthReply:
		soap_serialize_PointerTons2__APAuthReply(soap, (ns2__APAuthReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APReply:
		soap_serialize_PointerTons2__APReply(soap, (ns2__APReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APCheckStatusReply:
		soap_serialize_PointerTons2__APCheckStatusReply(soap, (ns2__APCheckStatusReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APInitiateReply:
		soap_serialize_PointerTons2__APInitiateReply(soap, (ns2__APInitiateReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PinDebitReversalReply:
		soap_serialize_PointerTons2__PinDebitReversalReply(soap, (ns2__PinDebitReversalReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PinDebitCreditReply:
		soap_serialize_PointerTons2__PinDebitCreditReply(soap, (ns2__PinDebitCreditReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PinDebitPurchaseReply:
		soap_serialize_PointerTons2__PinDebitPurchaseReply(soap, (ns2__PinDebitPurchaseReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BoletoPaymentReply:
		soap_serialize_PointerTons2__BoletoPaymentReply(soap, (ns2__BoletoPaymentReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ChinaRefundReply:
		soap_serialize_PointerTons2__ChinaRefundReply(soap, (ns2__ChinaRefundReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ChinaPaymentReply:
		soap_serialize_PointerTons2__ChinaPaymentReply(soap, (ns2__ChinaPaymentReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalDoRefTransactionReply:
		soap_serialize_PointerTons2__PayPalDoRefTransactionReply(soap, (ns2__PayPalDoRefTransactionReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalCreateAgreementReply:
		soap_serialize_PointerTons2__PayPalCreateAgreementReply(soap, (ns2__PayPalCreateAgreementReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalUpdateAgreementReply:
		soap_serialize_PointerTons2__PayPalUpdateAgreementReply(soap, (ns2__PayPalUpdateAgreementReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalEcOrderSetupReply:
		soap_serialize_PointerTons2__PayPalEcOrderSetupReply(soap, (ns2__PayPalEcOrderSetupReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalAuthorizationReply:
		soap_serialize_PointerTons2__PayPalAuthorizationReply(soap, (ns2__PayPalAuthorizationReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalEcSetReply:
		soap_serialize_PointerTons2__PayPalEcSetReply(soap, (ns2__PayPalEcSetReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalEcGetDetailsReply:
		soap_serialize_PointerTons2__PayPalEcGetDetailsReply(soap, (ns2__PayPalEcGetDetailsReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalEcDoPaymentReply:
		soap_serialize_PointerTons2__PayPalEcDoPaymentReply(soap, (ns2__PayPalEcDoPaymentReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalDoCaptureReply:
		soap_serialize_PointerTons2__PayPalDoCaptureReply(soap, (ns2__PayPalDoCaptureReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalAuthReversalReply:
		soap_serialize_PointerTons2__PayPalAuthReversalReply(soap, (ns2__PayPalAuthReversalReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalRefundReply:
		soap_serialize_PointerTons2__PayPalRefundReply(soap, (ns2__PayPalRefundReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DecisionReply:
		soap_serialize_PointerTons2__DecisionReply(soap, (ns2__DecisionReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CaseManagementActionReply:
		soap_serialize_PointerTons2__CaseManagementActionReply(soap, (ns2__CaseManagementActionReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FraudUpdateReply:
		soap_serialize_PointerTons2__FraudUpdateReply(soap, (ns2__FraudUpdateReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RiskUpdateReply:
		soap_serialize_PointerTons2__RiskUpdateReply(soap, (ns2__RiskUpdateReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalPreapprovedUpdateReply:
		soap_serialize_PointerTons2__PayPalPreapprovedUpdateReply(soap, (ns2__PayPalPreapprovedUpdateReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalPreapprovedPaymentReply:
		soap_serialize_PointerTons2__PayPalPreapprovedPaymentReply(soap, (ns2__PayPalPreapprovedPaymentReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalButtonCreateReply:
		soap_serialize_PointerTons2__PayPalButtonCreateReply(soap, (ns2__PayPalButtonCreateReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PinlessDebitReversalReply:
		soap_serialize_PointerTons2__PinlessDebitReversalReply(soap, (ns2__PinlessDebitReversalReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PinlessDebitValidateReply:
		soap_serialize_PointerTons2__PinlessDebitValidateReply(soap, (ns2__PinlessDebitValidateReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PinlessDebitReply:
		soap_serialize_PointerTons2__PinlessDebitReply(soap, (ns2__PinlessDebitReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VoidReply:
		soap_serialize_PointerTons2__VoidReply(soap, (ns2__VoidReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalCreditReply:
		soap_serialize_PointerTons2__PayPalCreditReply(soap, (ns2__PayPalCreditReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalPaymentReply:
		soap_serialize_PointerTons2__PayPalPaymentReply(soap, (ns2__PayPalPaymentReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PaySubscriptionDeleteReply:
		soap_serialize_PointerTons2__PaySubscriptionDeleteReply(soap, (ns2__PaySubscriptionDeleteReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PaySubscriptionRetrieveReply:
		soap_serialize_PointerTons2__PaySubscriptionRetrieveReply(soap, (ns2__PaySubscriptionRetrieveReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PaySubscriptionEventUpdateReply:
		soap_serialize_PointerTons2__PaySubscriptionEventUpdateReply(soap, (ns2__PaySubscriptionEventUpdateReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PaySubscriptionUpdateReply:
		soap_serialize_PointerTons2__PaySubscriptionUpdateReply(soap, (ns2__PaySubscriptionUpdateReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PaySubscriptionCreateReply:
		soap_serialize_PointerTons2__PaySubscriptionCreateReply(soap, (ns2__PaySubscriptionCreateReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DirectDebitRefundReply:
		soap_serialize_PointerTons2__DirectDebitRefundReply(soap, (ns2__DirectDebitRefundReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DirectDebitValidateReply:
		soap_serialize_PointerTons2__DirectDebitValidateReply(soap, (ns2__DirectDebitValidateReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DirectDebitReply:
		soap_serialize_PointerTons2__DirectDebitReply(soap, (ns2__DirectDebitReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DirectDebitMandateReply:
		soap_serialize_PointerTons2__DirectDebitMandateReply(soap, (ns2__DirectDebitMandateReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BankTransferRealTimeReply:
		soap_serialize_PointerTons2__BankTransferRealTimeReply(soap, (ns2__BankTransferRealTimeReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BankTransferRefundReply:
		soap_serialize_PointerTons2__BankTransferRefundReply(soap, (ns2__BankTransferRefundReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BankTransferReply:
		soap_serialize_PointerTons2__BankTransferReply(soap, (ns2__BankTransferReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FXRatesReply:
		soap_serialize_PointerTons2__FXRatesReply(soap, (ns2__FXRatesReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ExportReply:
		soap_serialize_PointerTons2__ExportReply(soap, (ns2__ExportReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DAVReply:
		soap_serialize_PointerTons2__DAVReply(soap, (ns2__DAVReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AFSReply:
		soap_serialize_PointerTons2__AFSReply(soap, (ns2__AFSReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DMEReply:
		soap_serialize_PointerTons2__DMEReply(soap, (ns2__DMEReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__EncryptPaymentDataReply:
		soap_serialize_PointerTons2__EncryptPaymentDataReply(soap, (ns2__EncryptPaymentDataReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaxReply:
		soap_serialize_PointerTons2__TaxReply(soap, (ns2__TaxReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayerAuthValidateReply:
		soap_serialize_PointerTons2__PayerAuthValidateReply(soap, (ns2__PayerAuthValidateReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayerAuthEnrollReply:
		soap_serialize_PointerTons2__PayerAuthEnrollReply(soap, (ns2__PayerAuthEnrollReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ECAuthenticateReply:
		soap_serialize_PointerTons2__ECAuthenticateReply(soap, (ns2__ECAuthenticateReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ECCreditReply:
		soap_serialize_PointerTons2__ECCreditReply(soap, (ns2__ECCreditReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ECDebitReply:
		soap_serialize_PointerTons2__ECDebitReply(soap, (ns2__ECDebitReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CCDCCUpdateReply:
		soap_serialize_PointerTons2__CCDCCUpdateReply(soap, (ns2__CCDCCUpdateReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CCDCCReply:
		soap_serialize_PointerTons2__CCDCCReply(soap, (ns2__CCDCCReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CCAutoAuthReversalReply:
		soap_serialize_PointerTons2__CCAutoAuthReversalReply(soap, (ns2__CCAutoAuthReversalReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CCAuthReversalReply:
		soap_serialize_PointerTons2__CCAuthReversalReply(soap, (ns2__CCAuthReversalReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CCCreditReply:
		soap_serialize_PointerTons2__CCCreditReply(soap, (ns2__CCCreditReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CCCaptureReply:
		soap_serialize_PointerTons2__CCCaptureReply(soap, (ns2__CCCaptureReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ServiceFeeCalculateReply:
		soap_serialize_PointerTons2__ServiceFeeCalculateReply(soap, (ns2__ServiceFeeCalculateReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CCIncrementalAuthReply:
		soap_serialize_PointerTons2__CCIncrementalAuthReply(soap, (ns2__CCIncrementalAuthReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CCSaleReversalReply:
		soap_serialize_PointerTons2__CCSaleReversalReply(soap, (ns2__CCSaleReversalReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CCSaleCreditReply:
		soap_serialize_PointerTons2__CCSaleCreditReply(soap, (ns2__CCSaleCreditReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CCSaleReply:
		soap_serialize_PointerTons2__CCSaleReply(soap, (ns2__CCSaleReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VerificationReply:
		soap_serialize_PointerTons2__VerificationReply(soap, (ns2__VerificationReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OCTReply:
		soap_serialize_PointerTons2__OCTReply(soap, (ns2__OCTReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CCAuthReply:
		soap_serialize_PointerTons2__CCAuthReply(soap, (ns2__CCAuthReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DeniedPartiesMatch:
		soap_serialize_PointerTons2__DeniedPartiesMatch(soap, (ns2__DeniedPartiesMatch *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APOptionsOption:
		soap_serialize_PointerTons2__APOptionsOption(soap, (ns2__APOptionsOption *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RuleResultItems:
		soap_serialize_PointerTons2__RuleResultItems(soap, (ns2__RuleResultItems *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Field:
		soap_serialize_PointerTons2__Field(soap, (ns2__Field *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AdditionalFields:
		soap_serialize_PointerTons2__AdditionalFields(soap, (ns2__AdditionalFields *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ProfileReply:
		soap_serialize_PointerTons2__ProfileReply(soap, (ns2__ProfileReply *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RuleResultItem:
		soap_serialize_PointerTons2__RuleResultItem(soap, (ns2__RuleResultItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FXQuote:
		soap_serialize_PointerTons2__FXQuote(soap, (ns2__FXQuote *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DeviceFingerprint:
		soap_serialize_PointerTons2__DeviceFingerprint(soap, (ns2__DeviceFingerprint *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaxReplyItem:
		soap_serialize_PointerTons2__TaxReplyItem(soap, (ns2__TaxReplyItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__issuer:
		soap_serialize_PointerTons2__issuer(soap, (ns2__issuer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BinLookupService:
		soap_serialize_PointerTons2__BinLookupService(soap, (ns2__BinLookupService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__EncryptPaymentDataService:
		soap_serialize_PointerTons2__EncryptPaymentDataService(soap, (ns2__EncryptPaymentDataService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Aft:
		soap_serialize_PointerTons2__Aft(soap, (ns2__Aft *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Wallet:
		soap_serialize_PointerTons2__Wallet(soap, (ns2__Wallet *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PromotionGroup:
		soap_serialize_PointerTons2__PromotionGroup(soap, (ns2__PromotionGroup *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DecryptVisaCheckoutDataService:
		soap_serialize_PointerTons2__DecryptVisaCheckoutDataService(soap, (ns2__DecryptVisaCheckoutDataService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VC:
		soap_serialize_PointerTons2__VC(soap, (ns2__VC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AutoRentalData:
		soap_serialize_PointerTons2__AutoRentalData(soap, (ns2__AutoRentalData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Sender:
		soap_serialize_PointerTons2__Sender(soap, (ns2__Sender *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Recipient:
		soap_serialize_PointerTons2__Recipient(soap, (ns2__Recipient *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PaymentNetworkToken:
		soap_serialize_PointerTons2__PaymentNetworkToken(soap, (ns2__PaymentNetworkToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__HostedDataRetrieveService:
		soap_serialize_PointerTons2__HostedDataRetrieveService(soap, (ns2__HostedDataRetrieveService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__HostedDataCreateService:
		soap_serialize_PointerTons2__HostedDataCreateService(soap, (ns2__HostedDataCreateService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__EmvRequest:
		soap_serialize_PointerTons2__EmvRequest(soap, (ns2__EmvRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CCDCCUpdateService:
		soap_serialize_PointerTons2__CCDCCUpdateService(soap, (ns2__CCDCCUpdateService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalTransactionSearchService:
		soap_serialize_PointerTons2__PayPalTransactionSearchService(soap, (ns2__PayPalTransactionSearchService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalGetTxnDetailsService:
		soap_serialize_PointerTons2__PayPalGetTxnDetailsService(soap, (ns2__PayPalGetTxnDetailsService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APConfirmPurchaseService:
		soap_serialize_PointerTons2__APConfirmPurchaseService(soap, (ns2__APConfirmPurchaseService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APTransactionDetailsService:
		soap_serialize_PointerTons2__APTransactionDetailsService(soap, (ns2__APTransactionDetailsService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APCheckOutDetailsService:
		soap_serialize_PointerTons2__APCheckOutDetailsService(soap, (ns2__APCheckOutDetailsService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APSaleService:
		soap_serialize_PointerTons2__APSaleService(soap, (ns2__APSaleService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APRefundService:
		soap_serialize_PointerTons2__APRefundService(soap, (ns2__APRefundService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APOptionsService:
		soap_serialize_PointerTons2__APOptionsService(soap, (ns2__APOptionsService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APCaptureService:
		soap_serialize_PointerTons2__APCaptureService(soap, (ns2__APCaptureService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APAuthReversalService:
		soap_serialize_PointerTons2__APAuthReversalService(soap, (ns2__APAuthReversalService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APAuthService:
		soap_serialize_PointerTons2__APAuthService(soap, (ns2__APAuthService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AP:
		soap_serialize_PointerTons2__AP(soap, (ns2__AP *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PinDebitReversalService:
		soap_serialize_PointerTons2__PinDebitReversalService(soap, (ns2__PinDebitReversalService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PinDebitCreditService:
		soap_serialize_PointerTons2__PinDebitCreditService(soap, (ns2__PinDebitCreditService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PinDebitPurchaseService:
		soap_serialize_PointerTons2__PinDebitPurchaseService(soap, (ns2__PinDebitPurchaseService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APCheckStatusService:
		soap_serialize_PointerTons2__APCheckStatusService(soap, (ns2__APCheckStatusService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APInitiateService:
		soap_serialize_PointerTons2__APInitiateService(soap, (ns2__APInitiateService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BoletoPaymentService:
		soap_serialize_PointerTons2__BoletoPaymentService(soap, (ns2__BoletoPaymentService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ChinaRefundService:
		soap_serialize_PointerTons2__ChinaRefundService(soap, (ns2__ChinaRefundService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ChinaPaymentService:
		soap_serialize_PointerTons2__ChinaPaymentService(soap, (ns2__ChinaPaymentService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalDoRefTransactionService:
		soap_serialize_PointerTons2__PayPalDoRefTransactionService(soap, (ns2__PayPalDoRefTransactionService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalCreateAgreementService:
		soap_serialize_PointerTons2__PayPalCreateAgreementService(soap, (ns2__PayPalCreateAgreementService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalUpdateAgreementService:
		soap_serialize_PointerTons2__PayPalUpdateAgreementService(soap, (ns2__PayPalUpdateAgreementService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalAuthorizationService:
		soap_serialize_PointerTons2__PayPalAuthorizationService(soap, (ns2__PayPalAuthorizationService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalEcOrderSetupService:
		soap_serialize_PointerTons2__PayPalEcOrderSetupService(soap, (ns2__PayPalEcOrderSetupService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalEcSetService:
		soap_serialize_PointerTons2__PayPalEcSetService(soap, (ns2__PayPalEcSetService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalEcGetDetailsService:
		soap_serialize_PointerTons2__PayPalEcGetDetailsService(soap, (ns2__PayPalEcGetDetailsService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalEcDoPaymentService:
		soap_serialize_PointerTons2__PayPalEcDoPaymentService(soap, (ns2__PayPalEcDoPaymentService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalDoCaptureService:
		soap_serialize_PointerTons2__PayPalDoCaptureService(soap, (ns2__PayPalDoCaptureService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalAuthReversalService:
		soap_serialize_PointerTons2__PayPalAuthReversalService(soap, (ns2__PayPalAuthReversalService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalRefundService:
		soap_serialize_PointerTons2__PayPalRefundService(soap, (ns2__PayPalRefundService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RequestReserved:
		soap_serialize_PointerTons2__RequestReserved(soap, (ns2__RequestReserved *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CaseManagementActionService:
		soap_serialize_PointerTons2__CaseManagementActionService(soap, (ns2__CaseManagementActionService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FraudUpdateService:
		soap_serialize_PointerTons2__FraudUpdateService(soap, (ns2__FraudUpdateService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RiskUpdateService:
		soap_serialize_PointerTons2__RiskUpdateService(soap, (ns2__RiskUpdateService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalPreapprovedUpdateService:
		soap_serialize_PointerTons2__PayPalPreapprovedUpdateService(soap, (ns2__PayPalPreapprovedUpdateService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalPreapprovedPaymentService:
		soap_serialize_PointerTons2__PayPalPreapprovedPaymentService(soap, (ns2__PayPalPreapprovedPaymentService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalButtonCreateService:
		soap_serialize_PointerTons2__PayPalButtonCreateService(soap, (ns2__PayPalButtonCreateService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__LodgingData:
		soap_serialize_PointerTons2__LodgingData(soap, (ns2__LodgingData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AncillaryData:
		soap_serialize_PointerTons2__AncillaryData(soap, (ns2__AncillaryData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AirlineData:
		soap_serialize_PointerTons2__AirlineData(soap, (ns2__AirlineData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Batch:
		soap_serialize_PointerTons2__Batch(soap, (ns2__Batch *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PinlessDebitReversalService:
		soap_serialize_PointerTons2__PinlessDebitReversalService(soap, (ns2__PinlessDebitReversalService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PinlessDebitValidateService:
		soap_serialize_PointerTons2__PinlessDebitValidateService(soap, (ns2__PinlessDebitValidateService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PinlessDebitService:
		soap_serialize_PointerTons2__PinlessDebitService(soap, (ns2__PinlessDebitService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BusinessRules:
		soap_serialize_PointerTons2__BusinessRules(soap, (ns2__BusinessRules *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VoidService:
		soap_serialize_PointerTons2__VoidService(soap, (ns2__VoidService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalCreditService:
		soap_serialize_PointerTons2__PayPalCreditService(soap, (ns2__PayPalCreditService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPalPaymentService:
		soap_serialize_PointerTons2__PayPalPaymentService(soap, (ns2__PayPalPaymentService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PaySubscriptionDeleteService:
		soap_serialize_PointerTons2__PaySubscriptionDeleteService(soap, (ns2__PaySubscriptionDeleteService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PaySubscriptionRetrieveService:
		soap_serialize_PointerTons2__PaySubscriptionRetrieveService(soap, (ns2__PaySubscriptionRetrieveService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PaySubscriptionEventUpdateService:
		soap_serialize_PointerTons2__PaySubscriptionEventUpdateService(soap, (ns2__PaySubscriptionEventUpdateService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PaySubscriptionUpdateService:
		soap_serialize_PointerTons2__PaySubscriptionUpdateService(soap, (ns2__PaySubscriptionUpdateService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PaySubscriptionCreateService:
		soap_serialize_PointerTons2__PaySubscriptionCreateService(soap, (ns2__PaySubscriptionCreateService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DirectDebitValidateService:
		soap_serialize_PointerTons2__DirectDebitValidateService(soap, (ns2__DirectDebitValidateService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DirectDebitRefundService:
		soap_serialize_PointerTons2__DirectDebitRefundService(soap, (ns2__DirectDebitRefundService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DirectDebitService:
		soap_serialize_PointerTons2__DirectDebitService(soap, (ns2__DirectDebitService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DirectDebitMandateService:
		soap_serialize_PointerTons2__DirectDebitMandateService(soap, (ns2__DirectDebitMandateService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BankTransferRealTimeService:
		soap_serialize_PointerTons2__BankTransferRealTimeService(soap, (ns2__BankTransferRealTimeService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BankTransferRefundService:
		soap_serialize_PointerTons2__BankTransferRefundService(soap, (ns2__BankTransferRefundService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BankTransferService:
		soap_serialize_PointerTons2__BankTransferService(soap, (ns2__BankTransferService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FXRatesService:
		soap_serialize_PointerTons2__FXRatesService(soap, (ns2__FXRatesService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ExportService:
		soap_serialize_PointerTons2__ExportService(soap, (ns2__ExportService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DAVService:
		soap_serialize_PointerTons2__DAVService(soap, (ns2__DAVService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AFSService:
		soap_serialize_PointerTons2__AFSService(soap, (ns2__AFSService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DMEService:
		soap_serialize_PointerTons2__DMEService(soap, (ns2__DMEService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TaxService:
		soap_serialize_PointerTons2__TaxService(soap, (ns2__TaxService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayerAuthValidateService:
		soap_serialize_PointerTons2__PayerAuthValidateService(soap, (ns2__PayerAuthValidateService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayerAuthEnrollService:
		soap_serialize_PointerTons2__PayerAuthEnrollService(soap, (ns2__PayerAuthEnrollService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ECAuthenticateService:
		soap_serialize_PointerTons2__ECAuthenticateService(soap, (ns2__ECAuthenticateService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ECCreditService:
		soap_serialize_PointerTons2__ECCreditService(soap, (ns2__ECCreditService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ECDebitService:
		soap_serialize_PointerTons2__ECDebitService(soap, (ns2__ECDebitService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ServiceFeeCalculateService:
		soap_serialize_PointerTons2__ServiceFeeCalculateService(soap, (ns2__ServiceFeeCalculateService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CCDCCService:
		soap_serialize_PointerTons2__CCDCCService(soap, (ns2__CCDCCService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CCAutoAuthReversalService:
		soap_serialize_PointerTons2__CCAutoAuthReversalService(soap, (ns2__CCAutoAuthReversalService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CCAuthReversalService:
		soap_serialize_PointerTons2__CCAuthReversalService(soap, (ns2__CCAuthReversalService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CCCreditService:
		soap_serialize_PointerTons2__CCCreditService(soap, (ns2__CCCreditService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CCCaptureService:
		soap_serialize_PointerTons2__CCCaptureService(soap, (ns2__CCCaptureService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CCIncrementalAuthService:
		soap_serialize_PointerTons2__CCIncrementalAuthService(soap, (ns2__CCIncrementalAuthService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CCSaleReversalService:
		soap_serialize_PointerTons2__CCSaleReversalService(soap, (ns2__CCSaleReversalService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CCSaleCreditService:
		soap_serialize_PointerTons2__CCSaleCreditService(soap, (ns2__CCSaleCreditService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CCSaleService:
		soap_serialize_PointerTons2__CCSaleService(soap, (ns2__CCSaleService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__VerificationService:
		soap_serialize_PointerTons2__VerificationService(soap, (ns2__VerificationService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OCTService:
		soap_serialize_PointerTons2__OCTService(soap, (ns2__OCTService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CCAuthService:
		soap_serialize_PointerTons2__CCAuthService(soap, (ns2__CCAuthService *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ServiceFee:
		soap_serialize_PointerTons2__ServiceFee(soap, (ns2__ServiceFee *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__JPO:
		soap_serialize_PointerTons2__JPO(soap, (ns2__JPO *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MerchantSecureData:
		soap_serialize_PointerTons2__MerchantSecureData(soap, (ns2__MerchantSecureData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MerchantDefinedData:
		soap_serialize_PointerTons2__MerchantDefinedData(soap, (ns2__MerchantDefinedData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayPal:
		soap_serialize_PointerTons2__PayPal(soap, (ns2__PayPal *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OtherTax:
		soap_serialize_PointerTons2__OtherTax(soap, (ns2__OtherTax *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DecisionManager:
		soap_serialize_PointerTons2__DecisionManager(soap, (ns2__DecisionManager *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RecurringSubscriptionInfo:
		soap_serialize_PointerTons2__RecurringSubscriptionInfo(soap, (ns2__RecurringSubscriptionInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Subscription:
		soap_serialize_PointerTons2__Subscription(soap, (ns2__Subscription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BankInfo:
		soap_serialize_PointerTons2__BankInfo(soap, (ns2__BankInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FundTransfer:
		soap_serialize_PointerTons2__FundTransfer(soap, (ns2__FundTransfer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__UCAF:
		soap_serialize_PointerTons2__UCAF(soap, (ns2__UCAF *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__GECC:
		soap_serialize_PointerTons2__GECC(soap, (ns2__GECC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BML:
		soap_serialize_PointerTons2__BML(soap, (ns2__BML *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Check:
		soap_serialize_PointerTons2__Check(soap, (ns2__Check *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Card:
		soap_serialize_PointerTons2__Card(soap, (ns2__Card *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Installment:
		soap_serialize_PointerTons2__Installment(soap, (ns2__Installment *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__EncryptedPayment:
		soap_serialize_PointerTons2__EncryptedPayment(soap, (ns2__EncryptedPayment *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Pos:
		soap_serialize_PointerTons2__Pos(soap, (ns2__Pos *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DCC:
		soap_serialize_PointerTons2__DCC(soap, (ns2__DCC *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FundingTotals:
		soap_serialize_PointerTons2__FundingTotals(soap, (ns2__FundingTotals *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PurchaseTotals:
		soap_serialize_PointerTons2__PurchaseTotals(soap, (ns2__PurchaseTotals *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Item:
		soap_serialize_PointerTons2__Item(soap, (ns2__Item *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ShipFrom:
		soap_serialize_PointerTons2__ShipFrom(soap, (ns2__ShipFrom *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PersonalId:
		soap_serialize_PointerTons2__PersonalId(soap, (ns2__PersonalId *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ShipTo:
		soap_serialize_PointerTons2__ShipTo(soap, (ns2__ShipTo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__BillTo:
		soap_serialize_PointerTons2__BillTo(soap, (ns2__BillTo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__InvoiceHeader:
		soap_serialize_PointerTons2__InvoiceHeader(soap, (ns2__InvoiceHeader *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__APDevice:
		soap_serialize_PointerTons2__APDevice(soap, (ns2__APDevice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DecisionManagerTravelLeg:
		soap_serialize_PointerTons2__DecisionManagerTravelLeg(soap, (ns2__DecisionManagerTravelLeg *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DecisionManagerTravelData:
		soap_serialize_PointerTons2__DecisionManagerTravelData(soap, (ns2__DecisionManagerTravelData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PaySubscriptionEvent:
		soap_serialize_PointerTons2__PaySubscriptionEvent(soap, (ns2__PaySubscriptionEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Address:
		soap_serialize_PointerTons2__Address(soap, (ns2__Address *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__dateTime:
		soap_serialize_PointerTons2__dateTime(soap, (wchar_t **const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__integer:
		soap_serialize_PointerToxsd__integer(soap, (wchar_t **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__boolean:
		soap_serialize_PointerTons2__boolean(soap, (wchar_t **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__amount:
		soap_serialize_PointerTons2__amount(soap, (wchar_t **const*)ptr);
		break;
	case SOAP_TYPE_ns2__dateTime:
		soap_serialize_wstring(soap, (wchar_t*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_ns2__boolean:
		soap_serialize_wstring(soap, (wchar_t*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_ns2__amount:
		soap_serialize_wstring(soap, (wchar_t*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_xsd__integer:
		soap_serialize_wstring(soap, (wchar_t*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_wstring:
		soap_serialize_wstring(soap, (wchar_t*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Security:
		soap_serialize_PointerTo_wsse__Security(soap, (struct _wsse__Security *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignatureType:
		soap_serialize_PointerTods__SignatureType(soap, (struct ds__SignatureType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsc__SecurityContextTokenType:
		soap_serialize_PointerTowsc__SecurityContextTokenType(soap, (struct wsc__SecurityContextTokenType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptedKeyType:
		soap_serialize_PointerToxenc__EncryptedKeyType(soap, (struct xenc__EncryptedKeyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, (struct _wsse__BinarySecurityToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		soap_serialize_PointerTo_wsse__UsernameToken(soap, (struct _wsse__UsernameToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		soap_serialize_PointerTo_wsu__Timestamp(soap, (struct _wsu__Timestamp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__wsc__DerivedKeyTokenType_sequence:
		soap_serialize_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, (struct __wsc__DerivedKeyTokenType_sequence *const*)ptr);
		break;
	case SOAP_TYPE_PointerToULONG64:
		soap_serialize_PointerToULONG64(soap, (ULONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsc__PropertiesType:
		soap_serialize_PointerTowsc__PropertiesType(soap, (struct wsc__PropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_wsc__FaultCodeOpenEnumType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTo_xenc__ReferenceList:
		soap_serialize_PointerTo_xenc__ReferenceList(soap, (struct _xenc__ReferenceList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__xenc__union_ReferenceList:
		soap_serialize_PointerTo__xenc__union_ReferenceList(soap, (struct __xenc__union_ReferenceList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__ReferenceType:
		soap_serialize_PointerToxenc__ReferenceType(soap, (struct xenc__ReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptionPropertyType:
		soap_serialize_PointerToxenc__EncryptionPropertyType(soap, (struct xenc__EncryptionPropertyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__TransformsType:
		soap_serialize_PointerToxenc__TransformsType(soap, (struct xenc__TransformsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__CipherReferenceType:
		soap_serialize_PointerToxenc__CipherReferenceType(soap, (struct xenc__CipherReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptionPropertiesType:
		soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, (struct xenc__EncryptionPropertiesType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__CipherDataType:
		soap_serialize_PointerToxenc__CipherDataType(soap, (struct xenc__CipherDataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ds__KeyInfo:
		soap_serialize_PointerTo_ds__KeyInfo(soap, (struct ds__KeyInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxenc__EncryptionMethodType:
		soap_serialize_PointerToxenc__EncryptionMethodType(soap, (struct xenc__EncryptionMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		soap_serialize_PointerTods__X509IssuerSerialType(soap, (struct ds__X509IssuerSerialType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		soap_serialize_PointerTods__RSAKeyValueType(soap, (struct ds__RSAKeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		soap_serialize_PointerTods__DSAKeyValueType(soap, (struct ds__DSAKeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__TransformType:
		soap_serialize_PointerTods__TransformType(soap, (struct ds__TransformType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__DigestMethodType:
		soap_serialize_PointerTods__DigestMethodType(soap, (struct ds__DigestMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__TransformsType:
		soap_serialize_PointerTods__TransformsType(soap, (struct ds__TransformsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		soap_serialize_PointerToPointerTods__ReferenceType(soap, (struct ds__ReferenceType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__ReferenceType:
		soap_serialize_PointerTods__ReferenceType(soap, (struct ds__ReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		soap_serialize_PointerTods__SignatureMethodType(soap, (struct ds__SignatureMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		soap_serialize_PointerTods__CanonicalizationMethodType(soap, (struct ds__CanonicalizationMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, (struct _wsse__SecurityTokenReference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		soap_serialize_PointerTods__RetrievalMethodType(soap, (struct ds__RetrievalMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__KeyValueType:
		soap_serialize_PointerTods__KeyValueType(soap, (struct ds__KeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, (struct _c14n__InclusiveNamespaces *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__KeyInfoType:
		soap_serialize_PointerTods__KeyInfoType(soap, (struct ds__KeyInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignedInfoType:
		soap_serialize_PointerTods__SignedInfoType(soap, (struct ds__SignedInfoType *const*)ptr);
		break;
	case SOAP_TYPE__ds__SignatureValue:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTods__X509DataType:
		soap_serialize_PointerTods__X509DataType(soap, (struct ds__X509DataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		soap_serialize_PointerTo_wsse__Embedded(soap, (struct _wsse__Embedded *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		soap_serialize_PointerTo_wsse__KeyIdentifier(soap, (struct _wsse__KeyIdentifier *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Reference:
		soap_serialize_PointerTo_wsse__Reference(soap, (struct _wsse__Reference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsse__EncodedString:
		soap_serialize_PointerTowsse__EncodedString(soap, (struct wsse__EncodedString *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Password:
		soap_serialize_PointerTo_wsse__Password(soap, (struct _wsse__Password *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE__wsu__Timestamp:
		return (void*)soap_instantiate__wsu__Timestamp(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsse__EncodedString:
		return (void*)soap_instantiate_wsse__EncodedString(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__UsernameToken:
		return (void*)soap_instantiate__wsse__UsernameToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__BinarySecurityToken:
		return (void*)soap_instantiate__wsse__BinarySecurityToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Reference:
		return (void*)soap_instantiate__wsse__Reference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Embedded:
		return (void*)soap_instantiate__wsse__Embedded(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__KeyIdentifier:
		return (void*)soap_instantiate__wsse__KeyIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__SecurityTokenReference:
		return (void*)soap_instantiate__wsse__SecurityTokenReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__SignatureType:
		return (void*)soap_instantiate_ds__SignatureType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		return (void*)soap_instantiate__c14n__InclusiveNamespaces(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__TransformType:
		return (void*)soap_instantiate_ds__TransformType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__KeyInfoType:
		return (void*)soap_instantiate_ds__KeyInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__SignedInfoType:
		return (void*)soap_instantiate_ds__SignedInfoType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return (void*)soap_instantiate_ds__CanonicalizationMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__SignatureMethodType:
		return (void*)soap_instantiate_ds__SignatureMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__ReferenceType:
		return (void*)soap_instantiate_ds__ReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__TransformsType:
		return (void*)soap_instantiate_ds__TransformsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__DigestMethodType:
		return (void*)soap_instantiate_ds__DigestMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__KeyValueType:
		return (void*)soap_instantiate_ds__KeyValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__RetrievalMethodType:
		return (void*)soap_instantiate_ds__RetrievalMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__X509DataType:
		return (void*)soap_instantiate_ds__X509DataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return (void*)soap_instantiate_ds__X509IssuerSerialType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__DSAKeyValueType:
		return (void*)soap_instantiate_ds__DSAKeyValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ds__RSAKeyValueType:
		return (void*)soap_instantiate_ds__RSAKeyValueType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		return (void*)soap_instantiate_xenc__EncryptionPropertyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__EncryptedType:
		return (void*)soap_instantiate_xenc__EncryptedType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__EncryptionMethodType:
		return (void*)soap_instantiate_xenc__EncryptionMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__CipherDataType:
		return (void*)soap_instantiate_xenc__CipherDataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__CipherReferenceType:
		return (void*)soap_instantiate_xenc__CipherReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__TransformsType:
		return (void*)soap_instantiate_xenc__TransformsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__AgreementMethodType:
		return (void*)soap_instantiate_xenc__AgreementMethodType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__ReferenceType:
		return (void*)soap_instantiate_xenc__ReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		return (void*)soap_instantiate_xenc__EncryptionPropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___xenc__union_ReferenceList:
		return (void*)soap_instantiate___xenc__union_ReferenceList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__xenc__ReferenceList:
		return (void*)soap_instantiate__xenc__ReferenceList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__EncryptedDataType:
		return (void*)soap_instantiate_xenc__EncryptedDataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xenc__EncryptedKeyType:
		return (void*)soap_instantiate_xenc__EncryptedKeyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsc__SecurityContextTokenType:
		return (void*)soap_instantiate_wsc__SecurityContextTokenType(soap, -1, type, arrayType, n);
	case SOAP_TYPE___wsc__DerivedKeyTokenType_sequence:
		return (void*)soap_instantiate___wsc__DerivedKeyTokenType_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsc__DerivedKeyTokenType:
		return (void*)soap_instantiate_wsc__DerivedKeyTokenType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsc__PropertiesType:
		return (void*)soap_instantiate_wsc__PropertiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Security:
		return (void*)soap_instantiate__wsse__Security(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsse__Password:
		return (void*)soap_instantiate__wsse__Password(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_ns2__Item:
		return (void*)soap_instantiate_ns2__Item(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CCAuthService:
		return (void*)soap_instantiate_ns2__CCAuthService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__OCTService:
		return (void*)soap_instantiate_ns2__OCTService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__VerificationService:
		return (void*)soap_instantiate_ns2__VerificationService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CCSaleService:
		return (void*)soap_instantiate_ns2__CCSaleService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CCSaleCreditService:
		return (void*)soap_instantiate_ns2__CCSaleCreditService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CCSaleReversalService:
		return (void*)soap_instantiate_ns2__CCSaleReversalService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CCIncrementalAuthService:
		return (void*)soap_instantiate_ns2__CCIncrementalAuthService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CCCaptureService:
		return (void*)soap_instantiate_ns2__CCCaptureService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CCCreditService:
		return (void*)soap_instantiate_ns2__CCCreditService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CCAuthReversalService:
		return (void*)soap_instantiate_ns2__CCAuthReversalService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CCAutoAuthReversalService:
		return (void*)soap_instantiate_ns2__CCAutoAuthReversalService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CCDCCService:
		return (void*)soap_instantiate_ns2__CCDCCService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ServiceFeeCalculateService:
		return (void*)soap_instantiate_ns2__ServiceFeeCalculateService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ECDebitService:
		return (void*)soap_instantiate_ns2__ECDebitService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ECCreditService:
		return (void*)soap_instantiate_ns2__ECCreditService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ECAuthenticateService:
		return (void*)soap_instantiate_ns2__ECAuthenticateService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayerAuthEnrollService:
		return (void*)soap_instantiate_ns2__PayerAuthEnrollService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayerAuthValidateService:
		return (void*)soap_instantiate_ns2__PayerAuthValidateService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaxService:
		return (void*)soap_instantiate_ns2__TaxService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DMEService:
		return (void*)soap_instantiate_ns2__DMEService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AFSService:
		return (void*)soap_instantiate_ns2__AFSService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DAVService:
		return (void*)soap_instantiate_ns2__DAVService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ExportService:
		return (void*)soap_instantiate_ns2__ExportService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FXRatesService:
		return (void*)soap_instantiate_ns2__FXRatesService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__BankTransferService:
		return (void*)soap_instantiate_ns2__BankTransferService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__BankTransferRefundService:
		return (void*)soap_instantiate_ns2__BankTransferRefundService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__BankTransferRealTimeService:
		return (void*)soap_instantiate_ns2__BankTransferRealTimeService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DirectDebitMandateService:
		return (void*)soap_instantiate_ns2__DirectDebitMandateService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DirectDebitService:
		return (void*)soap_instantiate_ns2__DirectDebitService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DirectDebitRefundService:
		return (void*)soap_instantiate_ns2__DirectDebitRefundService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DirectDebitValidateService:
		return (void*)soap_instantiate_ns2__DirectDebitValidateService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PaySubscriptionCreateService:
		return (void*)soap_instantiate_ns2__PaySubscriptionCreateService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PaySubscriptionUpdateService:
		return (void*)soap_instantiate_ns2__PaySubscriptionUpdateService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PaySubscriptionEventUpdateService:
		return (void*)soap_instantiate_ns2__PaySubscriptionEventUpdateService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PaySubscriptionRetrieveService:
		return (void*)soap_instantiate_ns2__PaySubscriptionRetrieveService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PaySubscriptionDeleteService:
		return (void*)soap_instantiate_ns2__PaySubscriptionDeleteService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalPaymentService:
		return (void*)soap_instantiate_ns2__PayPalPaymentService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalCreditService:
		return (void*)soap_instantiate_ns2__PayPalCreditService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalEcSetService:
		return (void*)soap_instantiate_ns2__PayPalEcSetService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalEcGetDetailsService:
		return (void*)soap_instantiate_ns2__PayPalEcGetDetailsService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalEcDoPaymentService:
		return (void*)soap_instantiate_ns2__PayPalEcDoPaymentService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalDoCaptureService:
		return (void*)soap_instantiate_ns2__PayPalDoCaptureService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalAuthReversalService:
		return (void*)soap_instantiate_ns2__PayPalAuthReversalService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalRefundService:
		return (void*)soap_instantiate_ns2__PayPalRefundService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalEcOrderSetupService:
		return (void*)soap_instantiate_ns2__PayPalEcOrderSetupService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalAuthorizationService:
		return (void*)soap_instantiate_ns2__PayPalAuthorizationService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalUpdateAgreementService:
		return (void*)soap_instantiate_ns2__PayPalUpdateAgreementService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalCreateAgreementService:
		return (void*)soap_instantiate_ns2__PayPalCreateAgreementService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalDoRefTransactionService:
		return (void*)soap_instantiate_ns2__PayPalDoRefTransactionService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__VoidService:
		return (void*)soap_instantiate_ns2__VoidService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PinlessDebitService:
		return (void*)soap_instantiate_ns2__PinlessDebitService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PinlessDebitValidateService:
		return (void*)soap_instantiate_ns2__PinlessDebitValidateService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PinlessDebitReversalService:
		return (void*)soap_instantiate_ns2__PinlessDebitReversalService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PinDebitPurchaseService:
		return (void*)soap_instantiate_ns2__PinDebitPurchaseService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PinDebitCreditService:
		return (void*)soap_instantiate_ns2__PinDebitCreditService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PinDebitReversalService:
		return (void*)soap_instantiate_ns2__PinDebitReversalService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalButtonCreateService:
		return (void*)soap_instantiate_ns2__PayPalButtonCreateService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalPreapprovedPaymentService:
		return (void*)soap_instantiate_ns2__PayPalPreapprovedPaymentService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalPreapprovedUpdateService:
		return (void*)soap_instantiate_ns2__PayPalPreapprovedUpdateService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ChinaPaymentService:
		return (void*)soap_instantiate_ns2__ChinaPaymentService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ChinaRefundService:
		return (void*)soap_instantiate_ns2__ChinaRefundService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__BoletoPaymentService:
		return (void*)soap_instantiate_ns2__BoletoPaymentService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PersonalId:
		return (void*)soap_instantiate_ns2__PersonalId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Address:
		return (void*)soap_instantiate_ns2__Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APInitiateService:
		return (void*)soap_instantiate_ns2__APInitiateService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APCheckStatusService:
		return (void*)soap_instantiate_ns2__APCheckStatusService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RiskUpdateService:
		return (void*)soap_instantiate_ns2__RiskUpdateService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FraudUpdateService:
		return (void*)soap_instantiate_ns2__FraudUpdateService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CaseManagementActionService:
		return (void*)soap_instantiate_ns2__CaseManagementActionService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__EncryptPaymentDataService:
		return (void*)soap_instantiate_ns2__EncryptPaymentDataService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__InvoiceHeader:
		return (void*)soap_instantiate_ns2__InvoiceHeader(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__BusinessRules:
		return (void*)soap_instantiate_ns2__BusinessRules(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__BillTo:
		return (void*)soap_instantiate_ns2__BillTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ShipTo:
		return (void*)soap_instantiate_ns2__ShipTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ShipFrom:
		return (void*)soap_instantiate_ns2__ShipFrom(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Card:
		return (void*)soap_instantiate_ns2__Card(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Check:
		return (void*)soap_instantiate_ns2__Check(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__BML:
		return (void*)soap_instantiate_ns2__BML(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__OtherTax:
		return (void*)soap_instantiate_ns2__OtherTax(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Aft:
		return (void*)soap_instantiate_ns2__Aft(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Wallet:
		return (void*)soap_instantiate_ns2__Wallet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PurchaseTotals:
		return (void*)soap_instantiate_ns2__PurchaseTotals(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FundingTotals:
		return (void*)soap_instantiate_ns2__FundingTotals(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__GECC:
		return (void*)soap_instantiate_ns2__GECC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__UCAF:
		return (void*)soap_instantiate_ns2__UCAF(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FundTransfer:
		return (void*)soap_instantiate_ns2__FundTransfer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__BankInfo:
		return (void*)soap_instantiate_ns2__BankInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RecurringSubscriptionInfo:
		return (void*)soap_instantiate_ns2__RecurringSubscriptionInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PaySubscriptionEvent:
		return (void*)soap_instantiate_ns2__PaySubscriptionEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Subscription:
		return (void*)soap_instantiate_ns2__Subscription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PaymentNetworkToken:
		return (void*)soap_instantiate_ns2__PaymentNetworkToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DecisionManager:
		return (void*)soap_instantiate_ns2__DecisionManager(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DecisionManagerTravelData:
		return (void*)soap_instantiate_ns2__DecisionManagerTravelData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DecisionManagerTravelLeg:
		return (void*)soap_instantiate_ns2__DecisionManagerTravelLeg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Batch:
		return (void*)soap_instantiate_ns2__Batch(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPal:
		return (void*)soap_instantiate_ns2__PayPal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__JPO:
		return (void*)soap_instantiate_ns2__JPO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Token:
		return (void*)soap_instantiate_ns2__Token(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AP:
		return (void*)soap_instantiate_ns2__AP(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APDevice:
		return (void*)soap_instantiate_ns2__APDevice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APAuthService:
		return (void*)soap_instantiate_ns2__APAuthService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APAuthReversalService:
		return (void*)soap_instantiate_ns2__APAuthReversalService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APCaptureService:
		return (void*)soap_instantiate_ns2__APCaptureService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APOptionsService:
		return (void*)soap_instantiate_ns2__APOptionsService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APRefundService:
		return (void*)soap_instantiate_ns2__APRefundService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APSaleService:
		return (void*)soap_instantiate_ns2__APSaleService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APCheckOutDetailsService:
		return (void*)soap_instantiate_ns2__APCheckOutDetailsService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APTransactionDetailsService:
		return (void*)soap_instantiate_ns2__APTransactionDetailsService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APConfirmPurchaseService:
		return (void*)soap_instantiate_ns2__APConfirmPurchaseService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalGetTxnDetailsService:
		return (void*)soap_instantiate_ns2__PayPalGetTxnDetailsService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalTransactionSearchService:
		return (void*)soap_instantiate_ns2__PayPalTransactionSearchService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Recipient:
		return (void*)soap_instantiate_ns2__Recipient(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Sender:
		return (void*)soap_instantiate_ns2__Sender(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RequestMessage:
		return (void*)soap_instantiate_ns2__RequestMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__VC:
		return (void*)soap_instantiate_ns2__VC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DecryptVisaCheckoutDataService:
		return (void*)soap_instantiate_ns2__DecryptVisaCheckoutDataService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DCC:
		return (void*)soap_instantiate_ns2__DCC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Promotion:
		return (void*)soap_instantiate_ns2__Promotion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PromotionGroup:
		return (void*)soap_instantiate_ns2__PromotionGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PromotionGroupReply:
		return (void*)soap_instantiate_ns2__PromotionGroupReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CCAuthReply:
		return (void*)soap_instantiate_ns2__CCAuthReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__OCTReply:
		return (void*)soap_instantiate_ns2__OCTReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__VerificationReply:
		return (void*)soap_instantiate_ns2__VerificationReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CCSaleReply:
		return (void*)soap_instantiate_ns2__CCSaleReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CCSaleCreditReply:
		return (void*)soap_instantiate_ns2__CCSaleCreditReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CCSaleReversalReply:
		return (void*)soap_instantiate_ns2__CCSaleReversalReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CCIncrementalAuthReply:
		return (void*)soap_instantiate_ns2__CCIncrementalAuthReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CCCaptureReply:
		return (void*)soap_instantiate_ns2__CCCaptureReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ServiceFeeCalculateReply:
		return (void*)soap_instantiate_ns2__ServiceFeeCalculateReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CCCreditReply:
		return (void*)soap_instantiate_ns2__CCCreditReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PinDebitPurchaseReply:
		return (void*)soap_instantiate_ns2__PinDebitPurchaseReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PinDebitCreditReply:
		return (void*)soap_instantiate_ns2__PinDebitCreditReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PinDebitReversalReply:
		return (void*)soap_instantiate_ns2__PinDebitReversalReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CCAuthReversalReply:
		return (void*)soap_instantiate_ns2__CCAuthReversalReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CCAutoAuthReversalReply:
		return (void*)soap_instantiate_ns2__CCAutoAuthReversalReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ECDebitReply:
		return (void*)soap_instantiate_ns2__ECDebitReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ECCreditReply:
		return (void*)soap_instantiate_ns2__ECCreditReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ECAuthenticateReply:
		return (void*)soap_instantiate_ns2__ECAuthenticateReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayerAuthEnrollReply:
		return (void*)soap_instantiate_ns2__PayerAuthEnrollReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayerAuthValidateReply:
		return (void*)soap_instantiate_ns2__PayerAuthValidateReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaxReplyItem:
		return (void*)soap_instantiate_ns2__TaxReplyItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TaxReply:
		return (void*)soap_instantiate_ns2__TaxReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DeviceFingerprint:
		return (void*)soap_instantiate_ns2__DeviceFingerprint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AFSReply:
		return (void*)soap_instantiate_ns2__AFSReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DAVReply:
		return (void*)soap_instantiate_ns2__DAVReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DeniedPartiesMatch:
		return (void*)soap_instantiate_ns2__DeniedPartiesMatch(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ExportReply:
		return (void*)soap_instantiate_ns2__ExportReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FXQuote:
		return (void*)soap_instantiate_ns2__FXQuote(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FXRatesReply:
		return (void*)soap_instantiate_ns2__FXRatesReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__BankTransferReply:
		return (void*)soap_instantiate_ns2__BankTransferReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__BankTransferRealTimeReply:
		return (void*)soap_instantiate_ns2__BankTransferRealTimeReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DirectDebitMandateReply:
		return (void*)soap_instantiate_ns2__DirectDebitMandateReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__BankTransferRefundReply:
		return (void*)soap_instantiate_ns2__BankTransferRefundReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DirectDebitReply:
		return (void*)soap_instantiate_ns2__DirectDebitReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DirectDebitValidateReply:
		return (void*)soap_instantiate_ns2__DirectDebitValidateReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DirectDebitRefundReply:
		return (void*)soap_instantiate_ns2__DirectDebitRefundReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PaySubscriptionCreateReply:
		return (void*)soap_instantiate_ns2__PaySubscriptionCreateReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PaySubscriptionUpdateReply:
		return (void*)soap_instantiate_ns2__PaySubscriptionUpdateReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply:
		return (void*)soap_instantiate_ns2__PaySubscriptionEventUpdateReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PaySubscriptionRetrieveReply:
		return (void*)soap_instantiate_ns2__PaySubscriptionRetrieveReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PaySubscriptionDeleteReply:
		return (void*)soap_instantiate_ns2__PaySubscriptionDeleteReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalPaymentReply:
		return (void*)soap_instantiate_ns2__PayPalPaymentReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalCreditReply:
		return (void*)soap_instantiate_ns2__PayPalCreditReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__VoidReply:
		return (void*)soap_instantiate_ns2__VoidReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PinlessDebitReply:
		return (void*)soap_instantiate_ns2__PinlessDebitReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PinlessDebitValidateReply:
		return (void*)soap_instantiate_ns2__PinlessDebitValidateReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PinlessDebitReversalReply:
		return (void*)soap_instantiate_ns2__PinlessDebitReversalReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalButtonCreateReply:
		return (void*)soap_instantiate_ns2__PayPalButtonCreateReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply:
		return (void*)soap_instantiate_ns2__PayPalPreapprovedPaymentReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply:
		return (void*)soap_instantiate_ns2__PayPalPreapprovedUpdateReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalEcSetReply:
		return (void*)soap_instantiate_ns2__PayPalEcSetReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalEcGetDetailsReply:
		return (void*)soap_instantiate_ns2__PayPalEcGetDetailsReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalEcDoPaymentReply:
		return (void*)soap_instantiate_ns2__PayPalEcDoPaymentReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalDoCaptureReply:
		return (void*)soap_instantiate_ns2__PayPalDoCaptureReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalAuthReversalReply:
		return (void*)soap_instantiate_ns2__PayPalAuthReversalReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalRefundReply:
		return (void*)soap_instantiate_ns2__PayPalRefundReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalEcOrderSetupReply:
		return (void*)soap_instantiate_ns2__PayPalEcOrderSetupReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalAuthorizationReply:
		return (void*)soap_instantiate_ns2__PayPalAuthorizationReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalUpdateAgreementReply:
		return (void*)soap_instantiate_ns2__PayPalUpdateAgreementReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalCreateAgreementReply:
		return (void*)soap_instantiate_ns2__PayPalCreateAgreementReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalDoRefTransactionReply:
		return (void*)soap_instantiate_ns2__PayPalDoRefTransactionReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RiskUpdateReply:
		return (void*)soap_instantiate_ns2__RiskUpdateReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FraudUpdateReply:
		return (void*)soap_instantiate_ns2__FraudUpdateReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CaseManagementActionReply:
		return (void*)soap_instantiate_ns2__CaseManagementActionReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RuleResultItem:
		return (void*)soap_instantiate_ns2__RuleResultItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RuleResultItems:
		return (void*)soap_instantiate_ns2__RuleResultItems(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DecisionReply:
		return (void*)soap_instantiate_ns2__DecisionReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AdditionalFields:
		return (void*)soap_instantiate_ns2__AdditionalFields(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Field:
		return (void*)soap_instantiate_ns2__Field(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DMEReply:
		return (void*)soap_instantiate_ns2__DMEReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ProfileReply:
		return (void*)soap_instantiate_ns2__ProfileReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CCDCCReply:
		return (void*)soap_instantiate_ns2__CCDCCReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CCDCCUpdateReply:
		return (void*)soap_instantiate_ns2__CCDCCUpdateReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ChinaPaymentReply:
		return (void*)soap_instantiate_ns2__ChinaPaymentReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ChinaRefundReply:
		return (void*)soap_instantiate_ns2__ChinaRefundReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__BoletoPaymentReply:
		return (void*)soap_instantiate_ns2__BoletoPaymentReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APInitiateReply:
		return (void*)soap_instantiate_ns2__APInitiateReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APCheckStatusReply:
		return (void*)soap_instantiate_ns2__APCheckStatusReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APReply:
		return (void*)soap_instantiate_ns2__APReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APAuthReply:
		return (void*)soap_instantiate_ns2__APAuthReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APAuthReversalReply:
		return (void*)soap_instantiate_ns2__APAuthReversalReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APCaptureReply:
		return (void*)soap_instantiate_ns2__APCaptureReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APOptionsReply:
		return (void*)soap_instantiate_ns2__APOptionsReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APOptionsOption:
		return (void*)soap_instantiate_ns2__APOptionsOption(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APRefundReply:
		return (void*)soap_instantiate_ns2__APRefundReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APSaleReply:
		return (void*)soap_instantiate_ns2__APSaleReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APCheckOutDetailsReply:
		return (void*)soap_instantiate_ns2__APCheckOutDetailsReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APTransactionDetailsReply:
		return (void*)soap_instantiate_ns2__APTransactionDetailsReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__APConfirmPurchaseReply:
		return (void*)soap_instantiate_ns2__APConfirmPurchaseReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ReplyMessage:
		return (void*)soap_instantiate_ns2__ReplyMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FaultDetails:
		return (void*)soap_instantiate_ns2__FaultDetails(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AirlineData:
		return (void*)soap_instantiate_ns2__AirlineData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Leg:
		return (void*)soap_instantiate_ns2__Leg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AncillaryData:
		return (void*)soap_instantiate_ns2__AncillaryData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Service:
		return (void*)soap_instantiate_ns2__Service(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__LodgingData:
		return (void*)soap_instantiate_ns2__LodgingData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Pos:
		return (void*)soap_instantiate_ns2__Pos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__EncryptedPayment:
		return (void*)soap_instantiate_ns2__EncryptedPayment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Installment:
		return (void*)soap_instantiate_ns2__Installment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MerchantDefinedData:
		return (void*)soap_instantiate_ns2__MerchantDefinedData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MerchantSecureData:
		return (void*)soap_instantiate_ns2__MerchantSecureData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ReplyReserved:
		return (void*)soap_instantiate_ns2__ReplyReserved(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RequestReserved:
		return (void*)soap_instantiate_ns2__RequestReserved(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalGetTxnDetailsReply:
		return (void*)soap_instantiate_ns2__PayPalGetTxnDetailsReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PayPalTransactionSearchReply:
		return (void*)soap_instantiate_ns2__PayPalTransactionSearchReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PaypalTransaction:
		return (void*)soap_instantiate_ns2__PaypalTransaction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CCDCCUpdateService:
		return (void*)soap_instantiate_ns2__CCDCCUpdateService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ServiceFee:
		return (void*)soap_instantiate_ns2__ServiceFee(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__EmvRequest:
		return (void*)soap_instantiate_ns2__EmvRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__EmvReply:
		return (void*)soap_instantiate_ns2__EmvReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__OriginalTransaction:
		return (void*)soap_instantiate_ns2__OriginalTransaction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__HostedDataCreateService:
		return (void*)soap_instantiate_ns2__HostedDataCreateService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__HostedDataRetrieveService:
		return (void*)soap_instantiate_ns2__HostedDataRetrieveService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__HostedDataCreateReply:
		return (void*)soap_instantiate_ns2__HostedDataCreateReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__HostedDataRetrieveReply:
		return (void*)soap_instantiate_ns2__HostedDataRetrieveReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AutoRentalData:
		return (void*)soap_instantiate_ns2__AutoRentalData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__VCReply:
		return (void*)soap_instantiate_ns2__VCReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__VCCardArt:
		return (void*)soap_instantiate_ns2__VCCardArt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__VCCustomData:
		return (void*)soap_instantiate_ns2__VCCustomData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply:
		return (void*)soap_instantiate_ns2__DecryptVisaCheckoutDataReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__EncryptPaymentDataReply:
		return (void*)soap_instantiate_ns2__EncryptPaymentDataReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__BinLookupService:
		return (void*)soap_instantiate_ns2__BinLookupService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__BinLookupReply:
		return (void*)soap_instantiate_ns2__BinLookupReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__issuer:
		return (void*)soap_instantiate_ns2__issuer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MDDField:
		return (void*)soap_instantiate_ns2__MDDField(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__runTransactionResponse:
		return (void*)soap_instantiate___ns1__runTransactionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__runTransaction:
		return (void*)soap_instantiate___ns1__runTransaction(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE__ds__Signature:
		return (void*)soap_instantiate__ds__Signature(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ds__Transform:
		return (void*)soap_instantiate__ds__Transform(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ds__KeyInfo:
		return (void*)soap_instantiate__ds__KeyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__PaypalTransaction:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__PaypalTransaction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MDDField:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__MDDField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Service:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__Service(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Leg:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__Leg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__PromotionGroupReply:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__PromotionGroupReply(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__DeniedPartiesMatch:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__DeniedPartiesMatch(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Field:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__Field(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__RuleResultItem:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__RuleResultItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__FXQuote:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__FXQuote(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__TaxReplyItem:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__TaxReplyItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__PromotionGroup:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__PromotionGroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__RequestReserved:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__RequestReserved(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Item:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__Item(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		return (void*)soap_instantiate_std__vectorTemplateOf_XML(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__DecisionManagerTravelLeg:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__DecisionManagerTravelLeg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfwstring:
		return (void*)soap_instantiate_std__vectorTemplateOfwstring(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE__wsu__Timestamp:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct _wsu__Timestamp*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct _wsu__Timestamp*>(p->ptr));
		break;
	case SOAP_TYPE_wsse__EncodedString:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct wsse__EncodedString*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct wsse__EncodedString*>(p->ptr));
		break;
	case SOAP_TYPE__wsse__UsernameToken:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct _wsse__UsernameToken*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct _wsse__UsernameToken*>(p->ptr));
		break;
	case SOAP_TYPE__wsse__BinarySecurityToken:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct _wsse__BinarySecurityToken*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct _wsse__BinarySecurityToken*>(p->ptr));
		break;
	case SOAP_TYPE__wsse__Reference:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct _wsse__Reference*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct _wsse__Reference*>(p->ptr));
		break;
	case SOAP_TYPE__wsse__Embedded:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct _wsse__Embedded*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct _wsse__Embedded*>(p->ptr));
		break;
	case SOAP_TYPE__wsse__KeyIdentifier:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct _wsse__KeyIdentifier*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct _wsse__KeyIdentifier*>(p->ptr));
		break;
	case SOAP_TYPE__wsse__SecurityTokenReference:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct _wsse__SecurityTokenReference*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct _wsse__SecurityTokenReference*>(p->ptr));
		break;
	case SOAP_TYPE_ds__SignatureType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ds__SignatureType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ds__SignatureType*>(p->ptr));
		break;
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct _c14n__InclusiveNamespaces*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct _c14n__InclusiveNamespaces*>(p->ptr));
		break;
	case SOAP_TYPE_ds__TransformType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ds__TransformType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ds__TransformType*>(p->ptr));
		break;
	case SOAP_TYPE_ds__KeyInfoType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ds__KeyInfoType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ds__KeyInfoType*>(p->ptr));
		break;
	case SOAP_TYPE_ds__SignedInfoType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ds__SignedInfoType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ds__SignedInfoType*>(p->ptr));
		break;
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ds__CanonicalizationMethodType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ds__CanonicalizationMethodType*>(p->ptr));
		break;
	case SOAP_TYPE_ds__SignatureMethodType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ds__SignatureMethodType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ds__SignatureMethodType*>(p->ptr));
		break;
	case SOAP_TYPE_ds__ReferenceType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ds__ReferenceType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ds__ReferenceType*>(p->ptr));
		break;
	case SOAP_TYPE_ds__TransformsType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ds__TransformsType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ds__TransformsType*>(p->ptr));
		break;
	case SOAP_TYPE_ds__DigestMethodType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ds__DigestMethodType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ds__DigestMethodType*>(p->ptr));
		break;
	case SOAP_TYPE_ds__KeyValueType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ds__KeyValueType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ds__KeyValueType*>(p->ptr));
		break;
	case SOAP_TYPE_ds__RetrievalMethodType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ds__RetrievalMethodType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ds__RetrievalMethodType*>(p->ptr));
		break;
	case SOAP_TYPE_ds__X509DataType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ds__X509DataType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ds__X509DataType*>(p->ptr));
		break;
	case SOAP_TYPE_ds__X509IssuerSerialType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ds__X509IssuerSerialType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ds__X509IssuerSerialType*>(p->ptr));
		break;
	case SOAP_TYPE_ds__DSAKeyValueType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ds__DSAKeyValueType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ds__DSAKeyValueType*>(p->ptr));
		break;
	case SOAP_TYPE_ds__RSAKeyValueType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ds__RSAKeyValueType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ds__RSAKeyValueType*>(p->ptr));
		break;
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct xenc__EncryptionPropertyType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct xenc__EncryptionPropertyType*>(p->ptr));
		break;
	case SOAP_TYPE_xenc__EncryptedType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct xenc__EncryptedType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct xenc__EncryptedType*>(p->ptr));
		break;
	case SOAP_TYPE_xenc__EncryptionMethodType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct xenc__EncryptionMethodType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct xenc__EncryptionMethodType*>(p->ptr));
		break;
	case SOAP_TYPE_xenc__CipherDataType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct xenc__CipherDataType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct xenc__CipherDataType*>(p->ptr));
		break;
	case SOAP_TYPE_xenc__CipherReferenceType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct xenc__CipherReferenceType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct xenc__CipherReferenceType*>(p->ptr));
		break;
	case SOAP_TYPE_xenc__TransformsType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct xenc__TransformsType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct xenc__TransformsType*>(p->ptr));
		break;
	case SOAP_TYPE_xenc__AgreementMethodType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct xenc__AgreementMethodType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct xenc__AgreementMethodType*>(p->ptr));
		break;
	case SOAP_TYPE_xenc__ReferenceType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct xenc__ReferenceType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct xenc__ReferenceType*>(p->ptr));
		break;
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct xenc__EncryptionPropertiesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct xenc__EncryptionPropertiesType*>(p->ptr));
		break;
	case SOAP_TYPE___xenc__union_ReferenceList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __xenc__union_ReferenceList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __xenc__union_ReferenceList*>(p->ptr));
		break;
	case SOAP_TYPE__xenc__ReferenceList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct _xenc__ReferenceList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct _xenc__ReferenceList*>(p->ptr));
		break;
	case SOAP_TYPE_xenc__EncryptedDataType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct xenc__EncryptedDataType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct xenc__EncryptedDataType*>(p->ptr));
		break;
	case SOAP_TYPE_xenc__EncryptedKeyType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct xenc__EncryptedKeyType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct xenc__EncryptedKeyType*>(p->ptr));
		break;
	case SOAP_TYPE_wsc__SecurityContextTokenType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct wsc__SecurityContextTokenType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct wsc__SecurityContextTokenType*>(p->ptr));
		break;
	case SOAP_TYPE___wsc__DerivedKeyTokenType_sequence:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __wsc__DerivedKeyTokenType_sequence*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __wsc__DerivedKeyTokenType_sequence*>(p->ptr));
		break;
	case SOAP_TYPE_wsc__DerivedKeyTokenType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct wsc__DerivedKeyTokenType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct wsc__DerivedKeyTokenType*>(p->ptr));
		break;
	case SOAP_TYPE_wsc__PropertiesType:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct wsc__PropertiesType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct wsc__PropertiesType*>(p->ptr));
		break;
	case SOAP_TYPE__wsse__Security:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct _wsse__Security*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct _wsse__Security*>(p->ptr));
		break;
	case SOAP_TYPE__wsse__Password:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct _wsse__Password*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct _wsse__Password*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		break;
#endif
	case SOAP_TYPE_ns2__Item:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Item*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Item*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CCAuthService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CCAuthService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CCAuthService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__OCTService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__OCTService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__OCTService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__VerificationService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__VerificationService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__VerificationService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CCSaleService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CCSaleService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CCSaleService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CCSaleCreditService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CCSaleCreditService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CCSaleCreditService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CCSaleReversalService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CCSaleReversalService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CCSaleReversalService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CCIncrementalAuthService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CCIncrementalAuthService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CCIncrementalAuthService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CCCaptureService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CCCaptureService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CCCaptureService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CCCreditService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CCCreditService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CCCreditService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CCAuthReversalService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CCAuthReversalService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CCAuthReversalService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CCAutoAuthReversalService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CCAutoAuthReversalService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CCAutoAuthReversalService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CCDCCService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CCDCCService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CCDCCService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ServiceFeeCalculateService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ServiceFeeCalculateService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ServiceFeeCalculateService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ECDebitService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ECDebitService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ECDebitService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ECCreditService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ECCreditService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ECCreditService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ECAuthenticateService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ECAuthenticateService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ECAuthenticateService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayerAuthEnrollService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayerAuthEnrollService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayerAuthEnrollService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayerAuthValidateService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayerAuthValidateService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayerAuthValidateService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaxService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaxService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaxService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DMEService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DMEService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DMEService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__AFSService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__AFSService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__AFSService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DAVService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DAVService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DAVService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ExportService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ExportService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ExportService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__FXRatesService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__FXRatesService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__FXRatesService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__BankTransferService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__BankTransferService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__BankTransferService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__BankTransferRefundService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__BankTransferRefundService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__BankTransferRefundService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__BankTransferRealTimeService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__BankTransferRealTimeService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__BankTransferRealTimeService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DirectDebitMandateService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DirectDebitMandateService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DirectDebitMandateService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DirectDebitService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DirectDebitService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DirectDebitService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DirectDebitRefundService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DirectDebitRefundService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DirectDebitRefundService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DirectDebitValidateService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DirectDebitValidateService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DirectDebitValidateService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PaySubscriptionCreateService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PaySubscriptionCreateService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PaySubscriptionCreateService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PaySubscriptionUpdateService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PaySubscriptionUpdateService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PaySubscriptionUpdateService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PaySubscriptionEventUpdateService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PaySubscriptionEventUpdateService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PaySubscriptionEventUpdateService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PaySubscriptionRetrieveService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PaySubscriptionRetrieveService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PaySubscriptionRetrieveService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PaySubscriptionDeleteService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PaySubscriptionDeleteService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PaySubscriptionDeleteService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalPaymentService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalPaymentService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalPaymentService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalCreditService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalCreditService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalCreditService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalEcSetService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalEcSetService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalEcSetService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalEcGetDetailsService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalEcGetDetailsService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalEcGetDetailsService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalEcDoPaymentService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalEcDoPaymentService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalEcDoPaymentService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalDoCaptureService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalDoCaptureService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalDoCaptureService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalAuthReversalService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalAuthReversalService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalAuthReversalService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalRefundService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalRefundService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalRefundService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalEcOrderSetupService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalEcOrderSetupService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalEcOrderSetupService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalAuthorizationService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalAuthorizationService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalAuthorizationService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalUpdateAgreementService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalUpdateAgreementService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalUpdateAgreementService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalCreateAgreementService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalCreateAgreementService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalCreateAgreementService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalDoRefTransactionService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalDoRefTransactionService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalDoRefTransactionService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__VoidService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__VoidService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__VoidService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PinlessDebitService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PinlessDebitService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PinlessDebitService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PinlessDebitValidateService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PinlessDebitValidateService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PinlessDebitValidateService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PinlessDebitReversalService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PinlessDebitReversalService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PinlessDebitReversalService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PinDebitPurchaseService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PinDebitPurchaseService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PinDebitPurchaseService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PinDebitCreditService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PinDebitCreditService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PinDebitCreditService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PinDebitReversalService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PinDebitReversalService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PinDebitReversalService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalButtonCreateService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalButtonCreateService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalButtonCreateService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalPreapprovedPaymentService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalPreapprovedPaymentService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalPreapprovedPaymentService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalPreapprovedUpdateService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalPreapprovedUpdateService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalPreapprovedUpdateService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ChinaPaymentService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ChinaPaymentService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ChinaPaymentService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ChinaRefundService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ChinaRefundService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ChinaRefundService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__BoletoPaymentService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__BoletoPaymentService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__BoletoPaymentService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PersonalId:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PersonalId*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PersonalId*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Address:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Address*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Address*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APInitiateService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APInitiateService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APInitiateService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APCheckStatusService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APCheckStatusService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APCheckStatusService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__RiskUpdateService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__RiskUpdateService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__RiskUpdateService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__FraudUpdateService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__FraudUpdateService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__FraudUpdateService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CaseManagementActionService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CaseManagementActionService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CaseManagementActionService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__EncryptPaymentDataService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__EncryptPaymentDataService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__EncryptPaymentDataService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__InvoiceHeader:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__InvoiceHeader*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__InvoiceHeader*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__BusinessRules:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__BusinessRules*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__BusinessRules*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__BillTo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__BillTo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__BillTo*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ShipTo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ShipTo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ShipTo*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ShipFrom:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ShipFrom*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ShipFrom*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Card:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Card*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Card*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Check:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Check*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Check*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__BML:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__BML*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__BML*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__OtherTax:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__OtherTax*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__OtherTax*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Aft:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Aft*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Aft*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Wallet:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Wallet*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Wallet*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PurchaseTotals:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PurchaseTotals*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PurchaseTotals*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__FundingTotals:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__FundingTotals*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__FundingTotals*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__GECC:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__GECC*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__GECC*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__UCAF:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__UCAF*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__UCAF*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__FundTransfer:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__FundTransfer*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__FundTransfer*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__BankInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__BankInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__BankInfo*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__RecurringSubscriptionInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__RecurringSubscriptionInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__RecurringSubscriptionInfo*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PaySubscriptionEvent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PaySubscriptionEvent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PaySubscriptionEvent*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Subscription:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Subscription*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Subscription*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PaymentNetworkToken:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PaymentNetworkToken*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PaymentNetworkToken*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DecisionManager:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DecisionManager*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DecisionManager*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DecisionManagerTravelData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DecisionManagerTravelData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DecisionManagerTravelData*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DecisionManagerTravelLeg:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DecisionManagerTravelLeg*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DecisionManagerTravelLeg*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Batch:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Batch*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Batch*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPal:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPal*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPal*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__JPO:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__JPO*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__JPO*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Token:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Token*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Token*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__AP:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__AP*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__AP*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APDevice:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APDevice*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APDevice*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APAuthService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APAuthService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APAuthService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APAuthReversalService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APAuthReversalService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APAuthReversalService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APCaptureService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APCaptureService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APCaptureService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APOptionsService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APOptionsService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APOptionsService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APRefundService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APRefundService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APRefundService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APSaleService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APSaleService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APSaleService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APCheckOutDetailsService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APCheckOutDetailsService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APCheckOutDetailsService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APTransactionDetailsService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APTransactionDetailsService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APTransactionDetailsService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APConfirmPurchaseService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APConfirmPurchaseService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APConfirmPurchaseService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalGetTxnDetailsService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalGetTxnDetailsService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalGetTxnDetailsService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalTransactionSearchService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalTransactionSearchService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalTransactionSearchService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Recipient:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Recipient*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Recipient*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Sender:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Sender*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Sender*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__RequestMessage:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__RequestMessage*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__RequestMessage*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__VC:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__VC*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__VC*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DecryptVisaCheckoutDataService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DecryptVisaCheckoutDataService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DecryptVisaCheckoutDataService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DCC:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DCC*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DCC*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Promotion:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Promotion*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Promotion*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PromotionGroup:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PromotionGroup*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PromotionGroup*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PromotionGroupReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PromotionGroupReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PromotionGroupReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CCAuthReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CCAuthReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CCAuthReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__OCTReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__OCTReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__OCTReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__VerificationReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__VerificationReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__VerificationReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CCSaleReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CCSaleReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CCSaleReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CCSaleCreditReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CCSaleCreditReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CCSaleCreditReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CCSaleReversalReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CCSaleReversalReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CCSaleReversalReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CCIncrementalAuthReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CCIncrementalAuthReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CCIncrementalAuthReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CCCaptureReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CCCaptureReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CCCaptureReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ServiceFeeCalculateReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ServiceFeeCalculateReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ServiceFeeCalculateReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CCCreditReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CCCreditReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CCCreditReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PinDebitPurchaseReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PinDebitPurchaseReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PinDebitPurchaseReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PinDebitCreditReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PinDebitCreditReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PinDebitCreditReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PinDebitReversalReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PinDebitReversalReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PinDebitReversalReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CCAuthReversalReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CCAuthReversalReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CCAuthReversalReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CCAutoAuthReversalReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CCAutoAuthReversalReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CCAutoAuthReversalReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ECDebitReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ECDebitReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ECDebitReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ECCreditReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ECCreditReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ECCreditReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ECAuthenticateReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ECAuthenticateReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ECAuthenticateReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayerAuthEnrollReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayerAuthEnrollReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayerAuthEnrollReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayerAuthValidateReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayerAuthValidateReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayerAuthValidateReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaxReplyItem:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaxReplyItem*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaxReplyItem*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__TaxReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__TaxReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__TaxReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DeviceFingerprint:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DeviceFingerprint*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DeviceFingerprint*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__AFSReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__AFSReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__AFSReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DAVReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DAVReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DAVReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DeniedPartiesMatch:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DeniedPartiesMatch*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DeniedPartiesMatch*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ExportReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ExportReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ExportReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__FXQuote:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__FXQuote*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__FXQuote*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__FXRatesReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__FXRatesReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__FXRatesReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__BankTransferReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__BankTransferReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__BankTransferReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__BankTransferRealTimeReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__BankTransferRealTimeReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__BankTransferRealTimeReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DirectDebitMandateReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DirectDebitMandateReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DirectDebitMandateReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__BankTransferRefundReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__BankTransferRefundReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__BankTransferRefundReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DirectDebitReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DirectDebitReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DirectDebitReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DirectDebitValidateReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DirectDebitValidateReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DirectDebitValidateReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DirectDebitRefundReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DirectDebitRefundReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DirectDebitRefundReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PaySubscriptionCreateReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PaySubscriptionCreateReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PaySubscriptionCreateReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PaySubscriptionUpdateReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PaySubscriptionUpdateReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PaySubscriptionUpdateReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PaySubscriptionEventUpdateReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PaySubscriptionEventUpdateReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PaySubscriptionRetrieveReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PaySubscriptionRetrieveReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PaySubscriptionRetrieveReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PaySubscriptionDeleteReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PaySubscriptionDeleteReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PaySubscriptionDeleteReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalPaymentReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalPaymentReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalPaymentReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalCreditReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalCreditReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalCreditReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__VoidReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__VoidReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__VoidReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PinlessDebitReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PinlessDebitReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PinlessDebitReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PinlessDebitValidateReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PinlessDebitValidateReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PinlessDebitValidateReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PinlessDebitReversalReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PinlessDebitReversalReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PinlessDebitReversalReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalButtonCreateReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalButtonCreateReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalButtonCreateReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalPreapprovedPaymentReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalPreapprovedPaymentReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalPreapprovedUpdateReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalPreapprovedUpdateReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalEcSetReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalEcSetReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalEcSetReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalEcGetDetailsReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalEcGetDetailsReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalEcGetDetailsReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalEcDoPaymentReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalEcDoPaymentReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalEcDoPaymentReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalDoCaptureReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalDoCaptureReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalDoCaptureReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalAuthReversalReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalAuthReversalReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalAuthReversalReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalRefundReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalRefundReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalRefundReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalEcOrderSetupReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalEcOrderSetupReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalEcOrderSetupReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalAuthorizationReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalAuthorizationReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalAuthorizationReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalUpdateAgreementReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalUpdateAgreementReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalUpdateAgreementReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalCreateAgreementReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalCreateAgreementReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalCreateAgreementReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalDoRefTransactionReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalDoRefTransactionReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalDoRefTransactionReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__RiskUpdateReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__RiskUpdateReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__RiskUpdateReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__FraudUpdateReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__FraudUpdateReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__FraudUpdateReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CaseManagementActionReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CaseManagementActionReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CaseManagementActionReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__RuleResultItem:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__RuleResultItem*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__RuleResultItem*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__RuleResultItems:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__RuleResultItems*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__RuleResultItems*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DecisionReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DecisionReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DecisionReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__AdditionalFields:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__AdditionalFields*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__AdditionalFields*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Field:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Field*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Field*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DMEReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DMEReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DMEReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ProfileReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ProfileReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ProfileReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CCDCCReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CCDCCReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CCDCCReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CCDCCUpdateReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CCDCCUpdateReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CCDCCUpdateReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ChinaPaymentReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ChinaPaymentReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ChinaPaymentReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ChinaRefundReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ChinaRefundReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ChinaRefundReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__BoletoPaymentReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__BoletoPaymentReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__BoletoPaymentReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APInitiateReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APInitiateReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APInitiateReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APCheckStatusReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APCheckStatusReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APCheckStatusReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APAuthReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APAuthReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APAuthReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APAuthReversalReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APAuthReversalReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APAuthReversalReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APCaptureReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APCaptureReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APCaptureReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APOptionsReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APOptionsReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APOptionsReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APOptionsOption:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APOptionsOption*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APOptionsOption*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APRefundReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APRefundReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APRefundReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APSaleReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APSaleReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APSaleReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APCheckOutDetailsReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APCheckOutDetailsReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APCheckOutDetailsReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APTransactionDetailsReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APTransactionDetailsReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APTransactionDetailsReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__APConfirmPurchaseReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__APConfirmPurchaseReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__APConfirmPurchaseReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ReplyMessage:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ReplyMessage*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ReplyMessage*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__FaultDetails:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__FaultDetails*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__FaultDetails*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__AirlineData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__AirlineData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__AirlineData*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Leg:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Leg*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Leg*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__AncillaryData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__AncillaryData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__AncillaryData*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Service:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Service*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Service*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__LodgingData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__LodgingData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__LodgingData*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Pos:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Pos*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Pos*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__EncryptedPayment:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__EncryptedPayment*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__EncryptedPayment*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__Installment:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__Installment*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__Installment*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__MerchantDefinedData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__MerchantDefinedData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__MerchantDefinedData*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__MerchantSecureData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__MerchantSecureData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__MerchantSecureData*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ReplyReserved:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ReplyReserved*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ReplyReserved*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__RequestReserved:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__RequestReserved*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__RequestReserved*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalGetTxnDetailsReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalGetTxnDetailsReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalGetTxnDetailsReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PayPalTransactionSearchReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PayPalTransactionSearchReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PayPalTransactionSearchReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__PaypalTransaction:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__PaypalTransaction*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__PaypalTransaction*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__CCDCCUpdateService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__CCDCCUpdateService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__CCDCCUpdateService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__ServiceFee:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__ServiceFee*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__ServiceFee*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__EmvRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__EmvRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__EmvRequest*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__EmvReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__EmvReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__EmvReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__OriginalTransaction:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__OriginalTransaction*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__OriginalTransaction*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__HostedDataCreateService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__HostedDataCreateService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__HostedDataCreateService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__HostedDataRetrieveService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__HostedDataRetrieveService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__HostedDataRetrieveService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__HostedDataCreateReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__HostedDataCreateReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__HostedDataCreateReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__HostedDataRetrieveReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__HostedDataRetrieveReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__HostedDataRetrieveReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__AutoRentalData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__AutoRentalData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__AutoRentalData*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__VCReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__VCReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__VCReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__VCCardArt:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__VCCardArt*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__VCCardArt*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__VCCustomData:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__VCCustomData*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__VCCustomData*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__DecryptVisaCheckoutDataReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__DecryptVisaCheckoutDataReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__EncryptPaymentDataReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__EncryptPaymentDataReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__EncryptPaymentDataReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__BinLookupService:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__BinLookupService*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__BinLookupService*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__BinLookupReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__BinLookupReply*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__BinLookupReply*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__issuer:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__issuer*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__issuer*>(p->ptr));
		break;
	case SOAP_TYPE_ns2__MDDField:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns2__MDDField*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns2__MDDField*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__runTransactionResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__runTransactionResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__runTransactionResponse*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__runTransaction:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__runTransaction*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__runTransaction*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		break;
#endif
	case SOAP_TYPE__ds__Signature:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ds__SignatureType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ds__SignatureType*>(p->ptr));
		break;
	case SOAP_TYPE__ds__Transform:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ds__TransformType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ds__TransformType*>(p->ptr));
		break;
	case SOAP_TYPE__ds__KeyInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ds__KeyInfoType*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ds__KeyInfoType*>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__PaypalTransaction:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns2__PaypalTransaction *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns2__PaypalTransaction *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MDDField:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns2__MDDField *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns2__MDDField *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Service:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns2__Service *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns2__Service *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Leg:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns2__Leg *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns2__Leg *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__PromotionGroupReply:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns2__PromotionGroupReply *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns2__PromotionGroupReply *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__DeniedPartiesMatch:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns2__DeniedPartiesMatch *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns2__DeniedPartiesMatch *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Field:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns2__Field *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns2__Field *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__RuleResultItem:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns2__RuleResultItem *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns2__RuleResultItem *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__FXQuote:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns2__FXQuote *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns2__FXQuote *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__TaxReplyItem:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns2__TaxReplyItem *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns2__TaxReplyItem *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__PromotionGroup:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns2__PromotionGroup *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns2__PromotionGroup *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__RequestReserved:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns2__RequestReserved *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns2__RequestReserved *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Item:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns2__Item *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns2__Item *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<char *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<char *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__DecisionManagerTravelLeg:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns2__DecisionManagerTravelLeg *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns2__DecisionManagerTravelLeg *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfwstring:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<wchar_t *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<wchar_t *> *>(p->ptr));
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	do
	{	switch (t)
		{
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__PaypalTransaction:
		if (t == SOAP_TYPE_ns2__PaypalTransaction || soap_fbase(t, SOAP_TYPE_ns2__PaypalTransaction))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__PaypalTransaction *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__PaypalTransaction *> *)p)[index] = *(ns2__PaypalTransaction **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__MDDField:
		if (t == SOAP_TYPE_ns2__MDDField || soap_fbase(t, SOAP_TYPE_ns2__MDDField))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__MDDField *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__MDDField *> *)p)[index] = *(ns2__MDDField **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Service:
		if (t == SOAP_TYPE_ns2__Service || soap_fbase(t, SOAP_TYPE_ns2__Service))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__Service *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__Service *> *)p)[index] = *(ns2__Service **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Leg:
		if (t == SOAP_TYPE_ns2__Leg || soap_fbase(t, SOAP_TYPE_ns2__Leg))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__Leg *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__Leg *> *)p)[index] = *(ns2__Leg **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__PromotionGroupReply:
		if (t == SOAP_TYPE_ns2__PromotionGroupReply || soap_fbase(t, SOAP_TYPE_ns2__PromotionGroupReply))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__PromotionGroupReply *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__PromotionGroupReply *> *)p)[index] = *(ns2__PromotionGroupReply **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__DeniedPartiesMatch:
		if (t == SOAP_TYPE_ns2__DeniedPartiesMatch || soap_fbase(t, SOAP_TYPE_ns2__DeniedPartiesMatch))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__DeniedPartiesMatch *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__DeniedPartiesMatch *> *)p)[index] = *(ns2__DeniedPartiesMatch **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Field:
		if (t == SOAP_TYPE_ns2__Field || soap_fbase(t, SOAP_TYPE_ns2__Field))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__Field *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__Field *> *)p)[index] = *(ns2__Field **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__RuleResultItem:
		if (t == SOAP_TYPE_ns2__RuleResultItem || soap_fbase(t, SOAP_TYPE_ns2__RuleResultItem))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__RuleResultItem *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__RuleResultItem *> *)p)[index] = *(ns2__RuleResultItem **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__FXQuote:
		if (t == SOAP_TYPE_ns2__FXQuote || soap_fbase(t, SOAP_TYPE_ns2__FXQuote))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__FXQuote *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__FXQuote *> *)p)[index] = *(ns2__FXQuote **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__TaxReplyItem:
		if (t == SOAP_TYPE_ns2__TaxReplyItem || soap_fbase(t, SOAP_TYPE_ns2__TaxReplyItem))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__TaxReplyItem *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__TaxReplyItem *> *)p)[index] = *(ns2__TaxReplyItem **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__PromotionGroup:
		if (t == SOAP_TYPE_ns2__PromotionGroup || soap_fbase(t, SOAP_TYPE_ns2__PromotionGroup))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__PromotionGroup *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__PromotionGroup *> *)p)[index] = *(ns2__PromotionGroup **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__RequestReserved:
		if (t == SOAP_TYPE_ns2__RequestReserved || soap_fbase(t, SOAP_TYPE_ns2__RequestReserved))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__RequestReserved *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__RequestReserved *> *)p)[index] = *(ns2__RequestReserved **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Item:
		if (t == SOAP_TYPE_ns2__Item || soap_fbase(t, SOAP_TYPE_ns2__Item))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__Item *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__Item *> *)p)[index] = *(ns2__Item **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (t == SOAP_TYPE__XML)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<char *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<char *> *)p)[index] = *(char **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__DecisionManagerTravelLeg:
		if (t == SOAP_TYPE_ns2__DecisionManagerTravelLeg || soap_fbase(t, SOAP_TYPE_ns2__DecisionManagerTravelLeg))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns2__DecisionManagerTravelLeg *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns2__DecisionManagerTravelLeg *> *)p)[index] = *(ns2__DecisionManagerTravelLeg **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfwstring:
		if (t == SOAP_TYPE_wstring)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<wchar_t *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<wchar_t *> *)p)[index] = *(wchar_t **)q;
		}
		break;
	case SOAP_TYPE__wsu__Timestamp:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsu__Timestamp type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsu__Timestamp*)p = *(struct _wsu__Timestamp*)q;
		break;
	case SOAP_TYPE_wsse__EncodedString:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsse__EncodedString type=%d location=%p object=%p\n", t, p, q));
		*(struct wsse__EncodedString*)p = *(struct wsse__EncodedString*)q;
		break;
	case SOAP_TYPE__wsse__UsernameToken:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__UsernameToken type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__UsernameToken*)p = *(struct _wsse__UsernameToken*)q;
		break;
	case SOAP_TYPE__wsse__BinarySecurityToken:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__BinarySecurityToken type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__BinarySecurityToken*)p = *(struct _wsse__BinarySecurityToken*)q;
		break;
	case SOAP_TYPE__wsse__Reference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__Reference type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__Reference*)p = *(struct _wsse__Reference*)q;
		break;
	case SOAP_TYPE__wsse__Embedded:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__Embedded type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__Embedded*)p = *(struct _wsse__Embedded*)q;
		break;
	case SOAP_TYPE__wsse__KeyIdentifier:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__KeyIdentifier type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__KeyIdentifier*)p = *(struct _wsse__KeyIdentifier*)q;
		break;
	case SOAP_TYPE__wsse__SecurityTokenReference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__SecurityTokenReference type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__SecurityTokenReference*)p = *(struct _wsse__SecurityTokenReference*)q;
		break;
	case SOAP_TYPE_ds__SignatureType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__SignatureType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__SignatureType*)p = *(struct ds__SignatureType*)q;
		break;
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _c14n__InclusiveNamespaces type=%d location=%p object=%p\n", t, p, q));
		*(struct _c14n__InclusiveNamespaces*)p = *(struct _c14n__InclusiveNamespaces*)q;
		break;
	case SOAP_TYPE_ds__TransformType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__TransformType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__TransformType*)p = *(struct ds__TransformType*)q;
		break;
	case SOAP_TYPE_ds__KeyInfoType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__KeyInfoType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__KeyInfoType*)p = *(struct ds__KeyInfoType*)q;
		break;
	case SOAP_TYPE_ds__SignedInfoType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__SignedInfoType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__SignedInfoType*)p = *(struct ds__SignedInfoType*)q;
		break;
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__CanonicalizationMethodType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__CanonicalizationMethodType*)p = *(struct ds__CanonicalizationMethodType*)q;
		break;
	case SOAP_TYPE_ds__SignatureMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__SignatureMethodType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__SignatureMethodType*)p = *(struct ds__SignatureMethodType*)q;
		break;
	case SOAP_TYPE_ds__ReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__ReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__ReferenceType*)p = *(struct ds__ReferenceType*)q;
		break;
	case SOAP_TYPE_ds__TransformsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__TransformsType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__TransformsType*)p = *(struct ds__TransformsType*)q;
		break;
	case SOAP_TYPE_ds__DigestMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__DigestMethodType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__DigestMethodType*)p = *(struct ds__DigestMethodType*)q;
		break;
	case SOAP_TYPE_ds__KeyValueType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__KeyValueType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__KeyValueType*)p = *(struct ds__KeyValueType*)q;
		break;
	case SOAP_TYPE_ds__RetrievalMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__RetrievalMethodType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__RetrievalMethodType*)p = *(struct ds__RetrievalMethodType*)q;
		break;
	case SOAP_TYPE_ds__X509DataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__X509DataType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__X509DataType*)p = *(struct ds__X509DataType*)q;
		break;
	case SOAP_TYPE_ds__X509IssuerSerialType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__X509IssuerSerialType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__X509IssuerSerialType*)p = *(struct ds__X509IssuerSerialType*)q;
		break;
	case SOAP_TYPE_ds__DSAKeyValueType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__DSAKeyValueType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__DSAKeyValueType*)p = *(struct ds__DSAKeyValueType*)q;
		break;
	case SOAP_TYPE_ds__RSAKeyValueType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__RSAKeyValueType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__RSAKeyValueType*)p = *(struct ds__RSAKeyValueType*)q;
		break;
	case SOAP_TYPE_xenc__EncryptionPropertyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__EncryptionPropertyType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__EncryptionPropertyType*)p = *(struct xenc__EncryptionPropertyType*)q;
		break;
	case SOAP_TYPE_xenc__EncryptedType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__EncryptedType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__EncryptedType*)p = *(struct xenc__EncryptedType*)q;
		break;
	case SOAP_TYPE_xenc__EncryptionMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__EncryptionMethodType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__EncryptionMethodType*)p = *(struct xenc__EncryptionMethodType*)q;
		break;
	case SOAP_TYPE_xenc__CipherDataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__CipherDataType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__CipherDataType*)p = *(struct xenc__CipherDataType*)q;
		break;
	case SOAP_TYPE_xenc__CipherReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__CipherReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__CipherReferenceType*)p = *(struct xenc__CipherReferenceType*)q;
		break;
	case SOAP_TYPE_xenc__TransformsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__TransformsType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__TransformsType*)p = *(struct xenc__TransformsType*)q;
		break;
	case SOAP_TYPE_xenc__AgreementMethodType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__AgreementMethodType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__AgreementMethodType*)p = *(struct xenc__AgreementMethodType*)q;
		break;
	case SOAP_TYPE_xenc__ReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__ReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__ReferenceType*)p = *(struct xenc__ReferenceType*)q;
		break;
	case SOAP_TYPE_xenc__EncryptionPropertiesType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__EncryptionPropertiesType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__EncryptionPropertiesType*)p = *(struct xenc__EncryptionPropertiesType*)q;
		break;
	case SOAP_TYPE___xenc__union_ReferenceList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __xenc__union_ReferenceList type=%d location=%p object=%p\n", t, p, q));
		*(struct __xenc__union_ReferenceList*)p = *(struct __xenc__union_ReferenceList*)q;
		break;
	case SOAP_TYPE__xenc__ReferenceList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _xenc__ReferenceList type=%d location=%p object=%p\n", t, p, q));
		*(struct _xenc__ReferenceList*)p = *(struct _xenc__ReferenceList*)q;
		break;
	case SOAP_TYPE_xenc__EncryptedDataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__EncryptedDataType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__EncryptedDataType*)p = *(struct xenc__EncryptedDataType*)q;
		break;
	case SOAP_TYPE_xenc__EncryptedKeyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct xenc__EncryptedKeyType type=%d location=%p object=%p\n", t, p, q));
		*(struct xenc__EncryptedKeyType*)p = *(struct xenc__EncryptedKeyType*)q;
		break;
	case SOAP_TYPE_wsc__SecurityContextTokenType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsc__SecurityContextTokenType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsc__SecurityContextTokenType*)p = *(struct wsc__SecurityContextTokenType*)q;
		break;
	case SOAP_TYPE__wsc__union_DerivedKeyTokenType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _wsc__union_DerivedKeyTokenType type=%d location=%p object=%p\n", t, p, q));
		*(union _wsc__union_DerivedKeyTokenType*)p = *(union _wsc__union_DerivedKeyTokenType*)q;
		break;
	case SOAP_TYPE___wsc__DerivedKeyTokenType_sequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __wsc__DerivedKeyTokenType_sequence type=%d location=%p object=%p\n", t, p, q));
		*(struct __wsc__DerivedKeyTokenType_sequence*)p = *(struct __wsc__DerivedKeyTokenType_sequence*)q;
		break;
	case SOAP_TYPE_wsc__DerivedKeyTokenType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsc__DerivedKeyTokenType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsc__DerivedKeyTokenType*)p = *(struct wsc__DerivedKeyTokenType*)q;
		break;
	case SOAP_TYPE_wsc__PropertiesType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsc__PropertiesType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsc__PropertiesType*)p = *(struct wsc__PropertiesType*)q;
		break;
	case SOAP_TYPE__wsse__Security:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__Security type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__Security*)p = *(struct _wsse__Security*)q;
		break;
	case SOAP_TYPE__wsse__Password:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _wsse__Password type=%d location=%p object=%p\n", t, p, q));
		*(struct _wsse__Password*)p = *(struct _wsse__Password*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
	case SOAP_TYPE_ns2__Item:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Item type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Item*)p = *(ns2__Item*)q;
		break;
	case SOAP_TYPE_ns2__CCAuthService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CCAuthService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CCAuthService*)p = *(ns2__CCAuthService*)q;
		break;
	case SOAP_TYPE_ns2__OCTService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__OCTService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__OCTService*)p = *(ns2__OCTService*)q;
		break;
	case SOAP_TYPE_ns2__VerificationService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__VerificationService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__VerificationService*)p = *(ns2__VerificationService*)q;
		break;
	case SOAP_TYPE_ns2__CCSaleService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CCSaleService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CCSaleService*)p = *(ns2__CCSaleService*)q;
		break;
	case SOAP_TYPE_ns2__CCSaleCreditService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CCSaleCreditService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CCSaleCreditService*)p = *(ns2__CCSaleCreditService*)q;
		break;
	case SOAP_TYPE_ns2__CCSaleReversalService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CCSaleReversalService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CCSaleReversalService*)p = *(ns2__CCSaleReversalService*)q;
		break;
	case SOAP_TYPE_ns2__CCIncrementalAuthService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CCIncrementalAuthService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CCIncrementalAuthService*)p = *(ns2__CCIncrementalAuthService*)q;
		break;
	case SOAP_TYPE_ns2__CCCaptureService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CCCaptureService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CCCaptureService*)p = *(ns2__CCCaptureService*)q;
		break;
	case SOAP_TYPE_ns2__CCCreditService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CCCreditService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CCCreditService*)p = *(ns2__CCCreditService*)q;
		break;
	case SOAP_TYPE_ns2__CCAuthReversalService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CCAuthReversalService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CCAuthReversalService*)p = *(ns2__CCAuthReversalService*)q;
		break;
	case SOAP_TYPE_ns2__CCAutoAuthReversalService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CCAutoAuthReversalService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CCAutoAuthReversalService*)p = *(ns2__CCAutoAuthReversalService*)q;
		break;
	case SOAP_TYPE_ns2__CCDCCService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CCDCCService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CCDCCService*)p = *(ns2__CCDCCService*)q;
		break;
	case SOAP_TYPE_ns2__ServiceFeeCalculateService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ServiceFeeCalculateService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ServiceFeeCalculateService*)p = *(ns2__ServiceFeeCalculateService*)q;
		break;
	case SOAP_TYPE_ns2__ECDebitService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ECDebitService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ECDebitService*)p = *(ns2__ECDebitService*)q;
		break;
	case SOAP_TYPE_ns2__ECCreditService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ECCreditService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ECCreditService*)p = *(ns2__ECCreditService*)q;
		break;
	case SOAP_TYPE_ns2__ECAuthenticateService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ECAuthenticateService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ECAuthenticateService*)p = *(ns2__ECAuthenticateService*)q;
		break;
	case SOAP_TYPE_ns2__PayerAuthEnrollService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayerAuthEnrollService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayerAuthEnrollService*)p = *(ns2__PayerAuthEnrollService*)q;
		break;
	case SOAP_TYPE_ns2__PayerAuthValidateService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayerAuthValidateService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayerAuthValidateService*)p = *(ns2__PayerAuthValidateService*)q;
		break;
	case SOAP_TYPE_ns2__TaxService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaxService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaxService*)p = *(ns2__TaxService*)q;
		break;
	case SOAP_TYPE_ns2__DMEService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DMEService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DMEService*)p = *(ns2__DMEService*)q;
		break;
	case SOAP_TYPE_ns2__AFSService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__AFSService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__AFSService*)p = *(ns2__AFSService*)q;
		break;
	case SOAP_TYPE_ns2__DAVService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DAVService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DAVService*)p = *(ns2__DAVService*)q;
		break;
	case SOAP_TYPE_ns2__ExportService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ExportService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ExportService*)p = *(ns2__ExportService*)q;
		break;
	case SOAP_TYPE_ns2__FXRatesService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__FXRatesService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__FXRatesService*)p = *(ns2__FXRatesService*)q;
		break;
	case SOAP_TYPE_ns2__BankTransferService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__BankTransferService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__BankTransferService*)p = *(ns2__BankTransferService*)q;
		break;
	case SOAP_TYPE_ns2__BankTransferRefundService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__BankTransferRefundService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__BankTransferRefundService*)p = *(ns2__BankTransferRefundService*)q;
		break;
	case SOAP_TYPE_ns2__BankTransferRealTimeService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__BankTransferRealTimeService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__BankTransferRealTimeService*)p = *(ns2__BankTransferRealTimeService*)q;
		break;
	case SOAP_TYPE_ns2__DirectDebitMandateService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DirectDebitMandateService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DirectDebitMandateService*)p = *(ns2__DirectDebitMandateService*)q;
		break;
	case SOAP_TYPE_ns2__DirectDebitService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DirectDebitService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DirectDebitService*)p = *(ns2__DirectDebitService*)q;
		break;
	case SOAP_TYPE_ns2__DirectDebitRefundService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DirectDebitRefundService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DirectDebitRefundService*)p = *(ns2__DirectDebitRefundService*)q;
		break;
	case SOAP_TYPE_ns2__DirectDebitValidateService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DirectDebitValidateService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DirectDebitValidateService*)p = *(ns2__DirectDebitValidateService*)q;
		break;
	case SOAP_TYPE_ns2__PaySubscriptionCreateService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PaySubscriptionCreateService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PaySubscriptionCreateService*)p = *(ns2__PaySubscriptionCreateService*)q;
		break;
	case SOAP_TYPE_ns2__PaySubscriptionUpdateService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PaySubscriptionUpdateService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PaySubscriptionUpdateService*)p = *(ns2__PaySubscriptionUpdateService*)q;
		break;
	case SOAP_TYPE_ns2__PaySubscriptionEventUpdateService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PaySubscriptionEventUpdateService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PaySubscriptionEventUpdateService*)p = *(ns2__PaySubscriptionEventUpdateService*)q;
		break;
	case SOAP_TYPE_ns2__PaySubscriptionRetrieveService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PaySubscriptionRetrieveService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PaySubscriptionRetrieveService*)p = *(ns2__PaySubscriptionRetrieveService*)q;
		break;
	case SOAP_TYPE_ns2__PaySubscriptionDeleteService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PaySubscriptionDeleteService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PaySubscriptionDeleteService*)p = *(ns2__PaySubscriptionDeleteService*)q;
		break;
	case SOAP_TYPE_ns2__PayPalPaymentService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalPaymentService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalPaymentService*)p = *(ns2__PayPalPaymentService*)q;
		break;
	case SOAP_TYPE_ns2__PayPalCreditService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalCreditService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalCreditService*)p = *(ns2__PayPalCreditService*)q;
		break;
	case SOAP_TYPE_ns2__PayPalEcSetService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalEcSetService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalEcSetService*)p = *(ns2__PayPalEcSetService*)q;
		break;
	case SOAP_TYPE_ns2__PayPalEcGetDetailsService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalEcGetDetailsService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalEcGetDetailsService*)p = *(ns2__PayPalEcGetDetailsService*)q;
		break;
	case SOAP_TYPE_ns2__PayPalEcDoPaymentService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalEcDoPaymentService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalEcDoPaymentService*)p = *(ns2__PayPalEcDoPaymentService*)q;
		break;
	case SOAP_TYPE_ns2__PayPalDoCaptureService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalDoCaptureService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalDoCaptureService*)p = *(ns2__PayPalDoCaptureService*)q;
		break;
	case SOAP_TYPE_ns2__PayPalAuthReversalService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalAuthReversalService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalAuthReversalService*)p = *(ns2__PayPalAuthReversalService*)q;
		break;
	case SOAP_TYPE_ns2__PayPalRefundService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalRefundService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalRefundService*)p = *(ns2__PayPalRefundService*)q;
		break;
	case SOAP_TYPE_ns2__PayPalEcOrderSetupService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalEcOrderSetupService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalEcOrderSetupService*)p = *(ns2__PayPalEcOrderSetupService*)q;
		break;
	case SOAP_TYPE_ns2__PayPalAuthorizationService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalAuthorizationService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalAuthorizationService*)p = *(ns2__PayPalAuthorizationService*)q;
		break;
	case SOAP_TYPE_ns2__PayPalUpdateAgreementService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalUpdateAgreementService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalUpdateAgreementService*)p = *(ns2__PayPalUpdateAgreementService*)q;
		break;
	case SOAP_TYPE_ns2__PayPalCreateAgreementService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalCreateAgreementService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalCreateAgreementService*)p = *(ns2__PayPalCreateAgreementService*)q;
		break;
	case SOAP_TYPE_ns2__PayPalDoRefTransactionService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalDoRefTransactionService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalDoRefTransactionService*)p = *(ns2__PayPalDoRefTransactionService*)q;
		break;
	case SOAP_TYPE_ns2__VoidService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__VoidService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__VoidService*)p = *(ns2__VoidService*)q;
		break;
	case SOAP_TYPE_ns2__PinlessDebitService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PinlessDebitService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PinlessDebitService*)p = *(ns2__PinlessDebitService*)q;
		break;
	case SOAP_TYPE_ns2__PinlessDebitValidateService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PinlessDebitValidateService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PinlessDebitValidateService*)p = *(ns2__PinlessDebitValidateService*)q;
		break;
	case SOAP_TYPE_ns2__PinlessDebitReversalService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PinlessDebitReversalService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PinlessDebitReversalService*)p = *(ns2__PinlessDebitReversalService*)q;
		break;
	case SOAP_TYPE_ns2__PinDebitPurchaseService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PinDebitPurchaseService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PinDebitPurchaseService*)p = *(ns2__PinDebitPurchaseService*)q;
		break;
	case SOAP_TYPE_ns2__PinDebitCreditService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PinDebitCreditService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PinDebitCreditService*)p = *(ns2__PinDebitCreditService*)q;
		break;
	case SOAP_TYPE_ns2__PinDebitReversalService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PinDebitReversalService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PinDebitReversalService*)p = *(ns2__PinDebitReversalService*)q;
		break;
	case SOAP_TYPE_ns2__PayPalButtonCreateService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalButtonCreateService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalButtonCreateService*)p = *(ns2__PayPalButtonCreateService*)q;
		break;
	case SOAP_TYPE_ns2__PayPalPreapprovedPaymentService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalPreapprovedPaymentService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalPreapprovedPaymentService*)p = *(ns2__PayPalPreapprovedPaymentService*)q;
		break;
	case SOAP_TYPE_ns2__PayPalPreapprovedUpdateService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalPreapprovedUpdateService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalPreapprovedUpdateService*)p = *(ns2__PayPalPreapprovedUpdateService*)q;
		break;
	case SOAP_TYPE_ns2__ChinaPaymentService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ChinaPaymentService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ChinaPaymentService*)p = *(ns2__ChinaPaymentService*)q;
		break;
	case SOAP_TYPE_ns2__ChinaRefundService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ChinaRefundService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ChinaRefundService*)p = *(ns2__ChinaRefundService*)q;
		break;
	case SOAP_TYPE_ns2__BoletoPaymentService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__BoletoPaymentService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__BoletoPaymentService*)p = *(ns2__BoletoPaymentService*)q;
		break;
	case SOAP_TYPE_ns2__PersonalId:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PersonalId type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PersonalId*)p = *(ns2__PersonalId*)q;
		break;
	case SOAP_TYPE_ns2__Address:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Address type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Address*)p = *(ns2__Address*)q;
		break;
	case SOAP_TYPE_ns2__APInitiateService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APInitiateService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APInitiateService*)p = *(ns2__APInitiateService*)q;
		break;
	case SOAP_TYPE_ns2__APCheckStatusService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APCheckStatusService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APCheckStatusService*)p = *(ns2__APCheckStatusService*)q;
		break;
	case SOAP_TYPE_ns2__RiskUpdateService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__RiskUpdateService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__RiskUpdateService*)p = *(ns2__RiskUpdateService*)q;
		break;
	case SOAP_TYPE_ns2__FraudUpdateService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__FraudUpdateService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__FraudUpdateService*)p = *(ns2__FraudUpdateService*)q;
		break;
	case SOAP_TYPE_ns2__CaseManagementActionService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CaseManagementActionService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CaseManagementActionService*)p = *(ns2__CaseManagementActionService*)q;
		break;
	case SOAP_TYPE_ns2__EncryptPaymentDataService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__EncryptPaymentDataService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__EncryptPaymentDataService*)p = *(ns2__EncryptPaymentDataService*)q;
		break;
	case SOAP_TYPE_ns2__InvoiceHeader:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__InvoiceHeader type=%d location=%p object=%p\n", t, p, q));
		*(ns2__InvoiceHeader*)p = *(ns2__InvoiceHeader*)q;
		break;
	case SOAP_TYPE_ns2__BusinessRules:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__BusinessRules type=%d location=%p object=%p\n", t, p, q));
		*(ns2__BusinessRules*)p = *(ns2__BusinessRules*)q;
		break;
	case SOAP_TYPE_ns2__BillTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__BillTo type=%d location=%p object=%p\n", t, p, q));
		*(ns2__BillTo*)p = *(ns2__BillTo*)q;
		break;
	case SOAP_TYPE_ns2__ShipTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ShipTo type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ShipTo*)p = *(ns2__ShipTo*)q;
		break;
	case SOAP_TYPE_ns2__ShipFrom:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ShipFrom type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ShipFrom*)p = *(ns2__ShipFrom*)q;
		break;
	case SOAP_TYPE_ns2__Card:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Card type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Card*)p = *(ns2__Card*)q;
		break;
	case SOAP_TYPE_ns2__Check:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Check type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Check*)p = *(ns2__Check*)q;
		break;
	case SOAP_TYPE_ns2__BML:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__BML type=%d location=%p object=%p\n", t, p, q));
		*(ns2__BML*)p = *(ns2__BML*)q;
		break;
	case SOAP_TYPE_ns2__OtherTax:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__OtherTax type=%d location=%p object=%p\n", t, p, q));
		*(ns2__OtherTax*)p = *(ns2__OtherTax*)q;
		break;
	case SOAP_TYPE_ns2__Aft:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Aft type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Aft*)p = *(ns2__Aft*)q;
		break;
	case SOAP_TYPE_ns2__Wallet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Wallet type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Wallet*)p = *(ns2__Wallet*)q;
		break;
	case SOAP_TYPE_ns2__PurchaseTotals:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PurchaseTotals type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PurchaseTotals*)p = *(ns2__PurchaseTotals*)q;
		break;
	case SOAP_TYPE_ns2__FundingTotals:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__FundingTotals type=%d location=%p object=%p\n", t, p, q));
		*(ns2__FundingTotals*)p = *(ns2__FundingTotals*)q;
		break;
	case SOAP_TYPE_ns2__GECC:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__GECC type=%d location=%p object=%p\n", t, p, q));
		*(ns2__GECC*)p = *(ns2__GECC*)q;
		break;
	case SOAP_TYPE_ns2__UCAF:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__UCAF type=%d location=%p object=%p\n", t, p, q));
		*(ns2__UCAF*)p = *(ns2__UCAF*)q;
		break;
	case SOAP_TYPE_ns2__FundTransfer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__FundTransfer type=%d location=%p object=%p\n", t, p, q));
		*(ns2__FundTransfer*)p = *(ns2__FundTransfer*)q;
		break;
	case SOAP_TYPE_ns2__BankInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__BankInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns2__BankInfo*)p = *(ns2__BankInfo*)q;
		break;
	case SOAP_TYPE_ns2__RecurringSubscriptionInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__RecurringSubscriptionInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns2__RecurringSubscriptionInfo*)p = *(ns2__RecurringSubscriptionInfo*)q;
		break;
	case SOAP_TYPE_ns2__PaySubscriptionEvent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PaySubscriptionEvent type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PaySubscriptionEvent*)p = *(ns2__PaySubscriptionEvent*)q;
		break;
	case SOAP_TYPE_ns2__Subscription:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Subscription type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Subscription*)p = *(ns2__Subscription*)q;
		break;
	case SOAP_TYPE_ns2__PaymentNetworkToken:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PaymentNetworkToken type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PaymentNetworkToken*)p = *(ns2__PaymentNetworkToken*)q;
		break;
	case SOAP_TYPE_ns2__DecisionManager:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DecisionManager type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DecisionManager*)p = *(ns2__DecisionManager*)q;
		break;
	case SOAP_TYPE_ns2__DecisionManagerTravelData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DecisionManagerTravelData type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DecisionManagerTravelData*)p = *(ns2__DecisionManagerTravelData*)q;
		break;
	case SOAP_TYPE_ns2__DecisionManagerTravelLeg:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DecisionManagerTravelLeg type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DecisionManagerTravelLeg*)p = *(ns2__DecisionManagerTravelLeg*)q;
		break;
	case SOAP_TYPE_ns2__Batch:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Batch type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Batch*)p = *(ns2__Batch*)q;
		break;
	case SOAP_TYPE_ns2__PayPal:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPal type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPal*)p = *(ns2__PayPal*)q;
		break;
	case SOAP_TYPE_ns2__JPO:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__JPO type=%d location=%p object=%p\n", t, p, q));
		*(ns2__JPO*)p = *(ns2__JPO*)q;
		break;
	case SOAP_TYPE_ns2__Token:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Token type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Token*)p = *(ns2__Token*)q;
		break;
	case SOAP_TYPE_ns2__AP:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__AP type=%d location=%p object=%p\n", t, p, q));
		*(ns2__AP*)p = *(ns2__AP*)q;
		break;
	case SOAP_TYPE_ns2__APDevice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APDevice type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APDevice*)p = *(ns2__APDevice*)q;
		break;
	case SOAP_TYPE_ns2__APAuthService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APAuthService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APAuthService*)p = *(ns2__APAuthService*)q;
		break;
	case SOAP_TYPE_ns2__APAuthReversalService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APAuthReversalService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APAuthReversalService*)p = *(ns2__APAuthReversalService*)q;
		break;
	case SOAP_TYPE_ns2__APCaptureService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APCaptureService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APCaptureService*)p = *(ns2__APCaptureService*)q;
		break;
	case SOAP_TYPE_ns2__APOptionsService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APOptionsService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APOptionsService*)p = *(ns2__APOptionsService*)q;
		break;
	case SOAP_TYPE_ns2__APRefundService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APRefundService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APRefundService*)p = *(ns2__APRefundService*)q;
		break;
	case SOAP_TYPE_ns2__APSaleService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APSaleService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APSaleService*)p = *(ns2__APSaleService*)q;
		break;
	case SOAP_TYPE_ns2__APCheckOutDetailsService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APCheckOutDetailsService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APCheckOutDetailsService*)p = *(ns2__APCheckOutDetailsService*)q;
		break;
	case SOAP_TYPE_ns2__APTransactionDetailsService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APTransactionDetailsService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APTransactionDetailsService*)p = *(ns2__APTransactionDetailsService*)q;
		break;
	case SOAP_TYPE_ns2__APConfirmPurchaseService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APConfirmPurchaseService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APConfirmPurchaseService*)p = *(ns2__APConfirmPurchaseService*)q;
		break;
	case SOAP_TYPE_ns2__PayPalGetTxnDetailsService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalGetTxnDetailsService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalGetTxnDetailsService*)p = *(ns2__PayPalGetTxnDetailsService*)q;
		break;
	case SOAP_TYPE_ns2__PayPalTransactionSearchService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalTransactionSearchService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalTransactionSearchService*)p = *(ns2__PayPalTransactionSearchService*)q;
		break;
	case SOAP_TYPE_ns2__Recipient:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Recipient type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Recipient*)p = *(ns2__Recipient*)q;
		break;
	case SOAP_TYPE_ns2__Sender:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Sender type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Sender*)p = *(ns2__Sender*)q;
		break;
	case SOAP_TYPE_ns2__RequestMessage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__RequestMessage type=%d location=%p object=%p\n", t, p, q));
		*(ns2__RequestMessage*)p = *(ns2__RequestMessage*)q;
		break;
	case SOAP_TYPE_ns2__VC:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__VC type=%d location=%p object=%p\n", t, p, q));
		*(ns2__VC*)p = *(ns2__VC*)q;
		break;
	case SOAP_TYPE_ns2__DecryptVisaCheckoutDataService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DecryptVisaCheckoutDataService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DecryptVisaCheckoutDataService*)p = *(ns2__DecryptVisaCheckoutDataService*)q;
		break;
	case SOAP_TYPE_ns2__DCC:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DCC type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DCC*)p = *(ns2__DCC*)q;
		break;
	case SOAP_TYPE_ns2__Promotion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Promotion type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Promotion*)p = *(ns2__Promotion*)q;
		break;
	case SOAP_TYPE_ns2__PromotionGroup:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PromotionGroup type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PromotionGroup*)p = *(ns2__PromotionGroup*)q;
		break;
	case SOAP_TYPE_ns2__PromotionGroupReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PromotionGroupReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PromotionGroupReply*)p = *(ns2__PromotionGroupReply*)q;
		break;
	case SOAP_TYPE_ns2__CCAuthReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CCAuthReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CCAuthReply*)p = *(ns2__CCAuthReply*)q;
		break;
	case SOAP_TYPE_ns2__OCTReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__OCTReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__OCTReply*)p = *(ns2__OCTReply*)q;
		break;
	case SOAP_TYPE_ns2__VerificationReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__VerificationReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__VerificationReply*)p = *(ns2__VerificationReply*)q;
		break;
	case SOAP_TYPE_ns2__CCSaleReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CCSaleReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CCSaleReply*)p = *(ns2__CCSaleReply*)q;
		break;
	case SOAP_TYPE_ns2__CCSaleCreditReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CCSaleCreditReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CCSaleCreditReply*)p = *(ns2__CCSaleCreditReply*)q;
		break;
	case SOAP_TYPE_ns2__CCSaleReversalReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CCSaleReversalReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CCSaleReversalReply*)p = *(ns2__CCSaleReversalReply*)q;
		break;
	case SOAP_TYPE_ns2__CCIncrementalAuthReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CCIncrementalAuthReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CCIncrementalAuthReply*)p = *(ns2__CCIncrementalAuthReply*)q;
		break;
	case SOAP_TYPE_ns2__CCCaptureReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CCCaptureReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CCCaptureReply*)p = *(ns2__CCCaptureReply*)q;
		break;
	case SOAP_TYPE_ns2__ServiceFeeCalculateReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ServiceFeeCalculateReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ServiceFeeCalculateReply*)p = *(ns2__ServiceFeeCalculateReply*)q;
		break;
	case SOAP_TYPE_ns2__CCCreditReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CCCreditReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CCCreditReply*)p = *(ns2__CCCreditReply*)q;
		break;
	case SOAP_TYPE_ns2__PinDebitPurchaseReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PinDebitPurchaseReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PinDebitPurchaseReply*)p = *(ns2__PinDebitPurchaseReply*)q;
		break;
	case SOAP_TYPE_ns2__PinDebitCreditReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PinDebitCreditReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PinDebitCreditReply*)p = *(ns2__PinDebitCreditReply*)q;
		break;
	case SOAP_TYPE_ns2__PinDebitReversalReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PinDebitReversalReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PinDebitReversalReply*)p = *(ns2__PinDebitReversalReply*)q;
		break;
	case SOAP_TYPE_ns2__CCAuthReversalReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CCAuthReversalReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CCAuthReversalReply*)p = *(ns2__CCAuthReversalReply*)q;
		break;
	case SOAP_TYPE_ns2__CCAutoAuthReversalReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CCAutoAuthReversalReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CCAutoAuthReversalReply*)p = *(ns2__CCAutoAuthReversalReply*)q;
		break;
	case SOAP_TYPE_ns2__ECDebitReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ECDebitReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ECDebitReply*)p = *(ns2__ECDebitReply*)q;
		break;
	case SOAP_TYPE_ns2__ECCreditReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ECCreditReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ECCreditReply*)p = *(ns2__ECCreditReply*)q;
		break;
	case SOAP_TYPE_ns2__ECAuthenticateReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ECAuthenticateReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ECAuthenticateReply*)p = *(ns2__ECAuthenticateReply*)q;
		break;
	case SOAP_TYPE_ns2__PayerAuthEnrollReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayerAuthEnrollReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayerAuthEnrollReply*)p = *(ns2__PayerAuthEnrollReply*)q;
		break;
	case SOAP_TYPE_ns2__PayerAuthValidateReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayerAuthValidateReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayerAuthValidateReply*)p = *(ns2__PayerAuthValidateReply*)q;
		break;
	case SOAP_TYPE_ns2__TaxReplyItem:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaxReplyItem type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaxReplyItem*)p = *(ns2__TaxReplyItem*)q;
		break;
	case SOAP_TYPE_ns2__TaxReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__TaxReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__TaxReply*)p = *(ns2__TaxReply*)q;
		break;
	case SOAP_TYPE_ns2__DeviceFingerprint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DeviceFingerprint type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DeviceFingerprint*)p = *(ns2__DeviceFingerprint*)q;
		break;
	case SOAP_TYPE_ns2__AFSReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__AFSReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__AFSReply*)p = *(ns2__AFSReply*)q;
		break;
	case SOAP_TYPE_ns2__DAVReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DAVReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DAVReply*)p = *(ns2__DAVReply*)q;
		break;
	case SOAP_TYPE_ns2__DeniedPartiesMatch:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DeniedPartiesMatch type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DeniedPartiesMatch*)p = *(ns2__DeniedPartiesMatch*)q;
		break;
	case SOAP_TYPE_ns2__ExportReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ExportReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ExportReply*)p = *(ns2__ExportReply*)q;
		break;
	case SOAP_TYPE_ns2__FXQuote:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__FXQuote type=%d location=%p object=%p\n", t, p, q));
		*(ns2__FXQuote*)p = *(ns2__FXQuote*)q;
		break;
	case SOAP_TYPE_ns2__FXRatesReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__FXRatesReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__FXRatesReply*)p = *(ns2__FXRatesReply*)q;
		break;
	case SOAP_TYPE_ns2__BankTransferReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__BankTransferReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__BankTransferReply*)p = *(ns2__BankTransferReply*)q;
		break;
	case SOAP_TYPE_ns2__BankTransferRealTimeReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__BankTransferRealTimeReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__BankTransferRealTimeReply*)p = *(ns2__BankTransferRealTimeReply*)q;
		break;
	case SOAP_TYPE_ns2__DirectDebitMandateReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DirectDebitMandateReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DirectDebitMandateReply*)p = *(ns2__DirectDebitMandateReply*)q;
		break;
	case SOAP_TYPE_ns2__BankTransferRefundReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__BankTransferRefundReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__BankTransferRefundReply*)p = *(ns2__BankTransferRefundReply*)q;
		break;
	case SOAP_TYPE_ns2__DirectDebitReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DirectDebitReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DirectDebitReply*)p = *(ns2__DirectDebitReply*)q;
		break;
	case SOAP_TYPE_ns2__DirectDebitValidateReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DirectDebitValidateReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DirectDebitValidateReply*)p = *(ns2__DirectDebitValidateReply*)q;
		break;
	case SOAP_TYPE_ns2__DirectDebitRefundReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DirectDebitRefundReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DirectDebitRefundReply*)p = *(ns2__DirectDebitRefundReply*)q;
		break;
	case SOAP_TYPE_ns2__PaySubscriptionCreateReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PaySubscriptionCreateReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PaySubscriptionCreateReply*)p = *(ns2__PaySubscriptionCreateReply*)q;
		break;
	case SOAP_TYPE_ns2__PaySubscriptionUpdateReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PaySubscriptionUpdateReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PaySubscriptionUpdateReply*)p = *(ns2__PaySubscriptionUpdateReply*)q;
		break;
	case SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PaySubscriptionEventUpdateReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PaySubscriptionEventUpdateReply*)p = *(ns2__PaySubscriptionEventUpdateReply*)q;
		break;
	case SOAP_TYPE_ns2__PaySubscriptionRetrieveReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PaySubscriptionRetrieveReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PaySubscriptionRetrieveReply*)p = *(ns2__PaySubscriptionRetrieveReply*)q;
		break;
	case SOAP_TYPE_ns2__PaySubscriptionDeleteReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PaySubscriptionDeleteReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PaySubscriptionDeleteReply*)p = *(ns2__PaySubscriptionDeleteReply*)q;
		break;
	case SOAP_TYPE_ns2__PayPalPaymentReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalPaymentReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalPaymentReply*)p = *(ns2__PayPalPaymentReply*)q;
		break;
	case SOAP_TYPE_ns2__PayPalCreditReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalCreditReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalCreditReply*)p = *(ns2__PayPalCreditReply*)q;
		break;
	case SOAP_TYPE_ns2__VoidReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__VoidReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__VoidReply*)p = *(ns2__VoidReply*)q;
		break;
	case SOAP_TYPE_ns2__PinlessDebitReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PinlessDebitReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PinlessDebitReply*)p = *(ns2__PinlessDebitReply*)q;
		break;
	case SOAP_TYPE_ns2__PinlessDebitValidateReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PinlessDebitValidateReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PinlessDebitValidateReply*)p = *(ns2__PinlessDebitValidateReply*)q;
		break;
	case SOAP_TYPE_ns2__PinlessDebitReversalReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PinlessDebitReversalReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PinlessDebitReversalReply*)p = *(ns2__PinlessDebitReversalReply*)q;
		break;
	case SOAP_TYPE_ns2__PayPalButtonCreateReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalButtonCreateReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalButtonCreateReply*)p = *(ns2__PayPalButtonCreateReply*)q;
		break;
	case SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalPreapprovedPaymentReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalPreapprovedPaymentReply*)p = *(ns2__PayPalPreapprovedPaymentReply*)q;
		break;
	case SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalPreapprovedUpdateReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalPreapprovedUpdateReply*)p = *(ns2__PayPalPreapprovedUpdateReply*)q;
		break;
	case SOAP_TYPE_ns2__PayPalEcSetReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalEcSetReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalEcSetReply*)p = *(ns2__PayPalEcSetReply*)q;
		break;
	case SOAP_TYPE_ns2__PayPalEcGetDetailsReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalEcGetDetailsReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalEcGetDetailsReply*)p = *(ns2__PayPalEcGetDetailsReply*)q;
		break;
	case SOAP_TYPE_ns2__PayPalEcDoPaymentReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalEcDoPaymentReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalEcDoPaymentReply*)p = *(ns2__PayPalEcDoPaymentReply*)q;
		break;
	case SOAP_TYPE_ns2__PayPalDoCaptureReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalDoCaptureReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalDoCaptureReply*)p = *(ns2__PayPalDoCaptureReply*)q;
		break;
	case SOAP_TYPE_ns2__PayPalAuthReversalReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalAuthReversalReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalAuthReversalReply*)p = *(ns2__PayPalAuthReversalReply*)q;
		break;
	case SOAP_TYPE_ns2__PayPalRefundReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalRefundReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalRefundReply*)p = *(ns2__PayPalRefundReply*)q;
		break;
	case SOAP_TYPE_ns2__PayPalEcOrderSetupReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalEcOrderSetupReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalEcOrderSetupReply*)p = *(ns2__PayPalEcOrderSetupReply*)q;
		break;
	case SOAP_TYPE_ns2__PayPalAuthorizationReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalAuthorizationReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalAuthorizationReply*)p = *(ns2__PayPalAuthorizationReply*)q;
		break;
	case SOAP_TYPE_ns2__PayPalUpdateAgreementReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalUpdateAgreementReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalUpdateAgreementReply*)p = *(ns2__PayPalUpdateAgreementReply*)q;
		break;
	case SOAP_TYPE_ns2__PayPalCreateAgreementReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalCreateAgreementReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalCreateAgreementReply*)p = *(ns2__PayPalCreateAgreementReply*)q;
		break;
	case SOAP_TYPE_ns2__PayPalDoRefTransactionReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalDoRefTransactionReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalDoRefTransactionReply*)p = *(ns2__PayPalDoRefTransactionReply*)q;
		break;
	case SOAP_TYPE_ns2__RiskUpdateReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__RiskUpdateReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__RiskUpdateReply*)p = *(ns2__RiskUpdateReply*)q;
		break;
	case SOAP_TYPE_ns2__FraudUpdateReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__FraudUpdateReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__FraudUpdateReply*)p = *(ns2__FraudUpdateReply*)q;
		break;
	case SOAP_TYPE_ns2__CaseManagementActionReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CaseManagementActionReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CaseManagementActionReply*)p = *(ns2__CaseManagementActionReply*)q;
		break;
	case SOAP_TYPE_ns2__RuleResultItem:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__RuleResultItem type=%d location=%p object=%p\n", t, p, q));
		*(ns2__RuleResultItem*)p = *(ns2__RuleResultItem*)q;
		break;
	case SOAP_TYPE_ns2__RuleResultItems:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__RuleResultItems type=%d location=%p object=%p\n", t, p, q));
		*(ns2__RuleResultItems*)p = *(ns2__RuleResultItems*)q;
		break;
	case SOAP_TYPE_ns2__DecisionReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DecisionReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DecisionReply*)p = *(ns2__DecisionReply*)q;
		break;
	case SOAP_TYPE_ns2__AdditionalFields:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__AdditionalFields type=%d location=%p object=%p\n", t, p, q));
		*(ns2__AdditionalFields*)p = *(ns2__AdditionalFields*)q;
		break;
	case SOAP_TYPE_ns2__Field:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Field type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Field*)p = *(ns2__Field*)q;
		break;
	case SOAP_TYPE_ns2__DMEReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DMEReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DMEReply*)p = *(ns2__DMEReply*)q;
		break;
	case SOAP_TYPE_ns2__ProfileReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ProfileReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ProfileReply*)p = *(ns2__ProfileReply*)q;
		break;
	case SOAP_TYPE_ns2__CCDCCReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CCDCCReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CCDCCReply*)p = *(ns2__CCDCCReply*)q;
		break;
	case SOAP_TYPE_ns2__CCDCCUpdateReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CCDCCUpdateReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CCDCCUpdateReply*)p = *(ns2__CCDCCUpdateReply*)q;
		break;
	case SOAP_TYPE_ns2__ChinaPaymentReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ChinaPaymentReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ChinaPaymentReply*)p = *(ns2__ChinaPaymentReply*)q;
		break;
	case SOAP_TYPE_ns2__ChinaRefundReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ChinaRefundReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ChinaRefundReply*)p = *(ns2__ChinaRefundReply*)q;
		break;
	case SOAP_TYPE_ns2__BoletoPaymentReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__BoletoPaymentReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__BoletoPaymentReply*)p = *(ns2__BoletoPaymentReply*)q;
		break;
	case SOAP_TYPE_ns2__APInitiateReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APInitiateReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APInitiateReply*)p = *(ns2__APInitiateReply*)q;
		break;
	case SOAP_TYPE_ns2__APCheckStatusReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APCheckStatusReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APCheckStatusReply*)p = *(ns2__APCheckStatusReply*)q;
		break;
	case SOAP_TYPE_ns2__APReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APReply*)p = *(ns2__APReply*)q;
		break;
	case SOAP_TYPE_ns2__APAuthReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APAuthReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APAuthReply*)p = *(ns2__APAuthReply*)q;
		break;
	case SOAP_TYPE_ns2__APAuthReversalReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APAuthReversalReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APAuthReversalReply*)p = *(ns2__APAuthReversalReply*)q;
		break;
	case SOAP_TYPE_ns2__APCaptureReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APCaptureReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APCaptureReply*)p = *(ns2__APCaptureReply*)q;
		break;
	case SOAP_TYPE_ns2__APOptionsReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APOptionsReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APOptionsReply*)p = *(ns2__APOptionsReply*)q;
		break;
	case SOAP_TYPE_ns2__APOptionsOption:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APOptionsOption type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APOptionsOption*)p = *(ns2__APOptionsOption*)q;
		break;
	case SOAP_TYPE_ns2__APRefundReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APRefundReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APRefundReply*)p = *(ns2__APRefundReply*)q;
		break;
	case SOAP_TYPE_ns2__APSaleReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APSaleReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APSaleReply*)p = *(ns2__APSaleReply*)q;
		break;
	case SOAP_TYPE_ns2__APCheckOutDetailsReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APCheckOutDetailsReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APCheckOutDetailsReply*)p = *(ns2__APCheckOutDetailsReply*)q;
		break;
	case SOAP_TYPE_ns2__APTransactionDetailsReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APTransactionDetailsReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APTransactionDetailsReply*)p = *(ns2__APTransactionDetailsReply*)q;
		break;
	case SOAP_TYPE_ns2__APConfirmPurchaseReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__APConfirmPurchaseReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__APConfirmPurchaseReply*)p = *(ns2__APConfirmPurchaseReply*)q;
		break;
	case SOAP_TYPE_ns2__ReplyMessage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ReplyMessage type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ReplyMessage*)p = *(ns2__ReplyMessage*)q;
		break;
	case SOAP_TYPE_ns2__FaultDetails:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__FaultDetails type=%d location=%p object=%p\n", t, p, q));
		*(ns2__FaultDetails*)p = *(ns2__FaultDetails*)q;
		break;
	case SOAP_TYPE_ns2__AirlineData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__AirlineData type=%d location=%p object=%p\n", t, p, q));
		*(ns2__AirlineData*)p = *(ns2__AirlineData*)q;
		break;
	case SOAP_TYPE_ns2__Leg:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Leg type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Leg*)p = *(ns2__Leg*)q;
		break;
	case SOAP_TYPE_ns2__AncillaryData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__AncillaryData type=%d location=%p object=%p\n", t, p, q));
		*(ns2__AncillaryData*)p = *(ns2__AncillaryData*)q;
		break;
	case SOAP_TYPE_ns2__Service:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Service type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Service*)p = *(ns2__Service*)q;
		break;
	case SOAP_TYPE_ns2__LodgingData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__LodgingData type=%d location=%p object=%p\n", t, p, q));
		*(ns2__LodgingData*)p = *(ns2__LodgingData*)q;
		break;
	case SOAP_TYPE_ns2__Pos:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Pos type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Pos*)p = *(ns2__Pos*)q;
		break;
	case SOAP_TYPE_ns2__EncryptedPayment:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__EncryptedPayment type=%d location=%p object=%p\n", t, p, q));
		*(ns2__EncryptedPayment*)p = *(ns2__EncryptedPayment*)q;
		break;
	case SOAP_TYPE_ns2__Installment:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__Installment type=%d location=%p object=%p\n", t, p, q));
		*(ns2__Installment*)p = *(ns2__Installment*)q;
		break;
	case SOAP_TYPE_ns2__MerchantDefinedData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__MerchantDefinedData type=%d location=%p object=%p\n", t, p, q));
		*(ns2__MerchantDefinedData*)p = *(ns2__MerchantDefinedData*)q;
		break;
	case SOAP_TYPE_ns2__MerchantSecureData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__MerchantSecureData type=%d location=%p object=%p\n", t, p, q));
		*(ns2__MerchantSecureData*)p = *(ns2__MerchantSecureData*)q;
		break;
	case SOAP_TYPE_ns2__ReplyReserved:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ReplyReserved type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ReplyReserved*)p = *(ns2__ReplyReserved*)q;
		break;
	case SOAP_TYPE_ns2__RequestReserved:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__RequestReserved type=%d location=%p object=%p\n", t, p, q));
		*(ns2__RequestReserved*)p = *(ns2__RequestReserved*)q;
		break;
	case SOAP_TYPE_ns2__PayPalGetTxnDetailsReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalGetTxnDetailsReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalGetTxnDetailsReply*)p = *(ns2__PayPalGetTxnDetailsReply*)q;
		break;
	case SOAP_TYPE_ns2__PayPalTransactionSearchReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PayPalTransactionSearchReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PayPalTransactionSearchReply*)p = *(ns2__PayPalTransactionSearchReply*)q;
		break;
	case SOAP_TYPE_ns2__PaypalTransaction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__PaypalTransaction type=%d location=%p object=%p\n", t, p, q));
		*(ns2__PaypalTransaction*)p = *(ns2__PaypalTransaction*)q;
		break;
	case SOAP_TYPE_ns2__CCDCCUpdateService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__CCDCCUpdateService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__CCDCCUpdateService*)p = *(ns2__CCDCCUpdateService*)q;
		break;
	case SOAP_TYPE_ns2__ServiceFee:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__ServiceFee type=%d location=%p object=%p\n", t, p, q));
		*(ns2__ServiceFee*)p = *(ns2__ServiceFee*)q;
		break;
	case SOAP_TYPE_ns2__EmvRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__EmvRequest type=%d location=%p object=%p\n", t, p, q));
		*(ns2__EmvRequest*)p = *(ns2__EmvRequest*)q;
		break;
	case SOAP_TYPE_ns2__EmvReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__EmvReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__EmvReply*)p = *(ns2__EmvReply*)q;
		break;
	case SOAP_TYPE_ns2__OriginalTransaction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__OriginalTransaction type=%d location=%p object=%p\n", t, p, q));
		*(ns2__OriginalTransaction*)p = *(ns2__OriginalTransaction*)q;
		break;
	case SOAP_TYPE_ns2__HostedDataCreateService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__HostedDataCreateService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__HostedDataCreateService*)p = *(ns2__HostedDataCreateService*)q;
		break;
	case SOAP_TYPE_ns2__HostedDataRetrieveService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__HostedDataRetrieveService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__HostedDataRetrieveService*)p = *(ns2__HostedDataRetrieveService*)q;
		break;
	case SOAP_TYPE_ns2__HostedDataCreateReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__HostedDataCreateReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__HostedDataCreateReply*)p = *(ns2__HostedDataCreateReply*)q;
		break;
	case SOAP_TYPE_ns2__HostedDataRetrieveReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__HostedDataRetrieveReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__HostedDataRetrieveReply*)p = *(ns2__HostedDataRetrieveReply*)q;
		break;
	case SOAP_TYPE_ns2__AutoRentalData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__AutoRentalData type=%d location=%p object=%p\n", t, p, q));
		*(ns2__AutoRentalData*)p = *(ns2__AutoRentalData*)q;
		break;
	case SOAP_TYPE_ns2__VCReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__VCReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__VCReply*)p = *(ns2__VCReply*)q;
		break;
	case SOAP_TYPE_ns2__VCCardArt:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__VCCardArt type=%d location=%p object=%p\n", t, p, q));
		*(ns2__VCCardArt*)p = *(ns2__VCCardArt*)q;
		break;
	case SOAP_TYPE_ns2__VCCustomData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__VCCustomData type=%d location=%p object=%p\n", t, p, q));
		*(ns2__VCCustomData*)p = *(ns2__VCCustomData*)q;
		break;
	case SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__DecryptVisaCheckoutDataReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__DecryptVisaCheckoutDataReply*)p = *(ns2__DecryptVisaCheckoutDataReply*)q;
		break;
	case SOAP_TYPE_ns2__EncryptPaymentDataReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__EncryptPaymentDataReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__EncryptPaymentDataReply*)p = *(ns2__EncryptPaymentDataReply*)q;
		break;
	case SOAP_TYPE_ns2__BinLookupService:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__BinLookupService type=%d location=%p object=%p\n", t, p, q));
		*(ns2__BinLookupService*)p = *(ns2__BinLookupService*)q;
		break;
	case SOAP_TYPE_ns2__BinLookupReply:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__BinLookupReply type=%d location=%p object=%p\n", t, p, q));
		*(ns2__BinLookupReply*)p = *(ns2__BinLookupReply*)q;
		break;
	case SOAP_TYPE_ns2__issuer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__issuer type=%d location=%p object=%p\n", t, p, q));
		*(ns2__issuer*)p = *(ns2__issuer*)q;
		break;
	case SOAP_TYPE_ns2__MDDField:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns2__MDDField type=%d location=%p object=%p\n", t, p, q));
		*(ns2__MDDField*)p = *(ns2__MDDField*)q;
		break;
	case SOAP_TYPE___ns1__runTransactionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__runTransactionResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__runTransactionResponse*)p = *(struct __ns1__runTransactionResponse*)q;
		break;
	case SOAP_TYPE___ns1__runTransaction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__runTransaction type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__runTransaction*)p = *(struct __ns1__runTransaction*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE__ds__Signature:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__SignatureType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__SignatureType*)p = *(struct ds__SignatureType*)q;
		break;
	case SOAP_TYPE__ds__Transform:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__TransformType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__TransformType*)p = *(struct ds__TransformType*)q;
		break;
	case SOAP_TYPE__ds__KeyInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ds__KeyInfoType type=%d location=%p object=%p\n", t, p, q));
		*(struct ds__KeyInfoType*)p = *(struct ds__KeyInfoType*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag?tag:"byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag?tag:"int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ULONG64(struct soap *soap, ULONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ULONG64
	*a = SOAP_DEFAULT_ULONG64;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ULONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_ULONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_ULONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	a = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_ULONG64);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ULONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	if (soap_out_ULONG64(soap, tag?tag:"unsignedLong", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_ULONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ULONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__FaultCodeType(struct soap *soap, enum wsc__FaultCodeType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsc__FaultCodeType
	*a = SOAP_DEFAULT_wsc__FaultCodeType;
#else
	*a = (enum wsc__FaultCodeType)0;
#endif
}

static const struct soap_code_map soap_codes_wsc__FaultCodeType[] =
{	{ (LONG64)wsc__BadContextToken, "wsc:BadContextToken" },
	{ (LONG64)wsc__UnsupportedContextToken, "wsc:UnsupportedContextToken" },
	{ (LONG64)wsc__UnknownDerivationSource, "wsc:UnknownDerivationSource" },
	{ (LONG64)wsc__RenewNeeded, "wsc:RenewNeeded" },
	{ (LONG64)wsc__UnableToRenew, "wsc:UnableToRenew" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsc__FaultCodeType2s(struct soap *soap, enum wsc__FaultCodeType n)
{	const char *s = soap_code_str(soap_codes_wsc__FaultCodeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__FaultCodeType(struct soap *soap, const char *tag, int id, const enum wsc__FaultCodeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__FaultCodeType), type) || soap_send(soap, soap_wsc__FaultCodeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsc__FaultCodeType(struct soap *soap, const char *s, enum wsc__FaultCodeType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsc__FaultCodeType, t);
	if (map)
		*a = (enum wsc__FaultCodeType)map->code;
	else
	{	LONG64 n;
		if (soap_s2LONG64(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum wsc__FaultCodeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsc__FaultCodeType * SOAP_FMAC4 soap_in_wsc__FaultCodeType(struct soap *soap, const char *tag, enum wsc__FaultCodeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsc__FaultCodeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__FaultCodeType, sizeof(enum wsc__FaultCodeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2wsc__FaultCodeType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsc__FaultCodeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__FaultCodeType, SOAP_TYPE_wsc__FaultCodeType, sizeof(enum wsc__FaultCodeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__FaultCodeType(struct soap *soap, const enum wsc__FaultCodeType *a, const char *tag, const char *type)
{
	if (soap_out_wsc__FaultCodeType(soap, tag?tag:"wsc:FaultCodeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsc__FaultCodeType * SOAP_FMAC4 soap_get_wsc__FaultCodeType(struct soap *soap, enum wsc__FaultCodeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__FaultCodeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsse__FaultcodeEnum
	*a = SOAP_DEFAULT_wsse__FaultcodeEnum;
#else
	*a = (enum wsse__FaultcodeEnum)0;
#endif
}

static const struct soap_code_map soap_codes_wsse__FaultcodeEnum[] =
{	{ (LONG64)wsse__UnsupportedSecurityToken, "wsse:UnsupportedSecurityToken" },
	{ (LONG64)wsse__UnsupportedAlgorithm, "wsse:UnsupportedAlgorithm" },
	{ (LONG64)wsse__InvalidSecurity, "wsse:InvalidSecurity" },
	{ (LONG64)wsse__InvalidSecurityToken, "wsse:InvalidSecurityToken" },
	{ (LONG64)wsse__FailedAuthentication, "wsse:FailedAuthentication" },
	{ (LONG64)wsse__FailedCheck, "wsse:FailedCheck" },
	{ (LONG64)wsse__SecurityTokenUnavailable, "wsse:SecurityTokenUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsse__FaultcodeEnum2s(struct soap *soap, enum wsse__FaultcodeEnum n)
{	const char *s = soap_code_str(soap_codes_wsse__FaultcodeEnum, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsse__FaultcodeEnum(struct soap *soap, const char *tag, int id, const enum wsse__FaultcodeEnum *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsse__FaultcodeEnum), type) || soap_send(soap, soap_wsse__FaultcodeEnum2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsse__FaultcodeEnum(struct soap *soap, const char *s, enum wsse__FaultcodeEnum *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsse__FaultcodeEnum, t);
	if (map)
		*a = (enum wsse__FaultcodeEnum)map->code;
	else
	{	LONG64 n;
		if (soap_s2LONG64(soap, s, &n) || n < 0 || n > 6)
			return soap->error = SOAP_TYPE;
		*a = (enum wsse__FaultcodeEnum)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_in_wsse__FaultcodeEnum(struct soap *soap, const char *tag, enum wsse__FaultcodeEnum *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsse__FaultcodeEnum *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2wsse__FaultcodeEnum(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsse__FaultcodeEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsse__FaultcodeEnum, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsse__FaultcodeEnum(struct soap *soap, const enum wsse__FaultcodeEnum *a, const char *tag, const char *type)
{
	if (soap_out_wsse__FaultcodeEnum(soap, tag?tag:"wsse:FaultcodeEnum", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_get_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsse__FaultcodeEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsu__tTimestampFault
	*a = SOAP_DEFAULT_wsu__tTimestampFault;
#else
	*a = (enum wsu__tTimestampFault)0;
#endif
}

static const struct soap_code_map soap_codes_wsu__tTimestampFault[] =
{	{ (LONG64)wsu__MessageExpired, "wsu:MessageExpired" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsu__tTimestampFault2s(struct soap *soap, enum wsu__tTimestampFault n)
{	const char *s = soap_code_str(soap_codes_wsu__tTimestampFault, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsu__tTimestampFault(struct soap *soap, const char *tag, int id, const enum wsu__tTimestampFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsu__tTimestampFault), type) || soap_send(soap, soap_wsu__tTimestampFault2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsu__tTimestampFault(struct soap *soap, const char *s, enum wsu__tTimestampFault *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsu__tTimestampFault, t);
	if (map)
		*a = (enum wsu__tTimestampFault)map->code;
	else
	{	LONG64 n;
		if (soap_s2LONG64(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsu__tTimestampFault)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_in_wsu__tTimestampFault(struct soap *soap, const char *tag, enum wsu__tTimestampFault *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsu__tTimestampFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2wsu__tTimestampFault(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsu__tTimestampFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsu__tTimestampFault, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsu__tTimestampFault(struct soap *soap, const enum wsu__tTimestampFault *a, const char *tag, const char *type)
{
	if (soap_out_wsu__tTimestampFault(soap, tag?tag:"wsu:tTimestampFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_get_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsu__tTimestampFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__issuer::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__issuer::additionalData = NULL;
	/* transient soap skipped */
}

void ns2__issuer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__issuer::additionalData);
#endif
}

int ns2__issuer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__issuer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__issuer(struct soap *soap, const char *tag, int id, const ns2__issuer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__issuer), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:additionalData", -1, (wchar_t*const*)&a->ns2__issuer::additionalData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__issuer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__issuer(soap, tag, this, type);
}

SOAP_FMAC3 ns2__issuer * SOAP_FMAC4 soap_in_ns2__issuer(struct soap *soap, const char *tag, ns2__issuer *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__issuer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__issuer, sizeof(ns2__issuer), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__issuer)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__issuer *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_additionalData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_additionalData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:additionalData", (wchar_t**)&a->ns2__issuer::additionalData, "xsd:string"))
				{	soap_flag_additionalData1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__issuer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__issuer, SOAP_TYPE_ns2__issuer, sizeof(ns2__issuer), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__issuer * SOAP_FMAC2 soap_instantiate_ns2__issuer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__issuer(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__issuer *p;
	size_t k = sizeof(ns2__issuer);
	if (n < 0)
	{	p = SOAP_NEW(ns2__issuer);
		if (p)
			((ns2__issuer*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__issuer, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__issuer*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__issuer location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__issuer, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__issuer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:issuer", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__issuer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__issuer(soap, this, tag, type);
}

SOAP_FMAC3 ns2__issuer * SOAP_FMAC4 soap_get_ns2__issuer(struct soap *soap, ns2__issuer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__issuer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__BinLookupReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__BinLookupReply::reasonCode = NULL;
	this->ns2__BinLookupReply::cardType = NULL;
	this->ns2__BinLookupReply::cardGroup = NULL;
	this->ns2__BinLookupReply::issuerName = NULL;
	this->ns2__BinLookupReply::issuerCountry = NULL;
	this->ns2__BinLookupReply::issuedCurrency = NULL;
	this->ns2__BinLookupReply::level2Eligibility = NULL;
	this->ns2__BinLookupReply::level3Eligibility = NULL;
	this->ns2__BinLookupReply::cardCategory = NULL;
	this->ns2__BinLookupReply::crossBorderIndicator = NULL;
	this->ns2__BinLookupReply::issuerPhoneNumber = NULL;
	this->ns2__BinLookupReply::billingCurrency = NULL;
	this->ns2__BinLookupReply::billingCurrencyMinorDigits = NULL;
	this->ns2__BinLookupReply::fastFundsIndicator = NULL;
	this->ns2__BinLookupReply::octBlockIndicator = NULL;
	this->ns2__BinLookupReply::onlineGamblingBlockIndicator = NULL;
	this->ns2__BinLookupReply::requestDateTime = NULL;
	/* transient soap skipped */
}

void ns2__BinLookupReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__BinLookupReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BinLookupReply::cardType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BinLookupReply::cardGroup);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BinLookupReply::issuerName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BinLookupReply::issuerCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BinLookupReply::issuedCurrency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BinLookupReply::level2Eligibility);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BinLookupReply::level3Eligibility);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BinLookupReply::cardCategory);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BinLookupReply::crossBorderIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BinLookupReply::issuerPhoneNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BinLookupReply::billingCurrency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BinLookupReply::billingCurrencyMinorDigits);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BinLookupReply::fastFundsIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BinLookupReply::octBlockIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BinLookupReply::onlineGamblingBlockIndicator);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__BinLookupReply::requestDateTime);
#endif
}

int ns2__BinLookupReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__BinLookupReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BinLookupReply(struct soap *soap, const char *tag, int id, const ns2__BinLookupReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BinLookupReply), type))
		return soap->error;
	if (!a->ns2__BinLookupReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__BinLookupReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardType", -1, (wchar_t*const*)&a->ns2__BinLookupReply::cardType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardGroup", -1, (wchar_t*const*)&a->ns2__BinLookupReply::cardGroup, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:issuerName", -1, (wchar_t*const*)&a->ns2__BinLookupReply::issuerName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:issuerCountry", -1, (wchar_t*const*)&a->ns2__BinLookupReply::issuerCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:issuedCurrency", -1, (wchar_t*const*)&a->ns2__BinLookupReply::issuedCurrency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:level2Eligibility", -1, (wchar_t*const*)&a->ns2__BinLookupReply::level2Eligibility, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:level3Eligibility", -1, (wchar_t*const*)&a->ns2__BinLookupReply::level3Eligibility, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardCategory", -1, (wchar_t*const*)&a->ns2__BinLookupReply::cardCategory, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:crossBorderIndicator", -1, (wchar_t*const*)&a->ns2__BinLookupReply::crossBorderIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:issuerPhoneNumber", -1, (wchar_t*const*)&a->ns2__BinLookupReply::issuerPhoneNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:billingCurrency", -1, (wchar_t*const*)&a->ns2__BinLookupReply::billingCurrency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:billingCurrencyMinorDigits", -1, (wchar_t*const*)&a->ns2__BinLookupReply::billingCurrencyMinorDigits, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:fastFundsIndicator", -1, (wchar_t*const*)&a->ns2__BinLookupReply::fastFundsIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:octBlockIndicator", -1, (wchar_t*const*)&a->ns2__BinLookupReply::octBlockIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:onlineGamblingBlockIndicator", -1, (wchar_t*const*)&a->ns2__BinLookupReply::onlineGamblingBlockIndicator, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__BinLookupReply::requestDateTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__BinLookupReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__BinLookupReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__BinLookupReply * SOAP_FMAC4 soap_in_ns2__BinLookupReply(struct soap *soap, const char *tag, ns2__BinLookupReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__BinLookupReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BinLookupReply, sizeof(ns2__BinLookupReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__BinLookupReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__BinLookupReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_cardType1 = 1;
	size_t soap_flag_cardGroup1 = 1;
	size_t soap_flag_issuerName1 = 1;
	size_t soap_flag_issuerCountry1 = 1;
	size_t soap_flag_issuedCurrency1 = 1;
	size_t soap_flag_level2Eligibility1 = 1;
	size_t soap_flag_level3Eligibility1 = 1;
	size_t soap_flag_cardCategory1 = 1;
	size_t soap_flag_crossBorderIndicator1 = 1;
	size_t soap_flag_issuerPhoneNumber1 = 1;
	size_t soap_flag_billingCurrency1 = 1;
	size_t soap_flag_billingCurrencyMinorDigits1 = 1;
	size_t soap_flag_fastFundsIndicator1 = 1;
	size_t soap_flag_octBlockIndicator1 = 1;
	size_t soap_flag_onlineGamblingBlockIndicator1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__BinLookupReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_cardType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardType", (wchar_t**)&a->ns2__BinLookupReply::cardType, "xsd:string"))
				{	soap_flag_cardType1--;
					continue;
				}
			if (soap_flag_cardGroup1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardGroup", (wchar_t**)&a->ns2__BinLookupReply::cardGroup, "xsd:string"))
				{	soap_flag_cardGroup1--;
					continue;
				}
			if (soap_flag_issuerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:issuerName", (wchar_t**)&a->ns2__BinLookupReply::issuerName, "xsd:string"))
				{	soap_flag_issuerName1--;
					continue;
				}
			if (soap_flag_issuerCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:issuerCountry", (wchar_t**)&a->ns2__BinLookupReply::issuerCountry, "xsd:string"))
				{	soap_flag_issuerCountry1--;
					continue;
				}
			if (soap_flag_issuedCurrency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:issuedCurrency", (wchar_t**)&a->ns2__BinLookupReply::issuedCurrency, "xsd:string"))
				{	soap_flag_issuedCurrency1--;
					continue;
				}
			if (soap_flag_level2Eligibility1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:level2Eligibility", (wchar_t**)&a->ns2__BinLookupReply::level2Eligibility, "xsd:string"))
				{	soap_flag_level2Eligibility1--;
					continue;
				}
			if (soap_flag_level3Eligibility1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:level3Eligibility", (wchar_t**)&a->ns2__BinLookupReply::level3Eligibility, "xsd:string"))
				{	soap_flag_level3Eligibility1--;
					continue;
				}
			if (soap_flag_cardCategory1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardCategory", (wchar_t**)&a->ns2__BinLookupReply::cardCategory, "xsd:string"))
				{	soap_flag_cardCategory1--;
					continue;
				}
			if (soap_flag_crossBorderIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:crossBorderIndicator", (wchar_t**)&a->ns2__BinLookupReply::crossBorderIndicator, "xsd:string"))
				{	soap_flag_crossBorderIndicator1--;
					continue;
				}
			if (soap_flag_issuerPhoneNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:issuerPhoneNumber", (wchar_t**)&a->ns2__BinLookupReply::issuerPhoneNumber, "xsd:string"))
				{	soap_flag_issuerPhoneNumber1--;
					continue;
				}
			if (soap_flag_billingCurrency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:billingCurrency", (wchar_t**)&a->ns2__BinLookupReply::billingCurrency, "xsd:string"))
				{	soap_flag_billingCurrency1--;
					continue;
				}
			if (soap_flag_billingCurrencyMinorDigits1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:billingCurrencyMinorDigits", (wchar_t**)&a->ns2__BinLookupReply::billingCurrencyMinorDigits, "xsd:string"))
				{	soap_flag_billingCurrencyMinorDigits1--;
					continue;
				}
			if (soap_flag_fastFundsIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:fastFundsIndicator", (wchar_t**)&a->ns2__BinLookupReply::fastFundsIndicator, "xsd:string"))
				{	soap_flag_fastFundsIndicator1--;
					continue;
				}
			if (soap_flag_octBlockIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:octBlockIndicator", (wchar_t**)&a->ns2__BinLookupReply::octBlockIndicator, "xsd:string"))
				{	soap_flag_octBlockIndicator1--;
					continue;
				}
			if (soap_flag_onlineGamblingBlockIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:onlineGamblingBlockIndicator", (wchar_t**)&a->ns2__BinLookupReply::onlineGamblingBlockIndicator, "xsd:string"))
				{	soap_flag_onlineGamblingBlockIndicator1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__BinLookupReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__BinLookupReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BinLookupReply, SOAP_TYPE_ns2__BinLookupReply, sizeof(ns2__BinLookupReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__BinLookupReply * SOAP_FMAC2 soap_instantiate_ns2__BinLookupReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__BinLookupReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__BinLookupReply *p;
	size_t k = sizeof(ns2__BinLookupReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__BinLookupReply);
		if (p)
			((ns2__BinLookupReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__BinLookupReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__BinLookupReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__BinLookupReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__BinLookupReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__BinLookupReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:BinLookupReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__BinLookupReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__BinLookupReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__BinLookupReply * SOAP_FMAC4 soap_get_ns2__BinLookupReply(struct soap *soap, ns2__BinLookupReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BinLookupReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__BinLookupService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__BinLookupService::run = NULL;
	/* transient soap skipped */
}

void ns2__BinLookupService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__BinLookupService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__BinLookupService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BinLookupService(struct soap *soap, const char *tag, int id, const ns2__BinLookupService *a, const char *type)
{
	if (((ns2__BinLookupService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__BinLookupService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BinLookupService), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__BinLookupService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__BinLookupService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__BinLookupService * SOAP_FMAC4 soap_in_ns2__BinLookupService(struct soap *soap, const char *tag, ns2__BinLookupService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__BinLookupService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BinLookupService, sizeof(ns2__BinLookupService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__BinLookupService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__BinLookupService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__BinLookupService*)a)->run))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__BinLookupService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BinLookupService, SOAP_TYPE_ns2__BinLookupService, sizeof(ns2__BinLookupService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__BinLookupService * SOAP_FMAC2 soap_instantiate_ns2__BinLookupService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__BinLookupService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__BinLookupService *p;
	size_t k = sizeof(ns2__BinLookupService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__BinLookupService);
		if (p)
			((ns2__BinLookupService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__BinLookupService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__BinLookupService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__BinLookupService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__BinLookupService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__BinLookupService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:BinLookupService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__BinLookupService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__BinLookupService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__BinLookupService * SOAP_FMAC4 soap_get_ns2__BinLookupService(struct soap *soap, ns2__BinLookupService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BinLookupService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__EncryptPaymentDataReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__EncryptPaymentDataReply::reasonCode = NULL;
	this->ns2__EncryptPaymentDataReply::requestDateTime = NULL;
	/* transient soap skipped */
}

void ns2__EncryptPaymentDataReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__EncryptPaymentDataReply::reasonCode);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__EncryptPaymentDataReply::requestDateTime);
#endif
}

int ns2__EncryptPaymentDataReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__EncryptPaymentDataReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EncryptPaymentDataReply(struct soap *soap, const char *tag, int id, const ns2__EncryptPaymentDataReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EncryptPaymentDataReply), type))
		return soap->error;
	if (!a->ns2__EncryptPaymentDataReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__EncryptPaymentDataReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__EncryptPaymentDataReply::requestDateTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__EncryptPaymentDataReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__EncryptPaymentDataReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__EncryptPaymentDataReply * SOAP_FMAC4 soap_in_ns2__EncryptPaymentDataReply(struct soap *soap, const char *tag, ns2__EncryptPaymentDataReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__EncryptPaymentDataReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EncryptPaymentDataReply, sizeof(ns2__EncryptPaymentDataReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__EncryptPaymentDataReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__EncryptPaymentDataReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__EncryptPaymentDataReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__EncryptPaymentDataReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__EncryptPaymentDataReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EncryptPaymentDataReply, SOAP_TYPE_ns2__EncryptPaymentDataReply, sizeof(ns2__EncryptPaymentDataReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__EncryptPaymentDataReply * SOAP_FMAC2 soap_instantiate_ns2__EncryptPaymentDataReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__EncryptPaymentDataReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__EncryptPaymentDataReply *p;
	size_t k = sizeof(ns2__EncryptPaymentDataReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__EncryptPaymentDataReply);
		if (p)
			((ns2__EncryptPaymentDataReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__EncryptPaymentDataReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__EncryptPaymentDataReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__EncryptPaymentDataReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__EncryptPaymentDataReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__EncryptPaymentDataReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:EncryptPaymentDataReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__EncryptPaymentDataReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__EncryptPaymentDataReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__EncryptPaymentDataReply * SOAP_FMAC4 soap_get_ns2__EncryptPaymentDataReply(struct soap *soap, ns2__EncryptPaymentDataReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EncryptPaymentDataReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DecryptVisaCheckoutDataReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DecryptVisaCheckoutDataReply::reasonCode = NULL;
	/* transient soap skipped */
}

void ns2__DecryptVisaCheckoutDataReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__DecryptVisaCheckoutDataReply::reasonCode);
#endif
}

int ns2__DecryptVisaCheckoutDataReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DecryptVisaCheckoutDataReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DecryptVisaCheckoutDataReply(struct soap *soap, const char *tag, int id, const ns2__DecryptVisaCheckoutDataReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply), type))
		return soap->error;
	if (!a->ns2__DecryptVisaCheckoutDataReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__DecryptVisaCheckoutDataReply::reasonCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DecryptVisaCheckoutDataReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DecryptVisaCheckoutDataReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DecryptVisaCheckoutDataReply * SOAP_FMAC4 soap_in_ns2__DecryptVisaCheckoutDataReply(struct soap *soap, const char *tag, ns2__DecryptVisaCheckoutDataReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DecryptVisaCheckoutDataReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply, sizeof(ns2__DecryptVisaCheckoutDataReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DecryptVisaCheckoutDataReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__DecryptVisaCheckoutDataReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__DecryptVisaCheckoutDataReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply, SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply, sizeof(ns2__DecryptVisaCheckoutDataReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DecryptVisaCheckoutDataReply * SOAP_FMAC2 soap_instantiate_ns2__DecryptVisaCheckoutDataReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DecryptVisaCheckoutDataReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DecryptVisaCheckoutDataReply *p;
	size_t k = sizeof(ns2__DecryptVisaCheckoutDataReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DecryptVisaCheckoutDataReply);
		if (p)
			((ns2__DecryptVisaCheckoutDataReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DecryptVisaCheckoutDataReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DecryptVisaCheckoutDataReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DecryptVisaCheckoutDataReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DecryptVisaCheckoutDataReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:DecryptVisaCheckoutDataReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DecryptVisaCheckoutDataReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DecryptVisaCheckoutDataReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DecryptVisaCheckoutDataReply * SOAP_FMAC4 soap_get_ns2__DecryptVisaCheckoutDataReply(struct soap *soap, ns2__DecryptVisaCheckoutDataReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DecryptVisaCheckoutDataReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__VCCustomData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__VCCustomData::name = NULL;
	this->ns2__VCCustomData::value = NULL;
	this->ns2__VCCustomData::id = NULL;
	/* transient soap skipped */
}

void ns2__VCCustomData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCCustomData::name);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCCustomData::value);
#endif
}

int ns2__VCCustomData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__VCCustomData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VCCustomData(struct soap *soap, const char *tag, int id, const ns2__VCCustomData *a, const char *type)
{
	if (((ns2__VCCustomData*)a)->id)
		if (*((ns2__VCCustomData*)a)->id)
			soap_set_attr(soap, "id", soap_xsd__integer2s(soap, *((ns2__VCCustomData*)a)->id), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VCCustomData), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:name", -1, (wchar_t*const*)&a->ns2__VCCustomData::name, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:value", -1, (wchar_t*const*)&a->ns2__VCCustomData::value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__VCCustomData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__VCCustomData(soap, tag, this, type);
}

SOAP_FMAC3 ns2__VCCustomData * SOAP_FMAC4 soap_in_ns2__VCCustomData(struct soap *soap, const char *tag, ns2__VCCustomData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__VCCustomData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VCCustomData, sizeof(ns2__VCCustomData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__VCCustomData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__VCCustomData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "id", 0);
		if (t)
		{
			if (!(((ns2__VCCustomData*)a)->id = (wchar_t **)soap_malloc(soap, sizeof(wchar_t *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__integer(soap, t, ((ns2__VCCustomData*)a)->id))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:name", (wchar_t**)&a->ns2__VCCustomData::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:value", (wchar_t**)&a->ns2__VCCustomData::value, "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__VCCustomData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VCCustomData, SOAP_TYPE_ns2__VCCustomData, sizeof(ns2__VCCustomData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__VCCustomData * SOAP_FMAC2 soap_instantiate_ns2__VCCustomData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__VCCustomData(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__VCCustomData *p;
	size_t k = sizeof(ns2__VCCustomData);
	if (n < 0)
	{	p = SOAP_NEW(ns2__VCCustomData);
		if (p)
			((ns2__VCCustomData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__VCCustomData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__VCCustomData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__VCCustomData location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__VCCustomData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__VCCustomData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:VCCustomData", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__VCCustomData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__VCCustomData(soap, this, tag, type);
}

SOAP_FMAC3 ns2__VCCustomData * SOAP_FMAC4 soap_get_ns2__VCCustomData(struct soap *soap, ns2__VCCustomData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VCCustomData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__VCCardArt::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__VCCardArt::fileName = NULL;
	this->ns2__VCCardArt::height = NULL;
	this->ns2__VCCardArt::width = NULL;
	this->ns2__VCCardArt::id = NULL;
	/* transient soap skipped */
}

void ns2__VCCardArt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCCardArt::fileName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCCardArt::height);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCCardArt::width);
#endif
}

int ns2__VCCardArt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__VCCardArt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VCCardArt(struct soap *soap, const char *tag, int id, const ns2__VCCardArt *a, const char *type)
{
	if (((ns2__VCCardArt*)a)->id)
		if (*((ns2__VCCardArt*)a)->id)
			soap_set_attr(soap, "id", soap_xsd__integer2s(soap, *((ns2__VCCardArt*)a)->id), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VCCardArt), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:fileName", -1, (wchar_t*const*)&a->ns2__VCCardArt::fileName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:height", -1, (wchar_t*const*)&a->ns2__VCCardArt::height, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:width", -1, (wchar_t*const*)&a->ns2__VCCardArt::width, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__VCCardArt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__VCCardArt(soap, tag, this, type);
}

SOAP_FMAC3 ns2__VCCardArt * SOAP_FMAC4 soap_in_ns2__VCCardArt(struct soap *soap, const char *tag, ns2__VCCardArt *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__VCCardArt *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VCCardArt, sizeof(ns2__VCCardArt), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__VCCardArt)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__VCCardArt *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "id", 0);
		if (t)
		{
			if (!(((ns2__VCCardArt*)a)->id = (wchar_t **)soap_malloc(soap, sizeof(wchar_t *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__integer(soap, t, ((ns2__VCCardArt*)a)->id))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_fileName1 = 1;
	size_t soap_flag_height1 = 1;
	size_t soap_flag_width1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:fileName", (wchar_t**)&a->ns2__VCCardArt::fileName, "xsd:string"))
				{	soap_flag_fileName1--;
					continue;
				}
			if (soap_flag_height1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:height", (wchar_t**)&a->ns2__VCCardArt::height, "xsd:string"))
				{	soap_flag_height1--;
					continue;
				}
			if (soap_flag_width1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:width", (wchar_t**)&a->ns2__VCCardArt::width, "xsd:string"))
				{	soap_flag_width1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__VCCardArt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VCCardArt, SOAP_TYPE_ns2__VCCardArt, sizeof(ns2__VCCardArt), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__VCCardArt * SOAP_FMAC2 soap_instantiate_ns2__VCCardArt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__VCCardArt(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__VCCardArt *p;
	size_t k = sizeof(ns2__VCCardArt);
	if (n < 0)
	{	p = SOAP_NEW(ns2__VCCardArt);
		if (p)
			((ns2__VCCardArt*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__VCCardArt, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__VCCardArt*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__VCCardArt location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__VCCardArt, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__VCCardArt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:VCCardArt", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__VCCardArt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__VCCardArt(soap, this, tag, type);
}

SOAP_FMAC3 ns2__VCCardArt * SOAP_FMAC4 soap_get_ns2__VCCardArt(struct soap *soap, ns2__VCCardArt *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VCCardArt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__VCReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__VCReply::creationTimeStamp = NULL;
	this->ns2__VCReply::alternateShippingAddressCountryCode = NULL;
	this->ns2__VCReply::alternateShippingAddressPostalCode = NULL;
	this->ns2__VCReply::vcAccountLoginName = NULL;
	this->ns2__VCReply::vcAccountFirstName = NULL;
	this->ns2__VCReply::vcAccountLastName = NULL;
	this->ns2__VCReply::vcAccountEncryptedID = NULL;
	this->ns2__VCReply::vcAccountEmail = NULL;
	this->ns2__VCReply::vcAccountMobilePhoneNumber = NULL;
	this->ns2__VCReply::merchantReferenceID = NULL;
	this->ns2__VCReply::subtotalAmount = NULL;
	this->ns2__VCReply::shippingHandlingAmount = NULL;
	this->ns2__VCReply::taxAmount = NULL;
	this->ns2__VCReply::discountAmount = NULL;
	this->ns2__VCReply::giftWrapAmount = NULL;
	this->ns2__VCReply::uncategorizedAmount = NULL;
	this->ns2__VCReply::totalPurchaseAmount = NULL;
	this->ns2__VCReply::walletReferenceID = NULL;
	this->ns2__VCReply::promotionCode = NULL;
	this->ns2__VCReply::paymentInstrumentID = NULL;
	this->ns2__VCReply::cardVerificationStatus = NULL;
	this->ns2__VCReply::issuerID = NULL;
	this->ns2__VCReply::paymentInstrumentNickName = NULL;
	this->ns2__VCReply::nameOnCard = NULL;
	this->ns2__VCReply::cardType = NULL;
	this->ns2__VCReply::cardGroup = NULL;
	this->ns2__VCReply::cardArt = NULL;
	this->ns2__VCReply::riskAdvice = NULL;
	this->ns2__VCReply::riskScore = NULL;
	this->ns2__VCReply::riskAdditionalData = NULL;
	this->ns2__VCReply::avsCodeRaw = NULL;
	this->ns2__VCReply::cvnCodeRaw = NULL;
	this->ns2__VCReply::eciRaw = NULL;
	this->ns2__VCReply::eci = NULL;
	this->ns2__VCReply::cavv = NULL;
	this->ns2__VCReply::veresEnrolled = NULL;
	this->ns2__VCReply::veresTimeStamp = NULL;
	this->ns2__VCReply::paresStatus = NULL;
	this->ns2__VCReply::paresTimeStamp = NULL;
	this->ns2__VCReply::xid = NULL;
	this->ns2__VCReply::customData = NULL;
	/* transient soap skipped */
}

void ns2__VCReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::creationTimeStamp);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::alternateShippingAddressCountryCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::alternateShippingAddressPostalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::vcAccountLoginName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::vcAccountFirstName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::vcAccountLastName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::vcAccountEncryptedID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::vcAccountEmail);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::vcAccountMobilePhoneNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::merchantReferenceID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::subtotalAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::shippingHandlingAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::taxAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::discountAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::giftWrapAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::uncategorizedAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::totalPurchaseAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::walletReferenceID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::promotionCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::paymentInstrumentID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::cardVerificationStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::issuerID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::paymentInstrumentNickName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::nameOnCard);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::cardType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::cardGroup);
	soap_serialize_PointerTons2__VCCardArt(soap, &this->ns2__VCReply::cardArt);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::riskAdvice);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::riskScore);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::riskAdditionalData);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::avsCodeRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::cvnCodeRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::eciRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::eci);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::cavv);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::veresEnrolled);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::veresTimeStamp);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::paresStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::paresTimeStamp);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VCReply::xid);
	soap_serialize_PointerTons2__VCCustomData(soap, &this->ns2__VCReply::customData);
#endif
}

int ns2__VCReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__VCReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VCReply(struct soap *soap, const char *tag, int id, const ns2__VCReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VCReply), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:creationTimeStamp", -1, (wchar_t*const*)&a->ns2__VCReply::creationTimeStamp, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:alternateShippingAddressCountryCode", -1, (wchar_t*const*)&a->ns2__VCReply::alternateShippingAddressCountryCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:alternateShippingAddressPostalCode", -1, (wchar_t*const*)&a->ns2__VCReply::alternateShippingAddressPostalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:vcAccountLoginName", -1, (wchar_t*const*)&a->ns2__VCReply::vcAccountLoginName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:vcAccountFirstName", -1, (wchar_t*const*)&a->ns2__VCReply::vcAccountFirstName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:vcAccountLastName", -1, (wchar_t*const*)&a->ns2__VCReply::vcAccountLastName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:vcAccountEncryptedID", -1, (wchar_t*const*)&a->ns2__VCReply::vcAccountEncryptedID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:vcAccountEmail", -1, (wchar_t*const*)&a->ns2__VCReply::vcAccountEmail, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:vcAccountMobilePhoneNumber", -1, (wchar_t*const*)&a->ns2__VCReply::vcAccountMobilePhoneNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantReferenceID", -1, (wchar_t*const*)&a->ns2__VCReply::merchantReferenceID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:subtotalAmount", -1, (wchar_t*const*)&a->ns2__VCReply::subtotalAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shippingHandlingAmount", -1, (wchar_t*const*)&a->ns2__VCReply::shippingHandlingAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:taxAmount", -1, (wchar_t*const*)&a->ns2__VCReply::taxAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:discountAmount", -1, (wchar_t*const*)&a->ns2__VCReply::discountAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:giftWrapAmount", -1, (wchar_t*const*)&a->ns2__VCReply::giftWrapAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:uncategorizedAmount", -1, (wchar_t*const*)&a->ns2__VCReply::uncategorizedAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:totalPurchaseAmount", -1, (wchar_t*const*)&a->ns2__VCReply::totalPurchaseAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:walletReferenceID", -1, (wchar_t*const*)&a->ns2__VCReply::walletReferenceID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:promotionCode", -1, (wchar_t*const*)&a->ns2__VCReply::promotionCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentInstrumentID", -1, (wchar_t*const*)&a->ns2__VCReply::paymentInstrumentID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardVerificationStatus", -1, (wchar_t*const*)&a->ns2__VCReply::cardVerificationStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:issuerID", -1, (wchar_t*const*)&a->ns2__VCReply::issuerID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentInstrumentNickName", -1, (wchar_t*const*)&a->ns2__VCReply::paymentInstrumentNickName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:nameOnCard", -1, (wchar_t*const*)&a->ns2__VCReply::nameOnCard, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardType", -1, (wchar_t*const*)&a->ns2__VCReply::cardType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardGroup", -1, (wchar_t*const*)&a->ns2__VCReply::cardGroup, ""))
		return soap->error;
	if (soap_out_PointerTons2__VCCardArt(soap, "ns2:cardArt", -1, &a->ns2__VCReply::cardArt, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:riskAdvice", -1, (wchar_t*const*)&a->ns2__VCReply::riskAdvice, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:riskScore", -1, (wchar_t*const*)&a->ns2__VCReply::riskScore, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:riskAdditionalData", -1, (wchar_t*const*)&a->ns2__VCReply::riskAdditionalData, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:avsCodeRaw", -1, (wchar_t*const*)&a->ns2__VCReply::avsCodeRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cvnCodeRaw", -1, (wchar_t*const*)&a->ns2__VCReply::cvnCodeRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:eciRaw", -1, (wchar_t*const*)&a->ns2__VCReply::eciRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:eci", -1, (wchar_t*const*)&a->ns2__VCReply::eci, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cavv", -1, (wchar_t*const*)&a->ns2__VCReply::cavv, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:veresEnrolled", -1, (wchar_t*const*)&a->ns2__VCReply::veresEnrolled, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:veresTimeStamp", -1, (wchar_t*const*)&a->ns2__VCReply::veresTimeStamp, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paresStatus", -1, (wchar_t*const*)&a->ns2__VCReply::paresStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paresTimeStamp", -1, (wchar_t*const*)&a->ns2__VCReply::paresTimeStamp, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:xid", -1, (wchar_t*const*)&a->ns2__VCReply::xid, ""))
		return soap->error;
	if (soap_out_PointerTons2__VCCustomData(soap, "ns2:customData", -1, &a->ns2__VCReply::customData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__VCReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__VCReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__VCReply * SOAP_FMAC4 soap_in_ns2__VCReply(struct soap *soap, const char *tag, ns2__VCReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__VCReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VCReply, sizeof(ns2__VCReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__VCReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__VCReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_creationTimeStamp1 = 1;
	size_t soap_flag_alternateShippingAddressCountryCode1 = 1;
	size_t soap_flag_alternateShippingAddressPostalCode1 = 1;
	size_t soap_flag_vcAccountLoginName1 = 1;
	size_t soap_flag_vcAccountFirstName1 = 1;
	size_t soap_flag_vcAccountLastName1 = 1;
	size_t soap_flag_vcAccountEncryptedID1 = 1;
	size_t soap_flag_vcAccountEmail1 = 1;
	size_t soap_flag_vcAccountMobilePhoneNumber1 = 1;
	size_t soap_flag_merchantReferenceID1 = 1;
	size_t soap_flag_subtotalAmount1 = 1;
	size_t soap_flag_shippingHandlingAmount1 = 1;
	size_t soap_flag_taxAmount1 = 1;
	size_t soap_flag_discountAmount1 = 1;
	size_t soap_flag_giftWrapAmount1 = 1;
	size_t soap_flag_uncategorizedAmount1 = 1;
	size_t soap_flag_totalPurchaseAmount1 = 1;
	size_t soap_flag_walletReferenceID1 = 1;
	size_t soap_flag_promotionCode1 = 1;
	size_t soap_flag_paymentInstrumentID1 = 1;
	size_t soap_flag_cardVerificationStatus1 = 1;
	size_t soap_flag_issuerID1 = 1;
	size_t soap_flag_paymentInstrumentNickName1 = 1;
	size_t soap_flag_nameOnCard1 = 1;
	size_t soap_flag_cardType1 = 1;
	size_t soap_flag_cardGroup1 = 1;
	size_t soap_flag_cardArt1 = 1;
	size_t soap_flag_riskAdvice1 = 1;
	size_t soap_flag_riskScore1 = 1;
	size_t soap_flag_riskAdditionalData1 = 1;
	size_t soap_flag_avsCodeRaw1 = 1;
	size_t soap_flag_cvnCodeRaw1 = 1;
	size_t soap_flag_eciRaw1 = 1;
	size_t soap_flag_eci1 = 1;
	size_t soap_flag_cavv1 = 1;
	size_t soap_flag_veresEnrolled1 = 1;
	size_t soap_flag_veresTimeStamp1 = 1;
	size_t soap_flag_paresStatus1 = 1;
	size_t soap_flag_paresTimeStamp1 = 1;
	size_t soap_flag_xid1 = 1;
	size_t soap_flag_customData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_creationTimeStamp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:creationTimeStamp", (wchar_t**)&a->ns2__VCReply::creationTimeStamp, "xsd:string"))
				{	soap_flag_creationTimeStamp1--;
					continue;
				}
			if (soap_flag_alternateShippingAddressCountryCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:alternateShippingAddressCountryCode", (wchar_t**)&a->ns2__VCReply::alternateShippingAddressCountryCode, "xsd:string"))
				{	soap_flag_alternateShippingAddressCountryCode1--;
					continue;
				}
			if (soap_flag_alternateShippingAddressPostalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:alternateShippingAddressPostalCode", (wchar_t**)&a->ns2__VCReply::alternateShippingAddressPostalCode, "xsd:string"))
				{	soap_flag_alternateShippingAddressPostalCode1--;
					continue;
				}
			if (soap_flag_vcAccountLoginName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:vcAccountLoginName", (wchar_t**)&a->ns2__VCReply::vcAccountLoginName, "xsd:string"))
				{	soap_flag_vcAccountLoginName1--;
					continue;
				}
			if (soap_flag_vcAccountFirstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:vcAccountFirstName", (wchar_t**)&a->ns2__VCReply::vcAccountFirstName, "xsd:string"))
				{	soap_flag_vcAccountFirstName1--;
					continue;
				}
			if (soap_flag_vcAccountLastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:vcAccountLastName", (wchar_t**)&a->ns2__VCReply::vcAccountLastName, "xsd:string"))
				{	soap_flag_vcAccountLastName1--;
					continue;
				}
			if (soap_flag_vcAccountEncryptedID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:vcAccountEncryptedID", (wchar_t**)&a->ns2__VCReply::vcAccountEncryptedID, "xsd:string"))
				{	soap_flag_vcAccountEncryptedID1--;
					continue;
				}
			if (soap_flag_vcAccountEmail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:vcAccountEmail", (wchar_t**)&a->ns2__VCReply::vcAccountEmail, "xsd:string"))
				{	soap_flag_vcAccountEmail1--;
					continue;
				}
			if (soap_flag_vcAccountMobilePhoneNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:vcAccountMobilePhoneNumber", (wchar_t**)&a->ns2__VCReply::vcAccountMobilePhoneNumber, "xsd:string"))
				{	soap_flag_vcAccountMobilePhoneNumber1--;
					continue;
				}
			if (soap_flag_merchantReferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantReferenceID", (wchar_t**)&a->ns2__VCReply::merchantReferenceID, "xsd:string"))
				{	soap_flag_merchantReferenceID1--;
					continue;
				}
			if (soap_flag_subtotalAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:subtotalAmount", (wchar_t**)&a->ns2__VCReply::subtotalAmount, "xsd:string"))
				{	soap_flag_subtotalAmount1--;
					continue;
				}
			if (soap_flag_shippingHandlingAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shippingHandlingAmount", (wchar_t**)&a->ns2__VCReply::shippingHandlingAmount, "xsd:string"))
				{	soap_flag_shippingHandlingAmount1--;
					continue;
				}
			if (soap_flag_taxAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:taxAmount", (wchar_t**)&a->ns2__VCReply::taxAmount, "xsd:string"))
				{	soap_flag_taxAmount1--;
					continue;
				}
			if (soap_flag_discountAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:discountAmount", (wchar_t**)&a->ns2__VCReply::discountAmount, "xsd:string"))
				{	soap_flag_discountAmount1--;
					continue;
				}
			if (soap_flag_giftWrapAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:giftWrapAmount", (wchar_t**)&a->ns2__VCReply::giftWrapAmount, "xsd:string"))
				{	soap_flag_giftWrapAmount1--;
					continue;
				}
			if (soap_flag_uncategorizedAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:uncategorizedAmount", (wchar_t**)&a->ns2__VCReply::uncategorizedAmount, "xsd:string"))
				{	soap_flag_uncategorizedAmount1--;
					continue;
				}
			if (soap_flag_totalPurchaseAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:totalPurchaseAmount", (wchar_t**)&a->ns2__VCReply::totalPurchaseAmount, "xsd:string"))
				{	soap_flag_totalPurchaseAmount1--;
					continue;
				}
			if (soap_flag_walletReferenceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:walletReferenceID", (wchar_t**)&a->ns2__VCReply::walletReferenceID, "xsd:string"))
				{	soap_flag_walletReferenceID1--;
					continue;
				}
			if (soap_flag_promotionCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:promotionCode", (wchar_t**)&a->ns2__VCReply::promotionCode, "xsd:string"))
				{	soap_flag_promotionCode1--;
					continue;
				}
			if (soap_flag_paymentInstrumentID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentInstrumentID", (wchar_t**)&a->ns2__VCReply::paymentInstrumentID, "xsd:string"))
				{	soap_flag_paymentInstrumentID1--;
					continue;
				}
			if (soap_flag_cardVerificationStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardVerificationStatus", (wchar_t**)&a->ns2__VCReply::cardVerificationStatus, "xsd:string"))
				{	soap_flag_cardVerificationStatus1--;
					continue;
				}
			if (soap_flag_issuerID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:issuerID", (wchar_t**)&a->ns2__VCReply::issuerID, "xsd:string"))
				{	soap_flag_issuerID1--;
					continue;
				}
			if (soap_flag_paymentInstrumentNickName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentInstrumentNickName", (wchar_t**)&a->ns2__VCReply::paymentInstrumentNickName, "xsd:string"))
				{	soap_flag_paymentInstrumentNickName1--;
					continue;
				}
			if (soap_flag_nameOnCard1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:nameOnCard", (wchar_t**)&a->ns2__VCReply::nameOnCard, "xsd:string"))
				{	soap_flag_nameOnCard1--;
					continue;
				}
			if (soap_flag_cardType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardType", (wchar_t**)&a->ns2__VCReply::cardType, "xsd:string"))
				{	soap_flag_cardType1--;
					continue;
				}
			if (soap_flag_cardGroup1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardGroup", (wchar_t**)&a->ns2__VCReply::cardGroup, "xsd:string"))
				{	soap_flag_cardGroup1--;
					continue;
				}
			if (soap_flag_cardArt1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VCCardArt(soap, "ns2:cardArt", &a->ns2__VCReply::cardArt, "ns2:VCCardArt"))
				{	soap_flag_cardArt1--;
					continue;
				}
			if (soap_flag_riskAdvice1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:riskAdvice", (wchar_t**)&a->ns2__VCReply::riskAdvice, "xsd:string"))
				{	soap_flag_riskAdvice1--;
					continue;
				}
			if (soap_flag_riskScore1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:riskScore", (wchar_t**)&a->ns2__VCReply::riskScore, "xsd:string"))
				{	soap_flag_riskScore1--;
					continue;
				}
			if (soap_flag_riskAdditionalData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:riskAdditionalData", (wchar_t**)&a->ns2__VCReply::riskAdditionalData, "xsd:string"))
				{	soap_flag_riskAdditionalData1--;
					continue;
				}
			if (soap_flag_avsCodeRaw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:avsCodeRaw", (wchar_t**)&a->ns2__VCReply::avsCodeRaw, "xsd:string"))
				{	soap_flag_avsCodeRaw1--;
					continue;
				}
			if (soap_flag_cvnCodeRaw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cvnCodeRaw", (wchar_t**)&a->ns2__VCReply::cvnCodeRaw, "xsd:string"))
				{	soap_flag_cvnCodeRaw1--;
					continue;
				}
			if (soap_flag_eciRaw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:eciRaw", (wchar_t**)&a->ns2__VCReply::eciRaw, "xsd:string"))
				{	soap_flag_eciRaw1--;
					continue;
				}
			if (soap_flag_eci1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:eci", (wchar_t**)&a->ns2__VCReply::eci, "xsd:string"))
				{	soap_flag_eci1--;
					continue;
				}
			if (soap_flag_cavv1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cavv", (wchar_t**)&a->ns2__VCReply::cavv, "xsd:string"))
				{	soap_flag_cavv1--;
					continue;
				}
			if (soap_flag_veresEnrolled1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:veresEnrolled", (wchar_t**)&a->ns2__VCReply::veresEnrolled, "xsd:string"))
				{	soap_flag_veresEnrolled1--;
					continue;
				}
			if (soap_flag_veresTimeStamp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:veresTimeStamp", (wchar_t**)&a->ns2__VCReply::veresTimeStamp, "xsd:string"))
				{	soap_flag_veresTimeStamp1--;
					continue;
				}
			if (soap_flag_paresStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paresStatus", (wchar_t**)&a->ns2__VCReply::paresStatus, "xsd:string"))
				{	soap_flag_paresStatus1--;
					continue;
				}
			if (soap_flag_paresTimeStamp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paresTimeStamp", (wchar_t**)&a->ns2__VCReply::paresTimeStamp, "xsd:string"))
				{	soap_flag_paresTimeStamp1--;
					continue;
				}
			if (soap_flag_xid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:xid", (wchar_t**)&a->ns2__VCReply::xid, "xsd:string"))
				{	soap_flag_xid1--;
					continue;
				}
			if (soap_flag_customData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VCCustomData(soap, "ns2:customData", &a->ns2__VCReply::customData, "ns2:VCCustomData"))
				{	soap_flag_customData1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__VCReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VCReply, SOAP_TYPE_ns2__VCReply, sizeof(ns2__VCReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__VCReply * SOAP_FMAC2 soap_instantiate_ns2__VCReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__VCReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__VCReply *p;
	size_t k = sizeof(ns2__VCReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__VCReply);
		if (p)
			((ns2__VCReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__VCReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__VCReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__VCReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__VCReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__VCReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:VCReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__VCReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__VCReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__VCReply * SOAP_FMAC4 soap_get_ns2__VCReply(struct soap *soap, ns2__VCReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VCReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__AutoRentalData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__AutoRentalData::adjustmentCost = NULL;
	this->ns2__AutoRentalData::adjustmentCode = NULL;
	this->ns2__AutoRentalData::agreementNumber = NULL;
	this->ns2__AutoRentalData::classCode = NULL;
	this->ns2__AutoRentalData::customerServicePhoneNumber = NULL;
	this->ns2__AutoRentalData::dailyRate = NULL;
	this->ns2__AutoRentalData::mileageCost = NULL;
	this->ns2__AutoRentalData::gasCost = NULL;
	this->ns2__AutoRentalData::insuranceCost = NULL;
	this->ns2__AutoRentalData::lateReturnCost = NULL;
	this->ns2__AutoRentalData::maximumFreeMiles = NULL;
	this->ns2__AutoRentalData::milesTraveled = NULL;
	this->ns2__AutoRentalData::oneWayCost = NULL;
	this->ns2__AutoRentalData::parkingViolationCost = NULL;
	this->ns2__AutoRentalData::pickUpCity = NULL;
	this->ns2__AutoRentalData::pickUpCountry = NULL;
	this->ns2__AutoRentalData::pickUpDate = NULL;
	this->ns2__AutoRentalData::pickUpState = NULL;
	this->ns2__AutoRentalData::pickUpTime = NULL;
	this->ns2__AutoRentalData::ratePerMile = NULL;
	this->ns2__AutoRentalData::renterName = NULL;
	this->ns2__AutoRentalData::returnCity = NULL;
	this->ns2__AutoRentalData::returnCountry = NULL;
	this->ns2__AutoRentalData::returnDate = NULL;
	this->ns2__AutoRentalData::returnLocationID = NULL;
	this->ns2__AutoRentalData::returnState = NULL;
	this->ns2__AutoRentalData::returnTime = NULL;
	this->ns2__AutoRentalData::specialProgramCode = NULL;
	/* transient soap skipped */
}

void ns2__AutoRentalData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__amount(soap, &this->ns2__AutoRentalData::adjustmentCost);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AutoRentalData::adjustmentCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AutoRentalData::agreementNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AutoRentalData::classCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AutoRentalData::customerServicePhoneNumber);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__AutoRentalData::dailyRate);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__AutoRentalData::mileageCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__AutoRentalData::gasCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__AutoRentalData::insuranceCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__AutoRentalData::lateReturnCost);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__AutoRentalData::maximumFreeMiles);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__AutoRentalData::milesTraveled);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__AutoRentalData::oneWayCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__AutoRentalData::parkingViolationCost);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AutoRentalData::pickUpCity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AutoRentalData::pickUpCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AutoRentalData::pickUpDate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AutoRentalData::pickUpState);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__AutoRentalData::pickUpTime);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__AutoRentalData::ratePerMile);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AutoRentalData::renterName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AutoRentalData::returnCity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AutoRentalData::returnCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AutoRentalData::returnDate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AutoRentalData::returnLocationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AutoRentalData::returnState);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__AutoRentalData::returnTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AutoRentalData::specialProgramCode);
#endif
}

int ns2__AutoRentalData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AutoRentalData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AutoRentalData(struct soap *soap, const char *tag, int id, const ns2__AutoRentalData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AutoRentalData), type))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:adjustmentCost", -1, &a->ns2__AutoRentalData::adjustmentCost, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:adjustmentCode", -1, (wchar_t*const*)&a->ns2__AutoRentalData::adjustmentCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:agreementNumber", -1, (wchar_t*const*)&a->ns2__AutoRentalData::agreementNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:classCode", -1, (wchar_t*const*)&a->ns2__AutoRentalData::classCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:customerServicePhoneNumber", -1, (wchar_t*const*)&a->ns2__AutoRentalData::customerServicePhoneNumber, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:dailyRate", -1, &a->ns2__AutoRentalData::dailyRate, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:mileageCost", -1, &a->ns2__AutoRentalData::mileageCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:gasCost", -1, &a->ns2__AutoRentalData::gasCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:insuranceCost", -1, &a->ns2__AutoRentalData::insuranceCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:lateReturnCost", -1, &a->ns2__AutoRentalData::lateReturnCost, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:maximumFreeMiles", -1, &a->ns2__AutoRentalData::maximumFreeMiles, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:milesTraveled", -1, &a->ns2__AutoRentalData::milesTraveled, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:oneWayCost", -1, &a->ns2__AutoRentalData::oneWayCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:parkingViolationCost", -1, &a->ns2__AutoRentalData::parkingViolationCost, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pickUpCity", -1, (wchar_t*const*)&a->ns2__AutoRentalData::pickUpCity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pickUpCountry", -1, (wchar_t*const*)&a->ns2__AutoRentalData::pickUpCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pickUpDate", -1, (wchar_t*const*)&a->ns2__AutoRentalData::pickUpDate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pickUpState", -1, (wchar_t*const*)&a->ns2__AutoRentalData::pickUpState, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:pickUpTime", -1, &a->ns2__AutoRentalData::pickUpTime, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:ratePerMile", -1, &a->ns2__AutoRentalData::ratePerMile, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:renterName", -1, (wchar_t*const*)&a->ns2__AutoRentalData::renterName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:returnCity", -1, (wchar_t*const*)&a->ns2__AutoRentalData::returnCity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:returnCountry", -1, (wchar_t*const*)&a->ns2__AutoRentalData::returnCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:returnDate", -1, (wchar_t*const*)&a->ns2__AutoRentalData::returnDate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:returnLocationID", -1, (wchar_t*const*)&a->ns2__AutoRentalData::returnLocationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:returnState", -1, (wchar_t*const*)&a->ns2__AutoRentalData::returnState, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:returnTime", -1, &a->ns2__AutoRentalData::returnTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:specialProgramCode", -1, (wchar_t*const*)&a->ns2__AutoRentalData::specialProgramCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__AutoRentalData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AutoRentalData(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AutoRentalData * SOAP_FMAC4 soap_in_ns2__AutoRentalData(struct soap *soap, const char *tag, ns2__AutoRentalData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AutoRentalData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AutoRentalData, sizeof(ns2__AutoRentalData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__AutoRentalData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__AutoRentalData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_adjustmentCost1 = 1;
	size_t soap_flag_adjustmentCode1 = 1;
	size_t soap_flag_agreementNumber1 = 1;
	size_t soap_flag_classCode1 = 1;
	size_t soap_flag_customerServicePhoneNumber1 = 1;
	size_t soap_flag_dailyRate1 = 1;
	size_t soap_flag_mileageCost1 = 1;
	size_t soap_flag_gasCost1 = 1;
	size_t soap_flag_insuranceCost1 = 1;
	size_t soap_flag_lateReturnCost1 = 1;
	size_t soap_flag_maximumFreeMiles1 = 1;
	size_t soap_flag_milesTraveled1 = 1;
	size_t soap_flag_oneWayCost1 = 1;
	size_t soap_flag_parkingViolationCost1 = 1;
	size_t soap_flag_pickUpCity1 = 1;
	size_t soap_flag_pickUpCountry1 = 1;
	size_t soap_flag_pickUpDate1 = 1;
	size_t soap_flag_pickUpState1 = 1;
	size_t soap_flag_pickUpTime1 = 1;
	size_t soap_flag_ratePerMile1 = 1;
	size_t soap_flag_renterName1 = 1;
	size_t soap_flag_returnCity1 = 1;
	size_t soap_flag_returnCountry1 = 1;
	size_t soap_flag_returnDate1 = 1;
	size_t soap_flag_returnLocationID1 = 1;
	size_t soap_flag_returnState1 = 1;
	size_t soap_flag_returnTime1 = 1;
	size_t soap_flag_specialProgramCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_adjustmentCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:adjustmentCost", &a->ns2__AutoRentalData::adjustmentCost, "ns2:amount"))
				{	soap_flag_adjustmentCost1--;
					continue;
				}
			if (soap_flag_adjustmentCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:adjustmentCode", (wchar_t**)&a->ns2__AutoRentalData::adjustmentCode, "xsd:string"))
				{	soap_flag_adjustmentCode1--;
					continue;
				}
			if (soap_flag_agreementNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:agreementNumber", (wchar_t**)&a->ns2__AutoRentalData::agreementNumber, "xsd:string"))
				{	soap_flag_agreementNumber1--;
					continue;
				}
			if (soap_flag_classCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:classCode", (wchar_t**)&a->ns2__AutoRentalData::classCode, "xsd:string"))
				{	soap_flag_classCode1--;
					continue;
				}
			if (soap_flag_customerServicePhoneNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:customerServicePhoneNumber", (wchar_t**)&a->ns2__AutoRentalData::customerServicePhoneNumber, "xsd:string"))
				{	soap_flag_customerServicePhoneNumber1--;
					continue;
				}
			if (soap_flag_dailyRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:dailyRate", &a->ns2__AutoRentalData::dailyRate, "ns2:amount"))
				{	soap_flag_dailyRate1--;
					continue;
				}
			if (soap_flag_mileageCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:mileageCost", &a->ns2__AutoRentalData::mileageCost, "ns2:amount"))
				{	soap_flag_mileageCost1--;
					continue;
				}
			if (soap_flag_gasCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:gasCost", &a->ns2__AutoRentalData::gasCost, "ns2:amount"))
				{	soap_flag_gasCost1--;
					continue;
				}
			if (soap_flag_insuranceCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:insuranceCost", &a->ns2__AutoRentalData::insuranceCost, "ns2:amount"))
				{	soap_flag_insuranceCost1--;
					continue;
				}
			if (soap_flag_lateReturnCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:lateReturnCost", &a->ns2__AutoRentalData::lateReturnCost, "ns2:amount"))
				{	soap_flag_lateReturnCost1--;
					continue;
				}
			if (soap_flag_maximumFreeMiles1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:maximumFreeMiles", &a->ns2__AutoRentalData::maximumFreeMiles, "xsd:integer"))
				{	soap_flag_maximumFreeMiles1--;
					continue;
				}
			if (soap_flag_milesTraveled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:milesTraveled", &a->ns2__AutoRentalData::milesTraveled, "xsd:integer"))
				{	soap_flag_milesTraveled1--;
					continue;
				}
			if (soap_flag_oneWayCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:oneWayCost", &a->ns2__AutoRentalData::oneWayCost, "ns2:amount"))
				{	soap_flag_oneWayCost1--;
					continue;
				}
			if (soap_flag_parkingViolationCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:parkingViolationCost", &a->ns2__AutoRentalData::parkingViolationCost, "ns2:amount"))
				{	soap_flag_parkingViolationCost1--;
					continue;
				}
			if (soap_flag_pickUpCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pickUpCity", (wchar_t**)&a->ns2__AutoRentalData::pickUpCity, "xsd:string"))
				{	soap_flag_pickUpCity1--;
					continue;
				}
			if (soap_flag_pickUpCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pickUpCountry", (wchar_t**)&a->ns2__AutoRentalData::pickUpCountry, "xsd:string"))
				{	soap_flag_pickUpCountry1--;
					continue;
				}
			if (soap_flag_pickUpDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pickUpDate", (wchar_t**)&a->ns2__AutoRentalData::pickUpDate, "xsd:string"))
				{	soap_flag_pickUpDate1--;
					continue;
				}
			if (soap_flag_pickUpState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pickUpState", (wchar_t**)&a->ns2__AutoRentalData::pickUpState, "xsd:string"))
				{	soap_flag_pickUpState1--;
					continue;
				}
			if (soap_flag_pickUpTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:pickUpTime", &a->ns2__AutoRentalData::pickUpTime, "xsd:integer"))
				{	soap_flag_pickUpTime1--;
					continue;
				}
			if (soap_flag_ratePerMile1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:ratePerMile", &a->ns2__AutoRentalData::ratePerMile, "ns2:amount"))
				{	soap_flag_ratePerMile1--;
					continue;
				}
			if (soap_flag_renterName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:renterName", (wchar_t**)&a->ns2__AutoRentalData::renterName, "xsd:string"))
				{	soap_flag_renterName1--;
					continue;
				}
			if (soap_flag_returnCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:returnCity", (wchar_t**)&a->ns2__AutoRentalData::returnCity, "xsd:string"))
				{	soap_flag_returnCity1--;
					continue;
				}
			if (soap_flag_returnCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:returnCountry", (wchar_t**)&a->ns2__AutoRentalData::returnCountry, "xsd:string"))
				{	soap_flag_returnCountry1--;
					continue;
				}
			if (soap_flag_returnDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:returnDate", (wchar_t**)&a->ns2__AutoRentalData::returnDate, "xsd:string"))
				{	soap_flag_returnDate1--;
					continue;
				}
			if (soap_flag_returnLocationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:returnLocationID", (wchar_t**)&a->ns2__AutoRentalData::returnLocationID, "xsd:string"))
				{	soap_flag_returnLocationID1--;
					continue;
				}
			if (soap_flag_returnState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:returnState", (wchar_t**)&a->ns2__AutoRentalData::returnState, "xsd:string"))
				{	soap_flag_returnState1--;
					continue;
				}
			if (soap_flag_returnTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:returnTime", &a->ns2__AutoRentalData::returnTime, "xsd:integer"))
				{	soap_flag_returnTime1--;
					continue;
				}
			if (soap_flag_specialProgramCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:specialProgramCode", (wchar_t**)&a->ns2__AutoRentalData::specialProgramCode, "xsd:string"))
				{	soap_flag_specialProgramCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AutoRentalData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AutoRentalData, SOAP_TYPE_ns2__AutoRentalData, sizeof(ns2__AutoRentalData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__AutoRentalData * SOAP_FMAC2 soap_instantiate_ns2__AutoRentalData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AutoRentalData(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__AutoRentalData *p;
	size_t k = sizeof(ns2__AutoRentalData);
	if (n < 0)
	{	p = SOAP_NEW(ns2__AutoRentalData);
		if (p)
			((ns2__AutoRentalData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__AutoRentalData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__AutoRentalData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__AutoRentalData location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__AutoRentalData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__AutoRentalData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:AutoRentalData", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AutoRentalData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AutoRentalData(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AutoRentalData * SOAP_FMAC4 soap_get_ns2__AutoRentalData(struct soap *soap, ns2__AutoRentalData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AutoRentalData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__HostedDataRetrieveReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__HostedDataRetrieveReply::responseMessage = NULL;
	this->ns2__HostedDataRetrieveReply::reasonCode = NULL;
	this->ns2__HostedDataRetrieveReply::aggregatorMerchantIdentifier = NULL;
	this->ns2__HostedDataRetrieveReply::customerFirstName = NULL;
	this->ns2__HostedDataRetrieveReply::customerLastName = NULL;
	this->ns2__HostedDataRetrieveReply::customerID = NULL;
	this->ns2__HostedDataRetrieveReply::paymentMethod = NULL;
	this->ns2__HostedDataRetrieveReply::billToStreet1 = NULL;
	this->ns2__HostedDataRetrieveReply::billToStreet2 = NULL;
	this->ns2__HostedDataRetrieveReply::billToEmail = NULL;
	this->ns2__HostedDataRetrieveReply::billToState = NULL;
	this->ns2__HostedDataRetrieveReply::billToFirstName = NULL;
	this->ns2__HostedDataRetrieveReply::billToLastName = NULL;
	this->ns2__HostedDataRetrieveReply::billToCity = NULL;
	this->ns2__HostedDataRetrieveReply::billToCountry = NULL;
	this->ns2__HostedDataRetrieveReply::billToPostalCode = NULL;
	this->ns2__HostedDataRetrieveReply::cardAccountNumber = NULL;
	this->ns2__HostedDataRetrieveReply::cardType = NULL;
	this->ns2__HostedDataRetrieveReply::cardExpirationMonth = NULL;
	this->ns2__HostedDataRetrieveReply::cardExpirationYear = NULL;
	this->ns2__HostedDataRetrieveReply::cardIssueNumber = NULL;
	this->ns2__HostedDataRetrieveReply::cardStartMonth = NULL;
	this->ns2__HostedDataRetrieveReply::cardStartYear = NULL;
	/* transient soap skipped */
}

void ns2__HostedDataRetrieveReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::responseMessage);
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::aggregatorMerchantIdentifier);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::customerFirstName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::customerLastName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::customerID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::paymentMethod);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::billToStreet1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::billToStreet2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::billToEmail);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::billToState);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::billToFirstName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::billToLastName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::billToCity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::billToCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::billToPostalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::cardAccountNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::cardType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::cardExpirationMonth);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::cardExpirationYear);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::cardIssueNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::cardStartMonth);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveReply::cardStartYear);
#endif
}

int ns2__HostedDataRetrieveReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__HostedDataRetrieveReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HostedDataRetrieveReply(struct soap *soap, const char *tag, int id, const ns2__HostedDataRetrieveReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__HostedDataRetrieveReply), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:responseMessage", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::responseMessage, ""))
		return soap->error;
	if (!a->ns2__HostedDataRetrieveReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:aggregatorMerchantIdentifier", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::aggregatorMerchantIdentifier, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:customerFirstName", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::customerFirstName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:customerLastName", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::customerLastName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:customerID", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::customerID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentMethod", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::paymentMethod, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:billToStreet1", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::billToStreet1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:billToStreet2", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::billToStreet2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:billToEmail", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::billToEmail, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:billToState", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::billToState, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:billToFirstName", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::billToFirstName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:billToLastName", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::billToLastName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:billToCity", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::billToCity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:billToCountry", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::billToCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:billToPostalCode", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::billToPostalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardAccountNumber", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::cardAccountNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardType", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::cardType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardExpirationMonth", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::cardExpirationMonth, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardExpirationYear", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::cardExpirationYear, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardIssueNumber", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::cardIssueNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardStartMonth", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::cardStartMonth, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardStartYear", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveReply::cardStartYear, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__HostedDataRetrieveReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__HostedDataRetrieveReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__HostedDataRetrieveReply * SOAP_FMAC4 soap_in_ns2__HostedDataRetrieveReply(struct soap *soap, const char *tag, ns2__HostedDataRetrieveReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__HostedDataRetrieveReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__HostedDataRetrieveReply, sizeof(ns2__HostedDataRetrieveReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__HostedDataRetrieveReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__HostedDataRetrieveReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_responseMessage1 = 1;
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_aggregatorMerchantIdentifier1 = 1;
	size_t soap_flag_customerFirstName1 = 1;
	size_t soap_flag_customerLastName1 = 1;
	size_t soap_flag_customerID1 = 1;
	size_t soap_flag_paymentMethod1 = 1;
	size_t soap_flag_billToStreet11 = 1;
	size_t soap_flag_billToStreet21 = 1;
	size_t soap_flag_billToEmail1 = 1;
	size_t soap_flag_billToState1 = 1;
	size_t soap_flag_billToFirstName1 = 1;
	size_t soap_flag_billToLastName1 = 1;
	size_t soap_flag_billToCity1 = 1;
	size_t soap_flag_billToCountry1 = 1;
	size_t soap_flag_billToPostalCode1 = 1;
	size_t soap_flag_cardAccountNumber1 = 1;
	size_t soap_flag_cardType1 = 1;
	size_t soap_flag_cardExpirationMonth1 = 1;
	size_t soap_flag_cardExpirationYear1 = 1;
	size_t soap_flag_cardIssueNumber1 = 1;
	size_t soap_flag_cardStartMonth1 = 1;
	size_t soap_flag_cardStartYear1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:responseMessage", (wchar_t**)&a->ns2__HostedDataRetrieveReply::responseMessage, "xsd:string"))
				{	soap_flag_responseMessage1--;
					continue;
				}
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__HostedDataRetrieveReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_aggregatorMerchantIdentifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:aggregatorMerchantIdentifier", (wchar_t**)&a->ns2__HostedDataRetrieveReply::aggregatorMerchantIdentifier, "xsd:string"))
				{	soap_flag_aggregatorMerchantIdentifier1--;
					continue;
				}
			if (soap_flag_customerFirstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:customerFirstName", (wchar_t**)&a->ns2__HostedDataRetrieveReply::customerFirstName, "xsd:string"))
				{	soap_flag_customerFirstName1--;
					continue;
				}
			if (soap_flag_customerLastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:customerLastName", (wchar_t**)&a->ns2__HostedDataRetrieveReply::customerLastName, "xsd:string"))
				{	soap_flag_customerLastName1--;
					continue;
				}
			if (soap_flag_customerID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:customerID", (wchar_t**)&a->ns2__HostedDataRetrieveReply::customerID, "xsd:string"))
				{	soap_flag_customerID1--;
					continue;
				}
			if (soap_flag_paymentMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentMethod", (wchar_t**)&a->ns2__HostedDataRetrieveReply::paymentMethod, "xsd:string"))
				{	soap_flag_paymentMethod1--;
					continue;
				}
			if (soap_flag_billToStreet11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:billToStreet1", (wchar_t**)&a->ns2__HostedDataRetrieveReply::billToStreet1, "xsd:string"))
				{	soap_flag_billToStreet11--;
					continue;
				}
			if (soap_flag_billToStreet21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:billToStreet2", (wchar_t**)&a->ns2__HostedDataRetrieveReply::billToStreet2, "xsd:string"))
				{	soap_flag_billToStreet21--;
					continue;
				}
			if (soap_flag_billToEmail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:billToEmail", (wchar_t**)&a->ns2__HostedDataRetrieveReply::billToEmail, "xsd:string"))
				{	soap_flag_billToEmail1--;
					continue;
				}
			if (soap_flag_billToState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:billToState", (wchar_t**)&a->ns2__HostedDataRetrieveReply::billToState, "xsd:string"))
				{	soap_flag_billToState1--;
					continue;
				}
			if (soap_flag_billToFirstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:billToFirstName", (wchar_t**)&a->ns2__HostedDataRetrieveReply::billToFirstName, "xsd:string"))
				{	soap_flag_billToFirstName1--;
					continue;
				}
			if (soap_flag_billToLastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:billToLastName", (wchar_t**)&a->ns2__HostedDataRetrieveReply::billToLastName, "xsd:string"))
				{	soap_flag_billToLastName1--;
					continue;
				}
			if (soap_flag_billToCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:billToCity", (wchar_t**)&a->ns2__HostedDataRetrieveReply::billToCity, "xsd:string"))
				{	soap_flag_billToCity1--;
					continue;
				}
			if (soap_flag_billToCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:billToCountry", (wchar_t**)&a->ns2__HostedDataRetrieveReply::billToCountry, "xsd:string"))
				{	soap_flag_billToCountry1--;
					continue;
				}
			if (soap_flag_billToPostalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:billToPostalCode", (wchar_t**)&a->ns2__HostedDataRetrieveReply::billToPostalCode, "xsd:string"))
				{	soap_flag_billToPostalCode1--;
					continue;
				}
			if (soap_flag_cardAccountNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardAccountNumber", (wchar_t**)&a->ns2__HostedDataRetrieveReply::cardAccountNumber, "xsd:string"))
				{	soap_flag_cardAccountNumber1--;
					continue;
				}
			if (soap_flag_cardType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardType", (wchar_t**)&a->ns2__HostedDataRetrieveReply::cardType, "xsd:string"))
				{	soap_flag_cardType1--;
					continue;
				}
			if (soap_flag_cardExpirationMonth1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardExpirationMonth", (wchar_t**)&a->ns2__HostedDataRetrieveReply::cardExpirationMonth, "xsd:string"))
				{	soap_flag_cardExpirationMonth1--;
					continue;
				}
			if (soap_flag_cardExpirationYear1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardExpirationYear", (wchar_t**)&a->ns2__HostedDataRetrieveReply::cardExpirationYear, "xsd:string"))
				{	soap_flag_cardExpirationYear1--;
					continue;
				}
			if (soap_flag_cardIssueNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardIssueNumber", (wchar_t**)&a->ns2__HostedDataRetrieveReply::cardIssueNumber, "xsd:string"))
				{	soap_flag_cardIssueNumber1--;
					continue;
				}
			if (soap_flag_cardStartMonth1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardStartMonth", (wchar_t**)&a->ns2__HostedDataRetrieveReply::cardStartMonth, "xsd:string"))
				{	soap_flag_cardStartMonth1--;
					continue;
				}
			if (soap_flag_cardStartYear1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardStartYear", (wchar_t**)&a->ns2__HostedDataRetrieveReply::cardStartYear, "xsd:string"))
				{	soap_flag_cardStartYear1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__HostedDataRetrieveReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__HostedDataRetrieveReply, SOAP_TYPE_ns2__HostedDataRetrieveReply, sizeof(ns2__HostedDataRetrieveReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__HostedDataRetrieveReply * SOAP_FMAC2 soap_instantiate_ns2__HostedDataRetrieveReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__HostedDataRetrieveReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__HostedDataRetrieveReply *p;
	size_t k = sizeof(ns2__HostedDataRetrieveReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__HostedDataRetrieveReply);
		if (p)
			((ns2__HostedDataRetrieveReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__HostedDataRetrieveReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__HostedDataRetrieveReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__HostedDataRetrieveReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__HostedDataRetrieveReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__HostedDataRetrieveReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:HostedDataRetrieveReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__HostedDataRetrieveReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__HostedDataRetrieveReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__HostedDataRetrieveReply * SOAP_FMAC4 soap_get_ns2__HostedDataRetrieveReply(struct soap *soap, ns2__HostedDataRetrieveReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HostedDataRetrieveReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__HostedDataCreateReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__HostedDataCreateReply::responseMessage = NULL;
	this->ns2__HostedDataCreateReply::reasonCode = NULL;
	this->ns2__HostedDataCreateReply::cardAccountNumberToken = NULL;
	this->ns2__HostedDataCreateReply::customerID = NULL;
	/* transient soap skipped */
}

void ns2__HostedDataCreateReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataCreateReply::responseMessage);
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__HostedDataCreateReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataCreateReply::cardAccountNumberToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataCreateReply::customerID);
#endif
}

int ns2__HostedDataCreateReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__HostedDataCreateReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HostedDataCreateReply(struct soap *soap, const char *tag, int id, const ns2__HostedDataCreateReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__HostedDataCreateReply), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:responseMessage", -1, (wchar_t*const*)&a->ns2__HostedDataCreateReply::responseMessage, ""))
		return soap->error;
	if (!a->ns2__HostedDataCreateReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__HostedDataCreateReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardAccountNumberToken", -1, (wchar_t*const*)&a->ns2__HostedDataCreateReply::cardAccountNumberToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:customerID", -1, (wchar_t*const*)&a->ns2__HostedDataCreateReply::customerID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__HostedDataCreateReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__HostedDataCreateReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__HostedDataCreateReply * SOAP_FMAC4 soap_in_ns2__HostedDataCreateReply(struct soap *soap, const char *tag, ns2__HostedDataCreateReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__HostedDataCreateReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__HostedDataCreateReply, sizeof(ns2__HostedDataCreateReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__HostedDataCreateReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__HostedDataCreateReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_responseMessage1 = 1;
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_cardAccountNumberToken1 = 1;
	size_t soap_flag_customerID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:responseMessage", (wchar_t**)&a->ns2__HostedDataCreateReply::responseMessage, "xsd:string"))
				{	soap_flag_responseMessage1--;
					continue;
				}
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__HostedDataCreateReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_cardAccountNumberToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardAccountNumberToken", (wchar_t**)&a->ns2__HostedDataCreateReply::cardAccountNumberToken, "xsd:string"))
				{	soap_flag_cardAccountNumberToken1--;
					continue;
				}
			if (soap_flag_customerID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:customerID", (wchar_t**)&a->ns2__HostedDataCreateReply::customerID, "xsd:string"))
				{	soap_flag_customerID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__HostedDataCreateReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__HostedDataCreateReply, SOAP_TYPE_ns2__HostedDataCreateReply, sizeof(ns2__HostedDataCreateReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__HostedDataCreateReply * SOAP_FMAC2 soap_instantiate_ns2__HostedDataCreateReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__HostedDataCreateReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__HostedDataCreateReply *p;
	size_t k = sizeof(ns2__HostedDataCreateReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__HostedDataCreateReply);
		if (p)
			((ns2__HostedDataCreateReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__HostedDataCreateReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__HostedDataCreateReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__HostedDataCreateReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__HostedDataCreateReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__HostedDataCreateReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:HostedDataCreateReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__HostedDataCreateReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__HostedDataCreateReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__HostedDataCreateReply * SOAP_FMAC4 soap_get_ns2__HostedDataCreateReply(struct soap *soap, ns2__HostedDataCreateReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HostedDataCreateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__HostedDataRetrieveService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__HostedDataRetrieveService::profileID = NULL;
	this->ns2__HostedDataRetrieveService::tokenValue = NULL;
	this->ns2__HostedDataRetrieveService::run = NULL;
	/* transient soap skipped */
}

void ns2__HostedDataRetrieveService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveService::profileID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataRetrieveService::tokenValue);
#endif
}

int ns2__HostedDataRetrieveService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__HostedDataRetrieveService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HostedDataRetrieveService(struct soap *soap, const char *tag, int id, const ns2__HostedDataRetrieveService *a, const char *type)
{
	if (((ns2__HostedDataRetrieveService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__HostedDataRetrieveService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__HostedDataRetrieveService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:profileID", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveService::profileID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:tokenValue", -1, (wchar_t*const*)&a->ns2__HostedDataRetrieveService::tokenValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__HostedDataRetrieveService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__HostedDataRetrieveService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__HostedDataRetrieveService * SOAP_FMAC4 soap_in_ns2__HostedDataRetrieveService(struct soap *soap, const char *tag, ns2__HostedDataRetrieveService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__HostedDataRetrieveService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__HostedDataRetrieveService, sizeof(ns2__HostedDataRetrieveService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__HostedDataRetrieveService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__HostedDataRetrieveService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__HostedDataRetrieveService*)a)->run))
		return NULL;
	size_t soap_flag_profileID1 = 1;
	size_t soap_flag_tokenValue1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_profileID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:profileID", (wchar_t**)&a->ns2__HostedDataRetrieveService::profileID, "xsd:string"))
				{	soap_flag_profileID1--;
					continue;
				}
			if (soap_flag_tokenValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:tokenValue", (wchar_t**)&a->ns2__HostedDataRetrieveService::tokenValue, "xsd:string"))
				{	soap_flag_tokenValue1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__HostedDataRetrieveService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__HostedDataRetrieveService, SOAP_TYPE_ns2__HostedDataRetrieveService, sizeof(ns2__HostedDataRetrieveService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__HostedDataRetrieveService * SOAP_FMAC2 soap_instantiate_ns2__HostedDataRetrieveService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__HostedDataRetrieveService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__HostedDataRetrieveService *p;
	size_t k = sizeof(ns2__HostedDataRetrieveService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__HostedDataRetrieveService);
		if (p)
			((ns2__HostedDataRetrieveService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__HostedDataRetrieveService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__HostedDataRetrieveService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__HostedDataRetrieveService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__HostedDataRetrieveService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__HostedDataRetrieveService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:HostedDataRetrieveService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__HostedDataRetrieveService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__HostedDataRetrieveService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__HostedDataRetrieveService * SOAP_FMAC4 soap_get_ns2__HostedDataRetrieveService(struct soap *soap, ns2__HostedDataRetrieveService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HostedDataRetrieveService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__HostedDataCreateService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__HostedDataCreateService::profileID = NULL;
	this->ns2__HostedDataCreateService::paymentMethod = NULL;
	this->ns2__HostedDataCreateService::run = NULL;
	/* transient soap skipped */
}

void ns2__HostedDataCreateService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataCreateService::profileID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__HostedDataCreateService::paymentMethod);
#endif
}

int ns2__HostedDataCreateService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__HostedDataCreateService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__HostedDataCreateService(struct soap *soap, const char *tag, int id, const ns2__HostedDataCreateService *a, const char *type)
{
	if (((ns2__HostedDataCreateService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__HostedDataCreateService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__HostedDataCreateService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:profileID", -1, (wchar_t*const*)&a->ns2__HostedDataCreateService::profileID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentMethod", -1, (wchar_t*const*)&a->ns2__HostedDataCreateService::paymentMethod, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__HostedDataCreateService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__HostedDataCreateService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__HostedDataCreateService * SOAP_FMAC4 soap_in_ns2__HostedDataCreateService(struct soap *soap, const char *tag, ns2__HostedDataCreateService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__HostedDataCreateService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__HostedDataCreateService, sizeof(ns2__HostedDataCreateService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__HostedDataCreateService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__HostedDataCreateService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__HostedDataCreateService*)a)->run))
		return NULL;
	size_t soap_flag_profileID1 = 1;
	size_t soap_flag_paymentMethod1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_profileID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:profileID", (wchar_t**)&a->ns2__HostedDataCreateService::profileID, "xsd:string"))
				{	soap_flag_profileID1--;
					continue;
				}
			if (soap_flag_paymentMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentMethod", (wchar_t**)&a->ns2__HostedDataCreateService::paymentMethod, "xsd:string"))
				{	soap_flag_paymentMethod1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__HostedDataCreateService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__HostedDataCreateService, SOAP_TYPE_ns2__HostedDataCreateService, sizeof(ns2__HostedDataCreateService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__HostedDataCreateService * SOAP_FMAC2 soap_instantiate_ns2__HostedDataCreateService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__HostedDataCreateService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__HostedDataCreateService *p;
	size_t k = sizeof(ns2__HostedDataCreateService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__HostedDataCreateService);
		if (p)
			((ns2__HostedDataCreateService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__HostedDataCreateService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__HostedDataCreateService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__HostedDataCreateService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__HostedDataCreateService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__HostedDataCreateService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:HostedDataCreateService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__HostedDataCreateService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__HostedDataCreateService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__HostedDataCreateService * SOAP_FMAC4 soap_get_ns2__HostedDataCreateService(struct soap *soap, ns2__HostedDataCreateService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__HostedDataCreateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__OriginalTransaction::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__OriginalTransaction::amount = NULL;
	this->ns2__OriginalTransaction::reasonCode = NULL;
	/* transient soap skipped */
}

void ns2__OriginalTransaction::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__amount(soap, &this->ns2__OriginalTransaction::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__OriginalTransaction::reasonCode);
#endif
}

int ns2__OriginalTransaction::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__OriginalTransaction(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OriginalTransaction(struct soap *soap, const char *tag, int id, const ns2__OriginalTransaction *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OriginalTransaction), type))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__OriginalTransaction::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__OriginalTransaction::reasonCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__OriginalTransaction::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__OriginalTransaction(soap, tag, this, type);
}

SOAP_FMAC3 ns2__OriginalTransaction * SOAP_FMAC4 soap_in_ns2__OriginalTransaction(struct soap *soap, const char *tag, ns2__OriginalTransaction *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__OriginalTransaction *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OriginalTransaction, sizeof(ns2__OriginalTransaction), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__OriginalTransaction)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__OriginalTransaction *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_reasonCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__OriginalTransaction::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__OriginalTransaction::reasonCode, "xsd:string"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__OriginalTransaction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OriginalTransaction, SOAP_TYPE_ns2__OriginalTransaction, sizeof(ns2__OriginalTransaction), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__OriginalTransaction * SOAP_FMAC2 soap_instantiate_ns2__OriginalTransaction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__OriginalTransaction(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__OriginalTransaction *p;
	size_t k = sizeof(ns2__OriginalTransaction);
	if (n < 0)
	{	p = SOAP_NEW(ns2__OriginalTransaction);
		if (p)
			((ns2__OriginalTransaction*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__OriginalTransaction, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__OriginalTransaction*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__OriginalTransaction location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__OriginalTransaction, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__OriginalTransaction::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:OriginalTransaction", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__OriginalTransaction::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__OriginalTransaction(soap, this, tag, type);
}

SOAP_FMAC3 ns2__OriginalTransaction * SOAP_FMAC4 soap_get_ns2__OriginalTransaction(struct soap *soap, ns2__OriginalTransaction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OriginalTransaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__EmvReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__EmvReply::combinedTags = NULL;
	this->ns2__EmvReply::decryptedRequestTags = NULL;
	this->ns2__EmvReply::chipValidationResults = NULL;
	this->ns2__EmvReply::chipValidationType = NULL;
	/* transient soap skipped */
}

void ns2__EmvReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__EmvReply::combinedTags);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__EmvReply::decryptedRequestTags);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__EmvReply::chipValidationResults);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__EmvReply::chipValidationType);
#endif
}

int ns2__EmvReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__EmvReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EmvReply(struct soap *soap, const char *tag, int id, const ns2__EmvReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EmvReply), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:combinedTags", -1, (wchar_t*const*)&a->ns2__EmvReply::combinedTags, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:decryptedRequestTags", -1, (wchar_t*const*)&a->ns2__EmvReply::decryptedRequestTags, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:chipValidationResults", -1, (wchar_t*const*)&a->ns2__EmvReply::chipValidationResults, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:chipValidationType", -1, (wchar_t*const*)&a->ns2__EmvReply::chipValidationType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__EmvReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__EmvReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__EmvReply * SOAP_FMAC4 soap_in_ns2__EmvReply(struct soap *soap, const char *tag, ns2__EmvReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__EmvReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EmvReply, sizeof(ns2__EmvReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__EmvReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__EmvReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_combinedTags1 = 1;
	size_t soap_flag_decryptedRequestTags1 = 1;
	size_t soap_flag_chipValidationResults1 = 1;
	size_t soap_flag_chipValidationType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_combinedTags1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:combinedTags", (wchar_t**)&a->ns2__EmvReply::combinedTags, "xsd:string"))
				{	soap_flag_combinedTags1--;
					continue;
				}
			if (soap_flag_decryptedRequestTags1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:decryptedRequestTags", (wchar_t**)&a->ns2__EmvReply::decryptedRequestTags, "xsd:string"))
				{	soap_flag_decryptedRequestTags1--;
					continue;
				}
			if (soap_flag_chipValidationResults1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:chipValidationResults", (wchar_t**)&a->ns2__EmvReply::chipValidationResults, "xsd:string"))
				{	soap_flag_chipValidationResults1--;
					continue;
				}
			if (soap_flag_chipValidationType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:chipValidationType", (wchar_t**)&a->ns2__EmvReply::chipValidationType, "xsd:string"))
				{	soap_flag_chipValidationType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__EmvReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EmvReply, SOAP_TYPE_ns2__EmvReply, sizeof(ns2__EmvReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__EmvReply * SOAP_FMAC2 soap_instantiate_ns2__EmvReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__EmvReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__EmvReply *p;
	size_t k = sizeof(ns2__EmvReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__EmvReply);
		if (p)
			((ns2__EmvReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__EmvReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__EmvReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__EmvReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__EmvReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__EmvReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:EmvReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__EmvReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__EmvReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__EmvReply * SOAP_FMAC4 soap_get_ns2__EmvReply(struct soap *soap, ns2__EmvReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EmvReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__EmvRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__EmvRequest::combinedTags = NULL;
	this->ns2__EmvRequest::cardSequenceNumber = NULL;
	this->ns2__EmvRequest::aidAndDFname = NULL;
	this->ns2__EmvRequest::fallback = NULL;
	this->ns2__EmvRequest::fallbackCondition = NULL;
	/* transient soap skipped */
}

void ns2__EmvRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__EmvRequest::combinedTags);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__EmvRequest::cardSequenceNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__EmvRequest::aidAndDFname);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__EmvRequest::fallback);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__EmvRequest::fallbackCondition);
#endif
}

int ns2__EmvRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__EmvRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EmvRequest(struct soap *soap, const char *tag, int id, const ns2__EmvRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EmvRequest), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:combinedTags", -1, (wchar_t*const*)&a->ns2__EmvRequest::combinedTags, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardSequenceNumber", -1, (wchar_t*const*)&a->ns2__EmvRequest::cardSequenceNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:aidAndDFname", -1, (wchar_t*const*)&a->ns2__EmvRequest::aidAndDFname, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:fallback", -1, (wchar_t*const*)&a->ns2__EmvRequest::fallback, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:fallbackCondition", -1, (wchar_t*const*)&a->ns2__EmvRequest::fallbackCondition, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__EmvRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__EmvRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns2__EmvRequest * SOAP_FMAC4 soap_in_ns2__EmvRequest(struct soap *soap, const char *tag, ns2__EmvRequest *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__EmvRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EmvRequest, sizeof(ns2__EmvRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__EmvRequest)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__EmvRequest *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_combinedTags1 = 1;
	size_t soap_flag_cardSequenceNumber1 = 1;
	size_t soap_flag_aidAndDFname1 = 1;
	size_t soap_flag_fallback1 = 1;
	size_t soap_flag_fallbackCondition1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_combinedTags1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:combinedTags", (wchar_t**)&a->ns2__EmvRequest::combinedTags, "xsd:string"))
				{	soap_flag_combinedTags1--;
					continue;
				}
			if (soap_flag_cardSequenceNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardSequenceNumber", (wchar_t**)&a->ns2__EmvRequest::cardSequenceNumber, "xsd:string"))
				{	soap_flag_cardSequenceNumber1--;
					continue;
				}
			if (soap_flag_aidAndDFname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:aidAndDFname", (wchar_t**)&a->ns2__EmvRequest::aidAndDFname, "xsd:string"))
				{	soap_flag_aidAndDFname1--;
					continue;
				}
			if (soap_flag_fallback1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:fallback", (wchar_t**)&a->ns2__EmvRequest::fallback, "xsd:string"))
				{	soap_flag_fallback1--;
					continue;
				}
			if (soap_flag_fallbackCondition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:fallbackCondition", (wchar_t**)&a->ns2__EmvRequest::fallbackCondition, "xsd:string"))
				{	soap_flag_fallbackCondition1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__EmvRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EmvRequest, SOAP_TYPE_ns2__EmvRequest, sizeof(ns2__EmvRequest), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__EmvRequest * SOAP_FMAC2 soap_instantiate_ns2__EmvRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__EmvRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__EmvRequest *p;
	size_t k = sizeof(ns2__EmvRequest);
	if (n < 0)
	{	p = SOAP_NEW(ns2__EmvRequest);
		if (p)
			((ns2__EmvRequest*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__EmvRequest, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__EmvRequest*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__EmvRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__EmvRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__EmvRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:EmvRequest", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__EmvRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__EmvRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns2__EmvRequest * SOAP_FMAC4 soap_get_ns2__EmvRequest(struct soap *soap, ns2__EmvRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EmvRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ServiceFee::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ServiceFee::merchantDescriptor = NULL;
	this->ns2__ServiceFee::merchantDescriptorContact = NULL;
	this->ns2__ServiceFee::merchantDescriptorState = NULL;
	/* transient soap skipped */
}

void ns2__ServiceFee::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ServiceFee::merchantDescriptor);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ServiceFee::merchantDescriptorContact);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ServiceFee::merchantDescriptorState);
#endif
}

int ns2__ServiceFee::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ServiceFee(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ServiceFee(struct soap *soap, const char *tag, int id, const ns2__ServiceFee *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ServiceFee), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantDescriptor", -1, (wchar_t*const*)&a->ns2__ServiceFee::merchantDescriptor, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantDescriptorContact", -1, (wchar_t*const*)&a->ns2__ServiceFee::merchantDescriptorContact, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantDescriptorState", -1, (wchar_t*const*)&a->ns2__ServiceFee::merchantDescriptorState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ServiceFee::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ServiceFee(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ServiceFee * SOAP_FMAC4 soap_in_ns2__ServiceFee(struct soap *soap, const char *tag, ns2__ServiceFee *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ServiceFee *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ServiceFee, sizeof(ns2__ServiceFee), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ServiceFee)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ServiceFee *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_merchantDescriptor1 = 1;
	size_t soap_flag_merchantDescriptorContact1 = 1;
	size_t soap_flag_merchantDescriptorState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_merchantDescriptor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantDescriptor", (wchar_t**)&a->ns2__ServiceFee::merchantDescriptor, "xsd:string"))
				{	soap_flag_merchantDescriptor1--;
					continue;
				}
			if (soap_flag_merchantDescriptorContact1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantDescriptorContact", (wchar_t**)&a->ns2__ServiceFee::merchantDescriptorContact, "xsd:string"))
				{	soap_flag_merchantDescriptorContact1--;
					continue;
				}
			if (soap_flag_merchantDescriptorState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantDescriptorState", (wchar_t**)&a->ns2__ServiceFee::merchantDescriptorState, "xsd:string"))
				{	soap_flag_merchantDescriptorState1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ServiceFee *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ServiceFee, SOAP_TYPE_ns2__ServiceFee, sizeof(ns2__ServiceFee), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ServiceFee * SOAP_FMAC2 soap_instantiate_ns2__ServiceFee(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ServiceFee(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ServiceFee *p;
	size_t k = sizeof(ns2__ServiceFee);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ServiceFee);
		if (p)
			((ns2__ServiceFee*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ServiceFee, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ServiceFee*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ServiceFee location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ServiceFee, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ServiceFee::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:ServiceFee", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ServiceFee::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ServiceFee(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ServiceFee * SOAP_FMAC4 soap_get_ns2__ServiceFee(struct soap *soap, ns2__ServiceFee *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ServiceFee(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CCDCCUpdateService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CCDCCUpdateService::reason = NULL;
	this->ns2__CCDCCUpdateService::action = NULL;
	this->ns2__CCDCCUpdateService::dccRequestID = NULL;
	this->ns2__CCDCCUpdateService::captureRequestID = NULL;
	this->ns2__CCDCCUpdateService::creditRequestID = NULL;
	this->ns2__CCDCCUpdateService::run = NULL;
	/* transient soap skipped */
}

void ns2__CCDCCUpdateService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCDCCUpdateService::reason);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCDCCUpdateService::action);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCDCCUpdateService::dccRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCDCCUpdateService::captureRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCDCCUpdateService::creditRequestID);
#endif
}

int ns2__CCDCCUpdateService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CCDCCUpdateService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CCDCCUpdateService(struct soap *soap, const char *tag, int id, const ns2__CCDCCUpdateService *a, const char *type)
{
	if (((ns2__CCDCCUpdateService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__CCDCCUpdateService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CCDCCUpdateService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reason", -1, (wchar_t*const*)&a->ns2__CCDCCUpdateService::reason, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:action", -1, (wchar_t*const*)&a->ns2__CCDCCUpdateService::action, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:dccRequestID", -1, (wchar_t*const*)&a->ns2__CCDCCUpdateService::dccRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:captureRequestID", -1, (wchar_t*const*)&a->ns2__CCDCCUpdateService::captureRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:creditRequestID", -1, (wchar_t*const*)&a->ns2__CCDCCUpdateService::creditRequestID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CCDCCUpdateService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CCDCCUpdateService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CCDCCUpdateService * SOAP_FMAC4 soap_in_ns2__CCDCCUpdateService(struct soap *soap, const char *tag, ns2__CCDCCUpdateService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CCDCCUpdateService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CCDCCUpdateService, sizeof(ns2__CCDCCUpdateService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CCDCCUpdateService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CCDCCUpdateService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__CCDCCUpdateService*)a)->run))
		return NULL;
	size_t soap_flag_reason1 = 1;
	size_t soap_flag_action1 = 1;
	size_t soap_flag_dccRequestID1 = 1;
	size_t soap_flag_captureRequestID1 = 1;
	size_t soap_flag_creditRequestID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reason", (wchar_t**)&a->ns2__CCDCCUpdateService::reason, "xsd:string"))
				{	soap_flag_reason1--;
					continue;
				}
			if (soap_flag_action1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:action", (wchar_t**)&a->ns2__CCDCCUpdateService::action, "xsd:string"))
				{	soap_flag_action1--;
					continue;
				}
			if (soap_flag_dccRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:dccRequestID", (wchar_t**)&a->ns2__CCDCCUpdateService::dccRequestID, "xsd:string"))
				{	soap_flag_dccRequestID1--;
					continue;
				}
			if (soap_flag_captureRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:captureRequestID", (wchar_t**)&a->ns2__CCDCCUpdateService::captureRequestID, "xsd:string"))
				{	soap_flag_captureRequestID1--;
					continue;
				}
			if (soap_flag_creditRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:creditRequestID", (wchar_t**)&a->ns2__CCDCCUpdateService::creditRequestID, "xsd:string"))
				{	soap_flag_creditRequestID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CCDCCUpdateService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CCDCCUpdateService, SOAP_TYPE_ns2__CCDCCUpdateService, sizeof(ns2__CCDCCUpdateService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CCDCCUpdateService * SOAP_FMAC2 soap_instantiate_ns2__CCDCCUpdateService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CCDCCUpdateService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CCDCCUpdateService *p;
	size_t k = sizeof(ns2__CCDCCUpdateService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CCDCCUpdateService);
		if (p)
			((ns2__CCDCCUpdateService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CCDCCUpdateService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CCDCCUpdateService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CCDCCUpdateService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CCDCCUpdateService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CCDCCUpdateService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CCDCCUpdateService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CCDCCUpdateService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CCDCCUpdateService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CCDCCUpdateService * SOAP_FMAC4 soap_get_ns2__CCDCCUpdateService(struct soap *soap, ns2__CCDCCUpdateService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CCDCCUpdateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PaypalTransaction::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PaypalTransaction::transactionTime = NULL;
	this->ns2__PaypalTransaction::transactionTimeZone = NULL;
	this->ns2__PaypalTransaction::transactionType = NULL;
	this->ns2__PaypalTransaction::paypalPayerOrPayeeEmail = NULL;
	this->ns2__PaypalTransaction::customerDisplayName = NULL;
	this->ns2__PaypalTransaction::transactionID = NULL;
	this->ns2__PaypalTransaction::paypalPaymentStatus = NULL;
	this->ns2__PaypalTransaction::grandTotalAmount = NULL;
	this->ns2__PaypalTransaction::currency = NULL;
	this->ns2__PaypalTransaction::paypalFeeAmount = NULL;
	this->ns2__PaypalTransaction::paypalNetAmount = NULL;
	this->ns2__PaypalTransaction::id = NULL;
	/* transient soap skipped */
}

void ns2__PaypalTransaction::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__PaypalTransaction::transactionTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaypalTransaction::transactionTimeZone);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaypalTransaction::transactionType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaypalTransaction::paypalPayerOrPayeeEmail);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaypalTransaction::customerDisplayName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaypalTransaction::transactionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaypalTransaction::paypalPaymentStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaypalTransaction::grandTotalAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaypalTransaction::currency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaypalTransaction::paypalFeeAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaypalTransaction::paypalNetAmount);
#endif
}

int ns2__PaypalTransaction::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PaypalTransaction(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PaypalTransaction(struct soap *soap, const char *tag, int id, const ns2__PaypalTransaction *a, const char *type)
{
	if (((ns2__PaypalTransaction*)a)->id)
		if (*((ns2__PaypalTransaction*)a)->id)
			soap_set_attr(soap, "id", soap_xsd__integer2s(soap, *((ns2__PaypalTransaction*)a)->id), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PaypalTransaction), type))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:transactionTime", -1, &a->ns2__PaypalTransaction::transactionTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionTimeZone", -1, (wchar_t*const*)&a->ns2__PaypalTransaction::transactionTimeZone, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionType", -1, (wchar_t*const*)&a->ns2__PaypalTransaction::transactionType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPayerOrPayeeEmail", -1, (wchar_t*const*)&a->ns2__PaypalTransaction::paypalPayerOrPayeeEmail, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:customerDisplayName", -1, (wchar_t*const*)&a->ns2__PaypalTransaction::customerDisplayName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionID", -1, (wchar_t*const*)&a->ns2__PaypalTransaction::transactionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPaymentStatus", -1, (wchar_t*const*)&a->ns2__PaypalTransaction::paypalPaymentStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:grandTotalAmount", -1, (wchar_t*const*)&a->ns2__PaypalTransaction::grandTotalAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:currency", -1, (wchar_t*const*)&a->ns2__PaypalTransaction::currency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalFeeAmount", -1, (wchar_t*const*)&a->ns2__PaypalTransaction::paypalFeeAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalNetAmount", -1, (wchar_t*const*)&a->ns2__PaypalTransaction::paypalNetAmount, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PaypalTransaction::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PaypalTransaction(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PaypalTransaction * SOAP_FMAC4 soap_in_ns2__PaypalTransaction(struct soap *soap, const char *tag, ns2__PaypalTransaction *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PaypalTransaction *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PaypalTransaction, sizeof(ns2__PaypalTransaction), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PaypalTransaction)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PaypalTransaction *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "id", 0);
		if (t)
		{
			if (!(((ns2__PaypalTransaction*)a)->id = (wchar_t **)soap_malloc(soap, sizeof(wchar_t *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__integer(soap, t, ((ns2__PaypalTransaction*)a)->id))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_transactionTime1 = 1;
	size_t soap_flag_transactionTimeZone1 = 1;
	size_t soap_flag_transactionType1 = 1;
	size_t soap_flag_paypalPayerOrPayeeEmail1 = 1;
	size_t soap_flag_customerDisplayName1 = 1;
	size_t soap_flag_transactionID1 = 1;
	size_t soap_flag_paypalPaymentStatus1 = 1;
	size_t soap_flag_grandTotalAmount1 = 1;
	size_t soap_flag_currency1 = 1;
	size_t soap_flag_paypalFeeAmount1 = 1;
	size_t soap_flag_paypalNetAmount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_transactionTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:transactionTime", &a->ns2__PaypalTransaction::transactionTime, "ns2:dateTime"))
				{	soap_flag_transactionTime1--;
					continue;
				}
			if (soap_flag_transactionTimeZone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionTimeZone", (wchar_t**)&a->ns2__PaypalTransaction::transactionTimeZone, "xsd:string"))
				{	soap_flag_transactionTimeZone1--;
					continue;
				}
			if (soap_flag_transactionType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionType", (wchar_t**)&a->ns2__PaypalTransaction::transactionType, "xsd:string"))
				{	soap_flag_transactionType1--;
					continue;
				}
			if (soap_flag_paypalPayerOrPayeeEmail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPayerOrPayeeEmail", (wchar_t**)&a->ns2__PaypalTransaction::paypalPayerOrPayeeEmail, "xsd:string"))
				{	soap_flag_paypalPayerOrPayeeEmail1--;
					continue;
				}
			if (soap_flag_customerDisplayName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:customerDisplayName", (wchar_t**)&a->ns2__PaypalTransaction::customerDisplayName, "xsd:string"))
				{	soap_flag_customerDisplayName1--;
					continue;
				}
			if (soap_flag_transactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionID", (wchar_t**)&a->ns2__PaypalTransaction::transactionID, "xsd:string"))
				{	soap_flag_transactionID1--;
					continue;
				}
			if (soap_flag_paypalPaymentStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPaymentStatus", (wchar_t**)&a->ns2__PaypalTransaction::paypalPaymentStatus, "xsd:string"))
				{	soap_flag_paypalPaymentStatus1--;
					continue;
				}
			if (soap_flag_grandTotalAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:grandTotalAmount", (wchar_t**)&a->ns2__PaypalTransaction::grandTotalAmount, "xsd:string"))
				{	soap_flag_grandTotalAmount1--;
					continue;
				}
			if (soap_flag_currency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:currency", (wchar_t**)&a->ns2__PaypalTransaction::currency, "xsd:string"))
				{	soap_flag_currency1--;
					continue;
				}
			if (soap_flag_paypalFeeAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalFeeAmount", (wchar_t**)&a->ns2__PaypalTransaction::paypalFeeAmount, "xsd:string"))
				{	soap_flag_paypalFeeAmount1--;
					continue;
				}
			if (soap_flag_paypalNetAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalNetAmount", (wchar_t**)&a->ns2__PaypalTransaction::paypalNetAmount, "xsd:string"))
				{	soap_flag_paypalNetAmount1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PaypalTransaction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PaypalTransaction, SOAP_TYPE_ns2__PaypalTransaction, sizeof(ns2__PaypalTransaction), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PaypalTransaction * SOAP_FMAC2 soap_instantiate_ns2__PaypalTransaction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PaypalTransaction(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PaypalTransaction *p;
	size_t k = sizeof(ns2__PaypalTransaction);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PaypalTransaction);
		if (p)
			((ns2__PaypalTransaction*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PaypalTransaction, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PaypalTransaction*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PaypalTransaction location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PaypalTransaction, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PaypalTransaction::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PaypalTransaction", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PaypalTransaction::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PaypalTransaction(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PaypalTransaction * SOAP_FMAC4 soap_get_ns2__PaypalTransaction(struct soap *soap, ns2__PaypalTransaction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PaypalTransaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalTransactionSearchReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalTransactionSearchReply::reasonCode = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__PaypalTransaction(soap, &this->ns2__PayPalTransactionSearchReply::transaction);
	this->ns2__PayPalTransactionSearchReply::errorCode = NULL;
	/* transient soap skipped */
}

void ns2__PayPalTransactionSearchReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PayPalTransactionSearchReply::reasonCode);
	soap_serialize_std__vectorTemplateOfPointerTons2__PaypalTransaction(soap, &this->ns2__PayPalTransactionSearchReply::transaction);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalTransactionSearchReply::errorCode);
#endif
}

int ns2__PayPalTransactionSearchReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalTransactionSearchReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalTransactionSearchReply(struct soap *soap, const char *tag, int id, const ns2__PayPalTransactionSearchReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalTransactionSearchReply), type))
		return soap->error;
	if (!a->ns2__PayPalTransactionSearchReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PayPalTransactionSearchReply::reasonCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__PaypalTransaction(soap, "ns2:transaction", -1, &a->ns2__PayPalTransactionSearchReply::transaction, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:errorCode", -1, (wchar_t*const*)&a->ns2__PayPalTransactionSearchReply::errorCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalTransactionSearchReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalTransactionSearchReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalTransactionSearchReply * SOAP_FMAC4 soap_in_ns2__PayPalTransactionSearchReply(struct soap *soap, const char *tag, ns2__PayPalTransactionSearchReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalTransactionSearchReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalTransactionSearchReply, sizeof(ns2__PayPalTransactionSearchReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalTransactionSearchReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalTransactionSearchReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_errorCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PayPalTransactionSearchReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__PaypalTransaction(soap, "ns2:transaction", &a->ns2__PayPalTransactionSearchReply::transaction, "ns2:PaypalTransaction"))
					continue;
			if (soap_flag_errorCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:errorCode", (wchar_t**)&a->ns2__PayPalTransactionSearchReply::errorCode, "xsd:string"))
				{	soap_flag_errorCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0 || a->ns2__PayPalTransactionSearchReply::transaction.size() > 999))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PayPalTransactionSearchReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalTransactionSearchReply, SOAP_TYPE_ns2__PayPalTransactionSearchReply, sizeof(ns2__PayPalTransactionSearchReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalTransactionSearchReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalTransactionSearchReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalTransactionSearchReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalTransactionSearchReply *p;
	size_t k = sizeof(ns2__PayPalTransactionSearchReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalTransactionSearchReply);
		if (p)
			((ns2__PayPalTransactionSearchReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalTransactionSearchReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalTransactionSearchReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalTransactionSearchReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalTransactionSearchReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalTransactionSearchReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalTransactionSearchReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalTransactionSearchReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalTransactionSearchReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalTransactionSearchReply * SOAP_FMAC4 soap_get_ns2__PayPalTransactionSearchReply(struct soap *soap, ns2__PayPalTransactionSearchReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalTransactionSearchReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalGetTxnDetailsReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalGetTxnDetailsReply::reasonCode = NULL;
	this->ns2__PayPalGetTxnDetailsReply::payer = NULL;
	this->ns2__PayPalGetTxnDetailsReply::payerId = NULL;
	this->ns2__PayPalGetTxnDetailsReply::payerStatus = NULL;
	this->ns2__PayPalGetTxnDetailsReply::payerCountry = NULL;
	this->ns2__PayPalGetTxnDetailsReply::payerBusiness = NULL;
	this->ns2__PayPalGetTxnDetailsReply::payerSalutation = NULL;
	this->ns2__PayPalGetTxnDetailsReply::payerFirstname = NULL;
	this->ns2__PayPalGetTxnDetailsReply::payerMiddlename = NULL;
	this->ns2__PayPalGetTxnDetailsReply::payerLastname = NULL;
	this->ns2__PayPalGetTxnDetailsReply::payerSuffix = NULL;
	this->ns2__PayPalGetTxnDetailsReply::addressID = NULL;
	this->ns2__PayPalGetTxnDetailsReply::addressStatus = NULL;
	this->ns2__PayPalGetTxnDetailsReply::shipToName = NULL;
	this->ns2__PayPalGetTxnDetailsReply::shipToAddress1 = NULL;
	this->ns2__PayPalGetTxnDetailsReply::shipToAddress2 = NULL;
	this->ns2__PayPalGetTxnDetailsReply::shipToCity = NULL;
	this->ns2__PayPalGetTxnDetailsReply::shipToState = NULL;
	this->ns2__PayPalGetTxnDetailsReply::shipToCountry = NULL;
	this->ns2__PayPalGetTxnDetailsReply::shipToZip = NULL;
	this->ns2__PayPalGetTxnDetailsReply::payerPhone = NULL;
	this->ns2__PayPalGetTxnDetailsReply::transactionId = NULL;
	this->ns2__PayPalGetTxnDetailsReply::parentTransactionId = NULL;
	this->ns2__PayPalGetTxnDetailsReply::paypalReceiptId = NULL;
	this->ns2__PayPalGetTxnDetailsReply::paypalTransactiontype = NULL;
	this->ns2__PayPalGetTxnDetailsReply::paypalPaymentType = NULL;
	this->ns2__PayPalGetTxnDetailsReply::paypalOrderTime = NULL;
	this->ns2__PayPalGetTxnDetailsReply::paypalPaymentGrossAmount = NULL;
	this->ns2__PayPalGetTxnDetailsReply::paypalFeeAmount = NULL;
	this->ns2__PayPalGetTxnDetailsReply::currency = NULL;
	this->ns2__PayPalGetTxnDetailsReply::paypalSettleAmount = NULL;
	this->ns2__PayPalGetTxnDetailsReply::paypalTaxAmount = NULL;
	this->ns2__PayPalGetTxnDetailsReply::paypalExchangeRate = NULL;
	this->ns2__PayPalGetTxnDetailsReply::paypalPaymentStatus = NULL;
	this->ns2__PayPalGetTxnDetailsReply::paypalPendingReason = NULL;
	this->ns2__PayPalGetTxnDetailsReply::paypalReasonCode = NULL;
	this->ns2__PayPalGetTxnDetailsReply::protectionEligibility = NULL;
	this->ns2__PayPalGetTxnDetailsReply::protectionEligibilityType = NULL;
	this->ns2__PayPalGetTxnDetailsReply::paypalNote = NULL;
	this->ns2__PayPalGetTxnDetailsReply::invoiceNumber = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__Item(soap, &this->ns2__PayPalGetTxnDetailsReply::item);
	this->ns2__PayPalGetTxnDetailsReply::errorCode = NULL;
	/* transient soap skipped */
}

void ns2__PayPalGetTxnDetailsReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::payer);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::payerId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::payerStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::payerCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::payerBusiness);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::payerSalutation);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::payerFirstname);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::payerMiddlename);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::payerLastname);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::payerSuffix);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::addressID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::addressStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::shipToName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::shipToAddress1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::shipToAddress2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::shipToCity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::shipToState);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::shipToCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::shipToZip);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::payerPhone);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::transactionId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::parentTransactionId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::paypalReceiptId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::paypalTransactiontype);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::paypalPaymentType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::paypalOrderTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::paypalPaymentGrossAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::paypalFeeAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::currency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::paypalSettleAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::paypalTaxAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::paypalExchangeRate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::paypalPaymentStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::paypalPendingReason);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::paypalReasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::protectionEligibility);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::protectionEligibilityType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::paypalNote);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::invoiceNumber);
	soap_serialize_std__vectorTemplateOfPointerTons2__Item(soap, &this->ns2__PayPalGetTxnDetailsReply::item);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsReply::errorCode);
#endif
}

int ns2__PayPalGetTxnDetailsReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalGetTxnDetailsReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalGetTxnDetailsReply(struct soap *soap, const char *tag, int id, const ns2__PayPalGetTxnDetailsReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalGetTxnDetailsReply), type))
		return soap->error;
	if (!a->ns2__PayPalGetTxnDetailsReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payer", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::payer, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerId", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::payerId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerStatus", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::payerStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerCountry", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::payerCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerBusiness", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::payerBusiness, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerSalutation", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::payerSalutation, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerFirstname", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::payerFirstname, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerMiddlename", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::payerMiddlename, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerLastname", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::payerLastname, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerSuffix", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::payerSuffix, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:addressID", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::addressID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:addressStatus", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::addressStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToName", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::shipToName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToAddress1", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::shipToAddress1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToAddress2", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::shipToAddress2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToCity", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::shipToCity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToState", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::shipToState, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToCountry", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::shipToCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToZip", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::shipToZip, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerPhone", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::payerPhone, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionId", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::transactionId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:parentTransactionId", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::parentTransactionId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalReceiptId", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::paypalReceiptId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalTransactiontype", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::paypalTransactiontype, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPaymentType", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::paypalPaymentType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalOrderTime", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::paypalOrderTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPaymentGrossAmount", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::paypalPaymentGrossAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalFeeAmount", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::paypalFeeAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:currency", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::currency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalSettleAmount", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::paypalSettleAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalTaxAmount", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::paypalTaxAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalExchangeRate", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::paypalExchangeRate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPaymentStatus", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::paypalPaymentStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPendingReason", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::paypalPendingReason, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalReasonCode", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::paypalReasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:protectionEligibility", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::protectionEligibility, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:protectionEligibilityType", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::protectionEligibilityType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalNote", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::paypalNote, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:invoiceNumber", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::invoiceNumber, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__Item(soap, "ns2:item", -1, &a->ns2__PayPalGetTxnDetailsReply::item, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:errorCode", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsReply::errorCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalGetTxnDetailsReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalGetTxnDetailsReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalGetTxnDetailsReply * SOAP_FMAC4 soap_in_ns2__PayPalGetTxnDetailsReply(struct soap *soap, const char *tag, ns2__PayPalGetTxnDetailsReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalGetTxnDetailsReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalGetTxnDetailsReply, sizeof(ns2__PayPalGetTxnDetailsReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalGetTxnDetailsReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalGetTxnDetailsReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_payer1 = 1;
	size_t soap_flag_payerId1 = 1;
	size_t soap_flag_payerStatus1 = 1;
	size_t soap_flag_payerCountry1 = 1;
	size_t soap_flag_payerBusiness1 = 1;
	size_t soap_flag_payerSalutation1 = 1;
	size_t soap_flag_payerFirstname1 = 1;
	size_t soap_flag_payerMiddlename1 = 1;
	size_t soap_flag_payerLastname1 = 1;
	size_t soap_flag_payerSuffix1 = 1;
	size_t soap_flag_addressID1 = 1;
	size_t soap_flag_addressStatus1 = 1;
	size_t soap_flag_shipToName1 = 1;
	size_t soap_flag_shipToAddress11 = 1;
	size_t soap_flag_shipToAddress21 = 1;
	size_t soap_flag_shipToCity1 = 1;
	size_t soap_flag_shipToState1 = 1;
	size_t soap_flag_shipToCountry1 = 1;
	size_t soap_flag_shipToZip1 = 1;
	size_t soap_flag_payerPhone1 = 1;
	size_t soap_flag_transactionId1 = 1;
	size_t soap_flag_parentTransactionId1 = 1;
	size_t soap_flag_paypalReceiptId1 = 1;
	size_t soap_flag_paypalTransactiontype1 = 1;
	size_t soap_flag_paypalPaymentType1 = 1;
	size_t soap_flag_paypalOrderTime1 = 1;
	size_t soap_flag_paypalPaymentGrossAmount1 = 1;
	size_t soap_flag_paypalFeeAmount1 = 1;
	size_t soap_flag_currency1 = 1;
	size_t soap_flag_paypalSettleAmount1 = 1;
	size_t soap_flag_paypalTaxAmount1 = 1;
	size_t soap_flag_paypalExchangeRate1 = 1;
	size_t soap_flag_paypalPaymentStatus1 = 1;
	size_t soap_flag_paypalPendingReason1 = 1;
	size_t soap_flag_paypalReasonCode1 = 1;
	size_t soap_flag_protectionEligibility1 = 1;
	size_t soap_flag_protectionEligibilityType1 = 1;
	size_t soap_flag_paypalNote1 = 1;
	size_t soap_flag_invoiceNumber1 = 1;
	size_t soap_flag_errorCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_payer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payer", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::payer, "xsd:string"))
				{	soap_flag_payer1--;
					continue;
				}
			if (soap_flag_payerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerId", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::payerId, "xsd:string"))
				{	soap_flag_payerId1--;
					continue;
				}
			if (soap_flag_payerStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerStatus", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::payerStatus, "xsd:string"))
				{	soap_flag_payerStatus1--;
					continue;
				}
			if (soap_flag_payerCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerCountry", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::payerCountry, "xsd:string"))
				{	soap_flag_payerCountry1--;
					continue;
				}
			if (soap_flag_payerBusiness1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerBusiness", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::payerBusiness, "xsd:string"))
				{	soap_flag_payerBusiness1--;
					continue;
				}
			if (soap_flag_payerSalutation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerSalutation", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::payerSalutation, "xsd:string"))
				{	soap_flag_payerSalutation1--;
					continue;
				}
			if (soap_flag_payerFirstname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerFirstname", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::payerFirstname, "xsd:string"))
				{	soap_flag_payerFirstname1--;
					continue;
				}
			if (soap_flag_payerMiddlename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerMiddlename", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::payerMiddlename, "xsd:string"))
				{	soap_flag_payerMiddlename1--;
					continue;
				}
			if (soap_flag_payerLastname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerLastname", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::payerLastname, "xsd:string"))
				{	soap_flag_payerLastname1--;
					continue;
				}
			if (soap_flag_payerSuffix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerSuffix", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::payerSuffix, "xsd:string"))
				{	soap_flag_payerSuffix1--;
					continue;
				}
			if (soap_flag_addressID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:addressID", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::addressID, "xsd:string"))
				{	soap_flag_addressID1--;
					continue;
				}
			if (soap_flag_addressStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:addressStatus", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::addressStatus, "xsd:string"))
				{	soap_flag_addressStatus1--;
					continue;
				}
			if (soap_flag_shipToName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToName", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::shipToName, "xsd:string"))
				{	soap_flag_shipToName1--;
					continue;
				}
			if (soap_flag_shipToAddress11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToAddress1", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::shipToAddress1, "xsd:string"))
				{	soap_flag_shipToAddress11--;
					continue;
				}
			if (soap_flag_shipToAddress21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToAddress2", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::shipToAddress2, "xsd:string"))
				{	soap_flag_shipToAddress21--;
					continue;
				}
			if (soap_flag_shipToCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToCity", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::shipToCity, "xsd:string"))
				{	soap_flag_shipToCity1--;
					continue;
				}
			if (soap_flag_shipToState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToState", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::shipToState, "xsd:string"))
				{	soap_flag_shipToState1--;
					continue;
				}
			if (soap_flag_shipToCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToCountry", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::shipToCountry, "xsd:string"))
				{	soap_flag_shipToCountry1--;
					continue;
				}
			if (soap_flag_shipToZip1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToZip", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::shipToZip, "xsd:string"))
				{	soap_flag_shipToZip1--;
					continue;
				}
			if (soap_flag_payerPhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerPhone", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::payerPhone, "xsd:string"))
				{	soap_flag_payerPhone1--;
					continue;
				}
			if (soap_flag_transactionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionId", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::transactionId, "xsd:string"))
				{	soap_flag_transactionId1--;
					continue;
				}
			if (soap_flag_parentTransactionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:parentTransactionId", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::parentTransactionId, "xsd:string"))
				{	soap_flag_parentTransactionId1--;
					continue;
				}
			if (soap_flag_paypalReceiptId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalReceiptId", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::paypalReceiptId, "xsd:string"))
				{	soap_flag_paypalReceiptId1--;
					continue;
				}
			if (soap_flag_paypalTransactiontype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalTransactiontype", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::paypalTransactiontype, "xsd:string"))
				{	soap_flag_paypalTransactiontype1--;
					continue;
				}
			if (soap_flag_paypalPaymentType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPaymentType", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::paypalPaymentType, "xsd:string"))
				{	soap_flag_paypalPaymentType1--;
					continue;
				}
			if (soap_flag_paypalOrderTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalOrderTime", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::paypalOrderTime, "xsd:string"))
				{	soap_flag_paypalOrderTime1--;
					continue;
				}
			if (soap_flag_paypalPaymentGrossAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPaymentGrossAmount", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::paypalPaymentGrossAmount, "xsd:string"))
				{	soap_flag_paypalPaymentGrossAmount1--;
					continue;
				}
			if (soap_flag_paypalFeeAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalFeeAmount", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::paypalFeeAmount, "xsd:string"))
				{	soap_flag_paypalFeeAmount1--;
					continue;
				}
			if (soap_flag_currency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:currency", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::currency, "xsd:string"))
				{	soap_flag_currency1--;
					continue;
				}
			if (soap_flag_paypalSettleAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalSettleAmount", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::paypalSettleAmount, "xsd:string"))
				{	soap_flag_paypalSettleAmount1--;
					continue;
				}
			if (soap_flag_paypalTaxAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalTaxAmount", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::paypalTaxAmount, "xsd:string"))
				{	soap_flag_paypalTaxAmount1--;
					continue;
				}
			if (soap_flag_paypalExchangeRate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalExchangeRate", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::paypalExchangeRate, "xsd:string"))
				{	soap_flag_paypalExchangeRate1--;
					continue;
				}
			if (soap_flag_paypalPaymentStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPaymentStatus", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::paypalPaymentStatus, "xsd:string"))
				{	soap_flag_paypalPaymentStatus1--;
					continue;
				}
			if (soap_flag_paypalPendingReason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPendingReason", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::paypalPendingReason, "xsd:string"))
				{	soap_flag_paypalPendingReason1--;
					continue;
				}
			if (soap_flag_paypalReasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalReasonCode", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::paypalReasonCode, "xsd:string"))
				{	soap_flag_paypalReasonCode1--;
					continue;
				}
			if (soap_flag_protectionEligibility1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:protectionEligibility", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::protectionEligibility, "xsd:string"))
				{	soap_flag_protectionEligibility1--;
					continue;
				}
			if (soap_flag_protectionEligibilityType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:protectionEligibilityType", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::protectionEligibilityType, "xsd:string"))
				{	soap_flag_protectionEligibilityType1--;
					continue;
				}
			if (soap_flag_paypalNote1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalNote", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::paypalNote, "xsd:string"))
				{	soap_flag_paypalNote1--;
					continue;
				}
			if (soap_flag_invoiceNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:invoiceNumber", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::invoiceNumber, "xsd:string"))
				{	soap_flag_invoiceNumber1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__Item(soap, "ns2:item", &a->ns2__PayPalGetTxnDetailsReply::item, "ns2:Item"))
					continue;
			if (soap_flag_errorCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:errorCode", (wchar_t**)&a->ns2__PayPalGetTxnDetailsReply::errorCode, "xsd:string"))
				{	soap_flag_errorCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0 || a->ns2__PayPalGetTxnDetailsReply::item.size() > 1000))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PayPalGetTxnDetailsReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalGetTxnDetailsReply, SOAP_TYPE_ns2__PayPalGetTxnDetailsReply, sizeof(ns2__PayPalGetTxnDetailsReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalGetTxnDetailsReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalGetTxnDetailsReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalGetTxnDetailsReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalGetTxnDetailsReply *p;
	size_t k = sizeof(ns2__PayPalGetTxnDetailsReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalGetTxnDetailsReply);
		if (p)
			((ns2__PayPalGetTxnDetailsReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalGetTxnDetailsReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalGetTxnDetailsReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalGetTxnDetailsReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalGetTxnDetailsReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalGetTxnDetailsReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalGetTxnDetailsReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalGetTxnDetailsReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalGetTxnDetailsReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalGetTxnDetailsReply * SOAP_FMAC4 soap_get_ns2__PayPalGetTxnDetailsReply(struct soap *soap, ns2__PayPalGetTxnDetailsReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalGetTxnDetailsReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__RequestReserved::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RequestReserved::name = NULL;
	this->ns2__RequestReserved::value = NULL;
	/* transient soap skipped */
}

void ns2__RequestReserved::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestReserved::name);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestReserved::value);
#endif
}

int ns2__RequestReserved::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RequestReserved(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RequestReserved(struct soap *soap, const char *tag, int id, const ns2__RequestReserved *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RequestReserved), type))
		return soap->error;
	if (!a->ns2__RequestReserved::name)
	{	if (soap_element_nil(soap, "ns2:name"))
			return soap->error;
	}
	else
	if (soap_out_wstring(soap, "ns2:name", -1, (wchar_t*const*)&a->ns2__RequestReserved::name, ""))
		return soap->error;
	if (!a->ns2__RequestReserved::value)
	{	if (soap_element_nil(soap, "ns2:value"))
			return soap->error;
	}
	else
	if (soap_out_wstring(soap, "ns2:value", -1, (wchar_t*const*)&a->ns2__RequestReserved::value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__RequestReserved::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RequestReserved(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RequestReserved * SOAP_FMAC4 soap_in_ns2__RequestReserved(struct soap *soap, const char *tag, ns2__RequestReserved *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RequestReserved *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RequestReserved, sizeof(ns2__RequestReserved), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__RequestReserved)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__RequestReserved *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_name1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:name", (wchar_t**)&a->ns2__RequestReserved::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:value", (wchar_t**)&a->ns2__RequestReserved::value, "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0 || soap_flag_value1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__RequestReserved *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RequestReserved, SOAP_TYPE_ns2__RequestReserved, sizeof(ns2__RequestReserved), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__RequestReserved * SOAP_FMAC2 soap_instantiate_ns2__RequestReserved(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RequestReserved(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__RequestReserved *p;
	size_t k = sizeof(ns2__RequestReserved);
	if (n < 0)
	{	p = SOAP_NEW(ns2__RequestReserved);
		if (p)
			((ns2__RequestReserved*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__RequestReserved, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__RequestReserved*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__RequestReserved location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__RequestReserved, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__RequestReserved::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:RequestReserved", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RequestReserved::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RequestReserved(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RequestReserved * SOAP_FMAC4 soap_get_ns2__RequestReserved(struct soap *soap, ns2__RequestReserved *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RequestReserved(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ReplyReserved::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns2__ReplyReserved::__any);
	/* transient soap skipped */
}

void ns2__ReplyReserved::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns2__ReplyReserved::__any);
#endif
}

int ns2__ReplyReserved::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ReplyReserved(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ReplyReserved(struct soap *soap, const char *tag, int id, const ns2__ReplyReserved *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ReplyReserved), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->ns2__ReplyReserved::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ReplyReserved::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ReplyReserved(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ReplyReserved * SOAP_FMAC4 soap_in_ns2__ReplyReserved(struct soap *soap, const char *tag, ns2__ReplyReserved *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ReplyReserved *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ReplyReserved, sizeof(ns2__ReplyReserved), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ReplyReserved)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ReplyReserved *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->ns2__ReplyReserved::__any, ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ReplyReserved *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ReplyReserved, SOAP_TYPE_ns2__ReplyReserved, sizeof(ns2__ReplyReserved), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ReplyReserved * SOAP_FMAC2 soap_instantiate_ns2__ReplyReserved(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ReplyReserved(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ReplyReserved *p;
	size_t k = sizeof(ns2__ReplyReserved);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ReplyReserved);
		if (p)
			((ns2__ReplyReserved*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ReplyReserved, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ReplyReserved*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ReplyReserved location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ReplyReserved, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ReplyReserved::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:ReplyReserved", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ReplyReserved::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ReplyReserved(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ReplyReserved * SOAP_FMAC4 soap_get_ns2__ReplyReserved(struct soap *soap, ns2__ReplyReserved *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ReplyReserved(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__MerchantSecureData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__MerchantSecureData::field1 = NULL;
	this->ns2__MerchantSecureData::field2 = NULL;
	this->ns2__MerchantSecureData::field3 = NULL;
	this->ns2__MerchantSecureData::field4 = NULL;
	/* transient soap skipped */
}

void ns2__MerchantSecureData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantSecureData::field1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantSecureData::field2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantSecureData::field3);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantSecureData::field4);
#endif
}

int ns2__MerchantSecureData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MerchantSecureData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MerchantSecureData(struct soap *soap, const char *tag, int id, const ns2__MerchantSecureData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MerchantSecureData), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field1", -1, (wchar_t*const*)&a->ns2__MerchantSecureData::field1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field2", -1, (wchar_t*const*)&a->ns2__MerchantSecureData::field2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field3", -1, (wchar_t*const*)&a->ns2__MerchantSecureData::field3, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field4", -1, (wchar_t*const*)&a->ns2__MerchantSecureData::field4, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__MerchantSecureData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MerchantSecureData(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MerchantSecureData * SOAP_FMAC4 soap_in_ns2__MerchantSecureData(struct soap *soap, const char *tag, ns2__MerchantSecureData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MerchantSecureData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MerchantSecureData, sizeof(ns2__MerchantSecureData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__MerchantSecureData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__MerchantSecureData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_field11 = 1;
	size_t soap_flag_field21 = 1;
	size_t soap_flag_field31 = 1;
	size_t soap_flag_field41 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_field11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field1", (wchar_t**)&a->ns2__MerchantSecureData::field1, "xsd:string"))
				{	soap_flag_field11--;
					continue;
				}
			if (soap_flag_field21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field2", (wchar_t**)&a->ns2__MerchantSecureData::field2, "xsd:string"))
				{	soap_flag_field21--;
					continue;
				}
			if (soap_flag_field31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field3", (wchar_t**)&a->ns2__MerchantSecureData::field3, "xsd:string"))
				{	soap_flag_field31--;
					continue;
				}
			if (soap_flag_field41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field4", (wchar_t**)&a->ns2__MerchantSecureData::field4, "xsd:string"))
				{	soap_flag_field41--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MerchantSecureData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MerchantSecureData, SOAP_TYPE_ns2__MerchantSecureData, sizeof(ns2__MerchantSecureData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__MerchantSecureData * SOAP_FMAC2 soap_instantiate_ns2__MerchantSecureData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MerchantSecureData(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__MerchantSecureData *p;
	size_t k = sizeof(ns2__MerchantSecureData);
	if (n < 0)
	{	p = SOAP_NEW(ns2__MerchantSecureData);
		if (p)
			((ns2__MerchantSecureData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__MerchantSecureData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__MerchantSecureData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__MerchantSecureData location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__MerchantSecureData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__MerchantSecureData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:MerchantSecureData", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MerchantSecureData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MerchantSecureData(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MerchantSecureData * SOAP_FMAC4 soap_get_ns2__MerchantSecureData(struct soap *soap, ns2__MerchantSecureData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MerchantSecureData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__MerchantDefinedData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__MerchantDefinedData::field1 = NULL;
	this->ns2__MerchantDefinedData::field2 = NULL;
	this->ns2__MerchantDefinedData::field3 = NULL;
	this->ns2__MerchantDefinedData::field4 = NULL;
	this->ns2__MerchantDefinedData::field5 = NULL;
	this->ns2__MerchantDefinedData::field6 = NULL;
	this->ns2__MerchantDefinedData::field7 = NULL;
	this->ns2__MerchantDefinedData::field8 = NULL;
	this->ns2__MerchantDefinedData::field9 = NULL;
	this->ns2__MerchantDefinedData::field10 = NULL;
	this->ns2__MerchantDefinedData::field11 = NULL;
	this->ns2__MerchantDefinedData::field12 = NULL;
	this->ns2__MerchantDefinedData::field13 = NULL;
	this->ns2__MerchantDefinedData::field14 = NULL;
	this->ns2__MerchantDefinedData::field15 = NULL;
	this->ns2__MerchantDefinedData::field16 = NULL;
	this->ns2__MerchantDefinedData::field17 = NULL;
	this->ns2__MerchantDefinedData::field18 = NULL;
	this->ns2__MerchantDefinedData::field19 = NULL;
	this->ns2__MerchantDefinedData::field20 = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__MDDField(soap, &this->ns2__MerchantDefinedData::mddField);
	/* transient soap skipped */
}

void ns2__MerchantDefinedData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantDefinedData::field1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantDefinedData::field2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantDefinedData::field3);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantDefinedData::field4);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantDefinedData::field5);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantDefinedData::field6);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantDefinedData::field7);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantDefinedData::field8);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantDefinedData::field9);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantDefinedData::field10);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantDefinedData::field11);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantDefinedData::field12);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantDefinedData::field13);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantDefinedData::field14);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantDefinedData::field15);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantDefinedData::field16);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantDefinedData::field17);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantDefinedData::field18);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantDefinedData::field19);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MerchantDefinedData::field20);
	soap_serialize_std__vectorTemplateOfPointerTons2__MDDField(soap, &this->ns2__MerchantDefinedData::mddField);
#endif
}

int ns2__MerchantDefinedData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MerchantDefinedData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MerchantDefinedData(struct soap *soap, const char *tag, int id, const ns2__MerchantDefinedData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MerchantDefinedData), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field1", -1, (wchar_t*const*)&a->ns2__MerchantDefinedData::field1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field2", -1, (wchar_t*const*)&a->ns2__MerchantDefinedData::field2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field3", -1, (wchar_t*const*)&a->ns2__MerchantDefinedData::field3, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field4", -1, (wchar_t*const*)&a->ns2__MerchantDefinedData::field4, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field5", -1, (wchar_t*const*)&a->ns2__MerchantDefinedData::field5, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field6", -1, (wchar_t*const*)&a->ns2__MerchantDefinedData::field6, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field7", -1, (wchar_t*const*)&a->ns2__MerchantDefinedData::field7, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field8", -1, (wchar_t*const*)&a->ns2__MerchantDefinedData::field8, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field9", -1, (wchar_t*const*)&a->ns2__MerchantDefinedData::field9, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field10", -1, (wchar_t*const*)&a->ns2__MerchantDefinedData::field10, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field11", -1, (wchar_t*const*)&a->ns2__MerchantDefinedData::field11, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field12", -1, (wchar_t*const*)&a->ns2__MerchantDefinedData::field12, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field13", -1, (wchar_t*const*)&a->ns2__MerchantDefinedData::field13, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field14", -1, (wchar_t*const*)&a->ns2__MerchantDefinedData::field14, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field15", -1, (wchar_t*const*)&a->ns2__MerchantDefinedData::field15, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field16", -1, (wchar_t*const*)&a->ns2__MerchantDefinedData::field16, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field17", -1, (wchar_t*const*)&a->ns2__MerchantDefinedData::field17, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field18", -1, (wchar_t*const*)&a->ns2__MerchantDefinedData::field18, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field19", -1, (wchar_t*const*)&a->ns2__MerchantDefinedData::field19, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:field20", -1, (wchar_t*const*)&a->ns2__MerchantDefinedData::field20, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__MDDField(soap, "ns2:mddField", -1, &a->ns2__MerchantDefinedData::mddField, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__MerchantDefinedData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MerchantDefinedData(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MerchantDefinedData * SOAP_FMAC4 soap_in_ns2__MerchantDefinedData(struct soap *soap, const char *tag, ns2__MerchantDefinedData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MerchantDefinedData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MerchantDefinedData, sizeof(ns2__MerchantDefinedData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__MerchantDefinedData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__MerchantDefinedData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_field11 = 1;
	size_t soap_flag_field21 = 1;
	size_t soap_flag_field31 = 1;
	size_t soap_flag_field41 = 1;
	size_t soap_flag_field51 = 1;
	size_t soap_flag_field61 = 1;
	size_t soap_flag_field71 = 1;
	size_t soap_flag_field81 = 1;
	size_t soap_flag_field91 = 1;
	size_t soap_flag_field101 = 1;
	size_t soap_flag_field111 = 1;
	size_t soap_flag_field121 = 1;
	size_t soap_flag_field131 = 1;
	size_t soap_flag_field141 = 1;
	size_t soap_flag_field151 = 1;
	size_t soap_flag_field161 = 1;
	size_t soap_flag_field171 = 1;
	size_t soap_flag_field181 = 1;
	size_t soap_flag_field191 = 1;
	size_t soap_flag_field201 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_field11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field1", (wchar_t**)&a->ns2__MerchantDefinedData::field1, "xsd:string"))
				{	soap_flag_field11--;
					continue;
				}
			if (soap_flag_field21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field2", (wchar_t**)&a->ns2__MerchantDefinedData::field2, "xsd:string"))
				{	soap_flag_field21--;
					continue;
				}
			if (soap_flag_field31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field3", (wchar_t**)&a->ns2__MerchantDefinedData::field3, "xsd:string"))
				{	soap_flag_field31--;
					continue;
				}
			if (soap_flag_field41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field4", (wchar_t**)&a->ns2__MerchantDefinedData::field4, "xsd:string"))
				{	soap_flag_field41--;
					continue;
				}
			if (soap_flag_field51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field5", (wchar_t**)&a->ns2__MerchantDefinedData::field5, "xsd:string"))
				{	soap_flag_field51--;
					continue;
				}
			if (soap_flag_field61 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field6", (wchar_t**)&a->ns2__MerchantDefinedData::field6, "xsd:string"))
				{	soap_flag_field61--;
					continue;
				}
			if (soap_flag_field71 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field7", (wchar_t**)&a->ns2__MerchantDefinedData::field7, "xsd:string"))
				{	soap_flag_field71--;
					continue;
				}
			if (soap_flag_field81 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field8", (wchar_t**)&a->ns2__MerchantDefinedData::field8, "xsd:string"))
				{	soap_flag_field81--;
					continue;
				}
			if (soap_flag_field91 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field9", (wchar_t**)&a->ns2__MerchantDefinedData::field9, "xsd:string"))
				{	soap_flag_field91--;
					continue;
				}
			if (soap_flag_field101 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field10", (wchar_t**)&a->ns2__MerchantDefinedData::field10, "xsd:string"))
				{	soap_flag_field101--;
					continue;
				}
			if (soap_flag_field111 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field11", (wchar_t**)&a->ns2__MerchantDefinedData::field11, "xsd:string"))
				{	soap_flag_field111--;
					continue;
				}
			if (soap_flag_field121 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field12", (wchar_t**)&a->ns2__MerchantDefinedData::field12, "xsd:string"))
				{	soap_flag_field121--;
					continue;
				}
			if (soap_flag_field131 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field13", (wchar_t**)&a->ns2__MerchantDefinedData::field13, "xsd:string"))
				{	soap_flag_field131--;
					continue;
				}
			if (soap_flag_field141 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field14", (wchar_t**)&a->ns2__MerchantDefinedData::field14, "xsd:string"))
				{	soap_flag_field141--;
					continue;
				}
			if (soap_flag_field151 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field15", (wchar_t**)&a->ns2__MerchantDefinedData::field15, "xsd:string"))
				{	soap_flag_field151--;
					continue;
				}
			if (soap_flag_field161 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field16", (wchar_t**)&a->ns2__MerchantDefinedData::field16, "xsd:string"))
				{	soap_flag_field161--;
					continue;
				}
			if (soap_flag_field171 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field17", (wchar_t**)&a->ns2__MerchantDefinedData::field17, "xsd:string"))
				{	soap_flag_field171--;
					continue;
				}
			if (soap_flag_field181 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field18", (wchar_t**)&a->ns2__MerchantDefinedData::field18, "xsd:string"))
				{	soap_flag_field181--;
					continue;
				}
			if (soap_flag_field191 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field19", (wchar_t**)&a->ns2__MerchantDefinedData::field19, "xsd:string"))
				{	soap_flag_field191--;
					continue;
				}
			if (soap_flag_field201 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:field20", (wchar_t**)&a->ns2__MerchantDefinedData::field20, "xsd:string"))
				{	soap_flag_field201--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__MDDField(soap, "ns2:mddField", &a->ns2__MerchantDefinedData::mddField, "ns2:MDDField"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__MerchantDefinedData::mddField.size() > 100))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns2__MerchantDefinedData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MerchantDefinedData, SOAP_TYPE_ns2__MerchantDefinedData, sizeof(ns2__MerchantDefinedData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__MerchantDefinedData * SOAP_FMAC2 soap_instantiate_ns2__MerchantDefinedData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MerchantDefinedData(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__MerchantDefinedData *p;
	size_t k = sizeof(ns2__MerchantDefinedData);
	if (n < 0)
	{	p = SOAP_NEW(ns2__MerchantDefinedData);
		if (p)
			((ns2__MerchantDefinedData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__MerchantDefinedData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__MerchantDefinedData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__MerchantDefinedData location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__MerchantDefinedData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__MerchantDefinedData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:MerchantDefinedData", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MerchantDefinedData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MerchantDefinedData(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MerchantDefinedData * SOAP_FMAC4 soap_get_ns2__MerchantDefinedData(struct soap *soap, ns2__MerchantDefinedData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MerchantDefinedData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__MDDField::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__MDDField::__item = NULL;
	this->ns2__MDDField::id = NULL;
	/* transient soap skipped */
}

void ns2__MDDField::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__MDDField::__item);
#endif
}

int ns2__MDDField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MDDField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MDDField(struct soap *soap, const char *tag, int id, const ns2__MDDField *a, const char *type)
{
	if (((ns2__MDDField*)a)->id)
		soap_set_attr(soap, "id", soap_xsd__integer2s(soap, ((ns2__MDDField*)a)->id), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_wstring(soap, tag, id, (wchar_t*const*)&a->ns2__MDDField::__item, "");
}

void *ns2__MDDField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MDDField(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MDDField * SOAP_FMAC4 soap_in_ns2__MDDField(struct soap *soap, const char *tag, ns2__MDDField *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns2__MDDField *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MDDField, sizeof(ns2__MDDField), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__MDDField)
		return (ns2__MDDField *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__integer(soap, soap_attr_value(soap, "id", 1), &((ns2__MDDField*)a)->id))
		return NULL;
	if (!soap_in_wstring(soap, tag, (wchar_t**)&a->ns2__MDDField::__item, "ns2:MDDField"))
		return NULL;
	return a;
}

SOAP_FMAC1 ns2__MDDField * SOAP_FMAC2 soap_instantiate_ns2__MDDField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MDDField(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__MDDField *p;
	size_t k = sizeof(ns2__MDDField);
	if (n < 0)
	{	p = SOAP_NEW(ns2__MDDField);
		if (p)
			((ns2__MDDField*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__MDDField, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__MDDField*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__MDDField location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__MDDField, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__MDDField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:MDDField", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MDDField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MDDField(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MDDField * SOAP_FMAC4 soap_get_ns2__MDDField(struct soap *soap, ns2__MDDField *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MDDField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Installment::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Installment::sequence = NULL;
	this->ns2__Installment::totalCount = NULL;
	this->ns2__Installment::totalAmount = NULL;
	this->ns2__Installment::frequency = NULL;
	this->ns2__Installment::amount = NULL;
	this->ns2__Installment::planType = NULL;
	/* transient soap skipped */
}

void ns2__Installment::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Installment::sequence);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Installment::totalCount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Installment::totalAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Installment::frequency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Installment::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Installment::planType);
#endif
}

int ns2__Installment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Installment(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Installment(struct soap *soap, const char *tag, int id, const ns2__Installment *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Installment), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sequence", -1, (wchar_t*const*)&a->ns2__Installment::sequence, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:totalCount", -1, (wchar_t*const*)&a->ns2__Installment::totalCount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:totalAmount", -1, (wchar_t*const*)&a->ns2__Installment::totalAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:frequency", -1, (wchar_t*const*)&a->ns2__Installment::frequency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:amount", -1, (wchar_t*const*)&a->ns2__Installment::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:planType", -1, (wchar_t*const*)&a->ns2__Installment::planType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Installment::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Installment(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Installment * SOAP_FMAC4 soap_in_ns2__Installment(struct soap *soap, const char *tag, ns2__Installment *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Installment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Installment, sizeof(ns2__Installment), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Installment)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Installment *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sequence1 = 1;
	size_t soap_flag_totalCount1 = 1;
	size_t soap_flag_totalAmount1 = 1;
	size_t soap_flag_frequency1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_planType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sequence1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sequence", (wchar_t**)&a->ns2__Installment::sequence, "xsd:string"))
				{	soap_flag_sequence1--;
					continue;
				}
			if (soap_flag_totalCount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:totalCount", (wchar_t**)&a->ns2__Installment::totalCount, "xsd:string"))
				{	soap_flag_totalCount1--;
					continue;
				}
			if (soap_flag_totalAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:totalAmount", (wchar_t**)&a->ns2__Installment::totalAmount, "xsd:string"))
				{	soap_flag_totalAmount1--;
					continue;
				}
			if (soap_flag_frequency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:frequency", (wchar_t**)&a->ns2__Installment::frequency, "xsd:string"))
				{	soap_flag_frequency1--;
					continue;
				}
			if (soap_flag_amount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:amount", (wchar_t**)&a->ns2__Installment::amount, "xsd:string"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_planType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:planType", (wchar_t**)&a->ns2__Installment::planType, "xsd:string"))
				{	soap_flag_planType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Installment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Installment, SOAP_TYPE_ns2__Installment, sizeof(ns2__Installment), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Installment * SOAP_FMAC2 soap_instantiate_ns2__Installment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Installment(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Installment *p;
	size_t k = sizeof(ns2__Installment);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Installment);
		if (p)
			((ns2__Installment*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Installment, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Installment*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Installment location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Installment, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Installment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:Installment", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Installment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Installment(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Installment * SOAP_FMAC4 soap_get_ns2__Installment(struct soap *soap, ns2__Installment *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Installment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__EncryptedPayment::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__EncryptedPayment::descriptor = NULL;
	this->ns2__EncryptedPayment::data = NULL;
	this->ns2__EncryptedPayment::encoding = NULL;
	this->ns2__EncryptedPayment::wrappedKey = NULL;
	/* transient soap skipped */
}

void ns2__EncryptedPayment::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__EncryptedPayment::descriptor);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__EncryptedPayment::data);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__EncryptedPayment::encoding);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__EncryptedPayment::wrappedKey);
#endif
}

int ns2__EncryptedPayment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__EncryptedPayment(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EncryptedPayment(struct soap *soap, const char *tag, int id, const ns2__EncryptedPayment *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EncryptedPayment), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:descriptor", -1, (wchar_t*const*)&a->ns2__EncryptedPayment::descriptor, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:data", -1, (wchar_t*const*)&a->ns2__EncryptedPayment::data, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:encoding", -1, (wchar_t*const*)&a->ns2__EncryptedPayment::encoding, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:wrappedKey", -1, (wchar_t*const*)&a->ns2__EncryptedPayment::wrappedKey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__EncryptedPayment::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__EncryptedPayment(soap, tag, this, type);
}

SOAP_FMAC3 ns2__EncryptedPayment * SOAP_FMAC4 soap_in_ns2__EncryptedPayment(struct soap *soap, const char *tag, ns2__EncryptedPayment *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__EncryptedPayment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EncryptedPayment, sizeof(ns2__EncryptedPayment), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__EncryptedPayment)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__EncryptedPayment *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_descriptor1 = 1;
	size_t soap_flag_data1 = 1;
	size_t soap_flag_encoding1 = 1;
	size_t soap_flag_wrappedKey1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_descriptor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:descriptor", (wchar_t**)&a->ns2__EncryptedPayment::descriptor, "xsd:string"))
				{	soap_flag_descriptor1--;
					continue;
				}
			if (soap_flag_data1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:data", (wchar_t**)&a->ns2__EncryptedPayment::data, "xsd:string"))
				{	soap_flag_data1--;
					continue;
				}
			if (soap_flag_encoding1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:encoding", (wchar_t**)&a->ns2__EncryptedPayment::encoding, "xsd:string"))
				{	soap_flag_encoding1--;
					continue;
				}
			if (soap_flag_wrappedKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:wrappedKey", (wchar_t**)&a->ns2__EncryptedPayment::wrappedKey, "xsd:string"))
				{	soap_flag_wrappedKey1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__EncryptedPayment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EncryptedPayment, SOAP_TYPE_ns2__EncryptedPayment, sizeof(ns2__EncryptedPayment), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__EncryptedPayment * SOAP_FMAC2 soap_instantiate_ns2__EncryptedPayment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__EncryptedPayment(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__EncryptedPayment *p;
	size_t k = sizeof(ns2__EncryptedPayment);
	if (n < 0)
	{	p = SOAP_NEW(ns2__EncryptedPayment);
		if (p)
			((ns2__EncryptedPayment*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__EncryptedPayment, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__EncryptedPayment*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__EncryptedPayment location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__EncryptedPayment, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__EncryptedPayment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:EncryptedPayment", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__EncryptedPayment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__EncryptedPayment(soap, this, tag, type);
}

SOAP_FMAC3 ns2__EncryptedPayment * SOAP_FMAC4 soap_get_ns2__EncryptedPayment(struct soap *soap, ns2__EncryptedPayment *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EncryptedPayment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Pos::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Pos::entryMode = NULL;
	this->ns2__Pos::cardPresent = NULL;
	this->ns2__Pos::terminalCapability = NULL;
	this->ns2__Pos::trackData = NULL;
	this->ns2__Pos::terminalID = NULL;
	this->ns2__Pos::terminalType = NULL;
	this->ns2__Pos::terminalLocation = NULL;
	this->ns2__Pos::transactionSecurity = NULL;
	this->ns2__Pos::catLevel = NULL;
	this->ns2__Pos::conditionCode = NULL;
	this->ns2__Pos::environment = NULL;
	this->ns2__Pos::paymentData = NULL;
	this->ns2__Pos::deviceReaderData = NULL;
	this->ns2__Pos::encryptionAlgorithm = NULL;
	this->ns2__Pos::encodingMethod = NULL;
	this->ns2__Pos::deviceID = NULL;
	this->ns2__Pos::serviceCode = NULL;
	this->ns2__Pos::terminalIDAlternate = NULL;
	this->ns2__Pos::terminalCompliance = NULL;
	/* transient soap skipped */
}

void ns2__Pos::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Pos::entryMode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Pos::cardPresent);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Pos::terminalCapability);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Pos::trackData);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Pos::terminalID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Pos::terminalType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Pos::terminalLocation);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Pos::transactionSecurity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Pos::catLevel);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Pos::conditionCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Pos::environment);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Pos::paymentData);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Pos::deviceReaderData);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Pos::encryptionAlgorithm);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Pos::encodingMethod);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Pos::deviceID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Pos::serviceCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Pos::terminalIDAlternate);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__Pos::terminalCompliance);
#endif
}

int ns2__Pos::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Pos(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Pos(struct soap *soap, const char *tag, int id, const ns2__Pos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Pos), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:entryMode", -1, (wchar_t*const*)&a->ns2__Pos::entryMode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardPresent", -1, (wchar_t*const*)&a->ns2__Pos::cardPresent, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:terminalCapability", -1, (wchar_t*const*)&a->ns2__Pos::terminalCapability, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:trackData", -1, (wchar_t*const*)&a->ns2__Pos::trackData, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:terminalID", -1, (wchar_t*const*)&a->ns2__Pos::terminalID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:terminalType", -1, (wchar_t*const*)&a->ns2__Pos::terminalType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:terminalLocation", -1, (wchar_t*const*)&a->ns2__Pos::terminalLocation, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionSecurity", -1, (wchar_t*const*)&a->ns2__Pos::transactionSecurity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:catLevel", -1, (wchar_t*const*)&a->ns2__Pos::catLevel, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:conditionCode", -1, (wchar_t*const*)&a->ns2__Pos::conditionCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:environment", -1, (wchar_t*const*)&a->ns2__Pos::environment, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentData", -1, (wchar_t*const*)&a->ns2__Pos::paymentData, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:deviceReaderData", -1, (wchar_t*const*)&a->ns2__Pos::deviceReaderData, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:encryptionAlgorithm", -1, (wchar_t*const*)&a->ns2__Pos::encryptionAlgorithm, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:encodingMethod", -1, (wchar_t*const*)&a->ns2__Pos::encodingMethod, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:deviceID", -1, (wchar_t*const*)&a->ns2__Pos::deviceID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:serviceCode", -1, (wchar_t*const*)&a->ns2__Pos::serviceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:terminalIDAlternate", -1, (wchar_t*const*)&a->ns2__Pos::terminalIDAlternate, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:terminalCompliance", -1, &a->ns2__Pos::terminalCompliance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Pos::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Pos(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Pos * SOAP_FMAC4 soap_in_ns2__Pos(struct soap *soap, const char *tag, ns2__Pos *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Pos *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Pos, sizeof(ns2__Pos), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Pos)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Pos *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_entryMode1 = 1;
	size_t soap_flag_cardPresent1 = 1;
	size_t soap_flag_terminalCapability1 = 1;
	size_t soap_flag_trackData1 = 1;
	size_t soap_flag_terminalID1 = 1;
	size_t soap_flag_terminalType1 = 1;
	size_t soap_flag_terminalLocation1 = 1;
	size_t soap_flag_transactionSecurity1 = 1;
	size_t soap_flag_catLevel1 = 1;
	size_t soap_flag_conditionCode1 = 1;
	size_t soap_flag_environment1 = 1;
	size_t soap_flag_paymentData1 = 1;
	size_t soap_flag_deviceReaderData1 = 1;
	size_t soap_flag_encryptionAlgorithm1 = 1;
	size_t soap_flag_encodingMethod1 = 1;
	size_t soap_flag_deviceID1 = 1;
	size_t soap_flag_serviceCode1 = 1;
	size_t soap_flag_terminalIDAlternate1 = 1;
	size_t soap_flag_terminalCompliance1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entryMode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:entryMode", (wchar_t**)&a->ns2__Pos::entryMode, "xsd:string"))
				{	soap_flag_entryMode1--;
					continue;
				}
			if (soap_flag_cardPresent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardPresent", (wchar_t**)&a->ns2__Pos::cardPresent, "xsd:string"))
				{	soap_flag_cardPresent1--;
					continue;
				}
			if (soap_flag_terminalCapability1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:terminalCapability", (wchar_t**)&a->ns2__Pos::terminalCapability, "xsd:string"))
				{	soap_flag_terminalCapability1--;
					continue;
				}
			if (soap_flag_trackData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:trackData", (wchar_t**)&a->ns2__Pos::trackData, "xsd:string"))
				{	soap_flag_trackData1--;
					continue;
				}
			if (soap_flag_terminalID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:terminalID", (wchar_t**)&a->ns2__Pos::terminalID, "xsd:string"))
				{	soap_flag_terminalID1--;
					continue;
				}
			if (soap_flag_terminalType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:terminalType", (wchar_t**)&a->ns2__Pos::terminalType, "xsd:string"))
				{	soap_flag_terminalType1--;
					continue;
				}
			if (soap_flag_terminalLocation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:terminalLocation", (wchar_t**)&a->ns2__Pos::terminalLocation, "xsd:string"))
				{	soap_flag_terminalLocation1--;
					continue;
				}
			if (soap_flag_transactionSecurity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionSecurity", (wchar_t**)&a->ns2__Pos::transactionSecurity, "xsd:string"))
				{	soap_flag_transactionSecurity1--;
					continue;
				}
			if (soap_flag_catLevel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:catLevel", (wchar_t**)&a->ns2__Pos::catLevel, "xsd:string"))
				{	soap_flag_catLevel1--;
					continue;
				}
			if (soap_flag_conditionCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:conditionCode", (wchar_t**)&a->ns2__Pos::conditionCode, "xsd:string"))
				{	soap_flag_conditionCode1--;
					continue;
				}
			if (soap_flag_environment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:environment", (wchar_t**)&a->ns2__Pos::environment, "xsd:string"))
				{	soap_flag_environment1--;
					continue;
				}
			if (soap_flag_paymentData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentData", (wchar_t**)&a->ns2__Pos::paymentData, "xsd:string"))
				{	soap_flag_paymentData1--;
					continue;
				}
			if (soap_flag_deviceReaderData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:deviceReaderData", (wchar_t**)&a->ns2__Pos::deviceReaderData, "xsd:string"))
				{	soap_flag_deviceReaderData1--;
					continue;
				}
			if (soap_flag_encryptionAlgorithm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:encryptionAlgorithm", (wchar_t**)&a->ns2__Pos::encryptionAlgorithm, "xsd:string"))
				{	soap_flag_encryptionAlgorithm1--;
					continue;
				}
			if (soap_flag_encodingMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:encodingMethod", (wchar_t**)&a->ns2__Pos::encodingMethod, "xsd:string"))
				{	soap_flag_encodingMethod1--;
					continue;
				}
			if (soap_flag_deviceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:deviceID", (wchar_t**)&a->ns2__Pos::deviceID, "xsd:string"))
				{	soap_flag_deviceID1--;
					continue;
				}
			if (soap_flag_serviceCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:serviceCode", (wchar_t**)&a->ns2__Pos::serviceCode, "xsd:string"))
				{	soap_flag_serviceCode1--;
					continue;
				}
			if (soap_flag_terminalIDAlternate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:terminalIDAlternate", (wchar_t**)&a->ns2__Pos::terminalIDAlternate, "xsd:string"))
				{	soap_flag_terminalIDAlternate1--;
					continue;
				}
			if (soap_flag_terminalCompliance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:terminalCompliance", &a->ns2__Pos::terminalCompliance, "xsd:integer"))
				{	soap_flag_terminalCompliance1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Pos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Pos, SOAP_TYPE_ns2__Pos, sizeof(ns2__Pos), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Pos * SOAP_FMAC2 soap_instantiate_ns2__Pos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Pos(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Pos *p;
	size_t k = sizeof(ns2__Pos);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Pos);
		if (p)
			((ns2__Pos*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Pos, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Pos*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Pos location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Pos, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Pos::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:Pos", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Pos::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Pos(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Pos * SOAP_FMAC4 soap_get_ns2__Pos(struct soap *soap, ns2__Pos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Pos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__LodgingData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__LodgingData::checkInDate = NULL;
	this->ns2__LodgingData::checkOutDate = NULL;
	this->ns2__LodgingData::dailyRoomRate1 = NULL;
	this->ns2__LodgingData::dailyRoomRate2 = NULL;
	this->ns2__LodgingData::dailyRoomRate3 = NULL;
	this->ns2__LodgingData::roomNights1 = NULL;
	this->ns2__LodgingData::roomNights2 = NULL;
	this->ns2__LodgingData::roomNights3 = NULL;
	this->ns2__LodgingData::guestSmokingPreference = NULL;
	this->ns2__LodgingData::numberOfRoomsBooked = NULL;
	this->ns2__LodgingData::numberOfGuests = NULL;
	this->ns2__LodgingData::roomBedType = NULL;
	this->ns2__LodgingData::roomTaxElements = NULL;
	this->ns2__LodgingData::roomRateType = NULL;
	this->ns2__LodgingData::guestName = NULL;
	this->ns2__LodgingData::customerServicePhoneNumber = NULL;
	this->ns2__LodgingData::corporateClientCode = NULL;
	this->ns2__LodgingData::promotionalCode = NULL;
	this->ns2__LodgingData::additionalCoupon = NULL;
	this->ns2__LodgingData::roomLocation = NULL;
	this->ns2__LodgingData::specialProgramCode = NULL;
	this->ns2__LodgingData::tax = NULL;
	this->ns2__LodgingData::prepaidCost = NULL;
	this->ns2__LodgingData::foodAndBeverageCost = NULL;
	this->ns2__LodgingData::roomTax = NULL;
	this->ns2__LodgingData::adjustmentAmount = NULL;
	this->ns2__LodgingData::phoneCost = NULL;
	this->ns2__LodgingData::restaurantCost = NULL;
	this->ns2__LodgingData::roomServiceCost = NULL;
	this->ns2__LodgingData::miniBarCost = NULL;
	this->ns2__LodgingData::laundryCost = NULL;
	this->ns2__LodgingData::miscellaneousCost = NULL;
	this->ns2__LodgingData::giftShopCost = NULL;
	this->ns2__LodgingData::movieCost = NULL;
	this->ns2__LodgingData::healthClubCost = NULL;
	this->ns2__LodgingData::valetParkingCost = NULL;
	this->ns2__LodgingData::cashDisbursementCost = NULL;
	this->ns2__LodgingData::nonRoomCost = NULL;
	this->ns2__LodgingData::businessCenterCost = NULL;
	this->ns2__LodgingData::loungeBarCost = NULL;
	this->ns2__LodgingData::transportationCost = NULL;
	this->ns2__LodgingData::gratuityCost = NULL;
	this->ns2__LodgingData::conferenceRoomCost = NULL;
	this->ns2__LodgingData::audioVisualCost = NULL;
	this->ns2__LodgingData::banquetCost = NULL;
	this->ns2__LodgingData::internetAccessCost = NULL;
	this->ns2__LodgingData::earlyCheckOutCost = NULL;
	this->ns2__LodgingData::nonRoomTax = NULL;
	this->ns2__LodgingData::travelAgencyCode = NULL;
	this->ns2__LodgingData::travelAgencyName = NULL;
	/* transient soap skipped */
}

void ns2__LodgingData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__LodgingData::checkInDate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__LodgingData::checkOutDate);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::dailyRoomRate1);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::dailyRoomRate2);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::dailyRoomRate3);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__LodgingData::roomNights1);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__LodgingData::roomNights2);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__LodgingData::roomNights3);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__LodgingData::guestSmokingPreference);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__LodgingData::numberOfRoomsBooked);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__LodgingData::numberOfGuests);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__LodgingData::roomBedType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__LodgingData::roomTaxElements);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__LodgingData::roomRateType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__LodgingData::guestName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__LodgingData::customerServicePhoneNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__LodgingData::corporateClientCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__LodgingData::promotionalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__LodgingData::additionalCoupon);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__LodgingData::roomLocation);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__LodgingData::specialProgramCode);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::tax);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::prepaidCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::foodAndBeverageCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::roomTax);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::adjustmentAmount);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::phoneCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::restaurantCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::roomServiceCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::miniBarCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::laundryCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::miscellaneousCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::giftShopCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::movieCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::healthClubCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::valetParkingCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::cashDisbursementCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::nonRoomCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::businessCenterCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::loungeBarCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::transportationCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::gratuityCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::conferenceRoomCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::audioVisualCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::banquetCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::internetAccessCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::earlyCheckOutCost);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__LodgingData::nonRoomTax);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__LodgingData::travelAgencyCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__LodgingData::travelAgencyName);
#endif
}

int ns2__LodgingData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__LodgingData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__LodgingData(struct soap *soap, const char *tag, int id, const ns2__LodgingData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__LodgingData), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:checkInDate", -1, (wchar_t*const*)&a->ns2__LodgingData::checkInDate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:checkOutDate", -1, (wchar_t*const*)&a->ns2__LodgingData::checkOutDate, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:dailyRoomRate1", -1, &a->ns2__LodgingData::dailyRoomRate1, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:dailyRoomRate2", -1, &a->ns2__LodgingData::dailyRoomRate2, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:dailyRoomRate3", -1, &a->ns2__LodgingData::dailyRoomRate3, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:roomNights1", -1, &a->ns2__LodgingData::roomNights1, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:roomNights2", -1, &a->ns2__LodgingData::roomNights2, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:roomNights3", -1, &a->ns2__LodgingData::roomNights3, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:guestSmokingPreference", -1, (wchar_t*const*)&a->ns2__LodgingData::guestSmokingPreference, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:numberOfRoomsBooked", -1, &a->ns2__LodgingData::numberOfRoomsBooked, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:numberOfGuests", -1, &a->ns2__LodgingData::numberOfGuests, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:roomBedType", -1, (wchar_t*const*)&a->ns2__LodgingData::roomBedType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:roomTaxElements", -1, (wchar_t*const*)&a->ns2__LodgingData::roomTaxElements, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:roomRateType", -1, (wchar_t*const*)&a->ns2__LodgingData::roomRateType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:guestName", -1, (wchar_t*const*)&a->ns2__LodgingData::guestName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:customerServicePhoneNumber", -1, (wchar_t*const*)&a->ns2__LodgingData::customerServicePhoneNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:corporateClientCode", -1, (wchar_t*const*)&a->ns2__LodgingData::corporateClientCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:promotionalCode", -1, (wchar_t*const*)&a->ns2__LodgingData::promotionalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:additionalCoupon", -1, (wchar_t*const*)&a->ns2__LodgingData::additionalCoupon, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:roomLocation", -1, (wchar_t*const*)&a->ns2__LodgingData::roomLocation, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:specialProgramCode", -1, (wchar_t*const*)&a->ns2__LodgingData::specialProgramCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:tax", -1, &a->ns2__LodgingData::tax, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:prepaidCost", -1, &a->ns2__LodgingData::prepaidCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:foodAndBeverageCost", -1, &a->ns2__LodgingData::foodAndBeverageCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:roomTax", -1, &a->ns2__LodgingData::roomTax, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:adjustmentAmount", -1, &a->ns2__LodgingData::adjustmentAmount, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:phoneCost", -1, &a->ns2__LodgingData::phoneCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:restaurantCost", -1, &a->ns2__LodgingData::restaurantCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:roomServiceCost", -1, &a->ns2__LodgingData::roomServiceCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:miniBarCost", -1, &a->ns2__LodgingData::miniBarCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:laundryCost", -1, &a->ns2__LodgingData::laundryCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:miscellaneousCost", -1, &a->ns2__LodgingData::miscellaneousCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:giftShopCost", -1, &a->ns2__LodgingData::giftShopCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:movieCost", -1, &a->ns2__LodgingData::movieCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:healthClubCost", -1, &a->ns2__LodgingData::healthClubCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:valetParkingCost", -1, &a->ns2__LodgingData::valetParkingCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:cashDisbursementCost", -1, &a->ns2__LodgingData::cashDisbursementCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:nonRoomCost", -1, &a->ns2__LodgingData::nonRoomCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:businessCenterCost", -1, &a->ns2__LodgingData::businessCenterCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:loungeBarCost", -1, &a->ns2__LodgingData::loungeBarCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:transportationCost", -1, &a->ns2__LodgingData::transportationCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:gratuityCost", -1, &a->ns2__LodgingData::gratuityCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:conferenceRoomCost", -1, &a->ns2__LodgingData::conferenceRoomCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:audioVisualCost", -1, &a->ns2__LodgingData::audioVisualCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:banquetCost", -1, &a->ns2__LodgingData::banquetCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:internetAccessCost", -1, &a->ns2__LodgingData::internetAccessCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:earlyCheckOutCost", -1, &a->ns2__LodgingData::earlyCheckOutCost, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:nonRoomTax", -1, &a->ns2__LodgingData::nonRoomTax, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:travelAgencyCode", -1, (wchar_t*const*)&a->ns2__LodgingData::travelAgencyCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:travelAgencyName", -1, (wchar_t*const*)&a->ns2__LodgingData::travelAgencyName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__LodgingData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__LodgingData(soap, tag, this, type);
}

SOAP_FMAC3 ns2__LodgingData * SOAP_FMAC4 soap_in_ns2__LodgingData(struct soap *soap, const char *tag, ns2__LodgingData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__LodgingData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__LodgingData, sizeof(ns2__LodgingData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__LodgingData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__LodgingData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_checkInDate1 = 1;
	size_t soap_flag_checkOutDate1 = 1;
	size_t soap_flag_dailyRoomRate11 = 1;
	size_t soap_flag_dailyRoomRate21 = 1;
	size_t soap_flag_dailyRoomRate31 = 1;
	size_t soap_flag_roomNights11 = 1;
	size_t soap_flag_roomNights21 = 1;
	size_t soap_flag_roomNights31 = 1;
	size_t soap_flag_guestSmokingPreference1 = 1;
	size_t soap_flag_numberOfRoomsBooked1 = 1;
	size_t soap_flag_numberOfGuests1 = 1;
	size_t soap_flag_roomBedType1 = 1;
	size_t soap_flag_roomTaxElements1 = 1;
	size_t soap_flag_roomRateType1 = 1;
	size_t soap_flag_guestName1 = 1;
	size_t soap_flag_customerServicePhoneNumber1 = 1;
	size_t soap_flag_corporateClientCode1 = 1;
	size_t soap_flag_promotionalCode1 = 1;
	size_t soap_flag_additionalCoupon1 = 1;
	size_t soap_flag_roomLocation1 = 1;
	size_t soap_flag_specialProgramCode1 = 1;
	size_t soap_flag_tax1 = 1;
	size_t soap_flag_prepaidCost1 = 1;
	size_t soap_flag_foodAndBeverageCost1 = 1;
	size_t soap_flag_roomTax1 = 1;
	size_t soap_flag_adjustmentAmount1 = 1;
	size_t soap_flag_phoneCost1 = 1;
	size_t soap_flag_restaurantCost1 = 1;
	size_t soap_flag_roomServiceCost1 = 1;
	size_t soap_flag_miniBarCost1 = 1;
	size_t soap_flag_laundryCost1 = 1;
	size_t soap_flag_miscellaneousCost1 = 1;
	size_t soap_flag_giftShopCost1 = 1;
	size_t soap_flag_movieCost1 = 1;
	size_t soap_flag_healthClubCost1 = 1;
	size_t soap_flag_valetParkingCost1 = 1;
	size_t soap_flag_cashDisbursementCost1 = 1;
	size_t soap_flag_nonRoomCost1 = 1;
	size_t soap_flag_businessCenterCost1 = 1;
	size_t soap_flag_loungeBarCost1 = 1;
	size_t soap_flag_transportationCost1 = 1;
	size_t soap_flag_gratuityCost1 = 1;
	size_t soap_flag_conferenceRoomCost1 = 1;
	size_t soap_flag_audioVisualCost1 = 1;
	size_t soap_flag_banquetCost1 = 1;
	size_t soap_flag_internetAccessCost1 = 1;
	size_t soap_flag_earlyCheckOutCost1 = 1;
	size_t soap_flag_nonRoomTax1 = 1;
	size_t soap_flag_travelAgencyCode1 = 1;
	size_t soap_flag_travelAgencyName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_checkInDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:checkInDate", (wchar_t**)&a->ns2__LodgingData::checkInDate, "xsd:string"))
				{	soap_flag_checkInDate1--;
					continue;
				}
			if (soap_flag_checkOutDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:checkOutDate", (wchar_t**)&a->ns2__LodgingData::checkOutDate, "xsd:string"))
				{	soap_flag_checkOutDate1--;
					continue;
				}
			if (soap_flag_dailyRoomRate11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:dailyRoomRate1", &a->ns2__LodgingData::dailyRoomRate1, "ns2:amount"))
				{	soap_flag_dailyRoomRate11--;
					continue;
				}
			if (soap_flag_dailyRoomRate21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:dailyRoomRate2", &a->ns2__LodgingData::dailyRoomRate2, "ns2:amount"))
				{	soap_flag_dailyRoomRate21--;
					continue;
				}
			if (soap_flag_dailyRoomRate31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:dailyRoomRate3", &a->ns2__LodgingData::dailyRoomRate3, "ns2:amount"))
				{	soap_flag_dailyRoomRate31--;
					continue;
				}
			if (soap_flag_roomNights11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:roomNights1", &a->ns2__LodgingData::roomNights1, "xsd:integer"))
				{	soap_flag_roomNights11--;
					continue;
				}
			if (soap_flag_roomNights21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:roomNights2", &a->ns2__LodgingData::roomNights2, "xsd:integer"))
				{	soap_flag_roomNights21--;
					continue;
				}
			if (soap_flag_roomNights31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:roomNights3", &a->ns2__LodgingData::roomNights3, "xsd:integer"))
				{	soap_flag_roomNights31--;
					continue;
				}
			if (soap_flag_guestSmokingPreference1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:guestSmokingPreference", (wchar_t**)&a->ns2__LodgingData::guestSmokingPreference, "xsd:string"))
				{	soap_flag_guestSmokingPreference1--;
					continue;
				}
			if (soap_flag_numberOfRoomsBooked1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:numberOfRoomsBooked", &a->ns2__LodgingData::numberOfRoomsBooked, "xsd:integer"))
				{	soap_flag_numberOfRoomsBooked1--;
					continue;
				}
			if (soap_flag_numberOfGuests1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:numberOfGuests", &a->ns2__LodgingData::numberOfGuests, "xsd:integer"))
				{	soap_flag_numberOfGuests1--;
					continue;
				}
			if (soap_flag_roomBedType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:roomBedType", (wchar_t**)&a->ns2__LodgingData::roomBedType, "xsd:string"))
				{	soap_flag_roomBedType1--;
					continue;
				}
			if (soap_flag_roomTaxElements1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:roomTaxElements", (wchar_t**)&a->ns2__LodgingData::roomTaxElements, "xsd:string"))
				{	soap_flag_roomTaxElements1--;
					continue;
				}
			if (soap_flag_roomRateType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:roomRateType", (wchar_t**)&a->ns2__LodgingData::roomRateType, "xsd:string"))
				{	soap_flag_roomRateType1--;
					continue;
				}
			if (soap_flag_guestName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:guestName", (wchar_t**)&a->ns2__LodgingData::guestName, "xsd:string"))
				{	soap_flag_guestName1--;
					continue;
				}
			if (soap_flag_customerServicePhoneNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:customerServicePhoneNumber", (wchar_t**)&a->ns2__LodgingData::customerServicePhoneNumber, "xsd:string"))
				{	soap_flag_customerServicePhoneNumber1--;
					continue;
				}
			if (soap_flag_corporateClientCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:corporateClientCode", (wchar_t**)&a->ns2__LodgingData::corporateClientCode, "xsd:string"))
				{	soap_flag_corporateClientCode1--;
					continue;
				}
			if (soap_flag_promotionalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:promotionalCode", (wchar_t**)&a->ns2__LodgingData::promotionalCode, "xsd:string"))
				{	soap_flag_promotionalCode1--;
					continue;
				}
			if (soap_flag_additionalCoupon1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:additionalCoupon", (wchar_t**)&a->ns2__LodgingData::additionalCoupon, "xsd:string"))
				{	soap_flag_additionalCoupon1--;
					continue;
				}
			if (soap_flag_roomLocation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:roomLocation", (wchar_t**)&a->ns2__LodgingData::roomLocation, "xsd:string"))
				{	soap_flag_roomLocation1--;
					continue;
				}
			if (soap_flag_specialProgramCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:specialProgramCode", (wchar_t**)&a->ns2__LodgingData::specialProgramCode, "xsd:string"))
				{	soap_flag_specialProgramCode1--;
					continue;
				}
			if (soap_flag_tax1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:tax", &a->ns2__LodgingData::tax, "ns2:amount"))
				{	soap_flag_tax1--;
					continue;
				}
			if (soap_flag_prepaidCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:prepaidCost", &a->ns2__LodgingData::prepaidCost, "ns2:amount"))
				{	soap_flag_prepaidCost1--;
					continue;
				}
			if (soap_flag_foodAndBeverageCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:foodAndBeverageCost", &a->ns2__LodgingData::foodAndBeverageCost, "ns2:amount"))
				{	soap_flag_foodAndBeverageCost1--;
					continue;
				}
			if (soap_flag_roomTax1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:roomTax", &a->ns2__LodgingData::roomTax, "ns2:amount"))
				{	soap_flag_roomTax1--;
					continue;
				}
			if (soap_flag_adjustmentAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:adjustmentAmount", &a->ns2__LodgingData::adjustmentAmount, "ns2:amount"))
				{	soap_flag_adjustmentAmount1--;
					continue;
				}
			if (soap_flag_phoneCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:phoneCost", &a->ns2__LodgingData::phoneCost, "ns2:amount"))
				{	soap_flag_phoneCost1--;
					continue;
				}
			if (soap_flag_restaurantCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:restaurantCost", &a->ns2__LodgingData::restaurantCost, "ns2:amount"))
				{	soap_flag_restaurantCost1--;
					continue;
				}
			if (soap_flag_roomServiceCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:roomServiceCost", &a->ns2__LodgingData::roomServiceCost, "ns2:amount"))
				{	soap_flag_roomServiceCost1--;
					continue;
				}
			if (soap_flag_miniBarCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:miniBarCost", &a->ns2__LodgingData::miniBarCost, "ns2:amount"))
				{	soap_flag_miniBarCost1--;
					continue;
				}
			if (soap_flag_laundryCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:laundryCost", &a->ns2__LodgingData::laundryCost, "ns2:amount"))
				{	soap_flag_laundryCost1--;
					continue;
				}
			if (soap_flag_miscellaneousCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:miscellaneousCost", &a->ns2__LodgingData::miscellaneousCost, "ns2:amount"))
				{	soap_flag_miscellaneousCost1--;
					continue;
				}
			if (soap_flag_giftShopCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:giftShopCost", &a->ns2__LodgingData::giftShopCost, "ns2:amount"))
				{	soap_flag_giftShopCost1--;
					continue;
				}
			if (soap_flag_movieCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:movieCost", &a->ns2__LodgingData::movieCost, "ns2:amount"))
				{	soap_flag_movieCost1--;
					continue;
				}
			if (soap_flag_healthClubCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:healthClubCost", &a->ns2__LodgingData::healthClubCost, "ns2:amount"))
				{	soap_flag_healthClubCost1--;
					continue;
				}
			if (soap_flag_valetParkingCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:valetParkingCost", &a->ns2__LodgingData::valetParkingCost, "ns2:amount"))
				{	soap_flag_valetParkingCost1--;
					continue;
				}
			if (soap_flag_cashDisbursementCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:cashDisbursementCost", &a->ns2__LodgingData::cashDisbursementCost, "ns2:amount"))
				{	soap_flag_cashDisbursementCost1--;
					continue;
				}
			if (soap_flag_nonRoomCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:nonRoomCost", &a->ns2__LodgingData::nonRoomCost, "ns2:amount"))
				{	soap_flag_nonRoomCost1--;
					continue;
				}
			if (soap_flag_businessCenterCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:businessCenterCost", &a->ns2__LodgingData::businessCenterCost, "ns2:amount"))
				{	soap_flag_businessCenterCost1--;
					continue;
				}
			if (soap_flag_loungeBarCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:loungeBarCost", &a->ns2__LodgingData::loungeBarCost, "ns2:amount"))
				{	soap_flag_loungeBarCost1--;
					continue;
				}
			if (soap_flag_transportationCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:transportationCost", &a->ns2__LodgingData::transportationCost, "ns2:amount"))
				{	soap_flag_transportationCost1--;
					continue;
				}
			if (soap_flag_gratuityCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:gratuityCost", &a->ns2__LodgingData::gratuityCost, "ns2:amount"))
				{	soap_flag_gratuityCost1--;
					continue;
				}
			if (soap_flag_conferenceRoomCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:conferenceRoomCost", &a->ns2__LodgingData::conferenceRoomCost, "ns2:amount"))
				{	soap_flag_conferenceRoomCost1--;
					continue;
				}
			if (soap_flag_audioVisualCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:audioVisualCost", &a->ns2__LodgingData::audioVisualCost, "ns2:amount"))
				{	soap_flag_audioVisualCost1--;
					continue;
				}
			if (soap_flag_banquetCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:banquetCost", &a->ns2__LodgingData::banquetCost, "ns2:amount"))
				{	soap_flag_banquetCost1--;
					continue;
				}
			if (soap_flag_internetAccessCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:internetAccessCost", &a->ns2__LodgingData::internetAccessCost, "ns2:amount"))
				{	soap_flag_internetAccessCost1--;
					continue;
				}
			if (soap_flag_earlyCheckOutCost1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:earlyCheckOutCost", &a->ns2__LodgingData::earlyCheckOutCost, "ns2:amount"))
				{	soap_flag_earlyCheckOutCost1--;
					continue;
				}
			if (soap_flag_nonRoomTax1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:nonRoomTax", &a->ns2__LodgingData::nonRoomTax, "ns2:amount"))
				{	soap_flag_nonRoomTax1--;
					continue;
				}
			if (soap_flag_travelAgencyCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:travelAgencyCode", (wchar_t**)&a->ns2__LodgingData::travelAgencyCode, "xsd:string"))
				{	soap_flag_travelAgencyCode1--;
					continue;
				}
			if (soap_flag_travelAgencyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:travelAgencyName", (wchar_t**)&a->ns2__LodgingData::travelAgencyName, "xsd:string"))
				{	soap_flag_travelAgencyName1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__LodgingData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__LodgingData, SOAP_TYPE_ns2__LodgingData, sizeof(ns2__LodgingData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__LodgingData * SOAP_FMAC2 soap_instantiate_ns2__LodgingData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__LodgingData(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__LodgingData *p;
	size_t k = sizeof(ns2__LodgingData);
	if (n < 0)
	{	p = SOAP_NEW(ns2__LodgingData);
		if (p)
			((ns2__LodgingData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__LodgingData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__LodgingData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__LodgingData location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__LodgingData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__LodgingData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:LodgingData", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__LodgingData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__LodgingData(soap, this, tag, type);
}

SOAP_FMAC3 ns2__LodgingData * SOAP_FMAC4 soap_get_ns2__LodgingData(struct soap *soap, ns2__LodgingData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__LodgingData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Service::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Service::categoryCode = NULL;
	this->ns2__Service::subcategoryCode = NULL;
	this->ns2__Service::id = NULL;
	/* transient soap skipped */
}

void ns2__Service::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Service::categoryCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Service::subcategoryCode);
#endif
}

int ns2__Service::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Service(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Service(struct soap *soap, const char *tag, int id, const ns2__Service *a, const char *type)
{
	if (((ns2__Service*)a)->id)
		soap_set_attr(soap, "id", soap_xsd__integer2s(soap, ((ns2__Service*)a)->id), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Service), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:categoryCode", -1, (wchar_t*const*)&a->ns2__Service::categoryCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:subcategoryCode", -1, (wchar_t*const*)&a->ns2__Service::subcategoryCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Service::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Service(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Service * SOAP_FMAC4 soap_in_ns2__Service(struct soap *soap, const char *tag, ns2__Service *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Service *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Service, sizeof(ns2__Service), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Service)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Service *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__integer(soap, soap_attr_value(soap, "id", 1), &((ns2__Service*)a)->id))
		return NULL;
	size_t soap_flag_categoryCode1 = 1;
	size_t soap_flag_subcategoryCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_categoryCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:categoryCode", (wchar_t**)&a->ns2__Service::categoryCode, "xsd:string"))
				{	soap_flag_categoryCode1--;
					continue;
				}
			if (soap_flag_subcategoryCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:subcategoryCode", (wchar_t**)&a->ns2__Service::subcategoryCode, "xsd:string"))
				{	soap_flag_subcategoryCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Service *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Service, SOAP_TYPE_ns2__Service, sizeof(ns2__Service), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Service * SOAP_FMAC2 soap_instantiate_ns2__Service(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Service(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Service *p;
	size_t k = sizeof(ns2__Service);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Service);
		if (p)
			((ns2__Service*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Service, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Service*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Service location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Service, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Service::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:Service", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Service::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Service(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Service * SOAP_FMAC4 soap_get_ns2__Service(struct soap *soap, ns2__Service *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Service(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__AncillaryData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__AncillaryData::ticketNumber = NULL;
	this->ns2__AncillaryData::passengerName = NULL;
	this->ns2__AncillaryData::connectedTicketNumber = NULL;
	this->ns2__AncillaryData::creditReasonIndicator = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__Service(soap, &this->ns2__AncillaryData::service);
	/* transient soap skipped */
}

void ns2__AncillaryData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AncillaryData::ticketNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AncillaryData::passengerName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AncillaryData::connectedTicketNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AncillaryData::creditReasonIndicator);
	soap_serialize_std__vectorTemplateOfPointerTons2__Service(soap, &this->ns2__AncillaryData::service);
#endif
}

int ns2__AncillaryData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AncillaryData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AncillaryData(struct soap *soap, const char *tag, int id, const ns2__AncillaryData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AncillaryData), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ticketNumber", -1, (wchar_t*const*)&a->ns2__AncillaryData::ticketNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:passengerName", -1, (wchar_t*const*)&a->ns2__AncillaryData::passengerName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:connectedTicketNumber", -1, (wchar_t*const*)&a->ns2__AncillaryData::connectedTicketNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:creditReasonIndicator", -1, (wchar_t*const*)&a->ns2__AncillaryData::creditReasonIndicator, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__Service(soap, "ns2:service", -1, &a->ns2__AncillaryData::service, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__AncillaryData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AncillaryData(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AncillaryData * SOAP_FMAC4 soap_in_ns2__AncillaryData(struct soap *soap, const char *tag, ns2__AncillaryData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AncillaryData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AncillaryData, sizeof(ns2__AncillaryData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__AncillaryData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__AncillaryData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ticketNumber1 = 1;
	size_t soap_flag_passengerName1 = 1;
	size_t soap_flag_connectedTicketNumber1 = 1;
	size_t soap_flag_creditReasonIndicator1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ticketNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ticketNumber", (wchar_t**)&a->ns2__AncillaryData::ticketNumber, "xsd:string"))
				{	soap_flag_ticketNumber1--;
					continue;
				}
			if (soap_flag_passengerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:passengerName", (wchar_t**)&a->ns2__AncillaryData::passengerName, "xsd:string"))
				{	soap_flag_passengerName1--;
					continue;
				}
			if (soap_flag_connectedTicketNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:connectedTicketNumber", (wchar_t**)&a->ns2__AncillaryData::connectedTicketNumber, "xsd:string"))
				{	soap_flag_connectedTicketNumber1--;
					continue;
				}
			if (soap_flag_creditReasonIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:creditReasonIndicator", (wchar_t**)&a->ns2__AncillaryData::creditReasonIndicator, "xsd:string"))
				{	soap_flag_creditReasonIndicator1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__Service(soap, "ns2:service", &a->ns2__AncillaryData::service, "ns2:Service"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__AncillaryData::service.size() > 1000))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns2__AncillaryData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AncillaryData, SOAP_TYPE_ns2__AncillaryData, sizeof(ns2__AncillaryData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__AncillaryData * SOAP_FMAC2 soap_instantiate_ns2__AncillaryData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AncillaryData(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__AncillaryData *p;
	size_t k = sizeof(ns2__AncillaryData);
	if (n < 0)
	{	p = SOAP_NEW(ns2__AncillaryData);
		if (p)
			((ns2__AncillaryData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__AncillaryData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__AncillaryData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__AncillaryData location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__AncillaryData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__AncillaryData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:AncillaryData", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AncillaryData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AncillaryData(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AncillaryData * SOAP_FMAC4 soap_get_ns2__AncillaryData(struct soap *soap, ns2__AncillaryData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AncillaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Leg::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Leg::carrierCode = NULL;
	this->ns2__Leg::flightNumber = NULL;
	this->ns2__Leg::originatingAirportCode = NULL;
	this->ns2__Leg::class_ = NULL;
	this->ns2__Leg::stopoverCode = NULL;
	this->ns2__Leg::departureDate = NULL;
	this->ns2__Leg::destination = NULL;
	this->ns2__Leg::fareBasis = NULL;
	this->ns2__Leg::departTax = NULL;
	this->ns2__Leg::conjunctionTicket = NULL;
	this->ns2__Leg::exchangeTicket = NULL;
	this->ns2__Leg::couponNumber = NULL;
	this->ns2__Leg::departureTime = NULL;
	this->ns2__Leg::departureTimeSegment = NULL;
	this->ns2__Leg::arrivalTime = NULL;
	this->ns2__Leg::arrivalTimeSegment = NULL;
	this->ns2__Leg::endorsementsRestrictions = NULL;
	this->ns2__Leg::fare = NULL;
	this->ns2__Leg::fee = NULL;
	this->ns2__Leg::tax = NULL;
	this->ns2__Leg::id = NULL;
	/* transient soap skipped */
}

void ns2__Leg::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Leg::carrierCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Leg::flightNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Leg::originatingAirportCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Leg::class_);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Leg::stopoverCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Leg::departureDate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Leg::destination);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Leg::fareBasis);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Leg::departTax);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Leg::conjunctionTicket);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Leg::exchangeTicket);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Leg::couponNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Leg::departureTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Leg::departureTimeSegment);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Leg::arrivalTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Leg::arrivalTimeSegment);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Leg::endorsementsRestrictions);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Leg::fare);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Leg::fee);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Leg::tax);
#endif
}

int ns2__Leg::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Leg(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Leg(struct soap *soap, const char *tag, int id, const ns2__Leg *a, const char *type)
{
	if (((ns2__Leg*)a)->id)
		soap_set_attr(soap, "id", soap_xsd__integer2s(soap, ((ns2__Leg*)a)->id), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Leg), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:carrierCode", -1, (wchar_t*const*)&a->ns2__Leg::carrierCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:flightNumber", -1, (wchar_t*const*)&a->ns2__Leg::flightNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:originatingAirportCode", -1, (wchar_t*const*)&a->ns2__Leg::originatingAirportCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:class", -1, (wchar_t*const*)&a->ns2__Leg::class_, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:stopoverCode", -1, (wchar_t*const*)&a->ns2__Leg::stopoverCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:departureDate", -1, (wchar_t*const*)&a->ns2__Leg::departureDate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:destination", -1, (wchar_t*const*)&a->ns2__Leg::destination, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:fareBasis", -1, (wchar_t*const*)&a->ns2__Leg::fareBasis, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:departTax", -1, (wchar_t*const*)&a->ns2__Leg::departTax, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:conjunctionTicket", -1, (wchar_t*const*)&a->ns2__Leg::conjunctionTicket, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:exchangeTicket", -1, (wchar_t*const*)&a->ns2__Leg::exchangeTicket, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:couponNumber", -1, (wchar_t*const*)&a->ns2__Leg::couponNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:departureTime", -1, (wchar_t*const*)&a->ns2__Leg::departureTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:departureTimeSegment", -1, (wchar_t*const*)&a->ns2__Leg::departureTimeSegment, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:arrivalTime", -1, (wchar_t*const*)&a->ns2__Leg::arrivalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:arrivalTimeSegment", -1, (wchar_t*const*)&a->ns2__Leg::arrivalTimeSegment, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:endorsementsRestrictions", -1, (wchar_t*const*)&a->ns2__Leg::endorsementsRestrictions, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:fare", -1, (wchar_t*const*)&a->ns2__Leg::fare, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:fee", -1, (wchar_t*const*)&a->ns2__Leg::fee, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:tax", -1, (wchar_t*const*)&a->ns2__Leg::tax, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Leg::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Leg(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Leg * SOAP_FMAC4 soap_in_ns2__Leg(struct soap *soap, const char *tag, ns2__Leg *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Leg *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Leg, sizeof(ns2__Leg), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Leg)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Leg *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__integer(soap, soap_attr_value(soap, "id", 1), &((ns2__Leg*)a)->id))
		return NULL;
	size_t soap_flag_carrierCode1 = 1;
	size_t soap_flag_flightNumber1 = 1;
	size_t soap_flag_originatingAirportCode1 = 1;
	size_t soap_flag_class_1 = 1;
	size_t soap_flag_stopoverCode1 = 1;
	size_t soap_flag_departureDate1 = 1;
	size_t soap_flag_destination1 = 1;
	size_t soap_flag_fareBasis1 = 1;
	size_t soap_flag_departTax1 = 1;
	size_t soap_flag_conjunctionTicket1 = 1;
	size_t soap_flag_exchangeTicket1 = 1;
	size_t soap_flag_couponNumber1 = 1;
	size_t soap_flag_departureTime1 = 1;
	size_t soap_flag_departureTimeSegment1 = 1;
	size_t soap_flag_arrivalTime1 = 1;
	size_t soap_flag_arrivalTimeSegment1 = 1;
	size_t soap_flag_endorsementsRestrictions1 = 1;
	size_t soap_flag_fare1 = 1;
	size_t soap_flag_fee1 = 1;
	size_t soap_flag_tax1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_carrierCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:carrierCode", (wchar_t**)&a->ns2__Leg::carrierCode, "xsd:string"))
				{	soap_flag_carrierCode1--;
					continue;
				}
			if (soap_flag_flightNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:flightNumber", (wchar_t**)&a->ns2__Leg::flightNumber, "xsd:string"))
				{	soap_flag_flightNumber1--;
					continue;
				}
			if (soap_flag_originatingAirportCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:originatingAirportCode", (wchar_t**)&a->ns2__Leg::originatingAirportCode, "xsd:string"))
				{	soap_flag_originatingAirportCode1--;
					continue;
				}
			if (soap_flag_class_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:class", (wchar_t**)&a->ns2__Leg::class_, "xsd:string"))
				{	soap_flag_class_1--;
					continue;
				}
			if (soap_flag_stopoverCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:stopoverCode", (wchar_t**)&a->ns2__Leg::stopoverCode, "xsd:string"))
				{	soap_flag_stopoverCode1--;
					continue;
				}
			if (soap_flag_departureDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:departureDate", (wchar_t**)&a->ns2__Leg::departureDate, "xsd:string"))
				{	soap_flag_departureDate1--;
					continue;
				}
			if (soap_flag_destination1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:destination", (wchar_t**)&a->ns2__Leg::destination, "xsd:string"))
				{	soap_flag_destination1--;
					continue;
				}
			if (soap_flag_fareBasis1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:fareBasis", (wchar_t**)&a->ns2__Leg::fareBasis, "xsd:string"))
				{	soap_flag_fareBasis1--;
					continue;
				}
			if (soap_flag_departTax1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:departTax", (wchar_t**)&a->ns2__Leg::departTax, "xsd:string"))
				{	soap_flag_departTax1--;
					continue;
				}
			if (soap_flag_conjunctionTicket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:conjunctionTicket", (wchar_t**)&a->ns2__Leg::conjunctionTicket, "xsd:string"))
				{	soap_flag_conjunctionTicket1--;
					continue;
				}
			if (soap_flag_exchangeTicket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:exchangeTicket", (wchar_t**)&a->ns2__Leg::exchangeTicket, "xsd:string"))
				{	soap_flag_exchangeTicket1--;
					continue;
				}
			if (soap_flag_couponNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:couponNumber", (wchar_t**)&a->ns2__Leg::couponNumber, "xsd:string"))
				{	soap_flag_couponNumber1--;
					continue;
				}
			if (soap_flag_departureTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:departureTime", (wchar_t**)&a->ns2__Leg::departureTime, "xsd:string"))
				{	soap_flag_departureTime1--;
					continue;
				}
			if (soap_flag_departureTimeSegment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:departureTimeSegment", (wchar_t**)&a->ns2__Leg::departureTimeSegment, "xsd:string"))
				{	soap_flag_departureTimeSegment1--;
					continue;
				}
			if (soap_flag_arrivalTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:arrivalTime", (wchar_t**)&a->ns2__Leg::arrivalTime, "xsd:string"))
				{	soap_flag_arrivalTime1--;
					continue;
				}
			if (soap_flag_arrivalTimeSegment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:arrivalTimeSegment", (wchar_t**)&a->ns2__Leg::arrivalTimeSegment, "xsd:string"))
				{	soap_flag_arrivalTimeSegment1--;
					continue;
				}
			if (soap_flag_endorsementsRestrictions1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:endorsementsRestrictions", (wchar_t**)&a->ns2__Leg::endorsementsRestrictions, "xsd:string"))
				{	soap_flag_endorsementsRestrictions1--;
					continue;
				}
			if (soap_flag_fare1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:fare", (wchar_t**)&a->ns2__Leg::fare, "xsd:string"))
				{	soap_flag_fare1--;
					continue;
				}
			if (soap_flag_fee1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:fee", (wchar_t**)&a->ns2__Leg::fee, "xsd:string"))
				{	soap_flag_fee1--;
					continue;
				}
			if (soap_flag_tax1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:tax", (wchar_t**)&a->ns2__Leg::tax, "xsd:string"))
				{	soap_flag_tax1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Leg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Leg, SOAP_TYPE_ns2__Leg, sizeof(ns2__Leg), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Leg * SOAP_FMAC2 soap_instantiate_ns2__Leg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Leg(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Leg *p;
	size_t k = sizeof(ns2__Leg);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Leg);
		if (p)
			((ns2__Leg*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Leg, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Leg*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Leg location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Leg, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Leg::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:Leg", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Leg::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Leg(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Leg * SOAP_FMAC4 soap_get_ns2__Leg(struct soap *soap, ns2__Leg *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Leg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__AirlineData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__AirlineData::agentCode = NULL;
	this->ns2__AirlineData::agentName = NULL;
	this->ns2__AirlineData::ticketIssuerCity = NULL;
	this->ns2__AirlineData::ticketIssuerState = NULL;
	this->ns2__AirlineData::ticketIssuerPostalCode = NULL;
	this->ns2__AirlineData::ticketIssuerCountry = NULL;
	this->ns2__AirlineData::ticketIssuerAddress = NULL;
	this->ns2__AirlineData::ticketIssuerCode = NULL;
	this->ns2__AirlineData::ticketIssuerName = NULL;
	this->ns2__AirlineData::ticketNumber = NULL;
	this->ns2__AirlineData::checkDigit = NULL;
	this->ns2__AirlineData::restrictedTicketIndicator = NULL;
	this->ns2__AirlineData::transactionType = NULL;
	this->ns2__AirlineData::extendedPaymentCode = NULL;
	this->ns2__AirlineData::carrierName = NULL;
	this->ns2__AirlineData::passengerName = NULL;
	this->ns2__AirlineData::customerCode = NULL;
	this->ns2__AirlineData::documentType = NULL;
	this->ns2__AirlineData::documentNumber = NULL;
	this->ns2__AirlineData::documentNumberOfParts = NULL;
	this->ns2__AirlineData::invoiceNumber = NULL;
	this->ns2__AirlineData::invoiceDate = NULL;
	this->ns2__AirlineData::chargeDetails = NULL;
	this->ns2__AirlineData::bookingReference = NULL;
	this->ns2__AirlineData::totalFee = NULL;
	this->ns2__AirlineData::clearingSequence = NULL;
	this->ns2__AirlineData::clearingCount = NULL;
	this->ns2__AirlineData::totalClearingAmount = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__Leg(soap, &this->ns2__AirlineData::leg);
	this->ns2__AirlineData::numberOfPassengers = NULL;
	this->ns2__AirlineData::reservationSystem = NULL;
	this->ns2__AirlineData::processIdentifier = NULL;
	this->ns2__AirlineData::iataNumericCode = NULL;
	this->ns2__AirlineData::ticketIssueDate = NULL;
	this->ns2__AirlineData::electronicTicket = NULL;
	this->ns2__AirlineData::originalTicketNumber = NULL;
	this->ns2__AirlineData::purchaseType = NULL;
	this->ns2__AirlineData::creditReasonIndicator = NULL;
	this->ns2__AirlineData::ticketUpdateIndicator = NULL;
	this->ns2__AirlineData::planNumber = NULL;
	this->ns2__AirlineData::arrivalDate = NULL;
	this->ns2__AirlineData::ticketRestrictionText = NULL;
	this->ns2__AirlineData::exchangeTicketAmount = NULL;
	this->ns2__AirlineData::exchangeTicketFee = NULL;
	this->ns2__AirlineData::journeyType = NULL;
	/* transient soap skipped */
}

void ns2__AirlineData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::agentCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::agentName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::ticketIssuerCity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::ticketIssuerState);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::ticketIssuerPostalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::ticketIssuerCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::ticketIssuerAddress);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::ticketIssuerCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::ticketIssuerName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::ticketNumber);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__AirlineData::checkDigit);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__AirlineData::restrictedTicketIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::transactionType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::extendedPaymentCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::carrierName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::passengerName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::customerCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::documentType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::documentNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::documentNumberOfParts);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::invoiceNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::invoiceDate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::chargeDetails);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::bookingReference);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__AirlineData::totalFee);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::clearingSequence);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__AirlineData::clearingCount);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__AirlineData::totalClearingAmount);
	soap_serialize_std__vectorTemplateOfPointerTons2__Leg(soap, &this->ns2__AirlineData::leg);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::numberOfPassengers);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::reservationSystem);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::processIdentifier);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::iataNumericCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::ticketIssueDate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::electronicTicket);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::originalTicketNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::purchaseType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::creditReasonIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::ticketUpdateIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::planNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::arrivalDate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::ticketRestrictionText);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__AirlineData::exchangeTicketAmount);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__AirlineData::exchangeTicketFee);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AirlineData::journeyType);
#endif
}

int ns2__AirlineData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AirlineData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AirlineData(struct soap *soap, const char *tag, int id, const ns2__AirlineData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AirlineData), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:agentCode", -1, (wchar_t*const*)&a->ns2__AirlineData::agentCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:agentName", -1, (wchar_t*const*)&a->ns2__AirlineData::agentName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ticketIssuerCity", -1, (wchar_t*const*)&a->ns2__AirlineData::ticketIssuerCity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ticketIssuerState", -1, (wchar_t*const*)&a->ns2__AirlineData::ticketIssuerState, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ticketIssuerPostalCode", -1, (wchar_t*const*)&a->ns2__AirlineData::ticketIssuerPostalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ticketIssuerCountry", -1, (wchar_t*const*)&a->ns2__AirlineData::ticketIssuerCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ticketIssuerAddress", -1, (wchar_t*const*)&a->ns2__AirlineData::ticketIssuerAddress, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ticketIssuerCode", -1, (wchar_t*const*)&a->ns2__AirlineData::ticketIssuerCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ticketIssuerName", -1, (wchar_t*const*)&a->ns2__AirlineData::ticketIssuerName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ticketNumber", -1, (wchar_t*const*)&a->ns2__AirlineData::ticketNumber, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:checkDigit", -1, &a->ns2__AirlineData::checkDigit, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:restrictedTicketIndicator", -1, &a->ns2__AirlineData::restrictedTicketIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionType", -1, (wchar_t*const*)&a->ns2__AirlineData::transactionType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:extendedPaymentCode", -1, (wchar_t*const*)&a->ns2__AirlineData::extendedPaymentCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:carrierName", -1, (wchar_t*const*)&a->ns2__AirlineData::carrierName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:passengerName", -1, (wchar_t*const*)&a->ns2__AirlineData::passengerName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:customerCode", -1, (wchar_t*const*)&a->ns2__AirlineData::customerCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:documentType", -1, (wchar_t*const*)&a->ns2__AirlineData::documentType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:documentNumber", -1, (wchar_t*const*)&a->ns2__AirlineData::documentNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:documentNumberOfParts", -1, (wchar_t*const*)&a->ns2__AirlineData::documentNumberOfParts, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:invoiceNumber", -1, (wchar_t*const*)&a->ns2__AirlineData::invoiceNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:invoiceDate", -1, (wchar_t*const*)&a->ns2__AirlineData::invoiceDate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:chargeDetails", -1, (wchar_t*const*)&a->ns2__AirlineData::chargeDetails, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:bookingReference", -1, (wchar_t*const*)&a->ns2__AirlineData::bookingReference, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:totalFee", -1, &a->ns2__AirlineData::totalFee, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:clearingSequence", -1, (wchar_t*const*)&a->ns2__AirlineData::clearingSequence, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:clearingCount", -1, &a->ns2__AirlineData::clearingCount, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:totalClearingAmount", -1, &a->ns2__AirlineData::totalClearingAmount, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__Leg(soap, "ns2:leg", -1, &a->ns2__AirlineData::leg, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:numberOfPassengers", -1, (wchar_t*const*)&a->ns2__AirlineData::numberOfPassengers, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reservationSystem", -1, (wchar_t*const*)&a->ns2__AirlineData::reservationSystem, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processIdentifier", -1, (wchar_t*const*)&a->ns2__AirlineData::processIdentifier, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:iataNumericCode", -1, (wchar_t*const*)&a->ns2__AirlineData::iataNumericCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ticketIssueDate", -1, (wchar_t*const*)&a->ns2__AirlineData::ticketIssueDate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:electronicTicket", -1, (wchar_t*const*)&a->ns2__AirlineData::electronicTicket, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:originalTicketNumber", -1, (wchar_t*const*)&a->ns2__AirlineData::originalTicketNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:purchaseType", -1, (wchar_t*const*)&a->ns2__AirlineData::purchaseType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:creditReasonIndicator", -1, (wchar_t*const*)&a->ns2__AirlineData::creditReasonIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ticketUpdateIndicator", -1, (wchar_t*const*)&a->ns2__AirlineData::ticketUpdateIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:planNumber", -1, (wchar_t*const*)&a->ns2__AirlineData::planNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:arrivalDate", -1, (wchar_t*const*)&a->ns2__AirlineData::arrivalDate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ticketRestrictionText", -1, (wchar_t*const*)&a->ns2__AirlineData::ticketRestrictionText, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:exchangeTicketAmount", -1, &a->ns2__AirlineData::exchangeTicketAmount, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:exchangeTicketFee", -1, &a->ns2__AirlineData::exchangeTicketFee, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:journeyType", -1, (wchar_t*const*)&a->ns2__AirlineData::journeyType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__AirlineData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AirlineData(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AirlineData * SOAP_FMAC4 soap_in_ns2__AirlineData(struct soap *soap, const char *tag, ns2__AirlineData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AirlineData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AirlineData, sizeof(ns2__AirlineData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__AirlineData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__AirlineData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_agentCode1 = 1;
	size_t soap_flag_agentName1 = 1;
	size_t soap_flag_ticketIssuerCity1 = 1;
	size_t soap_flag_ticketIssuerState1 = 1;
	size_t soap_flag_ticketIssuerPostalCode1 = 1;
	size_t soap_flag_ticketIssuerCountry1 = 1;
	size_t soap_flag_ticketIssuerAddress1 = 1;
	size_t soap_flag_ticketIssuerCode1 = 1;
	size_t soap_flag_ticketIssuerName1 = 1;
	size_t soap_flag_ticketNumber1 = 1;
	size_t soap_flag_checkDigit1 = 1;
	size_t soap_flag_restrictedTicketIndicator1 = 1;
	size_t soap_flag_transactionType1 = 1;
	size_t soap_flag_extendedPaymentCode1 = 1;
	size_t soap_flag_carrierName1 = 1;
	size_t soap_flag_passengerName1 = 1;
	size_t soap_flag_customerCode1 = 1;
	size_t soap_flag_documentType1 = 1;
	size_t soap_flag_documentNumber1 = 1;
	size_t soap_flag_documentNumberOfParts1 = 1;
	size_t soap_flag_invoiceNumber1 = 1;
	size_t soap_flag_invoiceDate1 = 1;
	size_t soap_flag_chargeDetails1 = 1;
	size_t soap_flag_bookingReference1 = 1;
	size_t soap_flag_totalFee1 = 1;
	size_t soap_flag_clearingSequence1 = 1;
	size_t soap_flag_clearingCount1 = 1;
	size_t soap_flag_totalClearingAmount1 = 1;
	size_t soap_flag_numberOfPassengers1 = 1;
	size_t soap_flag_reservationSystem1 = 1;
	size_t soap_flag_processIdentifier1 = 1;
	size_t soap_flag_iataNumericCode1 = 1;
	size_t soap_flag_ticketIssueDate1 = 1;
	size_t soap_flag_electronicTicket1 = 1;
	size_t soap_flag_originalTicketNumber1 = 1;
	size_t soap_flag_purchaseType1 = 1;
	size_t soap_flag_creditReasonIndicator1 = 1;
	size_t soap_flag_ticketUpdateIndicator1 = 1;
	size_t soap_flag_planNumber1 = 1;
	size_t soap_flag_arrivalDate1 = 1;
	size_t soap_flag_ticketRestrictionText1 = 1;
	size_t soap_flag_exchangeTicketAmount1 = 1;
	size_t soap_flag_exchangeTicketFee1 = 1;
	size_t soap_flag_journeyType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_agentCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:agentCode", (wchar_t**)&a->ns2__AirlineData::agentCode, "xsd:string"))
				{	soap_flag_agentCode1--;
					continue;
				}
			if (soap_flag_agentName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:agentName", (wchar_t**)&a->ns2__AirlineData::agentName, "xsd:string"))
				{	soap_flag_agentName1--;
					continue;
				}
			if (soap_flag_ticketIssuerCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ticketIssuerCity", (wchar_t**)&a->ns2__AirlineData::ticketIssuerCity, "xsd:string"))
				{	soap_flag_ticketIssuerCity1--;
					continue;
				}
			if (soap_flag_ticketIssuerState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ticketIssuerState", (wchar_t**)&a->ns2__AirlineData::ticketIssuerState, "xsd:string"))
				{	soap_flag_ticketIssuerState1--;
					continue;
				}
			if (soap_flag_ticketIssuerPostalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ticketIssuerPostalCode", (wchar_t**)&a->ns2__AirlineData::ticketIssuerPostalCode, "xsd:string"))
				{	soap_flag_ticketIssuerPostalCode1--;
					continue;
				}
			if (soap_flag_ticketIssuerCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ticketIssuerCountry", (wchar_t**)&a->ns2__AirlineData::ticketIssuerCountry, "xsd:string"))
				{	soap_flag_ticketIssuerCountry1--;
					continue;
				}
			if (soap_flag_ticketIssuerAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ticketIssuerAddress", (wchar_t**)&a->ns2__AirlineData::ticketIssuerAddress, "xsd:string"))
				{	soap_flag_ticketIssuerAddress1--;
					continue;
				}
			if (soap_flag_ticketIssuerCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ticketIssuerCode", (wchar_t**)&a->ns2__AirlineData::ticketIssuerCode, "xsd:string"))
				{	soap_flag_ticketIssuerCode1--;
					continue;
				}
			if (soap_flag_ticketIssuerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ticketIssuerName", (wchar_t**)&a->ns2__AirlineData::ticketIssuerName, "xsd:string"))
				{	soap_flag_ticketIssuerName1--;
					continue;
				}
			if (soap_flag_ticketNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ticketNumber", (wchar_t**)&a->ns2__AirlineData::ticketNumber, "xsd:string"))
				{	soap_flag_ticketNumber1--;
					continue;
				}
			if (soap_flag_checkDigit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:checkDigit", &a->ns2__AirlineData::checkDigit, "xsd:integer"))
				{	soap_flag_checkDigit1--;
					continue;
				}
			if (soap_flag_restrictedTicketIndicator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:restrictedTicketIndicator", &a->ns2__AirlineData::restrictedTicketIndicator, "xsd:integer"))
				{	soap_flag_restrictedTicketIndicator1--;
					continue;
				}
			if (soap_flag_transactionType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionType", (wchar_t**)&a->ns2__AirlineData::transactionType, "xsd:string"))
				{	soap_flag_transactionType1--;
					continue;
				}
			if (soap_flag_extendedPaymentCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:extendedPaymentCode", (wchar_t**)&a->ns2__AirlineData::extendedPaymentCode, "xsd:string"))
				{	soap_flag_extendedPaymentCode1--;
					continue;
				}
			if (soap_flag_carrierName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:carrierName", (wchar_t**)&a->ns2__AirlineData::carrierName, "xsd:string"))
				{	soap_flag_carrierName1--;
					continue;
				}
			if (soap_flag_passengerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:passengerName", (wchar_t**)&a->ns2__AirlineData::passengerName, "xsd:string"))
				{	soap_flag_passengerName1--;
					continue;
				}
			if (soap_flag_customerCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:customerCode", (wchar_t**)&a->ns2__AirlineData::customerCode, "xsd:string"))
				{	soap_flag_customerCode1--;
					continue;
				}
			if (soap_flag_documentType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:documentType", (wchar_t**)&a->ns2__AirlineData::documentType, "xsd:string"))
				{	soap_flag_documentType1--;
					continue;
				}
			if (soap_flag_documentNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:documentNumber", (wchar_t**)&a->ns2__AirlineData::documentNumber, "xsd:string"))
				{	soap_flag_documentNumber1--;
					continue;
				}
			if (soap_flag_documentNumberOfParts1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:documentNumberOfParts", (wchar_t**)&a->ns2__AirlineData::documentNumberOfParts, "xsd:string"))
				{	soap_flag_documentNumberOfParts1--;
					continue;
				}
			if (soap_flag_invoiceNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:invoiceNumber", (wchar_t**)&a->ns2__AirlineData::invoiceNumber, "xsd:string"))
				{	soap_flag_invoiceNumber1--;
					continue;
				}
			if (soap_flag_invoiceDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:invoiceDate", (wchar_t**)&a->ns2__AirlineData::invoiceDate, "xsd:string"))
				{	soap_flag_invoiceDate1--;
					continue;
				}
			if (soap_flag_chargeDetails1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:chargeDetails", (wchar_t**)&a->ns2__AirlineData::chargeDetails, "xsd:string"))
				{	soap_flag_chargeDetails1--;
					continue;
				}
			if (soap_flag_bookingReference1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:bookingReference", (wchar_t**)&a->ns2__AirlineData::bookingReference, "xsd:string"))
				{	soap_flag_bookingReference1--;
					continue;
				}
			if (soap_flag_totalFee1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:totalFee", &a->ns2__AirlineData::totalFee, "ns2:amount"))
				{	soap_flag_totalFee1--;
					continue;
				}
			if (soap_flag_clearingSequence1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:clearingSequence", (wchar_t**)&a->ns2__AirlineData::clearingSequence, "xsd:string"))
				{	soap_flag_clearingSequence1--;
					continue;
				}
			if (soap_flag_clearingCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:clearingCount", &a->ns2__AirlineData::clearingCount, "xsd:integer"))
				{	soap_flag_clearingCount1--;
					continue;
				}
			if (soap_flag_totalClearingAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:totalClearingAmount", &a->ns2__AirlineData::totalClearingAmount, "ns2:amount"))
				{	soap_flag_totalClearingAmount1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__Leg(soap, "ns2:leg", &a->ns2__AirlineData::leg, "ns2:Leg"))
					continue;
			if (soap_flag_numberOfPassengers1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:numberOfPassengers", (wchar_t**)&a->ns2__AirlineData::numberOfPassengers, "xsd:string"))
				{	soap_flag_numberOfPassengers1--;
					continue;
				}
			if (soap_flag_reservationSystem1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reservationSystem", (wchar_t**)&a->ns2__AirlineData::reservationSystem, "xsd:string"))
				{	soap_flag_reservationSystem1--;
					continue;
				}
			if (soap_flag_processIdentifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processIdentifier", (wchar_t**)&a->ns2__AirlineData::processIdentifier, "xsd:string"))
				{	soap_flag_processIdentifier1--;
					continue;
				}
			if (soap_flag_iataNumericCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:iataNumericCode", (wchar_t**)&a->ns2__AirlineData::iataNumericCode, "xsd:string"))
				{	soap_flag_iataNumericCode1--;
					continue;
				}
			if (soap_flag_ticketIssueDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ticketIssueDate", (wchar_t**)&a->ns2__AirlineData::ticketIssueDate, "xsd:string"))
				{	soap_flag_ticketIssueDate1--;
					continue;
				}
			if (soap_flag_electronicTicket1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:electronicTicket", (wchar_t**)&a->ns2__AirlineData::electronicTicket, "xsd:string"))
				{	soap_flag_electronicTicket1--;
					continue;
				}
			if (soap_flag_originalTicketNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:originalTicketNumber", (wchar_t**)&a->ns2__AirlineData::originalTicketNumber, "xsd:string"))
				{	soap_flag_originalTicketNumber1--;
					continue;
				}
			if (soap_flag_purchaseType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:purchaseType", (wchar_t**)&a->ns2__AirlineData::purchaseType, "xsd:string"))
				{	soap_flag_purchaseType1--;
					continue;
				}
			if (soap_flag_creditReasonIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:creditReasonIndicator", (wchar_t**)&a->ns2__AirlineData::creditReasonIndicator, "xsd:string"))
				{	soap_flag_creditReasonIndicator1--;
					continue;
				}
			if (soap_flag_ticketUpdateIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ticketUpdateIndicator", (wchar_t**)&a->ns2__AirlineData::ticketUpdateIndicator, "xsd:string"))
				{	soap_flag_ticketUpdateIndicator1--;
					continue;
				}
			if (soap_flag_planNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:planNumber", (wchar_t**)&a->ns2__AirlineData::planNumber, "xsd:string"))
				{	soap_flag_planNumber1--;
					continue;
				}
			if (soap_flag_arrivalDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:arrivalDate", (wchar_t**)&a->ns2__AirlineData::arrivalDate, "xsd:string"))
				{	soap_flag_arrivalDate1--;
					continue;
				}
			if (soap_flag_ticketRestrictionText1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ticketRestrictionText", (wchar_t**)&a->ns2__AirlineData::ticketRestrictionText, "xsd:string"))
				{	soap_flag_ticketRestrictionText1--;
					continue;
				}
			if (soap_flag_exchangeTicketAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:exchangeTicketAmount", &a->ns2__AirlineData::exchangeTicketAmount, "ns2:amount"))
				{	soap_flag_exchangeTicketAmount1--;
					continue;
				}
			if (soap_flag_exchangeTicketFee1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:exchangeTicketFee", &a->ns2__AirlineData::exchangeTicketFee, "ns2:amount"))
				{	soap_flag_exchangeTicketFee1--;
					continue;
				}
			if (soap_flag_journeyType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:journeyType", (wchar_t**)&a->ns2__AirlineData::journeyType, "xsd:string"))
				{	soap_flag_journeyType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__AirlineData::leg.size() > 1000))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns2__AirlineData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AirlineData, SOAP_TYPE_ns2__AirlineData, sizeof(ns2__AirlineData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__AirlineData * SOAP_FMAC2 soap_instantiate_ns2__AirlineData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AirlineData(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__AirlineData *p;
	size_t k = sizeof(ns2__AirlineData);
	if (n < 0)
	{	p = SOAP_NEW(ns2__AirlineData);
		if (p)
			((ns2__AirlineData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__AirlineData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__AirlineData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__AirlineData location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__AirlineData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__AirlineData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:AirlineData", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AirlineData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AirlineData(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AirlineData * SOAP_FMAC4 soap_get_ns2__AirlineData(struct soap *soap, ns2__AirlineData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AirlineData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__FaultDetails::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__FaultDetails::requestID = NULL;
	/* transient soap skipped */
}

void ns2__FaultDetails::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__FaultDetails::requestID);
#endif
}

int ns2__FaultDetails::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FaultDetails(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FaultDetails(struct soap *soap, const char *tag, int id, const ns2__FaultDetails *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FaultDetails), type))
		return soap->error;
	if (!a->ns2__FaultDetails::requestID)
	{	if (soap_element_nil(soap, "ns2:requestID"))
			return soap->error;
	}
	else
	if (soap_out_wstring(soap, "ns2:requestID", -1, (wchar_t*const*)&a->ns2__FaultDetails::requestID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__FaultDetails::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FaultDetails(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FaultDetails * SOAP_FMAC4 soap_in_ns2__FaultDetails(struct soap *soap, const char *tag, ns2__FaultDetails *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FaultDetails *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FaultDetails, sizeof(ns2__FaultDetails), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__FaultDetails)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__FaultDetails *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_requestID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:requestID", (wchar_t**)&a->ns2__FaultDetails::requestID, "xsd:string"))
				{	soap_flag_requestID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__FaultDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FaultDetails, SOAP_TYPE_ns2__FaultDetails, sizeof(ns2__FaultDetails), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__FaultDetails * SOAP_FMAC2 soap_instantiate_ns2__FaultDetails(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FaultDetails(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__FaultDetails *p;
	size_t k = sizeof(ns2__FaultDetails);
	if (n < 0)
	{	p = SOAP_NEW(ns2__FaultDetails);
		if (p)
			((ns2__FaultDetails*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__FaultDetails, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__FaultDetails*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__FaultDetails location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__FaultDetails, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__FaultDetails::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:FaultDetails", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FaultDetails::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FaultDetails(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FaultDetails * SOAP_FMAC4 soap_get_ns2__FaultDetails(struct soap *soap, ns2__FaultDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FaultDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ReplyMessage::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ReplyMessage::merchantReferenceCode = NULL;
	this->ns2__ReplyMessage::requestID = NULL;
	this->ns2__ReplyMessage::decision = NULL;
	this->ns2__ReplyMessage::reasonCode = NULL;
	soap_default_std__vectorTemplateOfwstring(soap, &this->ns2__ReplyMessage::missingField);
	soap_default_std__vectorTemplateOfwstring(soap, &this->ns2__ReplyMessage::invalidField);
	this->ns2__ReplyMessage::requestToken = NULL;
	this->ns2__ReplyMessage::purchaseTotals = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__DeniedPartiesMatch(soap, &this->ns2__ReplyMessage::deniedPartiesMatch);
	this->ns2__ReplyMessage::ccAuthReply = NULL;
	this->ns2__ReplyMessage::octReply = NULL;
	this->ns2__ReplyMessage::verificationReply = NULL;
	this->ns2__ReplyMessage::ccSaleReply = NULL;
	this->ns2__ReplyMessage::ccSaleCreditReply = NULL;
	this->ns2__ReplyMessage::ccSaleReversalReply = NULL;
	this->ns2__ReplyMessage::ccIncrementalAuthReply = NULL;
	this->ns2__ReplyMessage::serviceFeeCalculateReply = NULL;
	this->ns2__ReplyMessage::ccCaptureReply = NULL;
	this->ns2__ReplyMessage::ccCreditReply = NULL;
	this->ns2__ReplyMessage::ccAuthReversalReply = NULL;
	this->ns2__ReplyMessage::ccAutoAuthReversalReply = NULL;
	this->ns2__ReplyMessage::ccDCCReply = NULL;
	this->ns2__ReplyMessage::ccDCCUpdateReply = NULL;
	this->ns2__ReplyMessage::ecDebitReply = NULL;
	this->ns2__ReplyMessage::ecCreditReply = NULL;
	this->ns2__ReplyMessage::ecAuthenticateReply = NULL;
	this->ns2__ReplyMessage::payerAuthEnrollReply = NULL;
	this->ns2__ReplyMessage::payerAuthValidateReply = NULL;
	this->ns2__ReplyMessage::taxReply = NULL;
	this->ns2__ReplyMessage::encryptedPayment = NULL;
	this->ns2__ReplyMessage::encryptPaymentDataReply = NULL;
	this->ns2__ReplyMessage::dmeReply = NULL;
	this->ns2__ReplyMessage::afsReply = NULL;
	this->ns2__ReplyMessage::davReply = NULL;
	this->ns2__ReplyMessage::exportReply = NULL;
	this->ns2__ReplyMessage::fxRatesReply = NULL;
	this->ns2__ReplyMessage::bankTransferReply = NULL;
	this->ns2__ReplyMessage::bankTransferRefundReply = NULL;
	this->ns2__ReplyMessage::bankTransferRealTimeReply = NULL;
	this->ns2__ReplyMessage::directDebitMandateReply = NULL;
	this->ns2__ReplyMessage::directDebitReply = NULL;
	this->ns2__ReplyMessage::directDebitValidateReply = NULL;
	this->ns2__ReplyMessage::directDebitRefundReply = NULL;
	this->ns2__ReplyMessage::paySubscriptionCreateReply = NULL;
	this->ns2__ReplyMessage::paySubscriptionUpdateReply = NULL;
	this->ns2__ReplyMessage::paySubscriptionEventUpdateReply = NULL;
	this->ns2__ReplyMessage::paySubscriptionRetrieveReply = NULL;
	this->ns2__ReplyMessage::paySubscriptionDeleteReply = NULL;
	this->ns2__ReplyMessage::payPalPaymentReply = NULL;
	this->ns2__ReplyMessage::payPalCreditReply = NULL;
	this->ns2__ReplyMessage::voidReply = NULL;
	this->ns2__ReplyMessage::pinlessDebitReply = NULL;
	this->ns2__ReplyMessage::pinlessDebitValidateReply = NULL;
	this->ns2__ReplyMessage::pinlessDebitReversalReply = NULL;
	this->ns2__ReplyMessage::payPalButtonCreateReply = NULL;
	this->ns2__ReplyMessage::payPalPreapprovedPaymentReply = NULL;
	this->ns2__ReplyMessage::payPalPreapprovedUpdateReply = NULL;
	this->ns2__ReplyMessage::riskUpdateReply = NULL;
	this->ns2__ReplyMessage::fraudUpdateReply = NULL;
	this->ns2__ReplyMessage::caseManagementActionReply = NULL;
	this->ns2__ReplyMessage::decisionReply = NULL;
	this->ns2__ReplyMessage::payPalRefundReply = NULL;
	this->ns2__ReplyMessage::payPalAuthReversalReply = NULL;
	this->ns2__ReplyMessage::payPalDoCaptureReply = NULL;
	this->ns2__ReplyMessage::payPalEcDoPaymentReply = NULL;
	this->ns2__ReplyMessage::payPalEcGetDetailsReply = NULL;
	this->ns2__ReplyMessage::payPalEcSetReply = NULL;
	this->ns2__ReplyMessage::payPalAuthorizationReply = NULL;
	this->ns2__ReplyMessage::payPalEcOrderSetupReply = NULL;
	this->ns2__ReplyMessage::payPalUpdateAgreementReply = NULL;
	this->ns2__ReplyMessage::payPalCreateAgreementReply = NULL;
	this->ns2__ReplyMessage::payPalDoRefTransactionReply = NULL;
	this->ns2__ReplyMessage::chinaPaymentReply = NULL;
	this->ns2__ReplyMessage::chinaRefundReply = NULL;
	this->ns2__ReplyMessage::boletoPaymentReply = NULL;
	this->ns2__ReplyMessage::pinDebitPurchaseReply = NULL;
	this->ns2__ReplyMessage::pinDebitCreditReply = NULL;
	this->ns2__ReplyMessage::pinDebitReversalReply = NULL;
	this->ns2__ReplyMessage::apInitiateReply = NULL;
	this->ns2__ReplyMessage::apCheckStatusReply = NULL;
	this->ns2__ReplyMessage::receiptNumber = NULL;
	this->ns2__ReplyMessage::additionalData = NULL;
	this->ns2__ReplyMessage::solutionProviderTransactionID = NULL;
	this->ns2__ReplyMessage::apReply = NULL;
	this->ns2__ReplyMessage::shipTo = NULL;
	this->ns2__ReplyMessage::billTo = NULL;
	this->ns2__ReplyMessage::apAuthReply = NULL;
	this->ns2__ReplyMessage::apAuthReversalReply = NULL;
	this->ns2__ReplyMessage::apCaptureReply = NULL;
	this->ns2__ReplyMessage::apOptionsReply = NULL;
	this->ns2__ReplyMessage::apRefundReply = NULL;
	this->ns2__ReplyMessage::apSaleReply = NULL;
	this->ns2__ReplyMessage::apCheckoutDetailsReply = NULL;
	this->ns2__ReplyMessage::apTransactionDetailsReply = NULL;
	this->ns2__ReplyMessage::apConfirmPurchaseReply = NULL;
	this->ns2__ReplyMessage::promotion = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__PromotionGroupReply(soap, &this->ns2__ReplyMessage::promotionGroup);
	this->ns2__ReplyMessage::payPalGetTxnDetailsReply = NULL;
	this->ns2__ReplyMessage::payPalTransactionSearchReply = NULL;
	this->ns2__ReplyMessage::emvReply = NULL;
	this->ns2__ReplyMessage::originalTransaction = NULL;
	this->ns2__ReplyMessage::hostedDataCreateReply = NULL;
	this->ns2__ReplyMessage::hostedDataRetrieveReply = NULL;
	this->ns2__ReplyMessage::salesSlipNumber = NULL;
	this->ns2__ReplyMessage::additionalProcessorResponse = NULL;
	this->ns2__ReplyMessage::jpo = NULL;
	this->ns2__ReplyMessage::card = NULL;
	this->ns2__ReplyMessage::paymentNetworkToken = NULL;
	this->ns2__ReplyMessage::vcReply = NULL;
	this->ns2__ReplyMessage::decryptVisaCheckoutDataReply = NULL;
	this->ns2__ReplyMessage::binLookupReply = NULL;
	this->ns2__ReplyMessage::issuerMessage = NULL;
	this->ns2__ReplyMessage::token = NULL;
	this->ns2__ReplyMessage::issuer = NULL;
	this->ns2__ReplyMessage::recipient = NULL;
	this->ns2__ReplyMessage::reserved = NULL;
	/* transient soap skipped */
}

void ns2__ReplyMessage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ReplyMessage::merchantReferenceCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ReplyMessage::requestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ReplyMessage::decision);
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__ReplyMessage::reasonCode);
	soap_serialize_std__vectorTemplateOfwstring(soap, &this->ns2__ReplyMessage::missingField);
	soap_serialize_std__vectorTemplateOfwstring(soap, &this->ns2__ReplyMessage::invalidField);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ReplyMessage::requestToken);
	soap_serialize_PointerTons2__PurchaseTotals(soap, &this->ns2__ReplyMessage::purchaseTotals);
	soap_serialize_std__vectorTemplateOfPointerTons2__DeniedPartiesMatch(soap, &this->ns2__ReplyMessage::deniedPartiesMatch);
	soap_serialize_PointerTons2__CCAuthReply(soap, &this->ns2__ReplyMessage::ccAuthReply);
	soap_serialize_PointerTons2__OCTReply(soap, &this->ns2__ReplyMessage::octReply);
	soap_serialize_PointerTons2__VerificationReply(soap, &this->ns2__ReplyMessage::verificationReply);
	soap_serialize_PointerTons2__CCSaleReply(soap, &this->ns2__ReplyMessage::ccSaleReply);
	soap_serialize_PointerTons2__CCSaleCreditReply(soap, &this->ns2__ReplyMessage::ccSaleCreditReply);
	soap_serialize_PointerTons2__CCSaleReversalReply(soap, &this->ns2__ReplyMessage::ccSaleReversalReply);
	soap_serialize_PointerTons2__CCIncrementalAuthReply(soap, &this->ns2__ReplyMessage::ccIncrementalAuthReply);
	soap_serialize_PointerTons2__ServiceFeeCalculateReply(soap, &this->ns2__ReplyMessage::serviceFeeCalculateReply);
	soap_serialize_PointerTons2__CCCaptureReply(soap, &this->ns2__ReplyMessage::ccCaptureReply);
	soap_serialize_PointerTons2__CCCreditReply(soap, &this->ns2__ReplyMessage::ccCreditReply);
	soap_serialize_PointerTons2__CCAuthReversalReply(soap, &this->ns2__ReplyMessage::ccAuthReversalReply);
	soap_serialize_PointerTons2__CCAutoAuthReversalReply(soap, &this->ns2__ReplyMessage::ccAutoAuthReversalReply);
	soap_serialize_PointerTons2__CCDCCReply(soap, &this->ns2__ReplyMessage::ccDCCReply);
	soap_serialize_PointerTons2__CCDCCUpdateReply(soap, &this->ns2__ReplyMessage::ccDCCUpdateReply);
	soap_serialize_PointerTons2__ECDebitReply(soap, &this->ns2__ReplyMessage::ecDebitReply);
	soap_serialize_PointerTons2__ECCreditReply(soap, &this->ns2__ReplyMessage::ecCreditReply);
	soap_serialize_PointerTons2__ECAuthenticateReply(soap, &this->ns2__ReplyMessage::ecAuthenticateReply);
	soap_serialize_PointerTons2__PayerAuthEnrollReply(soap, &this->ns2__ReplyMessage::payerAuthEnrollReply);
	soap_serialize_PointerTons2__PayerAuthValidateReply(soap, &this->ns2__ReplyMessage::payerAuthValidateReply);
	soap_serialize_PointerTons2__TaxReply(soap, &this->ns2__ReplyMessage::taxReply);
	soap_serialize_PointerTons2__EncryptedPayment(soap, &this->ns2__ReplyMessage::encryptedPayment);
	soap_serialize_PointerTons2__EncryptPaymentDataReply(soap, &this->ns2__ReplyMessage::encryptPaymentDataReply);
	soap_serialize_PointerTons2__DMEReply(soap, &this->ns2__ReplyMessage::dmeReply);
	soap_serialize_PointerTons2__AFSReply(soap, &this->ns2__ReplyMessage::afsReply);
	soap_serialize_PointerTons2__DAVReply(soap, &this->ns2__ReplyMessage::davReply);
	soap_serialize_PointerTons2__ExportReply(soap, &this->ns2__ReplyMessage::exportReply);
	soap_serialize_PointerTons2__FXRatesReply(soap, &this->ns2__ReplyMessage::fxRatesReply);
	soap_serialize_PointerTons2__BankTransferReply(soap, &this->ns2__ReplyMessage::bankTransferReply);
	soap_serialize_PointerTons2__BankTransferRefundReply(soap, &this->ns2__ReplyMessage::bankTransferRefundReply);
	soap_serialize_PointerTons2__BankTransferRealTimeReply(soap, &this->ns2__ReplyMessage::bankTransferRealTimeReply);
	soap_serialize_PointerTons2__DirectDebitMandateReply(soap, &this->ns2__ReplyMessage::directDebitMandateReply);
	soap_serialize_PointerTons2__DirectDebitReply(soap, &this->ns2__ReplyMessage::directDebitReply);
	soap_serialize_PointerTons2__DirectDebitValidateReply(soap, &this->ns2__ReplyMessage::directDebitValidateReply);
	soap_serialize_PointerTons2__DirectDebitRefundReply(soap, &this->ns2__ReplyMessage::directDebitRefundReply);
	soap_serialize_PointerTons2__PaySubscriptionCreateReply(soap, &this->ns2__ReplyMessage::paySubscriptionCreateReply);
	soap_serialize_PointerTons2__PaySubscriptionUpdateReply(soap, &this->ns2__ReplyMessage::paySubscriptionUpdateReply);
	soap_serialize_PointerTons2__PaySubscriptionEventUpdateReply(soap, &this->ns2__ReplyMessage::paySubscriptionEventUpdateReply);
	soap_serialize_PointerTons2__PaySubscriptionRetrieveReply(soap, &this->ns2__ReplyMessage::paySubscriptionRetrieveReply);
	soap_serialize_PointerTons2__PaySubscriptionDeleteReply(soap, &this->ns2__ReplyMessage::paySubscriptionDeleteReply);
	soap_serialize_PointerTons2__PayPalPaymentReply(soap, &this->ns2__ReplyMessage::payPalPaymentReply);
	soap_serialize_PointerTons2__PayPalCreditReply(soap, &this->ns2__ReplyMessage::payPalCreditReply);
	soap_serialize_PointerTons2__VoidReply(soap, &this->ns2__ReplyMessage::voidReply);
	soap_serialize_PointerTons2__PinlessDebitReply(soap, &this->ns2__ReplyMessage::pinlessDebitReply);
	soap_serialize_PointerTons2__PinlessDebitValidateReply(soap, &this->ns2__ReplyMessage::pinlessDebitValidateReply);
	soap_serialize_PointerTons2__PinlessDebitReversalReply(soap, &this->ns2__ReplyMessage::pinlessDebitReversalReply);
	soap_serialize_PointerTons2__PayPalButtonCreateReply(soap, &this->ns2__ReplyMessage::payPalButtonCreateReply);
	soap_serialize_PointerTons2__PayPalPreapprovedPaymentReply(soap, &this->ns2__ReplyMessage::payPalPreapprovedPaymentReply);
	soap_serialize_PointerTons2__PayPalPreapprovedUpdateReply(soap, &this->ns2__ReplyMessage::payPalPreapprovedUpdateReply);
	soap_serialize_PointerTons2__RiskUpdateReply(soap, &this->ns2__ReplyMessage::riskUpdateReply);
	soap_serialize_PointerTons2__FraudUpdateReply(soap, &this->ns2__ReplyMessage::fraudUpdateReply);
	soap_serialize_PointerTons2__CaseManagementActionReply(soap, &this->ns2__ReplyMessage::caseManagementActionReply);
	soap_serialize_PointerTons2__DecisionReply(soap, &this->ns2__ReplyMessage::decisionReply);
	soap_serialize_PointerTons2__PayPalRefundReply(soap, &this->ns2__ReplyMessage::payPalRefundReply);
	soap_serialize_PointerTons2__PayPalAuthReversalReply(soap, &this->ns2__ReplyMessage::payPalAuthReversalReply);
	soap_serialize_PointerTons2__PayPalDoCaptureReply(soap, &this->ns2__ReplyMessage::payPalDoCaptureReply);
	soap_serialize_PointerTons2__PayPalEcDoPaymentReply(soap, &this->ns2__ReplyMessage::payPalEcDoPaymentReply);
	soap_serialize_PointerTons2__PayPalEcGetDetailsReply(soap, &this->ns2__ReplyMessage::payPalEcGetDetailsReply);
	soap_serialize_PointerTons2__PayPalEcSetReply(soap, &this->ns2__ReplyMessage::payPalEcSetReply);
	soap_serialize_PointerTons2__PayPalAuthorizationReply(soap, &this->ns2__ReplyMessage::payPalAuthorizationReply);
	soap_serialize_PointerTons2__PayPalEcOrderSetupReply(soap, &this->ns2__ReplyMessage::payPalEcOrderSetupReply);
	soap_serialize_PointerTons2__PayPalUpdateAgreementReply(soap, &this->ns2__ReplyMessage::payPalUpdateAgreementReply);
	soap_serialize_PointerTons2__PayPalCreateAgreementReply(soap, &this->ns2__ReplyMessage::payPalCreateAgreementReply);
	soap_serialize_PointerTons2__PayPalDoRefTransactionReply(soap, &this->ns2__ReplyMessage::payPalDoRefTransactionReply);
	soap_serialize_PointerTons2__ChinaPaymentReply(soap, &this->ns2__ReplyMessage::chinaPaymentReply);
	soap_serialize_PointerTons2__ChinaRefundReply(soap, &this->ns2__ReplyMessage::chinaRefundReply);
	soap_serialize_PointerTons2__BoletoPaymentReply(soap, &this->ns2__ReplyMessage::boletoPaymentReply);
	soap_serialize_PointerTons2__PinDebitPurchaseReply(soap, &this->ns2__ReplyMessage::pinDebitPurchaseReply);
	soap_serialize_PointerTons2__PinDebitCreditReply(soap, &this->ns2__ReplyMessage::pinDebitCreditReply);
	soap_serialize_PointerTons2__PinDebitReversalReply(soap, &this->ns2__ReplyMessage::pinDebitReversalReply);
	soap_serialize_PointerTons2__APInitiateReply(soap, &this->ns2__ReplyMessage::apInitiateReply);
	soap_serialize_PointerTons2__APCheckStatusReply(soap, &this->ns2__ReplyMessage::apCheckStatusReply);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ReplyMessage::receiptNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ReplyMessage::additionalData);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ReplyMessage::solutionProviderTransactionID);
	soap_serialize_PointerTons2__APReply(soap, &this->ns2__ReplyMessage::apReply);
	soap_serialize_PointerTons2__ShipTo(soap, &this->ns2__ReplyMessage::shipTo);
	soap_serialize_PointerTons2__BillTo(soap, &this->ns2__ReplyMessage::billTo);
	soap_serialize_PointerTons2__APAuthReply(soap, &this->ns2__ReplyMessage::apAuthReply);
	soap_serialize_PointerTons2__APAuthReversalReply(soap, &this->ns2__ReplyMessage::apAuthReversalReply);
	soap_serialize_PointerTons2__APCaptureReply(soap, &this->ns2__ReplyMessage::apCaptureReply);
	soap_serialize_PointerTons2__APOptionsReply(soap, &this->ns2__ReplyMessage::apOptionsReply);
	soap_serialize_PointerTons2__APRefundReply(soap, &this->ns2__ReplyMessage::apRefundReply);
	soap_serialize_PointerTons2__APSaleReply(soap, &this->ns2__ReplyMessage::apSaleReply);
	soap_serialize_PointerTons2__APCheckOutDetailsReply(soap, &this->ns2__ReplyMessage::apCheckoutDetailsReply);
	soap_serialize_PointerTons2__APTransactionDetailsReply(soap, &this->ns2__ReplyMessage::apTransactionDetailsReply);
	soap_serialize_PointerTons2__APConfirmPurchaseReply(soap, &this->ns2__ReplyMessage::apConfirmPurchaseReply);
	soap_serialize_PointerTons2__Promotion(soap, &this->ns2__ReplyMessage::promotion);
	soap_serialize_std__vectorTemplateOfPointerTons2__PromotionGroupReply(soap, &this->ns2__ReplyMessage::promotionGroup);
	soap_serialize_PointerTons2__PayPalGetTxnDetailsReply(soap, &this->ns2__ReplyMessage::payPalGetTxnDetailsReply);
	soap_serialize_PointerTons2__PayPalTransactionSearchReply(soap, &this->ns2__ReplyMessage::payPalTransactionSearchReply);
	soap_serialize_PointerTons2__EmvReply(soap, &this->ns2__ReplyMessage::emvReply);
	soap_serialize_PointerTons2__OriginalTransaction(soap, &this->ns2__ReplyMessage::originalTransaction);
	soap_serialize_PointerTons2__HostedDataCreateReply(soap, &this->ns2__ReplyMessage::hostedDataCreateReply);
	soap_serialize_PointerTons2__HostedDataRetrieveReply(soap, &this->ns2__ReplyMessage::hostedDataRetrieveReply);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ReplyMessage::salesSlipNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ReplyMessage::additionalProcessorResponse);
	soap_serialize_PointerTons2__JPO(soap, &this->ns2__ReplyMessage::jpo);
	soap_serialize_PointerTons2__Card(soap, &this->ns2__ReplyMessage::card);
	soap_serialize_PointerTons2__PaymentNetworkToken(soap, &this->ns2__ReplyMessage::paymentNetworkToken);
	soap_serialize_PointerTons2__VCReply(soap, &this->ns2__ReplyMessage::vcReply);
	soap_serialize_PointerTons2__DecryptVisaCheckoutDataReply(soap, &this->ns2__ReplyMessage::decryptVisaCheckoutDataReply);
	soap_serialize_PointerTons2__BinLookupReply(soap, &this->ns2__ReplyMessage::binLookupReply);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ReplyMessage::issuerMessage);
	soap_serialize_PointerTons2__Token(soap, &this->ns2__ReplyMessage::token);
	soap_serialize_PointerTons2__issuer(soap, &this->ns2__ReplyMessage::issuer);
	soap_serialize_PointerTons2__Recipient(soap, &this->ns2__ReplyMessage::recipient);
	soap_serialize_PointerTons2__ReplyReserved(soap, &this->ns2__ReplyMessage::reserved);
#endif
}

int ns2__ReplyMessage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ReplyMessage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ReplyMessage(struct soap *soap, const char *tag, int id, const ns2__ReplyMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ReplyMessage), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantReferenceCode", -1, (wchar_t*const*)&a->ns2__ReplyMessage::merchantReferenceCode, ""))
		return soap->error;
	if (!a->ns2__ReplyMessage::requestID)
	{	if (soap_element_nil(soap, "ns2:requestID"))
			return soap->error;
	}
	else
	if (soap_out_wstring(soap, "ns2:requestID", -1, (wchar_t*const*)&a->ns2__ReplyMessage::requestID, ""))
		return soap->error;
	if (!a->ns2__ReplyMessage::decision)
	{	if (soap_element_nil(soap, "ns2:decision"))
			return soap->error;
	}
	else
	if (soap_out_wstring(soap, "ns2:decision", -1, (wchar_t*const*)&a->ns2__ReplyMessage::decision, ""))
		return soap->error;
	if (!a->ns2__ReplyMessage::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__ReplyMessage::reasonCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwstring(soap, "ns2:missingField", -1, &a->ns2__ReplyMessage::missingField, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwstring(soap, "ns2:invalidField", -1, &a->ns2__ReplyMessage::invalidField, ""))
		return soap->error;
	if (!a->ns2__ReplyMessage::requestToken)
	{	if (soap_element_nil(soap, "ns2:requestToken"))
			return soap->error;
	}
	else
	if (soap_out_wstring(soap, "ns2:requestToken", -1, (wchar_t*const*)&a->ns2__ReplyMessage::requestToken, ""))
		return soap->error;
	if (soap_out_PointerTons2__PurchaseTotals(soap, "ns2:purchaseTotals", -1, &a->ns2__ReplyMessage::purchaseTotals, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__DeniedPartiesMatch(soap, "ns2:deniedPartiesMatch", -1, &a->ns2__ReplyMessage::deniedPartiesMatch, ""))
		return soap->error;
	if (soap_out_PointerTons2__CCAuthReply(soap, "ns2:ccAuthReply", -1, &a->ns2__ReplyMessage::ccAuthReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__OCTReply(soap, "ns2:octReply", -1, &a->ns2__ReplyMessage::octReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__VerificationReply(soap, "ns2:verificationReply", -1, &a->ns2__ReplyMessage::verificationReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__CCSaleReply(soap, "ns2:ccSaleReply", -1, &a->ns2__ReplyMessage::ccSaleReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__CCSaleCreditReply(soap, "ns2:ccSaleCreditReply", -1, &a->ns2__ReplyMessage::ccSaleCreditReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__CCSaleReversalReply(soap, "ns2:ccSaleReversalReply", -1, &a->ns2__ReplyMessage::ccSaleReversalReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__CCIncrementalAuthReply(soap, "ns2:ccIncrementalAuthReply", -1, &a->ns2__ReplyMessage::ccIncrementalAuthReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__ServiceFeeCalculateReply(soap, "ns2:serviceFeeCalculateReply", -1, &a->ns2__ReplyMessage::serviceFeeCalculateReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__CCCaptureReply(soap, "ns2:ccCaptureReply", -1, &a->ns2__ReplyMessage::ccCaptureReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__CCCreditReply(soap, "ns2:ccCreditReply", -1, &a->ns2__ReplyMessage::ccCreditReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__CCAuthReversalReply(soap, "ns2:ccAuthReversalReply", -1, &a->ns2__ReplyMessage::ccAuthReversalReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__CCAutoAuthReversalReply(soap, "ns2:ccAutoAuthReversalReply", -1, &a->ns2__ReplyMessage::ccAutoAuthReversalReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__CCDCCReply(soap, "ns2:ccDCCReply", -1, &a->ns2__ReplyMessage::ccDCCReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__CCDCCUpdateReply(soap, "ns2:ccDCCUpdateReply", -1, &a->ns2__ReplyMessage::ccDCCUpdateReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__ECDebitReply(soap, "ns2:ecDebitReply", -1, &a->ns2__ReplyMessage::ecDebitReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__ECCreditReply(soap, "ns2:ecCreditReply", -1, &a->ns2__ReplyMessage::ecCreditReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__ECAuthenticateReply(soap, "ns2:ecAuthenticateReply", -1, &a->ns2__ReplyMessage::ecAuthenticateReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayerAuthEnrollReply(soap, "ns2:payerAuthEnrollReply", -1, &a->ns2__ReplyMessage::payerAuthEnrollReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayerAuthValidateReply(soap, "ns2:payerAuthValidateReply", -1, &a->ns2__ReplyMessage::payerAuthValidateReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__TaxReply(soap, "ns2:taxReply", -1, &a->ns2__ReplyMessage::taxReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__EncryptedPayment(soap, "ns2:encryptedPayment", -1, &a->ns2__ReplyMessage::encryptedPayment, ""))
		return soap->error;
	if (soap_out_PointerTons2__EncryptPaymentDataReply(soap, "ns2:encryptPaymentDataReply", -1, &a->ns2__ReplyMessage::encryptPaymentDataReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__DMEReply(soap, "ns2:dmeReply", -1, &a->ns2__ReplyMessage::dmeReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__AFSReply(soap, "ns2:afsReply", -1, &a->ns2__ReplyMessage::afsReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__DAVReply(soap, "ns2:davReply", -1, &a->ns2__ReplyMessage::davReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__ExportReply(soap, "ns2:exportReply", -1, &a->ns2__ReplyMessage::exportReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__FXRatesReply(soap, "ns2:fxRatesReply", -1, &a->ns2__ReplyMessage::fxRatesReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__BankTransferReply(soap, "ns2:bankTransferReply", -1, &a->ns2__ReplyMessage::bankTransferReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__BankTransferRefundReply(soap, "ns2:bankTransferRefundReply", -1, &a->ns2__ReplyMessage::bankTransferRefundReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__BankTransferRealTimeReply(soap, "ns2:bankTransferRealTimeReply", -1, &a->ns2__ReplyMessage::bankTransferRealTimeReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__DirectDebitMandateReply(soap, "ns2:directDebitMandateReply", -1, &a->ns2__ReplyMessage::directDebitMandateReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__DirectDebitReply(soap, "ns2:directDebitReply", -1, &a->ns2__ReplyMessage::directDebitReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__DirectDebitValidateReply(soap, "ns2:directDebitValidateReply", -1, &a->ns2__ReplyMessage::directDebitValidateReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__DirectDebitRefundReply(soap, "ns2:directDebitRefundReply", -1, &a->ns2__ReplyMessage::directDebitRefundReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PaySubscriptionCreateReply(soap, "ns2:paySubscriptionCreateReply", -1, &a->ns2__ReplyMessage::paySubscriptionCreateReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PaySubscriptionUpdateReply(soap, "ns2:paySubscriptionUpdateReply", -1, &a->ns2__ReplyMessage::paySubscriptionUpdateReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PaySubscriptionEventUpdateReply(soap, "ns2:paySubscriptionEventUpdateReply", -1, &a->ns2__ReplyMessage::paySubscriptionEventUpdateReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PaySubscriptionRetrieveReply(soap, "ns2:paySubscriptionRetrieveReply", -1, &a->ns2__ReplyMessage::paySubscriptionRetrieveReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PaySubscriptionDeleteReply(soap, "ns2:paySubscriptionDeleteReply", -1, &a->ns2__ReplyMessage::paySubscriptionDeleteReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalPaymentReply(soap, "ns2:payPalPaymentReply", -1, &a->ns2__ReplyMessage::payPalPaymentReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalCreditReply(soap, "ns2:payPalCreditReply", -1, &a->ns2__ReplyMessage::payPalCreditReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__VoidReply(soap, "ns2:voidReply", -1, &a->ns2__ReplyMessage::voidReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PinlessDebitReply(soap, "ns2:pinlessDebitReply", -1, &a->ns2__ReplyMessage::pinlessDebitReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PinlessDebitValidateReply(soap, "ns2:pinlessDebitValidateReply", -1, &a->ns2__ReplyMessage::pinlessDebitValidateReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PinlessDebitReversalReply(soap, "ns2:pinlessDebitReversalReply", -1, &a->ns2__ReplyMessage::pinlessDebitReversalReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalButtonCreateReply(soap, "ns2:payPalButtonCreateReply", -1, &a->ns2__ReplyMessage::payPalButtonCreateReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalPreapprovedPaymentReply(soap, "ns2:payPalPreapprovedPaymentReply", -1, &a->ns2__ReplyMessage::payPalPreapprovedPaymentReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalPreapprovedUpdateReply(soap, "ns2:payPalPreapprovedUpdateReply", -1, &a->ns2__ReplyMessage::payPalPreapprovedUpdateReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__RiskUpdateReply(soap, "ns2:riskUpdateReply", -1, &a->ns2__ReplyMessage::riskUpdateReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__FraudUpdateReply(soap, "ns2:fraudUpdateReply", -1, &a->ns2__ReplyMessage::fraudUpdateReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__CaseManagementActionReply(soap, "ns2:caseManagementActionReply", -1, &a->ns2__ReplyMessage::caseManagementActionReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__DecisionReply(soap, "ns2:decisionReply", -1, &a->ns2__ReplyMessage::decisionReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalRefundReply(soap, "ns2:payPalRefundReply", -1, &a->ns2__ReplyMessage::payPalRefundReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalAuthReversalReply(soap, "ns2:payPalAuthReversalReply", -1, &a->ns2__ReplyMessage::payPalAuthReversalReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalDoCaptureReply(soap, "ns2:payPalDoCaptureReply", -1, &a->ns2__ReplyMessage::payPalDoCaptureReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalEcDoPaymentReply(soap, "ns2:payPalEcDoPaymentReply", -1, &a->ns2__ReplyMessage::payPalEcDoPaymentReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalEcGetDetailsReply(soap, "ns2:payPalEcGetDetailsReply", -1, &a->ns2__ReplyMessage::payPalEcGetDetailsReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalEcSetReply(soap, "ns2:payPalEcSetReply", -1, &a->ns2__ReplyMessage::payPalEcSetReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalAuthorizationReply(soap, "ns2:payPalAuthorizationReply", -1, &a->ns2__ReplyMessage::payPalAuthorizationReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalEcOrderSetupReply(soap, "ns2:payPalEcOrderSetupReply", -1, &a->ns2__ReplyMessage::payPalEcOrderSetupReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalUpdateAgreementReply(soap, "ns2:payPalUpdateAgreementReply", -1, &a->ns2__ReplyMessage::payPalUpdateAgreementReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalCreateAgreementReply(soap, "ns2:payPalCreateAgreementReply", -1, &a->ns2__ReplyMessage::payPalCreateAgreementReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalDoRefTransactionReply(soap, "ns2:payPalDoRefTransactionReply", -1, &a->ns2__ReplyMessage::payPalDoRefTransactionReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__ChinaPaymentReply(soap, "ns2:chinaPaymentReply", -1, &a->ns2__ReplyMessage::chinaPaymentReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__ChinaRefundReply(soap, "ns2:chinaRefundReply", -1, &a->ns2__ReplyMessage::chinaRefundReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__BoletoPaymentReply(soap, "ns2:boletoPaymentReply", -1, &a->ns2__ReplyMessage::boletoPaymentReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PinDebitPurchaseReply(soap, "ns2:pinDebitPurchaseReply", -1, &a->ns2__ReplyMessage::pinDebitPurchaseReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PinDebitCreditReply(soap, "ns2:pinDebitCreditReply", -1, &a->ns2__ReplyMessage::pinDebitCreditReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PinDebitReversalReply(soap, "ns2:pinDebitReversalReply", -1, &a->ns2__ReplyMessage::pinDebitReversalReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__APInitiateReply(soap, "ns2:apInitiateReply", -1, &a->ns2__ReplyMessage::apInitiateReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__APCheckStatusReply(soap, "ns2:apCheckStatusReply", -1, &a->ns2__ReplyMessage::apCheckStatusReply, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:receiptNumber", -1, (wchar_t*const*)&a->ns2__ReplyMessage::receiptNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:additionalData", -1, (wchar_t*const*)&a->ns2__ReplyMessage::additionalData, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:solutionProviderTransactionID", -1, (wchar_t*const*)&a->ns2__ReplyMessage::solutionProviderTransactionID, ""))
		return soap->error;
	if (soap_out_PointerTons2__APReply(soap, "ns2:apReply", -1, &a->ns2__ReplyMessage::apReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__ShipTo(soap, "ns2:shipTo", -1, &a->ns2__ReplyMessage::shipTo, ""))
		return soap->error;
	if (soap_out_PointerTons2__BillTo(soap, "ns2:billTo", -1, &a->ns2__ReplyMessage::billTo, ""))
		return soap->error;
	if (soap_out_PointerTons2__APAuthReply(soap, "ns2:apAuthReply", -1, &a->ns2__ReplyMessage::apAuthReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__APAuthReversalReply(soap, "ns2:apAuthReversalReply", -1, &a->ns2__ReplyMessage::apAuthReversalReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__APCaptureReply(soap, "ns2:apCaptureReply", -1, &a->ns2__ReplyMessage::apCaptureReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__APOptionsReply(soap, "ns2:apOptionsReply", -1, &a->ns2__ReplyMessage::apOptionsReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__APRefundReply(soap, "ns2:apRefundReply", -1, &a->ns2__ReplyMessage::apRefundReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__APSaleReply(soap, "ns2:apSaleReply", -1, &a->ns2__ReplyMessage::apSaleReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__APCheckOutDetailsReply(soap, "ns2:apCheckoutDetailsReply", -1, &a->ns2__ReplyMessage::apCheckoutDetailsReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__APTransactionDetailsReply(soap, "ns2:apTransactionDetailsReply", -1, &a->ns2__ReplyMessage::apTransactionDetailsReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__APConfirmPurchaseReply(soap, "ns2:apConfirmPurchaseReply", -1, &a->ns2__ReplyMessage::apConfirmPurchaseReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__Promotion(soap, "ns2:promotion", -1, &a->ns2__ReplyMessage::promotion, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__PromotionGroupReply(soap, "ns2:promotionGroup", -1, &a->ns2__ReplyMessage::promotionGroup, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalGetTxnDetailsReply(soap, "ns2:payPalGetTxnDetailsReply", -1, &a->ns2__ReplyMessage::payPalGetTxnDetailsReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalTransactionSearchReply(soap, "ns2:payPalTransactionSearchReply", -1, &a->ns2__ReplyMessage::payPalTransactionSearchReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__EmvReply(soap, "ns2:emvReply", -1, &a->ns2__ReplyMessage::emvReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__OriginalTransaction(soap, "ns2:originalTransaction", -1, &a->ns2__ReplyMessage::originalTransaction, ""))
		return soap->error;
	if (soap_out_PointerTons2__HostedDataCreateReply(soap, "ns2:hostedDataCreateReply", -1, &a->ns2__ReplyMessage::hostedDataCreateReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__HostedDataRetrieveReply(soap, "ns2:hostedDataRetrieveReply", -1, &a->ns2__ReplyMessage::hostedDataRetrieveReply, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:salesSlipNumber", -1, (wchar_t*const*)&a->ns2__ReplyMessage::salesSlipNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:additionalProcessorResponse", -1, (wchar_t*const*)&a->ns2__ReplyMessage::additionalProcessorResponse, ""))
		return soap->error;
	if (soap_out_PointerTons2__JPO(soap, "ns2:jpo", -1, &a->ns2__ReplyMessage::jpo, ""))
		return soap->error;
	if (soap_out_PointerTons2__Card(soap, "ns2:card", -1, &a->ns2__ReplyMessage::card, ""))
		return soap->error;
	if (soap_out_PointerTons2__PaymentNetworkToken(soap, "ns2:paymentNetworkToken", -1, &a->ns2__ReplyMessage::paymentNetworkToken, ""))
		return soap->error;
	if (soap_out_PointerTons2__VCReply(soap, "ns2:vcReply", -1, &a->ns2__ReplyMessage::vcReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__DecryptVisaCheckoutDataReply(soap, "ns2:decryptVisaCheckoutDataReply", -1, &a->ns2__ReplyMessage::decryptVisaCheckoutDataReply, ""))
		return soap->error;
	if (soap_out_PointerTons2__BinLookupReply(soap, "ns2:binLookupReply", -1, &a->ns2__ReplyMessage::binLookupReply, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:issuerMessage", -1, (wchar_t*const*)&a->ns2__ReplyMessage::issuerMessage, ""))
		return soap->error;
	if (soap_out_PointerTons2__Token(soap, "ns2:token", -1, &a->ns2__ReplyMessage::token, ""))
		return soap->error;
	if (soap_out_PointerTons2__issuer(soap, "ns2:issuer", -1, &a->ns2__ReplyMessage::issuer, ""))
		return soap->error;
	if (soap_out_PointerTons2__Recipient(soap, "ns2:recipient", -1, &a->ns2__ReplyMessage::recipient, ""))
		return soap->error;
	if (soap_out_PointerTons2__ReplyReserved(soap, "ns2:reserved", -1, &a->ns2__ReplyMessage::reserved, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ReplyMessage::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ReplyMessage(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ReplyMessage * SOAP_FMAC4 soap_in_ns2__ReplyMessage(struct soap *soap, const char *tag, ns2__ReplyMessage *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ReplyMessage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ReplyMessage, sizeof(ns2__ReplyMessage), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ReplyMessage)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ReplyMessage *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_merchantReferenceCode1 = 1;
	size_t soap_flag_requestID1 = 1;
	size_t soap_flag_decision1 = 1;
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_requestToken1 = 1;
	size_t soap_flag_purchaseTotals1 = 1;
	size_t soap_flag_ccAuthReply1 = 1;
	size_t soap_flag_octReply1 = 1;
	size_t soap_flag_verificationReply1 = 1;
	size_t soap_flag_ccSaleReply1 = 1;
	size_t soap_flag_ccSaleCreditReply1 = 1;
	size_t soap_flag_ccSaleReversalReply1 = 1;
	size_t soap_flag_ccIncrementalAuthReply1 = 1;
	size_t soap_flag_serviceFeeCalculateReply1 = 1;
	size_t soap_flag_ccCaptureReply1 = 1;
	size_t soap_flag_ccCreditReply1 = 1;
	size_t soap_flag_ccAuthReversalReply1 = 1;
	size_t soap_flag_ccAutoAuthReversalReply1 = 1;
	size_t soap_flag_ccDCCReply1 = 1;
	size_t soap_flag_ccDCCUpdateReply1 = 1;
	size_t soap_flag_ecDebitReply1 = 1;
	size_t soap_flag_ecCreditReply1 = 1;
	size_t soap_flag_ecAuthenticateReply1 = 1;
	size_t soap_flag_payerAuthEnrollReply1 = 1;
	size_t soap_flag_payerAuthValidateReply1 = 1;
	size_t soap_flag_taxReply1 = 1;
	size_t soap_flag_encryptedPayment1 = 1;
	size_t soap_flag_encryptPaymentDataReply1 = 1;
	size_t soap_flag_dmeReply1 = 1;
	size_t soap_flag_afsReply1 = 1;
	size_t soap_flag_davReply1 = 1;
	size_t soap_flag_exportReply1 = 1;
	size_t soap_flag_fxRatesReply1 = 1;
	size_t soap_flag_bankTransferReply1 = 1;
	size_t soap_flag_bankTransferRefundReply1 = 1;
	size_t soap_flag_bankTransferRealTimeReply1 = 1;
	size_t soap_flag_directDebitMandateReply1 = 1;
	size_t soap_flag_directDebitReply1 = 1;
	size_t soap_flag_directDebitValidateReply1 = 1;
	size_t soap_flag_directDebitRefundReply1 = 1;
	size_t soap_flag_paySubscriptionCreateReply1 = 1;
	size_t soap_flag_paySubscriptionUpdateReply1 = 1;
	size_t soap_flag_paySubscriptionEventUpdateReply1 = 1;
	size_t soap_flag_paySubscriptionRetrieveReply1 = 1;
	size_t soap_flag_paySubscriptionDeleteReply1 = 1;
	size_t soap_flag_payPalPaymentReply1 = 1;
	size_t soap_flag_payPalCreditReply1 = 1;
	size_t soap_flag_voidReply1 = 1;
	size_t soap_flag_pinlessDebitReply1 = 1;
	size_t soap_flag_pinlessDebitValidateReply1 = 1;
	size_t soap_flag_pinlessDebitReversalReply1 = 1;
	size_t soap_flag_payPalButtonCreateReply1 = 1;
	size_t soap_flag_payPalPreapprovedPaymentReply1 = 1;
	size_t soap_flag_payPalPreapprovedUpdateReply1 = 1;
	size_t soap_flag_riskUpdateReply1 = 1;
	size_t soap_flag_fraudUpdateReply1 = 1;
	size_t soap_flag_caseManagementActionReply1 = 1;
	size_t soap_flag_decisionReply1 = 1;
	size_t soap_flag_payPalRefundReply1 = 1;
	size_t soap_flag_payPalAuthReversalReply1 = 1;
	size_t soap_flag_payPalDoCaptureReply1 = 1;
	size_t soap_flag_payPalEcDoPaymentReply1 = 1;
	size_t soap_flag_payPalEcGetDetailsReply1 = 1;
	size_t soap_flag_payPalEcSetReply1 = 1;
	size_t soap_flag_payPalAuthorizationReply1 = 1;
	size_t soap_flag_payPalEcOrderSetupReply1 = 1;
	size_t soap_flag_payPalUpdateAgreementReply1 = 1;
	size_t soap_flag_payPalCreateAgreementReply1 = 1;
	size_t soap_flag_payPalDoRefTransactionReply1 = 1;
	size_t soap_flag_chinaPaymentReply1 = 1;
	size_t soap_flag_chinaRefundReply1 = 1;
	size_t soap_flag_boletoPaymentReply1 = 1;
	size_t soap_flag_pinDebitPurchaseReply1 = 1;
	size_t soap_flag_pinDebitCreditReply1 = 1;
	size_t soap_flag_pinDebitReversalReply1 = 1;
	size_t soap_flag_apInitiateReply1 = 1;
	size_t soap_flag_apCheckStatusReply1 = 1;
	size_t soap_flag_receiptNumber1 = 1;
	size_t soap_flag_additionalData1 = 1;
	size_t soap_flag_solutionProviderTransactionID1 = 1;
	size_t soap_flag_apReply1 = 1;
	size_t soap_flag_shipTo1 = 1;
	size_t soap_flag_billTo1 = 1;
	size_t soap_flag_apAuthReply1 = 1;
	size_t soap_flag_apAuthReversalReply1 = 1;
	size_t soap_flag_apCaptureReply1 = 1;
	size_t soap_flag_apOptionsReply1 = 1;
	size_t soap_flag_apRefundReply1 = 1;
	size_t soap_flag_apSaleReply1 = 1;
	size_t soap_flag_apCheckoutDetailsReply1 = 1;
	size_t soap_flag_apTransactionDetailsReply1 = 1;
	size_t soap_flag_apConfirmPurchaseReply1 = 1;
	size_t soap_flag_promotion1 = 1;
	size_t soap_flag_payPalGetTxnDetailsReply1 = 1;
	size_t soap_flag_payPalTransactionSearchReply1 = 1;
	size_t soap_flag_emvReply1 = 1;
	size_t soap_flag_originalTransaction1 = 1;
	size_t soap_flag_hostedDataCreateReply1 = 1;
	size_t soap_flag_hostedDataRetrieveReply1 = 1;
	size_t soap_flag_salesSlipNumber1 = 1;
	size_t soap_flag_additionalProcessorResponse1 = 1;
	size_t soap_flag_jpo1 = 1;
	size_t soap_flag_card1 = 1;
	size_t soap_flag_paymentNetworkToken1 = 1;
	size_t soap_flag_vcReply1 = 1;
	size_t soap_flag_decryptVisaCheckoutDataReply1 = 1;
	size_t soap_flag_binLookupReply1 = 1;
	size_t soap_flag_issuerMessage1 = 1;
	size_t soap_flag_token1 = 1;
	size_t soap_flag_issuer1 = 1;
	size_t soap_flag_recipient1 = 1;
	size_t soap_flag_reserved1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_merchantReferenceCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantReferenceCode", (wchar_t**)&a->ns2__ReplyMessage::merchantReferenceCode, "xsd:string"))
				{	soap_flag_merchantReferenceCode1--;
					continue;
				}
			if (soap_flag_requestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:requestID", (wchar_t**)&a->ns2__ReplyMessage::requestID, "xsd:string"))
				{	soap_flag_requestID1--;
					continue;
				}
			if (soap_flag_decision1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:decision", (wchar_t**)&a->ns2__ReplyMessage::decision, "xsd:string"))
				{	soap_flag_decision1--;
					continue;
				}
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__ReplyMessage::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfwstring(soap, "ns2:missingField", &a->ns2__ReplyMessage::missingField, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfwstring(soap, "ns2:invalidField", &a->ns2__ReplyMessage::invalidField, "xsd:string"))
					continue;
			if (soap_flag_requestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:requestToken", (wchar_t**)&a->ns2__ReplyMessage::requestToken, "xsd:string"))
				{	soap_flag_requestToken1--;
					continue;
				}
			if (soap_flag_purchaseTotals1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PurchaseTotals(soap, "ns2:purchaseTotals", &a->ns2__ReplyMessage::purchaseTotals, "ns2:PurchaseTotals"))
				{	soap_flag_purchaseTotals1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__DeniedPartiesMatch(soap, "ns2:deniedPartiesMatch", &a->ns2__ReplyMessage::deniedPartiesMatch, "ns2:DeniedPartiesMatch"))
					continue;
			if (soap_flag_ccAuthReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CCAuthReply(soap, "ns2:ccAuthReply", &a->ns2__ReplyMessage::ccAuthReply, "ns2:CCAuthReply"))
				{	soap_flag_ccAuthReply1--;
					continue;
				}
			if (soap_flag_octReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__OCTReply(soap, "ns2:octReply", &a->ns2__ReplyMessage::octReply, "ns2:OCTReply"))
				{	soap_flag_octReply1--;
					continue;
				}
			if (soap_flag_verificationReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VerificationReply(soap, "ns2:verificationReply", &a->ns2__ReplyMessage::verificationReply, "ns2:VerificationReply"))
				{	soap_flag_verificationReply1--;
					continue;
				}
			if (soap_flag_ccSaleReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CCSaleReply(soap, "ns2:ccSaleReply", &a->ns2__ReplyMessage::ccSaleReply, "ns2:CCSaleReply"))
				{	soap_flag_ccSaleReply1--;
					continue;
				}
			if (soap_flag_ccSaleCreditReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CCSaleCreditReply(soap, "ns2:ccSaleCreditReply", &a->ns2__ReplyMessage::ccSaleCreditReply, "ns2:CCSaleCreditReply"))
				{	soap_flag_ccSaleCreditReply1--;
					continue;
				}
			if (soap_flag_ccSaleReversalReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CCSaleReversalReply(soap, "ns2:ccSaleReversalReply", &a->ns2__ReplyMessage::ccSaleReversalReply, "ns2:CCSaleReversalReply"))
				{	soap_flag_ccSaleReversalReply1--;
					continue;
				}
			if (soap_flag_ccIncrementalAuthReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CCIncrementalAuthReply(soap, "ns2:ccIncrementalAuthReply", &a->ns2__ReplyMessage::ccIncrementalAuthReply, "ns2:CCIncrementalAuthReply"))
				{	soap_flag_ccIncrementalAuthReply1--;
					continue;
				}
			if (soap_flag_serviceFeeCalculateReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ServiceFeeCalculateReply(soap, "ns2:serviceFeeCalculateReply", &a->ns2__ReplyMessage::serviceFeeCalculateReply, "ns2:ServiceFeeCalculateReply"))
				{	soap_flag_serviceFeeCalculateReply1--;
					continue;
				}
			if (soap_flag_ccCaptureReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CCCaptureReply(soap, "ns2:ccCaptureReply", &a->ns2__ReplyMessage::ccCaptureReply, "ns2:CCCaptureReply"))
				{	soap_flag_ccCaptureReply1--;
					continue;
				}
			if (soap_flag_ccCreditReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CCCreditReply(soap, "ns2:ccCreditReply", &a->ns2__ReplyMessage::ccCreditReply, "ns2:CCCreditReply"))
				{	soap_flag_ccCreditReply1--;
					continue;
				}
			if (soap_flag_ccAuthReversalReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CCAuthReversalReply(soap, "ns2:ccAuthReversalReply", &a->ns2__ReplyMessage::ccAuthReversalReply, "ns2:CCAuthReversalReply"))
				{	soap_flag_ccAuthReversalReply1--;
					continue;
				}
			if (soap_flag_ccAutoAuthReversalReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CCAutoAuthReversalReply(soap, "ns2:ccAutoAuthReversalReply", &a->ns2__ReplyMessage::ccAutoAuthReversalReply, "ns2:CCAutoAuthReversalReply"))
				{	soap_flag_ccAutoAuthReversalReply1--;
					continue;
				}
			if (soap_flag_ccDCCReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CCDCCReply(soap, "ns2:ccDCCReply", &a->ns2__ReplyMessage::ccDCCReply, "ns2:CCDCCReply"))
				{	soap_flag_ccDCCReply1--;
					continue;
				}
			if (soap_flag_ccDCCUpdateReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CCDCCUpdateReply(soap, "ns2:ccDCCUpdateReply", &a->ns2__ReplyMessage::ccDCCUpdateReply, "ns2:CCDCCUpdateReply"))
				{	soap_flag_ccDCCUpdateReply1--;
					continue;
				}
			if (soap_flag_ecDebitReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ECDebitReply(soap, "ns2:ecDebitReply", &a->ns2__ReplyMessage::ecDebitReply, "ns2:ECDebitReply"))
				{	soap_flag_ecDebitReply1--;
					continue;
				}
			if (soap_flag_ecCreditReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ECCreditReply(soap, "ns2:ecCreditReply", &a->ns2__ReplyMessage::ecCreditReply, "ns2:ECCreditReply"))
				{	soap_flag_ecCreditReply1--;
					continue;
				}
			if (soap_flag_ecAuthenticateReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ECAuthenticateReply(soap, "ns2:ecAuthenticateReply", &a->ns2__ReplyMessage::ecAuthenticateReply, "ns2:ECAuthenticateReply"))
				{	soap_flag_ecAuthenticateReply1--;
					continue;
				}
			if (soap_flag_payerAuthEnrollReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayerAuthEnrollReply(soap, "ns2:payerAuthEnrollReply", &a->ns2__ReplyMessage::payerAuthEnrollReply, "ns2:PayerAuthEnrollReply"))
				{	soap_flag_payerAuthEnrollReply1--;
					continue;
				}
			if (soap_flag_payerAuthValidateReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayerAuthValidateReply(soap, "ns2:payerAuthValidateReply", &a->ns2__ReplyMessage::payerAuthValidateReply, "ns2:PayerAuthValidateReply"))
				{	soap_flag_payerAuthValidateReply1--;
					continue;
				}
			if (soap_flag_taxReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__TaxReply(soap, "ns2:taxReply", &a->ns2__ReplyMessage::taxReply, "ns2:TaxReply"))
				{	soap_flag_taxReply1--;
					continue;
				}
			if (soap_flag_encryptedPayment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EncryptedPayment(soap, "ns2:encryptedPayment", &a->ns2__ReplyMessage::encryptedPayment, "ns2:EncryptedPayment"))
				{	soap_flag_encryptedPayment1--;
					continue;
				}
			if (soap_flag_encryptPaymentDataReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EncryptPaymentDataReply(soap, "ns2:encryptPaymentDataReply", &a->ns2__ReplyMessage::encryptPaymentDataReply, "ns2:EncryptPaymentDataReply"))
				{	soap_flag_encryptPaymentDataReply1--;
					continue;
				}
			if (soap_flag_dmeReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DMEReply(soap, "ns2:dmeReply", &a->ns2__ReplyMessage::dmeReply, "ns2:DMEReply"))
				{	soap_flag_dmeReply1--;
					continue;
				}
			if (soap_flag_afsReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AFSReply(soap, "ns2:afsReply", &a->ns2__ReplyMessage::afsReply, "ns2:AFSReply"))
				{	soap_flag_afsReply1--;
					continue;
				}
			if (soap_flag_davReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DAVReply(soap, "ns2:davReply", &a->ns2__ReplyMessage::davReply, "ns2:DAVReply"))
				{	soap_flag_davReply1--;
					continue;
				}
			if (soap_flag_exportReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExportReply(soap, "ns2:exportReply", &a->ns2__ReplyMessage::exportReply, "ns2:ExportReply"))
				{	soap_flag_exportReply1--;
					continue;
				}
			if (soap_flag_fxRatesReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FXRatesReply(soap, "ns2:fxRatesReply", &a->ns2__ReplyMessage::fxRatesReply, "ns2:FXRatesReply"))
				{	soap_flag_fxRatesReply1--;
					continue;
				}
			if (soap_flag_bankTransferReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BankTransferReply(soap, "ns2:bankTransferReply", &a->ns2__ReplyMessage::bankTransferReply, "ns2:BankTransferReply"))
				{	soap_flag_bankTransferReply1--;
					continue;
				}
			if (soap_flag_bankTransferRefundReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BankTransferRefundReply(soap, "ns2:bankTransferRefundReply", &a->ns2__ReplyMessage::bankTransferRefundReply, "ns2:BankTransferRefundReply"))
				{	soap_flag_bankTransferRefundReply1--;
					continue;
				}
			if (soap_flag_bankTransferRealTimeReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BankTransferRealTimeReply(soap, "ns2:bankTransferRealTimeReply", &a->ns2__ReplyMessage::bankTransferRealTimeReply, "ns2:BankTransferRealTimeReply"))
				{	soap_flag_bankTransferRealTimeReply1--;
					continue;
				}
			if (soap_flag_directDebitMandateReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DirectDebitMandateReply(soap, "ns2:directDebitMandateReply", &a->ns2__ReplyMessage::directDebitMandateReply, "ns2:DirectDebitMandateReply"))
				{	soap_flag_directDebitMandateReply1--;
					continue;
				}
			if (soap_flag_directDebitReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DirectDebitReply(soap, "ns2:directDebitReply", &a->ns2__ReplyMessage::directDebitReply, "ns2:DirectDebitReply"))
				{	soap_flag_directDebitReply1--;
					continue;
				}
			if (soap_flag_directDebitValidateReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DirectDebitValidateReply(soap, "ns2:directDebitValidateReply", &a->ns2__ReplyMessage::directDebitValidateReply, "ns2:DirectDebitValidateReply"))
				{	soap_flag_directDebitValidateReply1--;
					continue;
				}
			if (soap_flag_directDebitRefundReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DirectDebitRefundReply(soap, "ns2:directDebitRefundReply", &a->ns2__ReplyMessage::directDebitRefundReply, "ns2:DirectDebitRefundReply"))
				{	soap_flag_directDebitRefundReply1--;
					continue;
				}
			if (soap_flag_paySubscriptionCreateReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PaySubscriptionCreateReply(soap, "ns2:paySubscriptionCreateReply", &a->ns2__ReplyMessage::paySubscriptionCreateReply, "ns2:PaySubscriptionCreateReply"))
				{	soap_flag_paySubscriptionCreateReply1--;
					continue;
				}
			if (soap_flag_paySubscriptionUpdateReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PaySubscriptionUpdateReply(soap, "ns2:paySubscriptionUpdateReply", &a->ns2__ReplyMessage::paySubscriptionUpdateReply, "ns2:PaySubscriptionUpdateReply"))
				{	soap_flag_paySubscriptionUpdateReply1--;
					continue;
				}
			if (soap_flag_paySubscriptionEventUpdateReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PaySubscriptionEventUpdateReply(soap, "ns2:paySubscriptionEventUpdateReply", &a->ns2__ReplyMessage::paySubscriptionEventUpdateReply, "ns2:PaySubscriptionEventUpdateReply"))
				{	soap_flag_paySubscriptionEventUpdateReply1--;
					continue;
				}
			if (soap_flag_paySubscriptionRetrieveReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PaySubscriptionRetrieveReply(soap, "ns2:paySubscriptionRetrieveReply", &a->ns2__ReplyMessage::paySubscriptionRetrieveReply, "ns2:PaySubscriptionRetrieveReply"))
				{	soap_flag_paySubscriptionRetrieveReply1--;
					continue;
				}
			if (soap_flag_paySubscriptionDeleteReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PaySubscriptionDeleteReply(soap, "ns2:paySubscriptionDeleteReply", &a->ns2__ReplyMessage::paySubscriptionDeleteReply, "ns2:PaySubscriptionDeleteReply"))
				{	soap_flag_paySubscriptionDeleteReply1--;
					continue;
				}
			if (soap_flag_payPalPaymentReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalPaymentReply(soap, "ns2:payPalPaymentReply", &a->ns2__ReplyMessage::payPalPaymentReply, "ns2:PayPalPaymentReply"))
				{	soap_flag_payPalPaymentReply1--;
					continue;
				}
			if (soap_flag_payPalCreditReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalCreditReply(soap, "ns2:payPalCreditReply", &a->ns2__ReplyMessage::payPalCreditReply, "ns2:PayPalCreditReply"))
				{	soap_flag_payPalCreditReply1--;
					continue;
				}
			if (soap_flag_voidReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VoidReply(soap, "ns2:voidReply", &a->ns2__ReplyMessage::voidReply, "ns2:VoidReply"))
				{	soap_flag_voidReply1--;
					continue;
				}
			if (soap_flag_pinlessDebitReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PinlessDebitReply(soap, "ns2:pinlessDebitReply", &a->ns2__ReplyMessage::pinlessDebitReply, "ns2:PinlessDebitReply"))
				{	soap_flag_pinlessDebitReply1--;
					continue;
				}
			if (soap_flag_pinlessDebitValidateReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PinlessDebitValidateReply(soap, "ns2:pinlessDebitValidateReply", &a->ns2__ReplyMessage::pinlessDebitValidateReply, "ns2:PinlessDebitValidateReply"))
				{	soap_flag_pinlessDebitValidateReply1--;
					continue;
				}
			if (soap_flag_pinlessDebitReversalReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PinlessDebitReversalReply(soap, "ns2:pinlessDebitReversalReply", &a->ns2__ReplyMessage::pinlessDebitReversalReply, "ns2:PinlessDebitReversalReply"))
				{	soap_flag_pinlessDebitReversalReply1--;
					continue;
				}
			if (soap_flag_payPalButtonCreateReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalButtonCreateReply(soap, "ns2:payPalButtonCreateReply", &a->ns2__ReplyMessage::payPalButtonCreateReply, "ns2:PayPalButtonCreateReply"))
				{	soap_flag_payPalButtonCreateReply1--;
					continue;
				}
			if (soap_flag_payPalPreapprovedPaymentReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalPreapprovedPaymentReply(soap, "ns2:payPalPreapprovedPaymentReply", &a->ns2__ReplyMessage::payPalPreapprovedPaymentReply, "ns2:PayPalPreapprovedPaymentReply"))
				{	soap_flag_payPalPreapprovedPaymentReply1--;
					continue;
				}
			if (soap_flag_payPalPreapprovedUpdateReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalPreapprovedUpdateReply(soap, "ns2:payPalPreapprovedUpdateReply", &a->ns2__ReplyMessage::payPalPreapprovedUpdateReply, "ns2:PayPalPreapprovedUpdateReply"))
				{	soap_flag_payPalPreapprovedUpdateReply1--;
					continue;
				}
			if (soap_flag_riskUpdateReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RiskUpdateReply(soap, "ns2:riskUpdateReply", &a->ns2__ReplyMessage::riskUpdateReply, "ns2:RiskUpdateReply"))
				{	soap_flag_riskUpdateReply1--;
					continue;
				}
			if (soap_flag_fraudUpdateReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FraudUpdateReply(soap, "ns2:fraudUpdateReply", &a->ns2__ReplyMessage::fraudUpdateReply, "ns2:FraudUpdateReply"))
				{	soap_flag_fraudUpdateReply1--;
					continue;
				}
			if (soap_flag_caseManagementActionReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CaseManagementActionReply(soap, "ns2:caseManagementActionReply", &a->ns2__ReplyMessage::caseManagementActionReply, "ns2:CaseManagementActionReply"))
				{	soap_flag_caseManagementActionReply1--;
					continue;
				}
			if (soap_flag_decisionReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DecisionReply(soap, "ns2:decisionReply", &a->ns2__ReplyMessage::decisionReply, "ns2:DecisionReply"))
				{	soap_flag_decisionReply1--;
					continue;
				}
			if (soap_flag_payPalRefundReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalRefundReply(soap, "ns2:payPalRefundReply", &a->ns2__ReplyMessage::payPalRefundReply, "ns2:PayPalRefundReply"))
				{	soap_flag_payPalRefundReply1--;
					continue;
				}
			if (soap_flag_payPalAuthReversalReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalAuthReversalReply(soap, "ns2:payPalAuthReversalReply", &a->ns2__ReplyMessage::payPalAuthReversalReply, "ns2:PayPalAuthReversalReply"))
				{	soap_flag_payPalAuthReversalReply1--;
					continue;
				}
			if (soap_flag_payPalDoCaptureReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalDoCaptureReply(soap, "ns2:payPalDoCaptureReply", &a->ns2__ReplyMessage::payPalDoCaptureReply, "ns2:PayPalDoCaptureReply"))
				{	soap_flag_payPalDoCaptureReply1--;
					continue;
				}
			if (soap_flag_payPalEcDoPaymentReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalEcDoPaymentReply(soap, "ns2:payPalEcDoPaymentReply", &a->ns2__ReplyMessage::payPalEcDoPaymentReply, "ns2:PayPalEcDoPaymentReply"))
				{	soap_flag_payPalEcDoPaymentReply1--;
					continue;
				}
			if (soap_flag_payPalEcGetDetailsReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalEcGetDetailsReply(soap, "ns2:payPalEcGetDetailsReply", &a->ns2__ReplyMessage::payPalEcGetDetailsReply, "ns2:PayPalEcGetDetailsReply"))
				{	soap_flag_payPalEcGetDetailsReply1--;
					continue;
				}
			if (soap_flag_payPalEcSetReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalEcSetReply(soap, "ns2:payPalEcSetReply", &a->ns2__ReplyMessage::payPalEcSetReply, "ns2:PayPalEcSetReply"))
				{	soap_flag_payPalEcSetReply1--;
					continue;
				}
			if (soap_flag_payPalAuthorizationReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalAuthorizationReply(soap, "ns2:payPalAuthorizationReply", &a->ns2__ReplyMessage::payPalAuthorizationReply, "ns2:PayPalAuthorizationReply"))
				{	soap_flag_payPalAuthorizationReply1--;
					continue;
				}
			if (soap_flag_payPalEcOrderSetupReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalEcOrderSetupReply(soap, "ns2:payPalEcOrderSetupReply", &a->ns2__ReplyMessage::payPalEcOrderSetupReply, "ns2:PayPalEcOrderSetupReply"))
				{	soap_flag_payPalEcOrderSetupReply1--;
					continue;
				}
			if (soap_flag_payPalUpdateAgreementReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalUpdateAgreementReply(soap, "ns2:payPalUpdateAgreementReply", &a->ns2__ReplyMessage::payPalUpdateAgreementReply, "ns2:PayPalUpdateAgreementReply"))
				{	soap_flag_payPalUpdateAgreementReply1--;
					continue;
				}
			if (soap_flag_payPalCreateAgreementReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalCreateAgreementReply(soap, "ns2:payPalCreateAgreementReply", &a->ns2__ReplyMessage::payPalCreateAgreementReply, "ns2:PayPalCreateAgreementReply"))
				{	soap_flag_payPalCreateAgreementReply1--;
					continue;
				}
			if (soap_flag_payPalDoRefTransactionReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalDoRefTransactionReply(soap, "ns2:payPalDoRefTransactionReply", &a->ns2__ReplyMessage::payPalDoRefTransactionReply, "ns2:PayPalDoRefTransactionReply"))
				{	soap_flag_payPalDoRefTransactionReply1--;
					continue;
				}
			if (soap_flag_chinaPaymentReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ChinaPaymentReply(soap, "ns2:chinaPaymentReply", &a->ns2__ReplyMessage::chinaPaymentReply, "ns2:ChinaPaymentReply"))
				{	soap_flag_chinaPaymentReply1--;
					continue;
				}
			if (soap_flag_chinaRefundReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ChinaRefundReply(soap, "ns2:chinaRefundReply", &a->ns2__ReplyMessage::chinaRefundReply, "ns2:ChinaRefundReply"))
				{	soap_flag_chinaRefundReply1--;
					continue;
				}
			if (soap_flag_boletoPaymentReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BoletoPaymentReply(soap, "ns2:boletoPaymentReply", &a->ns2__ReplyMessage::boletoPaymentReply, "ns2:BoletoPaymentReply"))
				{	soap_flag_boletoPaymentReply1--;
					continue;
				}
			if (soap_flag_pinDebitPurchaseReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PinDebitPurchaseReply(soap, "ns2:pinDebitPurchaseReply", &a->ns2__ReplyMessage::pinDebitPurchaseReply, "ns2:PinDebitPurchaseReply"))
				{	soap_flag_pinDebitPurchaseReply1--;
					continue;
				}
			if (soap_flag_pinDebitCreditReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PinDebitCreditReply(soap, "ns2:pinDebitCreditReply", &a->ns2__ReplyMessage::pinDebitCreditReply, "ns2:PinDebitCreditReply"))
				{	soap_flag_pinDebitCreditReply1--;
					continue;
				}
			if (soap_flag_pinDebitReversalReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PinDebitReversalReply(soap, "ns2:pinDebitReversalReply", &a->ns2__ReplyMessage::pinDebitReversalReply, "ns2:PinDebitReversalReply"))
				{	soap_flag_pinDebitReversalReply1--;
					continue;
				}
			if (soap_flag_apInitiateReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APInitiateReply(soap, "ns2:apInitiateReply", &a->ns2__ReplyMessage::apInitiateReply, "ns2:APInitiateReply"))
				{	soap_flag_apInitiateReply1--;
					continue;
				}
			if (soap_flag_apCheckStatusReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APCheckStatusReply(soap, "ns2:apCheckStatusReply", &a->ns2__ReplyMessage::apCheckStatusReply, "ns2:APCheckStatusReply"))
				{	soap_flag_apCheckStatusReply1--;
					continue;
				}
			if (soap_flag_receiptNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:receiptNumber", (wchar_t**)&a->ns2__ReplyMessage::receiptNumber, "xsd:string"))
				{	soap_flag_receiptNumber1--;
					continue;
				}
			if (soap_flag_additionalData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:additionalData", (wchar_t**)&a->ns2__ReplyMessage::additionalData, "xsd:string"))
				{	soap_flag_additionalData1--;
					continue;
				}
			if (soap_flag_solutionProviderTransactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:solutionProviderTransactionID", (wchar_t**)&a->ns2__ReplyMessage::solutionProviderTransactionID, "xsd:string"))
				{	soap_flag_solutionProviderTransactionID1--;
					continue;
				}
			if (soap_flag_apReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APReply(soap, "ns2:apReply", &a->ns2__ReplyMessage::apReply, "ns2:APReply"))
				{	soap_flag_apReply1--;
					continue;
				}
			if (soap_flag_shipTo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ShipTo(soap, "ns2:shipTo", &a->ns2__ReplyMessage::shipTo, "ns2:ShipTo"))
				{	soap_flag_shipTo1--;
					continue;
				}
			if (soap_flag_billTo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BillTo(soap, "ns2:billTo", &a->ns2__ReplyMessage::billTo, "ns2:BillTo"))
				{	soap_flag_billTo1--;
					continue;
				}
			if (soap_flag_apAuthReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APAuthReply(soap, "ns2:apAuthReply", &a->ns2__ReplyMessage::apAuthReply, "ns2:APAuthReply"))
				{	soap_flag_apAuthReply1--;
					continue;
				}
			if (soap_flag_apAuthReversalReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APAuthReversalReply(soap, "ns2:apAuthReversalReply", &a->ns2__ReplyMessage::apAuthReversalReply, "ns2:APAuthReversalReply"))
				{	soap_flag_apAuthReversalReply1--;
					continue;
				}
			if (soap_flag_apCaptureReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APCaptureReply(soap, "ns2:apCaptureReply", &a->ns2__ReplyMessage::apCaptureReply, "ns2:APCaptureReply"))
				{	soap_flag_apCaptureReply1--;
					continue;
				}
			if (soap_flag_apOptionsReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APOptionsReply(soap, "ns2:apOptionsReply", &a->ns2__ReplyMessage::apOptionsReply, "ns2:APOptionsReply"))
				{	soap_flag_apOptionsReply1--;
					continue;
				}
			if (soap_flag_apRefundReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APRefundReply(soap, "ns2:apRefundReply", &a->ns2__ReplyMessage::apRefundReply, "ns2:APRefundReply"))
				{	soap_flag_apRefundReply1--;
					continue;
				}
			if (soap_flag_apSaleReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APSaleReply(soap, "ns2:apSaleReply", &a->ns2__ReplyMessage::apSaleReply, "ns2:APSaleReply"))
				{	soap_flag_apSaleReply1--;
					continue;
				}
			if (soap_flag_apCheckoutDetailsReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APCheckOutDetailsReply(soap, "ns2:apCheckoutDetailsReply", &a->ns2__ReplyMessage::apCheckoutDetailsReply, "ns2:APCheckOutDetailsReply"))
				{	soap_flag_apCheckoutDetailsReply1--;
					continue;
				}
			if (soap_flag_apTransactionDetailsReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APTransactionDetailsReply(soap, "ns2:apTransactionDetailsReply", &a->ns2__ReplyMessage::apTransactionDetailsReply, "ns2:APTransactionDetailsReply"))
				{	soap_flag_apTransactionDetailsReply1--;
					continue;
				}
			if (soap_flag_apConfirmPurchaseReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APConfirmPurchaseReply(soap, "ns2:apConfirmPurchaseReply", &a->ns2__ReplyMessage::apConfirmPurchaseReply, "ns2:APConfirmPurchaseReply"))
				{	soap_flag_apConfirmPurchaseReply1--;
					continue;
				}
			if (soap_flag_promotion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Promotion(soap, "ns2:promotion", &a->ns2__ReplyMessage::promotion, "ns2:Promotion"))
				{	soap_flag_promotion1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__PromotionGroupReply(soap, "ns2:promotionGroup", &a->ns2__ReplyMessage::promotionGroup, "ns2:PromotionGroupReply"))
					continue;
			if (soap_flag_payPalGetTxnDetailsReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalGetTxnDetailsReply(soap, "ns2:payPalGetTxnDetailsReply", &a->ns2__ReplyMessage::payPalGetTxnDetailsReply, "ns2:PayPalGetTxnDetailsReply"))
				{	soap_flag_payPalGetTxnDetailsReply1--;
					continue;
				}
			if (soap_flag_payPalTransactionSearchReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalTransactionSearchReply(soap, "ns2:payPalTransactionSearchReply", &a->ns2__ReplyMessage::payPalTransactionSearchReply, "ns2:PayPalTransactionSearchReply"))
				{	soap_flag_payPalTransactionSearchReply1--;
					continue;
				}
			if (soap_flag_emvReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EmvReply(soap, "ns2:emvReply", &a->ns2__ReplyMessage::emvReply, "ns2:EmvReply"))
				{	soap_flag_emvReply1--;
					continue;
				}
			if (soap_flag_originalTransaction1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__OriginalTransaction(soap, "ns2:originalTransaction", &a->ns2__ReplyMessage::originalTransaction, "ns2:OriginalTransaction"))
				{	soap_flag_originalTransaction1--;
					continue;
				}
			if (soap_flag_hostedDataCreateReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__HostedDataCreateReply(soap, "ns2:hostedDataCreateReply", &a->ns2__ReplyMessage::hostedDataCreateReply, "ns2:HostedDataCreateReply"))
				{	soap_flag_hostedDataCreateReply1--;
					continue;
				}
			if (soap_flag_hostedDataRetrieveReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__HostedDataRetrieveReply(soap, "ns2:hostedDataRetrieveReply", &a->ns2__ReplyMessage::hostedDataRetrieveReply, "ns2:HostedDataRetrieveReply"))
				{	soap_flag_hostedDataRetrieveReply1--;
					continue;
				}
			if (soap_flag_salesSlipNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:salesSlipNumber", (wchar_t**)&a->ns2__ReplyMessage::salesSlipNumber, "xsd:string"))
				{	soap_flag_salesSlipNumber1--;
					continue;
				}
			if (soap_flag_additionalProcessorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:additionalProcessorResponse", (wchar_t**)&a->ns2__ReplyMessage::additionalProcessorResponse, "xsd:string"))
				{	soap_flag_additionalProcessorResponse1--;
					continue;
				}
			if (soap_flag_jpo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__JPO(soap, "ns2:jpo", &a->ns2__ReplyMessage::jpo, "ns2:JPO"))
				{	soap_flag_jpo1--;
					continue;
				}
			if (soap_flag_card1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Card(soap, "ns2:card", &a->ns2__ReplyMessage::card, "ns2:Card"))
				{	soap_flag_card1--;
					continue;
				}
			if (soap_flag_paymentNetworkToken1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PaymentNetworkToken(soap, "ns2:paymentNetworkToken", &a->ns2__ReplyMessage::paymentNetworkToken, "ns2:PaymentNetworkToken"))
				{	soap_flag_paymentNetworkToken1--;
					continue;
				}
			if (soap_flag_vcReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VCReply(soap, "ns2:vcReply", &a->ns2__ReplyMessage::vcReply, "ns2:VCReply"))
				{	soap_flag_vcReply1--;
					continue;
				}
			if (soap_flag_decryptVisaCheckoutDataReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DecryptVisaCheckoutDataReply(soap, "ns2:decryptVisaCheckoutDataReply", &a->ns2__ReplyMessage::decryptVisaCheckoutDataReply, "ns2:DecryptVisaCheckoutDataReply"))
				{	soap_flag_decryptVisaCheckoutDataReply1--;
					continue;
				}
			if (soap_flag_binLookupReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BinLookupReply(soap, "ns2:binLookupReply", &a->ns2__ReplyMessage::binLookupReply, "ns2:BinLookupReply"))
				{	soap_flag_binLookupReply1--;
					continue;
				}
			if (soap_flag_issuerMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:issuerMessage", (wchar_t**)&a->ns2__ReplyMessage::issuerMessage, "xsd:string"))
				{	soap_flag_issuerMessage1--;
					continue;
				}
			if (soap_flag_token1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Token(soap, "ns2:token", &a->ns2__ReplyMessage::token, "ns2:Token"))
				{	soap_flag_token1--;
					continue;
				}
			if (soap_flag_issuer1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__issuer(soap, "ns2:issuer", &a->ns2__ReplyMessage::issuer, "ns2:issuer"))
				{	soap_flag_issuer1--;
					continue;
				}
			if (soap_flag_recipient1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Recipient(soap, "ns2:recipient", &a->ns2__ReplyMessage::recipient, "ns2:Recipient"))
				{	soap_flag_recipient1--;
					continue;
				}
			if (soap_flag_reserved1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ReplyReserved(soap, "ns2:reserved", &a->ns2__ReplyMessage::reserved, "ns2:ReplyReserved"))
				{	soap_flag_reserved1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestID1 > 0 || soap_flag_decision1 > 0 || soap_flag_reasonCode1 > 0 || a->ns2__ReplyMessage::missingField.size() > 1000 || a->ns2__ReplyMessage::invalidField.size() > 1000 || soap_flag_requestToken1 > 0 || a->ns2__ReplyMessage::deniedPartiesMatch.size() > 100 || a->ns2__ReplyMessage::promotionGroup.size() > 100))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__ReplyMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ReplyMessage, SOAP_TYPE_ns2__ReplyMessage, sizeof(ns2__ReplyMessage), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ReplyMessage * SOAP_FMAC2 soap_instantiate_ns2__ReplyMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ReplyMessage(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ReplyMessage *p;
	size_t k = sizeof(ns2__ReplyMessage);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ReplyMessage);
		if (p)
			((ns2__ReplyMessage*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ReplyMessage, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ReplyMessage*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ReplyMessage location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ReplyMessage, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ReplyMessage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:ReplyMessage", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ReplyMessage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ReplyMessage(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ReplyMessage * SOAP_FMAC4 soap_get_ns2__ReplyMessage(struct soap *soap, ns2__ReplyMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ReplyMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APConfirmPurchaseReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APConfirmPurchaseReply::reasonCode = NULL;
	this->ns2__APConfirmPurchaseReply::status = NULL;
	this->ns2__APConfirmPurchaseReply::processorResponse = NULL;
	this->ns2__APConfirmPurchaseReply::amount = NULL;
	this->ns2__APConfirmPurchaseReply::dateTime = NULL;
	this->ns2__APConfirmPurchaseReply::providerResponse = NULL;
	/* transient soap skipped */
}

void ns2__APConfirmPurchaseReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__APConfirmPurchaseReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APConfirmPurchaseReply::status);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APConfirmPurchaseReply::processorResponse);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__APConfirmPurchaseReply::amount);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__APConfirmPurchaseReply::dateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APConfirmPurchaseReply::providerResponse);
#endif
}

int ns2__APConfirmPurchaseReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APConfirmPurchaseReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APConfirmPurchaseReply(struct soap *soap, const char *tag, int id, const ns2__APConfirmPurchaseReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APConfirmPurchaseReply), type))
		return soap->error;
	if (!a->ns2__APConfirmPurchaseReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__APConfirmPurchaseReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:status", -1, (wchar_t*const*)&a->ns2__APConfirmPurchaseReply::status, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__APConfirmPurchaseReply::processorResponse, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__APConfirmPurchaseReply::amount, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:dateTime", -1, &a->ns2__APConfirmPurchaseReply::dateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:providerResponse", -1, (wchar_t*const*)&a->ns2__APConfirmPurchaseReply::providerResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APConfirmPurchaseReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APConfirmPurchaseReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APConfirmPurchaseReply * SOAP_FMAC4 soap_in_ns2__APConfirmPurchaseReply(struct soap *soap, const char *tag, ns2__APConfirmPurchaseReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APConfirmPurchaseReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APConfirmPurchaseReply, sizeof(ns2__APConfirmPurchaseReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APConfirmPurchaseReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APConfirmPurchaseReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_dateTime1 = 1;
	size_t soap_flag_providerResponse1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__APConfirmPurchaseReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:status", (wchar_t**)&a->ns2__APConfirmPurchaseReply::status, "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__APConfirmPurchaseReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__APConfirmPurchaseReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_dateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:dateTime", &a->ns2__APConfirmPurchaseReply::dateTime, "ns2:dateTime"))
				{	soap_flag_dateTime1--;
					continue;
				}
			if (soap_flag_providerResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:providerResponse", (wchar_t**)&a->ns2__APConfirmPurchaseReply::providerResponse, "xsd:string"))
				{	soap_flag_providerResponse1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__APConfirmPurchaseReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APConfirmPurchaseReply, SOAP_TYPE_ns2__APConfirmPurchaseReply, sizeof(ns2__APConfirmPurchaseReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APConfirmPurchaseReply * SOAP_FMAC2 soap_instantiate_ns2__APConfirmPurchaseReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APConfirmPurchaseReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APConfirmPurchaseReply *p;
	size_t k = sizeof(ns2__APConfirmPurchaseReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APConfirmPurchaseReply);
		if (p)
			((ns2__APConfirmPurchaseReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APConfirmPurchaseReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APConfirmPurchaseReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APConfirmPurchaseReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APConfirmPurchaseReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APConfirmPurchaseReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APConfirmPurchaseReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APConfirmPurchaseReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APConfirmPurchaseReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APConfirmPurchaseReply * SOAP_FMAC4 soap_get_ns2__APConfirmPurchaseReply(struct soap *soap, ns2__APConfirmPurchaseReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APConfirmPurchaseReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APTransactionDetailsReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APTransactionDetailsReply::reasonCode = NULL;
	this->ns2__APTransactionDetailsReply::transactionID = NULL;
	this->ns2__APTransactionDetailsReply::status = NULL;
	this->ns2__APTransactionDetailsReply::processorResponse = NULL;
	this->ns2__APTransactionDetailsReply::dateTime = NULL;
	this->ns2__APTransactionDetailsReply::reconciliationID = NULL;
	this->ns2__APTransactionDetailsReply::providerResponse = NULL;
	/* transient soap skipped */
}

void ns2__APTransactionDetailsReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__APTransactionDetailsReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APTransactionDetailsReply::transactionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APTransactionDetailsReply::status);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APTransactionDetailsReply::processorResponse);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__APTransactionDetailsReply::dateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APTransactionDetailsReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APTransactionDetailsReply::providerResponse);
#endif
}

int ns2__APTransactionDetailsReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APTransactionDetailsReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APTransactionDetailsReply(struct soap *soap, const char *tag, int id, const ns2__APTransactionDetailsReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APTransactionDetailsReply), type))
		return soap->error;
	if (!a->ns2__APTransactionDetailsReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__APTransactionDetailsReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionID", -1, (wchar_t*const*)&a->ns2__APTransactionDetailsReply::transactionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:status", -1, (wchar_t*const*)&a->ns2__APTransactionDetailsReply::status, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__APTransactionDetailsReply::processorResponse, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:dateTime", -1, &a->ns2__APTransactionDetailsReply::dateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__APTransactionDetailsReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:providerResponse", -1, (wchar_t*const*)&a->ns2__APTransactionDetailsReply::providerResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APTransactionDetailsReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APTransactionDetailsReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APTransactionDetailsReply * SOAP_FMAC4 soap_in_ns2__APTransactionDetailsReply(struct soap *soap, const char *tag, ns2__APTransactionDetailsReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APTransactionDetailsReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APTransactionDetailsReply, sizeof(ns2__APTransactionDetailsReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APTransactionDetailsReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APTransactionDetailsReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_transactionID1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_dateTime1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_providerResponse1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__APTransactionDetailsReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_transactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionID", (wchar_t**)&a->ns2__APTransactionDetailsReply::transactionID, "xsd:string"))
				{	soap_flag_transactionID1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:status", (wchar_t**)&a->ns2__APTransactionDetailsReply::status, "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__APTransactionDetailsReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_dateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:dateTime", &a->ns2__APTransactionDetailsReply::dateTime, "ns2:dateTime"))
				{	soap_flag_dateTime1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__APTransactionDetailsReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_providerResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:providerResponse", (wchar_t**)&a->ns2__APTransactionDetailsReply::providerResponse, "xsd:string"))
				{	soap_flag_providerResponse1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__APTransactionDetailsReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APTransactionDetailsReply, SOAP_TYPE_ns2__APTransactionDetailsReply, sizeof(ns2__APTransactionDetailsReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APTransactionDetailsReply * SOAP_FMAC2 soap_instantiate_ns2__APTransactionDetailsReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APTransactionDetailsReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APTransactionDetailsReply *p;
	size_t k = sizeof(ns2__APTransactionDetailsReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APTransactionDetailsReply);
		if (p)
			((ns2__APTransactionDetailsReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APTransactionDetailsReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APTransactionDetailsReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APTransactionDetailsReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APTransactionDetailsReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APTransactionDetailsReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APTransactionDetailsReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APTransactionDetailsReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APTransactionDetailsReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APTransactionDetailsReply * SOAP_FMAC4 soap_get_ns2__APTransactionDetailsReply(struct soap *soap, ns2__APTransactionDetailsReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APTransactionDetailsReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APCheckOutDetailsReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APCheckOutDetailsReply::reasonCode = NULL;
	this->ns2__APCheckOutDetailsReply::status = NULL;
	this->ns2__APCheckOutDetailsReply::processorResponse = NULL;
	this->ns2__APCheckOutDetailsReply::dateTime = NULL;
	this->ns2__APCheckOutDetailsReply::providerResponse = NULL;
	/* transient soap skipped */
}

void ns2__APCheckOutDetailsReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__APCheckOutDetailsReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APCheckOutDetailsReply::status);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APCheckOutDetailsReply::processorResponse);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__APCheckOutDetailsReply::dateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APCheckOutDetailsReply::providerResponse);
#endif
}

int ns2__APCheckOutDetailsReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APCheckOutDetailsReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APCheckOutDetailsReply(struct soap *soap, const char *tag, int id, const ns2__APCheckOutDetailsReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APCheckOutDetailsReply), type))
		return soap->error;
	if (!a->ns2__APCheckOutDetailsReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__APCheckOutDetailsReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:status", -1, (wchar_t*const*)&a->ns2__APCheckOutDetailsReply::status, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__APCheckOutDetailsReply::processorResponse, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:dateTime", -1, &a->ns2__APCheckOutDetailsReply::dateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:providerResponse", -1, (wchar_t*const*)&a->ns2__APCheckOutDetailsReply::providerResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APCheckOutDetailsReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APCheckOutDetailsReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APCheckOutDetailsReply * SOAP_FMAC4 soap_in_ns2__APCheckOutDetailsReply(struct soap *soap, const char *tag, ns2__APCheckOutDetailsReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APCheckOutDetailsReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APCheckOutDetailsReply, sizeof(ns2__APCheckOutDetailsReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APCheckOutDetailsReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APCheckOutDetailsReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_dateTime1 = 1;
	size_t soap_flag_providerResponse1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__APCheckOutDetailsReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:status", (wchar_t**)&a->ns2__APCheckOutDetailsReply::status, "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__APCheckOutDetailsReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_dateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:dateTime", &a->ns2__APCheckOutDetailsReply::dateTime, "ns2:dateTime"))
				{	soap_flag_dateTime1--;
					continue;
				}
			if (soap_flag_providerResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:providerResponse", (wchar_t**)&a->ns2__APCheckOutDetailsReply::providerResponse, "xsd:string"))
				{	soap_flag_providerResponse1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__APCheckOutDetailsReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APCheckOutDetailsReply, SOAP_TYPE_ns2__APCheckOutDetailsReply, sizeof(ns2__APCheckOutDetailsReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APCheckOutDetailsReply * SOAP_FMAC2 soap_instantiate_ns2__APCheckOutDetailsReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APCheckOutDetailsReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APCheckOutDetailsReply *p;
	size_t k = sizeof(ns2__APCheckOutDetailsReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APCheckOutDetailsReply);
		if (p)
			((ns2__APCheckOutDetailsReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APCheckOutDetailsReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APCheckOutDetailsReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APCheckOutDetailsReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APCheckOutDetailsReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APCheckOutDetailsReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APCheckOutDetailsReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APCheckOutDetailsReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APCheckOutDetailsReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APCheckOutDetailsReply * SOAP_FMAC4 soap_get_ns2__APCheckOutDetailsReply(struct soap *soap, ns2__APCheckOutDetailsReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APCheckOutDetailsReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APSaleReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APSaleReply::reasonCode = NULL;
	this->ns2__APSaleReply::paymentStatus = NULL;
	this->ns2__APSaleReply::responseCode = NULL;
	this->ns2__APSaleReply::merchantURL = NULL;
	this->ns2__APSaleReply::processorTransactionID = NULL;
	this->ns2__APSaleReply::reconciliationID = NULL;
	/* transient soap skipped */
}

void ns2__APSaleReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__APSaleReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APSaleReply::paymentStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APSaleReply::responseCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APSaleReply::merchantURL);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APSaleReply::processorTransactionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APSaleReply::reconciliationID);
#endif
}

int ns2__APSaleReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APSaleReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APSaleReply(struct soap *soap, const char *tag, int id, const ns2__APSaleReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APSaleReply), type))
		return soap->error;
	if (!a->ns2__APSaleReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__APSaleReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentStatus", -1, (wchar_t*const*)&a->ns2__APSaleReply::paymentStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:responseCode", -1, (wchar_t*const*)&a->ns2__APSaleReply::responseCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantURL", -1, (wchar_t*const*)&a->ns2__APSaleReply::merchantURL, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorTransactionID", -1, (wchar_t*const*)&a->ns2__APSaleReply::processorTransactionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__APSaleReply::reconciliationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APSaleReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APSaleReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APSaleReply * SOAP_FMAC4 soap_in_ns2__APSaleReply(struct soap *soap, const char *tag, ns2__APSaleReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APSaleReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APSaleReply, sizeof(ns2__APSaleReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APSaleReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APSaleReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_paymentStatus1 = 1;
	size_t soap_flag_responseCode1 = 1;
	size_t soap_flag_merchantURL1 = 1;
	size_t soap_flag_processorTransactionID1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__APSaleReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_paymentStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentStatus", (wchar_t**)&a->ns2__APSaleReply::paymentStatus, "xsd:string"))
				{	soap_flag_paymentStatus1--;
					continue;
				}
			if (soap_flag_responseCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:responseCode", (wchar_t**)&a->ns2__APSaleReply::responseCode, "xsd:string"))
				{	soap_flag_responseCode1--;
					continue;
				}
			if (soap_flag_merchantURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantURL", (wchar_t**)&a->ns2__APSaleReply::merchantURL, "xsd:string"))
				{	soap_flag_merchantURL1--;
					continue;
				}
			if (soap_flag_processorTransactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorTransactionID", (wchar_t**)&a->ns2__APSaleReply::processorTransactionID, "xsd:string"))
				{	soap_flag_processorTransactionID1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__APSaleReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__APSaleReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APSaleReply, SOAP_TYPE_ns2__APSaleReply, sizeof(ns2__APSaleReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APSaleReply * SOAP_FMAC2 soap_instantiate_ns2__APSaleReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APSaleReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APSaleReply *p;
	size_t k = sizeof(ns2__APSaleReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APSaleReply);
		if (p)
			((ns2__APSaleReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APSaleReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APSaleReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APSaleReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APSaleReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APSaleReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APSaleReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APSaleReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APSaleReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APSaleReply * SOAP_FMAC4 soap_get_ns2__APSaleReply(struct soap *soap, ns2__APSaleReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APSaleReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APRefundReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APRefundReply::reasonCode = NULL;
	this->ns2__APRefundReply::transactionID = NULL;
	this->ns2__APRefundReply::status = NULL;
	this->ns2__APRefundReply::processorResponse = NULL;
	this->ns2__APRefundReply::amount = NULL;
	this->ns2__APRefundReply::dateTime = NULL;
	this->ns2__APRefundReply::reconciliationID = NULL;
	this->ns2__APRefundReply::returnRef = NULL;
	this->ns2__APRefundReply::providerResponse = NULL;
	this->ns2__APRefundReply::processorTransactionID = NULL;
	this->ns2__APRefundReply::paymentStatus = NULL;
	this->ns2__APRefundReply::responseCode = NULL;
	/* transient soap skipped */
}

void ns2__APRefundReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__APRefundReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APRefundReply::transactionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APRefundReply::status);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APRefundReply::processorResponse);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__APRefundReply::amount);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__APRefundReply::dateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APRefundReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APRefundReply::returnRef);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APRefundReply::providerResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APRefundReply::processorTransactionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APRefundReply::paymentStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APRefundReply::responseCode);
#endif
}

int ns2__APRefundReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APRefundReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APRefundReply(struct soap *soap, const char *tag, int id, const ns2__APRefundReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APRefundReply), type))
		return soap->error;
	if (!a->ns2__APRefundReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__APRefundReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionID", -1, (wchar_t*const*)&a->ns2__APRefundReply::transactionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:status", -1, (wchar_t*const*)&a->ns2__APRefundReply::status, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__APRefundReply::processorResponse, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__APRefundReply::amount, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:dateTime", -1, &a->ns2__APRefundReply::dateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__APRefundReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:returnRef", -1, (wchar_t*const*)&a->ns2__APRefundReply::returnRef, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:providerResponse", -1, (wchar_t*const*)&a->ns2__APRefundReply::providerResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorTransactionID", -1, (wchar_t*const*)&a->ns2__APRefundReply::processorTransactionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentStatus", -1, (wchar_t*const*)&a->ns2__APRefundReply::paymentStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:responseCode", -1, (wchar_t*const*)&a->ns2__APRefundReply::responseCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APRefundReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APRefundReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APRefundReply * SOAP_FMAC4 soap_in_ns2__APRefundReply(struct soap *soap, const char *tag, ns2__APRefundReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APRefundReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APRefundReply, sizeof(ns2__APRefundReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APRefundReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APRefundReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_transactionID1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_dateTime1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_returnRef1 = 1;
	size_t soap_flag_providerResponse1 = 1;
	size_t soap_flag_processorTransactionID1 = 1;
	size_t soap_flag_paymentStatus1 = 1;
	size_t soap_flag_responseCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__APRefundReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_transactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionID", (wchar_t**)&a->ns2__APRefundReply::transactionID, "xsd:string"))
				{	soap_flag_transactionID1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:status", (wchar_t**)&a->ns2__APRefundReply::status, "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__APRefundReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__APRefundReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_dateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:dateTime", &a->ns2__APRefundReply::dateTime, "ns2:dateTime"))
				{	soap_flag_dateTime1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__APRefundReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_returnRef1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:returnRef", (wchar_t**)&a->ns2__APRefundReply::returnRef, "xsd:string"))
				{	soap_flag_returnRef1--;
					continue;
				}
			if (soap_flag_providerResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:providerResponse", (wchar_t**)&a->ns2__APRefundReply::providerResponse, "xsd:string"))
				{	soap_flag_providerResponse1--;
					continue;
				}
			if (soap_flag_processorTransactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorTransactionID", (wchar_t**)&a->ns2__APRefundReply::processorTransactionID, "xsd:string"))
				{	soap_flag_processorTransactionID1--;
					continue;
				}
			if (soap_flag_paymentStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentStatus", (wchar_t**)&a->ns2__APRefundReply::paymentStatus, "xsd:string"))
				{	soap_flag_paymentStatus1--;
					continue;
				}
			if (soap_flag_responseCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:responseCode", (wchar_t**)&a->ns2__APRefundReply::responseCode, "xsd:string"))
				{	soap_flag_responseCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__APRefundReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APRefundReply, SOAP_TYPE_ns2__APRefundReply, sizeof(ns2__APRefundReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APRefundReply * SOAP_FMAC2 soap_instantiate_ns2__APRefundReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APRefundReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APRefundReply *p;
	size_t k = sizeof(ns2__APRefundReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APRefundReply);
		if (p)
			((ns2__APRefundReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APRefundReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APRefundReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APRefundReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APRefundReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APRefundReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APRefundReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APRefundReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APRefundReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APRefundReply * SOAP_FMAC4 soap_get_ns2__APRefundReply(struct soap *soap, ns2__APRefundReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APRefundReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APOptionsOption::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APOptionsOption::id = NULL;
	this->ns2__APOptionsOption::name = NULL;
	this->ns2__APOptionsOption::data = NULL;
	/* transient soap skipped */
}

void ns2__APOptionsOption::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APOptionsOption::id);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APOptionsOption::name);
#endif
}

int ns2__APOptionsOption::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APOptionsOption(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APOptionsOption(struct soap *soap, const char *tag, int id, const ns2__APOptionsOption *a, const char *type)
{
	if (((ns2__APOptionsOption*)a)->data)
		if (*((ns2__APOptionsOption*)a)->data)
			soap_set_attr(soap, "data", soap_xsd__integer2s(soap, *((ns2__APOptionsOption*)a)->data), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APOptionsOption), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:id", -1, (wchar_t*const*)&a->ns2__APOptionsOption::id, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:name", -1, (wchar_t*const*)&a->ns2__APOptionsOption::name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APOptionsOption::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APOptionsOption(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APOptionsOption * SOAP_FMAC4 soap_in_ns2__APOptionsOption(struct soap *soap, const char *tag, ns2__APOptionsOption *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APOptionsOption *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APOptionsOption, sizeof(ns2__APOptionsOption), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APOptionsOption)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APOptionsOption *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "data", 0);
		if (t)
		{
			if (!(((ns2__APOptionsOption*)a)->data = (wchar_t **)soap_malloc(soap, sizeof(wchar_t *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__integer(soap, t, ((ns2__APOptionsOption*)a)->data))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:id", (wchar_t**)&a->ns2__APOptionsOption::id, "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:name", (wchar_t**)&a->ns2__APOptionsOption::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__APOptionsOption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APOptionsOption, SOAP_TYPE_ns2__APOptionsOption, sizeof(ns2__APOptionsOption), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APOptionsOption * SOAP_FMAC2 soap_instantiate_ns2__APOptionsOption(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APOptionsOption(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APOptionsOption *p;
	size_t k = sizeof(ns2__APOptionsOption);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APOptionsOption);
		if (p)
			((ns2__APOptionsOption*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APOptionsOption, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APOptionsOption*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APOptionsOption location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APOptionsOption, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APOptionsOption::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APOptionsOption", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APOptionsOption::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APOptionsOption(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APOptionsOption * SOAP_FMAC4 soap_get_ns2__APOptionsOption(struct soap *soap, ns2__APOptionsOption *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APOptionsOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APOptionsReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APOptionsReply::reasonCode = NULL;
	this->ns2__APOptionsReply::responseCode = NULL;
	this->ns2__APOptionsReply::offset = NULL;
	this->ns2__APOptionsReply::count = NULL;
	this->ns2__APOptionsReply::totalCount = NULL;
	this->ns2__APOptionsReply::option = NULL;
	/* transient soap skipped */
}

void ns2__APOptionsReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__APOptionsReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APOptionsReply::responseCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APOptionsReply::offset);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APOptionsReply::count);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APOptionsReply::totalCount);
	soap_serialize_PointerTons2__APOptionsOption(soap, &this->ns2__APOptionsReply::option);
#endif
}

int ns2__APOptionsReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APOptionsReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APOptionsReply(struct soap *soap, const char *tag, int id, const ns2__APOptionsReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APOptionsReply), type))
		return soap->error;
	if (!a->ns2__APOptionsReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__APOptionsReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:responseCode", -1, (wchar_t*const*)&a->ns2__APOptionsReply::responseCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:offset", -1, (wchar_t*const*)&a->ns2__APOptionsReply::offset, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:count", -1, (wchar_t*const*)&a->ns2__APOptionsReply::count, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:totalCount", -1, (wchar_t*const*)&a->ns2__APOptionsReply::totalCount, ""))
		return soap->error;
	if (soap_out_PointerTons2__APOptionsOption(soap, "ns2:option", -1, &a->ns2__APOptionsReply::option, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APOptionsReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APOptionsReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APOptionsReply * SOAP_FMAC4 soap_in_ns2__APOptionsReply(struct soap *soap, const char *tag, ns2__APOptionsReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APOptionsReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APOptionsReply, sizeof(ns2__APOptionsReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APOptionsReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APOptionsReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_responseCode1 = 1;
	size_t soap_flag_offset1 = 1;
	size_t soap_flag_count1 = 1;
	size_t soap_flag_totalCount1 = 1;
	size_t soap_flag_option1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__APOptionsReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_responseCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:responseCode", (wchar_t**)&a->ns2__APOptionsReply::responseCode, "xsd:string"))
				{	soap_flag_responseCode1--;
					continue;
				}
			if (soap_flag_offset1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:offset", (wchar_t**)&a->ns2__APOptionsReply::offset, "xsd:string"))
				{	soap_flag_offset1--;
					continue;
				}
			if (soap_flag_count1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:count", (wchar_t**)&a->ns2__APOptionsReply::count, "xsd:string"))
				{	soap_flag_count1--;
					continue;
				}
			if (soap_flag_totalCount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:totalCount", (wchar_t**)&a->ns2__APOptionsReply::totalCount, "xsd:string"))
				{	soap_flag_totalCount1--;
					continue;
				}
			if (soap_flag_option1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APOptionsOption(soap, "ns2:option", &a->ns2__APOptionsReply::option, "ns2:APOptionsOption"))
				{	soap_flag_option1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__APOptionsReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APOptionsReply, SOAP_TYPE_ns2__APOptionsReply, sizeof(ns2__APOptionsReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APOptionsReply * SOAP_FMAC2 soap_instantiate_ns2__APOptionsReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APOptionsReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APOptionsReply *p;
	size_t k = sizeof(ns2__APOptionsReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APOptionsReply);
		if (p)
			((ns2__APOptionsReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APOptionsReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APOptionsReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APOptionsReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APOptionsReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APOptionsReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APOptionsReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APOptionsReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APOptionsReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APOptionsReply * SOAP_FMAC4 soap_get_ns2__APOptionsReply(struct soap *soap, ns2__APOptionsReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APOptionsReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APCaptureReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APCaptureReply::reasonCode = NULL;
	this->ns2__APCaptureReply::transactionID = NULL;
	this->ns2__APCaptureReply::status = NULL;
	this->ns2__APCaptureReply::processorResponse = NULL;
	this->ns2__APCaptureReply::amount = NULL;
	this->ns2__APCaptureReply::dateTime = NULL;
	this->ns2__APCaptureReply::reconciliationID = NULL;
	this->ns2__APCaptureReply::providerResponse = NULL;
	this->ns2__APCaptureReply::paymentStatus = NULL;
	this->ns2__APCaptureReply::responseCode = NULL;
	/* transient soap skipped */
}

void ns2__APCaptureReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__APCaptureReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APCaptureReply::transactionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APCaptureReply::status);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APCaptureReply::processorResponse);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__APCaptureReply::amount);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__APCaptureReply::dateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APCaptureReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APCaptureReply::providerResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APCaptureReply::paymentStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APCaptureReply::responseCode);
#endif
}

int ns2__APCaptureReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APCaptureReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APCaptureReply(struct soap *soap, const char *tag, int id, const ns2__APCaptureReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APCaptureReply), type))
		return soap->error;
	if (!a->ns2__APCaptureReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__APCaptureReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionID", -1, (wchar_t*const*)&a->ns2__APCaptureReply::transactionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:status", -1, (wchar_t*const*)&a->ns2__APCaptureReply::status, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__APCaptureReply::processorResponse, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__APCaptureReply::amount, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:dateTime", -1, &a->ns2__APCaptureReply::dateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__APCaptureReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:providerResponse", -1, (wchar_t*const*)&a->ns2__APCaptureReply::providerResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentStatus", -1, (wchar_t*const*)&a->ns2__APCaptureReply::paymentStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:responseCode", -1, (wchar_t*const*)&a->ns2__APCaptureReply::responseCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APCaptureReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APCaptureReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APCaptureReply * SOAP_FMAC4 soap_in_ns2__APCaptureReply(struct soap *soap, const char *tag, ns2__APCaptureReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APCaptureReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APCaptureReply, sizeof(ns2__APCaptureReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APCaptureReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APCaptureReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_transactionID1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_dateTime1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_providerResponse1 = 1;
	size_t soap_flag_paymentStatus1 = 1;
	size_t soap_flag_responseCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__APCaptureReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_transactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionID", (wchar_t**)&a->ns2__APCaptureReply::transactionID, "xsd:string"))
				{	soap_flag_transactionID1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:status", (wchar_t**)&a->ns2__APCaptureReply::status, "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__APCaptureReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__APCaptureReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_dateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:dateTime", &a->ns2__APCaptureReply::dateTime, "ns2:dateTime"))
				{	soap_flag_dateTime1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__APCaptureReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_providerResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:providerResponse", (wchar_t**)&a->ns2__APCaptureReply::providerResponse, "xsd:string"))
				{	soap_flag_providerResponse1--;
					continue;
				}
			if (soap_flag_paymentStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentStatus", (wchar_t**)&a->ns2__APCaptureReply::paymentStatus, "xsd:string"))
				{	soap_flag_paymentStatus1--;
					continue;
				}
			if (soap_flag_responseCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:responseCode", (wchar_t**)&a->ns2__APCaptureReply::responseCode, "xsd:string"))
				{	soap_flag_responseCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__APCaptureReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APCaptureReply, SOAP_TYPE_ns2__APCaptureReply, sizeof(ns2__APCaptureReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APCaptureReply * SOAP_FMAC2 soap_instantiate_ns2__APCaptureReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APCaptureReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APCaptureReply *p;
	size_t k = sizeof(ns2__APCaptureReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APCaptureReply);
		if (p)
			((ns2__APCaptureReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APCaptureReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APCaptureReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APCaptureReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APCaptureReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APCaptureReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APCaptureReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APCaptureReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APCaptureReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APCaptureReply * SOAP_FMAC4 soap_get_ns2__APCaptureReply(struct soap *soap, ns2__APCaptureReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APCaptureReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APAuthReversalReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APAuthReversalReply::reasonCode = NULL;
	this->ns2__APAuthReversalReply::transactionID = NULL;
	this->ns2__APAuthReversalReply::status = NULL;
	this->ns2__APAuthReversalReply::processorResponse = NULL;
	this->ns2__APAuthReversalReply::amount = NULL;
	this->ns2__APAuthReversalReply::dateTime = NULL;
	this->ns2__APAuthReversalReply::providerResponse = NULL;
	this->ns2__APAuthReversalReply::paymentStatus = NULL;
	this->ns2__APAuthReversalReply::responseCode = NULL;
	this->ns2__APAuthReversalReply::reconciliationID = NULL;
	/* transient soap skipped */
}

void ns2__APAuthReversalReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__APAuthReversalReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthReversalReply::transactionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthReversalReply::status);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthReversalReply::processorResponse);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__APAuthReversalReply::amount);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__APAuthReversalReply::dateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthReversalReply::providerResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthReversalReply::paymentStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthReversalReply::responseCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthReversalReply::reconciliationID);
#endif
}

int ns2__APAuthReversalReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APAuthReversalReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APAuthReversalReply(struct soap *soap, const char *tag, int id, const ns2__APAuthReversalReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APAuthReversalReply), type))
		return soap->error;
	if (!a->ns2__APAuthReversalReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__APAuthReversalReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionID", -1, (wchar_t*const*)&a->ns2__APAuthReversalReply::transactionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:status", -1, (wchar_t*const*)&a->ns2__APAuthReversalReply::status, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__APAuthReversalReply::processorResponse, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__APAuthReversalReply::amount, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:dateTime", -1, &a->ns2__APAuthReversalReply::dateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:providerResponse", -1, (wchar_t*const*)&a->ns2__APAuthReversalReply::providerResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentStatus", -1, (wchar_t*const*)&a->ns2__APAuthReversalReply::paymentStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:responseCode", -1, (wchar_t*const*)&a->ns2__APAuthReversalReply::responseCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__APAuthReversalReply::reconciliationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APAuthReversalReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APAuthReversalReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APAuthReversalReply * SOAP_FMAC4 soap_in_ns2__APAuthReversalReply(struct soap *soap, const char *tag, ns2__APAuthReversalReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APAuthReversalReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APAuthReversalReply, sizeof(ns2__APAuthReversalReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APAuthReversalReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APAuthReversalReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_transactionID1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_dateTime1 = 1;
	size_t soap_flag_providerResponse1 = 1;
	size_t soap_flag_paymentStatus1 = 1;
	size_t soap_flag_responseCode1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__APAuthReversalReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_transactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionID", (wchar_t**)&a->ns2__APAuthReversalReply::transactionID, "xsd:string"))
				{	soap_flag_transactionID1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:status", (wchar_t**)&a->ns2__APAuthReversalReply::status, "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__APAuthReversalReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__APAuthReversalReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_dateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:dateTime", &a->ns2__APAuthReversalReply::dateTime, "ns2:dateTime"))
				{	soap_flag_dateTime1--;
					continue;
				}
			if (soap_flag_providerResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:providerResponse", (wchar_t**)&a->ns2__APAuthReversalReply::providerResponse, "xsd:string"))
				{	soap_flag_providerResponse1--;
					continue;
				}
			if (soap_flag_paymentStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentStatus", (wchar_t**)&a->ns2__APAuthReversalReply::paymentStatus, "xsd:string"))
				{	soap_flag_paymentStatus1--;
					continue;
				}
			if (soap_flag_responseCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:responseCode", (wchar_t**)&a->ns2__APAuthReversalReply::responseCode, "xsd:string"))
				{	soap_flag_responseCode1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__APAuthReversalReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__APAuthReversalReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APAuthReversalReply, SOAP_TYPE_ns2__APAuthReversalReply, sizeof(ns2__APAuthReversalReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APAuthReversalReply * SOAP_FMAC2 soap_instantiate_ns2__APAuthReversalReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APAuthReversalReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APAuthReversalReply *p;
	size_t k = sizeof(ns2__APAuthReversalReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APAuthReversalReply);
		if (p)
			((ns2__APAuthReversalReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APAuthReversalReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APAuthReversalReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APAuthReversalReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APAuthReversalReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APAuthReversalReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APAuthReversalReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APAuthReversalReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APAuthReversalReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APAuthReversalReply * SOAP_FMAC4 soap_get_ns2__APAuthReversalReply(struct soap *soap, ns2__APAuthReversalReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APAuthReversalReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APAuthReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APAuthReply::reasonCode = NULL;
	this->ns2__APAuthReply::transactionID = NULL;
	this->ns2__APAuthReply::status = NULL;
	this->ns2__APAuthReply::processorResponse = NULL;
	this->ns2__APAuthReply::amount = NULL;
	this->ns2__APAuthReply::dateTime = NULL;
	this->ns2__APAuthReply::providerResponse = NULL;
	this->ns2__APAuthReply::paymentStatus = NULL;
	this->ns2__APAuthReply::responseCode = NULL;
	this->ns2__APAuthReply::authorizationCode = NULL;
	this->ns2__APAuthReply::merchantURL = NULL;
	this->ns2__APAuthReply::reconciliationID = NULL;
	this->ns2__APAuthReply::processorTransactionID = NULL;
	/* transient soap skipped */
}

void ns2__APAuthReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__APAuthReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthReply::transactionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthReply::status);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthReply::processorResponse);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__APAuthReply::amount);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__APAuthReply::dateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthReply::providerResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthReply::paymentStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthReply::responseCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthReply::authorizationCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthReply::merchantURL);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthReply::processorTransactionID);
#endif
}

int ns2__APAuthReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APAuthReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APAuthReply(struct soap *soap, const char *tag, int id, const ns2__APAuthReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APAuthReply), type))
		return soap->error;
	if (!a->ns2__APAuthReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__APAuthReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionID", -1, (wchar_t*const*)&a->ns2__APAuthReply::transactionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:status", -1, (wchar_t*const*)&a->ns2__APAuthReply::status, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__APAuthReply::processorResponse, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__APAuthReply::amount, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:dateTime", -1, &a->ns2__APAuthReply::dateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:providerResponse", -1, (wchar_t*const*)&a->ns2__APAuthReply::providerResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentStatus", -1, (wchar_t*const*)&a->ns2__APAuthReply::paymentStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:responseCode", -1, (wchar_t*const*)&a->ns2__APAuthReply::responseCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authorizationCode", -1, (wchar_t*const*)&a->ns2__APAuthReply::authorizationCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantURL", -1, (wchar_t*const*)&a->ns2__APAuthReply::merchantURL, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__APAuthReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorTransactionID", -1, (wchar_t*const*)&a->ns2__APAuthReply::processorTransactionID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APAuthReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APAuthReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APAuthReply * SOAP_FMAC4 soap_in_ns2__APAuthReply(struct soap *soap, const char *tag, ns2__APAuthReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APAuthReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APAuthReply, sizeof(ns2__APAuthReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APAuthReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APAuthReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_transactionID1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_dateTime1 = 1;
	size_t soap_flag_providerResponse1 = 1;
	size_t soap_flag_paymentStatus1 = 1;
	size_t soap_flag_responseCode1 = 1;
	size_t soap_flag_authorizationCode1 = 1;
	size_t soap_flag_merchantURL1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_processorTransactionID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__APAuthReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_transactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionID", (wchar_t**)&a->ns2__APAuthReply::transactionID, "xsd:string"))
				{	soap_flag_transactionID1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:status", (wchar_t**)&a->ns2__APAuthReply::status, "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__APAuthReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__APAuthReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_dateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:dateTime", &a->ns2__APAuthReply::dateTime, "ns2:dateTime"))
				{	soap_flag_dateTime1--;
					continue;
				}
			if (soap_flag_providerResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:providerResponse", (wchar_t**)&a->ns2__APAuthReply::providerResponse, "xsd:string"))
				{	soap_flag_providerResponse1--;
					continue;
				}
			if (soap_flag_paymentStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentStatus", (wchar_t**)&a->ns2__APAuthReply::paymentStatus, "xsd:string"))
				{	soap_flag_paymentStatus1--;
					continue;
				}
			if (soap_flag_responseCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:responseCode", (wchar_t**)&a->ns2__APAuthReply::responseCode, "xsd:string"))
				{	soap_flag_responseCode1--;
					continue;
				}
			if (soap_flag_authorizationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authorizationCode", (wchar_t**)&a->ns2__APAuthReply::authorizationCode, "xsd:string"))
				{	soap_flag_authorizationCode1--;
					continue;
				}
			if (soap_flag_merchantURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantURL", (wchar_t**)&a->ns2__APAuthReply::merchantURL, "xsd:string"))
				{	soap_flag_merchantURL1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__APAuthReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_processorTransactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorTransactionID", (wchar_t**)&a->ns2__APAuthReply::processorTransactionID, "xsd:string"))
				{	soap_flag_processorTransactionID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__APAuthReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APAuthReply, SOAP_TYPE_ns2__APAuthReply, sizeof(ns2__APAuthReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APAuthReply * SOAP_FMAC2 soap_instantiate_ns2__APAuthReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APAuthReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APAuthReply *p;
	size_t k = sizeof(ns2__APAuthReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APAuthReply);
		if (p)
			((ns2__APAuthReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APAuthReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APAuthReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APAuthReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APAuthReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APAuthReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APAuthReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APAuthReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APAuthReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APAuthReply * SOAP_FMAC4 soap_get_ns2__APAuthReply(struct soap *soap, ns2__APAuthReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APAuthReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APReply::orderID = NULL;
	this->ns2__APReply::cardGroup = NULL;
	this->ns2__APReply::cardType = NULL;
	this->ns2__APReply::cardNumberSuffix = NULL;
	this->ns2__APReply::cardExpirationMonth = NULL;
	this->ns2__APReply::cardExpirationYear = NULL;
	this->ns2__APReply::avsCodeRaw = NULL;
	this->ns2__APReply::purchaseID = NULL;
	this->ns2__APReply::productID = NULL;
	this->ns2__APReply::productDescription = NULL;
	this->ns2__APReply::shippingAmount = NULL;
	this->ns2__APReply::handlingAmount = NULL;
	this->ns2__APReply::shippingHandlingAmount = NULL;
	this->ns2__APReply::additionalAmount = NULL;
	this->ns2__APReply::taxAmount = NULL;
	this->ns2__APReply::subtotalAmount = NULL;
	this->ns2__APReply::totalPurchaseAmount = NULL;
	this->ns2__APReply::giftWrapAmount = NULL;
	this->ns2__APReply::discountAmount = NULL;
	this->ns2__APReply::cardNumberPrefix = NULL;
	this->ns2__APReply::riskIndicator = NULL;
	this->ns2__APReply::merchantUUID = NULL;
	this->ns2__APReply::merchantSiteID = NULL;
	/* transient soap skipped */
}

void ns2__APReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::orderID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::cardGroup);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::cardType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::cardNumberSuffix);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::cardExpirationMonth);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::cardExpirationYear);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::avsCodeRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::purchaseID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::productID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::productDescription);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::shippingAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::handlingAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::shippingHandlingAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::additionalAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::taxAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::subtotalAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::totalPurchaseAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::giftWrapAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::discountAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::cardNumberPrefix);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::riskIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::merchantUUID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APReply::merchantSiteID);
#endif
}

int ns2__APReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APReply(struct soap *soap, const char *tag, int id, const ns2__APReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APReply), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderID", -1, (wchar_t*const*)&a->ns2__APReply::orderID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardGroup", -1, (wchar_t*const*)&a->ns2__APReply::cardGroup, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardType", -1, (wchar_t*const*)&a->ns2__APReply::cardType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardNumberSuffix", -1, (wchar_t*const*)&a->ns2__APReply::cardNumberSuffix, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardExpirationMonth", -1, (wchar_t*const*)&a->ns2__APReply::cardExpirationMonth, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardExpirationYear", -1, (wchar_t*const*)&a->ns2__APReply::cardExpirationYear, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:avsCodeRaw", -1, (wchar_t*const*)&a->ns2__APReply::avsCodeRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:purchaseID", -1, (wchar_t*const*)&a->ns2__APReply::purchaseID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:productID", -1, (wchar_t*const*)&a->ns2__APReply::productID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:productDescription", -1, (wchar_t*const*)&a->ns2__APReply::productDescription, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shippingAmount", -1, (wchar_t*const*)&a->ns2__APReply::shippingAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:handlingAmount", -1, (wchar_t*const*)&a->ns2__APReply::handlingAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shippingHandlingAmount", -1, (wchar_t*const*)&a->ns2__APReply::shippingHandlingAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:additionalAmount", -1, (wchar_t*const*)&a->ns2__APReply::additionalAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:taxAmount", -1, (wchar_t*const*)&a->ns2__APReply::taxAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:subtotalAmount", -1, (wchar_t*const*)&a->ns2__APReply::subtotalAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:totalPurchaseAmount", -1, (wchar_t*const*)&a->ns2__APReply::totalPurchaseAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:giftWrapAmount", -1, (wchar_t*const*)&a->ns2__APReply::giftWrapAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:discountAmount", -1, (wchar_t*const*)&a->ns2__APReply::discountAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardNumberPrefix", -1, (wchar_t*const*)&a->ns2__APReply::cardNumberPrefix, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:riskIndicator", -1, (wchar_t*const*)&a->ns2__APReply::riskIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantUUID", -1, (wchar_t*const*)&a->ns2__APReply::merchantUUID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantSiteID", -1, (wchar_t*const*)&a->ns2__APReply::merchantSiteID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APReply * SOAP_FMAC4 soap_in_ns2__APReply(struct soap *soap, const char *tag, ns2__APReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APReply, sizeof(ns2__APReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_orderID1 = 1;
	size_t soap_flag_cardGroup1 = 1;
	size_t soap_flag_cardType1 = 1;
	size_t soap_flag_cardNumberSuffix1 = 1;
	size_t soap_flag_cardExpirationMonth1 = 1;
	size_t soap_flag_cardExpirationYear1 = 1;
	size_t soap_flag_avsCodeRaw1 = 1;
	size_t soap_flag_purchaseID1 = 1;
	size_t soap_flag_productID1 = 1;
	size_t soap_flag_productDescription1 = 1;
	size_t soap_flag_shippingAmount1 = 1;
	size_t soap_flag_handlingAmount1 = 1;
	size_t soap_flag_shippingHandlingAmount1 = 1;
	size_t soap_flag_additionalAmount1 = 1;
	size_t soap_flag_taxAmount1 = 1;
	size_t soap_flag_subtotalAmount1 = 1;
	size_t soap_flag_totalPurchaseAmount1 = 1;
	size_t soap_flag_giftWrapAmount1 = 1;
	size_t soap_flag_discountAmount1 = 1;
	size_t soap_flag_cardNumberPrefix1 = 1;
	size_t soap_flag_riskIndicator1 = 1;
	size_t soap_flag_merchantUUID1 = 1;
	size_t soap_flag_merchantSiteID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_orderID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderID", (wchar_t**)&a->ns2__APReply::orderID, "xsd:string"))
				{	soap_flag_orderID1--;
					continue;
				}
			if (soap_flag_cardGroup1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardGroup", (wchar_t**)&a->ns2__APReply::cardGroup, "xsd:string"))
				{	soap_flag_cardGroup1--;
					continue;
				}
			if (soap_flag_cardType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardType", (wchar_t**)&a->ns2__APReply::cardType, "xsd:string"))
				{	soap_flag_cardType1--;
					continue;
				}
			if (soap_flag_cardNumberSuffix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardNumberSuffix", (wchar_t**)&a->ns2__APReply::cardNumberSuffix, "xsd:string"))
				{	soap_flag_cardNumberSuffix1--;
					continue;
				}
			if (soap_flag_cardExpirationMonth1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardExpirationMonth", (wchar_t**)&a->ns2__APReply::cardExpirationMonth, "xsd:string"))
				{	soap_flag_cardExpirationMonth1--;
					continue;
				}
			if (soap_flag_cardExpirationYear1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardExpirationYear", (wchar_t**)&a->ns2__APReply::cardExpirationYear, "xsd:string"))
				{	soap_flag_cardExpirationYear1--;
					continue;
				}
			if (soap_flag_avsCodeRaw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:avsCodeRaw", (wchar_t**)&a->ns2__APReply::avsCodeRaw, "xsd:string"))
				{	soap_flag_avsCodeRaw1--;
					continue;
				}
			if (soap_flag_purchaseID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:purchaseID", (wchar_t**)&a->ns2__APReply::purchaseID, "xsd:string"))
				{	soap_flag_purchaseID1--;
					continue;
				}
			if (soap_flag_productID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:productID", (wchar_t**)&a->ns2__APReply::productID, "xsd:string"))
				{	soap_flag_productID1--;
					continue;
				}
			if (soap_flag_productDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:productDescription", (wchar_t**)&a->ns2__APReply::productDescription, "xsd:string"))
				{	soap_flag_productDescription1--;
					continue;
				}
			if (soap_flag_shippingAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shippingAmount", (wchar_t**)&a->ns2__APReply::shippingAmount, "xsd:string"))
				{	soap_flag_shippingAmount1--;
					continue;
				}
			if (soap_flag_handlingAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:handlingAmount", (wchar_t**)&a->ns2__APReply::handlingAmount, "xsd:string"))
				{	soap_flag_handlingAmount1--;
					continue;
				}
			if (soap_flag_shippingHandlingAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shippingHandlingAmount", (wchar_t**)&a->ns2__APReply::shippingHandlingAmount, "xsd:string"))
				{	soap_flag_shippingHandlingAmount1--;
					continue;
				}
			if (soap_flag_additionalAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:additionalAmount", (wchar_t**)&a->ns2__APReply::additionalAmount, "xsd:string"))
				{	soap_flag_additionalAmount1--;
					continue;
				}
			if (soap_flag_taxAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:taxAmount", (wchar_t**)&a->ns2__APReply::taxAmount, "xsd:string"))
				{	soap_flag_taxAmount1--;
					continue;
				}
			if (soap_flag_subtotalAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:subtotalAmount", (wchar_t**)&a->ns2__APReply::subtotalAmount, "xsd:string"))
				{	soap_flag_subtotalAmount1--;
					continue;
				}
			if (soap_flag_totalPurchaseAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:totalPurchaseAmount", (wchar_t**)&a->ns2__APReply::totalPurchaseAmount, "xsd:string"))
				{	soap_flag_totalPurchaseAmount1--;
					continue;
				}
			if (soap_flag_giftWrapAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:giftWrapAmount", (wchar_t**)&a->ns2__APReply::giftWrapAmount, "xsd:string"))
				{	soap_flag_giftWrapAmount1--;
					continue;
				}
			if (soap_flag_discountAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:discountAmount", (wchar_t**)&a->ns2__APReply::discountAmount, "xsd:string"))
				{	soap_flag_discountAmount1--;
					continue;
				}
			if (soap_flag_cardNumberPrefix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardNumberPrefix", (wchar_t**)&a->ns2__APReply::cardNumberPrefix, "xsd:string"))
				{	soap_flag_cardNumberPrefix1--;
					continue;
				}
			if (soap_flag_riskIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:riskIndicator", (wchar_t**)&a->ns2__APReply::riskIndicator, "xsd:string"))
				{	soap_flag_riskIndicator1--;
					continue;
				}
			if (soap_flag_merchantUUID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantUUID", (wchar_t**)&a->ns2__APReply::merchantUUID, "xsd:string"))
				{	soap_flag_merchantUUID1--;
					continue;
				}
			if (soap_flag_merchantSiteID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantSiteID", (wchar_t**)&a->ns2__APReply::merchantSiteID, "xsd:string"))
				{	soap_flag_merchantSiteID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__APReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APReply, SOAP_TYPE_ns2__APReply, sizeof(ns2__APReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APReply * SOAP_FMAC2 soap_instantiate_ns2__APReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APReply *p;
	size_t k = sizeof(ns2__APReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APReply);
		if (p)
			((ns2__APReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APReply * SOAP_FMAC4 soap_get_ns2__APReply(struct soap *soap, ns2__APReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APCheckStatusReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APCheckStatusReply::reasonCode = NULL;
	this->ns2__APCheckStatusReply::reconciliationID = NULL;
	this->ns2__APCheckStatusReply::paymentStatus = NULL;
	this->ns2__APCheckStatusReply::processorTradeNo = NULL;
	this->ns2__APCheckStatusReply::processorTransactionID = NULL;
	/* transient soap skipped */
}

void ns2__APCheckStatusReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__APCheckStatusReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APCheckStatusReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APCheckStatusReply::paymentStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APCheckStatusReply::processorTradeNo);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APCheckStatusReply::processorTransactionID);
#endif
}

int ns2__APCheckStatusReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APCheckStatusReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APCheckStatusReply(struct soap *soap, const char *tag, int id, const ns2__APCheckStatusReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APCheckStatusReply), type))
		return soap->error;
	if (!a->ns2__APCheckStatusReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__APCheckStatusReply::reasonCode, ""))
		return soap->error;
	if (!a->ns2__APCheckStatusReply::reconciliationID)
	{	if (soap_element_nil(soap, "ns2:reconciliationID"))
			return soap->error;
	}
	else
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__APCheckStatusReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentStatus", -1, (wchar_t*const*)&a->ns2__APCheckStatusReply::paymentStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorTradeNo", -1, (wchar_t*const*)&a->ns2__APCheckStatusReply::processorTradeNo, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorTransactionID", -1, (wchar_t*const*)&a->ns2__APCheckStatusReply::processorTransactionID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APCheckStatusReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APCheckStatusReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APCheckStatusReply * SOAP_FMAC4 soap_in_ns2__APCheckStatusReply(struct soap *soap, const char *tag, ns2__APCheckStatusReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APCheckStatusReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APCheckStatusReply, sizeof(ns2__APCheckStatusReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APCheckStatusReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APCheckStatusReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_paymentStatus1 = 1;
	size_t soap_flag_processorTradeNo1 = 1;
	size_t soap_flag_processorTransactionID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__APCheckStatusReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__APCheckStatusReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_paymentStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentStatus", (wchar_t**)&a->ns2__APCheckStatusReply::paymentStatus, "xsd:string"))
				{	soap_flag_paymentStatus1--;
					continue;
				}
			if (soap_flag_processorTradeNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorTradeNo", (wchar_t**)&a->ns2__APCheckStatusReply::processorTradeNo, "xsd:string"))
				{	soap_flag_processorTradeNo1--;
					continue;
				}
			if (soap_flag_processorTransactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorTransactionID", (wchar_t**)&a->ns2__APCheckStatusReply::processorTransactionID, "xsd:string"))
				{	soap_flag_processorTransactionID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0 || soap_flag_reconciliationID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__APCheckStatusReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APCheckStatusReply, SOAP_TYPE_ns2__APCheckStatusReply, sizeof(ns2__APCheckStatusReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APCheckStatusReply * SOAP_FMAC2 soap_instantiate_ns2__APCheckStatusReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APCheckStatusReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APCheckStatusReply *p;
	size_t k = sizeof(ns2__APCheckStatusReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APCheckStatusReply);
		if (p)
			((ns2__APCheckStatusReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APCheckStatusReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APCheckStatusReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APCheckStatusReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APCheckStatusReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APCheckStatusReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APCheckStatusReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APCheckStatusReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APCheckStatusReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APCheckStatusReply * SOAP_FMAC4 soap_get_ns2__APCheckStatusReply(struct soap *soap, ns2__APCheckStatusReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APCheckStatusReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APInitiateReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APInitiateReply::reasonCode = NULL;
	this->ns2__APInitiateReply::merchantURL = NULL;
	this->ns2__APInitiateReply::reconciliationID = NULL;
	this->ns2__APInitiateReply::amount = NULL;
	this->ns2__APInitiateReply::dateTime = NULL;
	this->ns2__APInitiateReply::signature = NULL;
	this->ns2__APInitiateReply::publicKey = NULL;
	this->ns2__APInitiateReply::paymentStatus = NULL;
	this->ns2__APInitiateReply::responseCode = NULL;
	/* transient soap skipped */
}

void ns2__APInitiateReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__APInitiateReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APInitiateReply::merchantURL);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APInitiateReply::reconciliationID);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__APInitiateReply::amount);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__APInitiateReply::dateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APInitiateReply::signature);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APInitiateReply::publicKey);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APInitiateReply::paymentStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APInitiateReply::responseCode);
#endif
}

int ns2__APInitiateReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APInitiateReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APInitiateReply(struct soap *soap, const char *tag, int id, const ns2__APInitiateReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APInitiateReply), type))
		return soap->error;
	if (!a->ns2__APInitiateReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__APInitiateReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantURL", -1, (wchar_t*const*)&a->ns2__APInitiateReply::merchantURL, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__APInitiateReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__APInitiateReply::amount, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:dateTime", -1, &a->ns2__APInitiateReply::dateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:signature", -1, (wchar_t*const*)&a->ns2__APInitiateReply::signature, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:publicKey", -1, (wchar_t*const*)&a->ns2__APInitiateReply::publicKey, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentStatus", -1, (wchar_t*const*)&a->ns2__APInitiateReply::paymentStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:responseCode", -1, (wchar_t*const*)&a->ns2__APInitiateReply::responseCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APInitiateReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APInitiateReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APInitiateReply * SOAP_FMAC4 soap_in_ns2__APInitiateReply(struct soap *soap, const char *tag, ns2__APInitiateReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APInitiateReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APInitiateReply, sizeof(ns2__APInitiateReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APInitiateReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APInitiateReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_merchantURL1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_dateTime1 = 1;
	size_t soap_flag_signature1 = 1;
	size_t soap_flag_publicKey1 = 1;
	size_t soap_flag_paymentStatus1 = 1;
	size_t soap_flag_responseCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__APInitiateReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_merchantURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantURL", (wchar_t**)&a->ns2__APInitiateReply::merchantURL, "xsd:string"))
				{	soap_flag_merchantURL1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__APInitiateReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__APInitiateReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_dateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:dateTime", &a->ns2__APInitiateReply::dateTime, "ns2:dateTime"))
				{	soap_flag_dateTime1--;
					continue;
				}
			if (soap_flag_signature1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:signature", (wchar_t**)&a->ns2__APInitiateReply::signature, "xsd:string"))
				{	soap_flag_signature1--;
					continue;
				}
			if (soap_flag_publicKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:publicKey", (wchar_t**)&a->ns2__APInitiateReply::publicKey, "xsd:string"))
				{	soap_flag_publicKey1--;
					continue;
				}
			if (soap_flag_paymentStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentStatus", (wchar_t**)&a->ns2__APInitiateReply::paymentStatus, "xsd:string"))
				{	soap_flag_paymentStatus1--;
					continue;
				}
			if (soap_flag_responseCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:responseCode", (wchar_t**)&a->ns2__APInitiateReply::responseCode, "xsd:string"))
				{	soap_flag_responseCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__APInitiateReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APInitiateReply, SOAP_TYPE_ns2__APInitiateReply, sizeof(ns2__APInitiateReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APInitiateReply * SOAP_FMAC2 soap_instantiate_ns2__APInitiateReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APInitiateReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APInitiateReply *p;
	size_t k = sizeof(ns2__APInitiateReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APInitiateReply);
		if (p)
			((ns2__APInitiateReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APInitiateReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APInitiateReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APInitiateReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APInitiateReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APInitiateReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APInitiateReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APInitiateReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APInitiateReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APInitiateReply * SOAP_FMAC4 soap_get_ns2__APInitiateReply(struct soap *soap, ns2__APInitiateReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APInitiateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__BoletoPaymentReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__BoletoPaymentReply::reasonCode = NULL;
	this->ns2__BoletoPaymentReply::requestDateTime = NULL;
	this->ns2__BoletoPaymentReply::amount = NULL;
	this->ns2__BoletoPaymentReply::reconciliationID = NULL;
	this->ns2__BoletoPaymentReply::boletoNumber = NULL;
	this->ns2__BoletoPaymentReply::expirationDate = NULL;
	this->ns2__BoletoPaymentReply::url = NULL;
	this->ns2__BoletoPaymentReply::avsCode = NULL;
	this->ns2__BoletoPaymentReply::avsCodeRaw = NULL;
	this->ns2__BoletoPaymentReply::barCodeNumber = NULL;
	this->ns2__BoletoPaymentReply::assignor = NULL;
	/* transient soap skipped */
}

void ns2__BoletoPaymentReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__BoletoPaymentReply::reasonCode);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__BoletoPaymentReply::requestDateTime);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__BoletoPaymentReply::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BoletoPaymentReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BoletoPaymentReply::boletoNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BoletoPaymentReply::expirationDate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BoletoPaymentReply::url);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BoletoPaymentReply::avsCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BoletoPaymentReply::avsCodeRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BoletoPaymentReply::barCodeNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BoletoPaymentReply::assignor);
#endif
}

int ns2__BoletoPaymentReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__BoletoPaymentReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BoletoPaymentReply(struct soap *soap, const char *tag, int id, const ns2__BoletoPaymentReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BoletoPaymentReply), type))
		return soap->error;
	if (!a->ns2__BoletoPaymentReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__BoletoPaymentReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__BoletoPaymentReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__BoletoPaymentReply::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__BoletoPaymentReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:boletoNumber", -1, (wchar_t*const*)&a->ns2__BoletoPaymentReply::boletoNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:expirationDate", -1, (wchar_t*const*)&a->ns2__BoletoPaymentReply::expirationDate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:url", -1, (wchar_t*const*)&a->ns2__BoletoPaymentReply::url, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:avsCode", -1, (wchar_t*const*)&a->ns2__BoletoPaymentReply::avsCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:avsCodeRaw", -1, (wchar_t*const*)&a->ns2__BoletoPaymentReply::avsCodeRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:barCodeNumber", -1, (wchar_t*const*)&a->ns2__BoletoPaymentReply::barCodeNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:assignor", -1, (wchar_t*const*)&a->ns2__BoletoPaymentReply::assignor, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__BoletoPaymentReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__BoletoPaymentReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__BoletoPaymentReply * SOAP_FMAC4 soap_in_ns2__BoletoPaymentReply(struct soap *soap, const char *tag, ns2__BoletoPaymentReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__BoletoPaymentReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BoletoPaymentReply, sizeof(ns2__BoletoPaymentReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__BoletoPaymentReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__BoletoPaymentReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_boletoNumber1 = 1;
	size_t soap_flag_expirationDate1 = 1;
	size_t soap_flag_url1 = 1;
	size_t soap_flag_avsCode1 = 1;
	size_t soap_flag_avsCodeRaw1 = 1;
	size_t soap_flag_barCodeNumber1 = 1;
	size_t soap_flag_assignor1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__BoletoPaymentReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__BoletoPaymentReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__BoletoPaymentReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__BoletoPaymentReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_boletoNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:boletoNumber", (wchar_t**)&a->ns2__BoletoPaymentReply::boletoNumber, "xsd:string"))
				{	soap_flag_boletoNumber1--;
					continue;
				}
			if (soap_flag_expirationDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:expirationDate", (wchar_t**)&a->ns2__BoletoPaymentReply::expirationDate, "xsd:string"))
				{	soap_flag_expirationDate1--;
					continue;
				}
			if (soap_flag_url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:url", (wchar_t**)&a->ns2__BoletoPaymentReply::url, "xsd:string"))
				{	soap_flag_url1--;
					continue;
				}
			if (soap_flag_avsCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:avsCode", (wchar_t**)&a->ns2__BoletoPaymentReply::avsCode, "xsd:string"))
				{	soap_flag_avsCode1--;
					continue;
				}
			if (soap_flag_avsCodeRaw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:avsCodeRaw", (wchar_t**)&a->ns2__BoletoPaymentReply::avsCodeRaw, "xsd:string"))
				{	soap_flag_avsCodeRaw1--;
					continue;
				}
			if (soap_flag_barCodeNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:barCodeNumber", (wchar_t**)&a->ns2__BoletoPaymentReply::barCodeNumber, "xsd:string"))
				{	soap_flag_barCodeNumber1--;
					continue;
				}
			if (soap_flag_assignor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:assignor", (wchar_t**)&a->ns2__BoletoPaymentReply::assignor, "xsd:string"))
				{	soap_flag_assignor1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__BoletoPaymentReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BoletoPaymentReply, SOAP_TYPE_ns2__BoletoPaymentReply, sizeof(ns2__BoletoPaymentReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__BoletoPaymentReply * SOAP_FMAC2 soap_instantiate_ns2__BoletoPaymentReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__BoletoPaymentReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__BoletoPaymentReply *p;
	size_t k = sizeof(ns2__BoletoPaymentReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__BoletoPaymentReply);
		if (p)
			((ns2__BoletoPaymentReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__BoletoPaymentReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__BoletoPaymentReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__BoletoPaymentReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__BoletoPaymentReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__BoletoPaymentReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:BoletoPaymentReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__BoletoPaymentReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__BoletoPaymentReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__BoletoPaymentReply * SOAP_FMAC4 soap_get_ns2__BoletoPaymentReply(struct soap *soap, ns2__BoletoPaymentReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BoletoPaymentReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ChinaRefundReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ChinaRefundReply::reasonCode = NULL;
	this->ns2__ChinaRefundReply::requestDateTime = NULL;
	this->ns2__ChinaRefundReply::amount = NULL;
	this->ns2__ChinaRefundReply::currency = NULL;
	/* transient soap skipped */
}

void ns2__ChinaRefundReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__ChinaRefundReply::reasonCode);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__ChinaRefundReply::requestDateTime);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__ChinaRefundReply::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ChinaRefundReply::currency);
#endif
}

int ns2__ChinaRefundReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ChinaRefundReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ChinaRefundReply(struct soap *soap, const char *tag, int id, const ns2__ChinaRefundReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ChinaRefundReply), type))
		return soap->error;
	if (!a->ns2__ChinaRefundReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__ChinaRefundReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__ChinaRefundReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__ChinaRefundReply::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:currency", -1, (wchar_t*const*)&a->ns2__ChinaRefundReply::currency, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ChinaRefundReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ChinaRefundReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ChinaRefundReply * SOAP_FMAC4 soap_in_ns2__ChinaRefundReply(struct soap *soap, const char *tag, ns2__ChinaRefundReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ChinaRefundReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ChinaRefundReply, sizeof(ns2__ChinaRefundReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ChinaRefundReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ChinaRefundReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_currency1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__ChinaRefundReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__ChinaRefundReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__ChinaRefundReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_currency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:currency", (wchar_t**)&a->ns2__ChinaRefundReply::currency, "xsd:string"))
				{	soap_flag_currency1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__ChinaRefundReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ChinaRefundReply, SOAP_TYPE_ns2__ChinaRefundReply, sizeof(ns2__ChinaRefundReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ChinaRefundReply * SOAP_FMAC2 soap_instantiate_ns2__ChinaRefundReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ChinaRefundReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ChinaRefundReply *p;
	size_t k = sizeof(ns2__ChinaRefundReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ChinaRefundReply);
		if (p)
			((ns2__ChinaRefundReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ChinaRefundReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ChinaRefundReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ChinaRefundReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ChinaRefundReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ChinaRefundReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:ChinaRefundReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ChinaRefundReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ChinaRefundReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ChinaRefundReply * SOAP_FMAC4 soap_get_ns2__ChinaRefundReply(struct soap *soap, ns2__ChinaRefundReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ChinaRefundReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ChinaPaymentReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ChinaPaymentReply::reasonCode = NULL;
	this->ns2__ChinaPaymentReply::requestDateTime = NULL;
	this->ns2__ChinaPaymentReply::amount = NULL;
	this->ns2__ChinaPaymentReply::currency = NULL;
	this->ns2__ChinaPaymentReply::reconciliationID = NULL;
	this->ns2__ChinaPaymentReply::formData = NULL;
	this->ns2__ChinaPaymentReply::verifyFailure = NULL;
	this->ns2__ChinaPaymentReply::verifyInProcess = NULL;
	this->ns2__ChinaPaymentReply::verifySuccess = NULL;
	/* transient soap skipped */
}

void ns2__ChinaPaymentReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__ChinaPaymentReply::reasonCode);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__ChinaPaymentReply::requestDateTime);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__ChinaPaymentReply::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ChinaPaymentReply::currency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ChinaPaymentReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ChinaPaymentReply::formData);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ChinaPaymentReply::verifyFailure);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ChinaPaymentReply::verifyInProcess);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ChinaPaymentReply::verifySuccess);
#endif
}

int ns2__ChinaPaymentReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ChinaPaymentReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ChinaPaymentReply(struct soap *soap, const char *tag, int id, const ns2__ChinaPaymentReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ChinaPaymentReply), type))
		return soap->error;
	if (!a->ns2__ChinaPaymentReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__ChinaPaymentReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__ChinaPaymentReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__ChinaPaymentReply::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:currency", -1, (wchar_t*const*)&a->ns2__ChinaPaymentReply::currency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__ChinaPaymentReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:formData", -1, (wchar_t*const*)&a->ns2__ChinaPaymentReply::formData, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:verifyFailure", -1, (wchar_t*const*)&a->ns2__ChinaPaymentReply::verifyFailure, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:verifyInProcess", -1, (wchar_t*const*)&a->ns2__ChinaPaymentReply::verifyInProcess, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:verifySuccess", -1, (wchar_t*const*)&a->ns2__ChinaPaymentReply::verifySuccess, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ChinaPaymentReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ChinaPaymentReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ChinaPaymentReply * SOAP_FMAC4 soap_in_ns2__ChinaPaymentReply(struct soap *soap, const char *tag, ns2__ChinaPaymentReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ChinaPaymentReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ChinaPaymentReply, sizeof(ns2__ChinaPaymentReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ChinaPaymentReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ChinaPaymentReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_currency1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_formData1 = 1;
	size_t soap_flag_verifyFailure1 = 1;
	size_t soap_flag_verifyInProcess1 = 1;
	size_t soap_flag_verifySuccess1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__ChinaPaymentReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__ChinaPaymentReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__ChinaPaymentReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_currency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:currency", (wchar_t**)&a->ns2__ChinaPaymentReply::currency, "xsd:string"))
				{	soap_flag_currency1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__ChinaPaymentReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_formData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:formData", (wchar_t**)&a->ns2__ChinaPaymentReply::formData, "xsd:string"))
				{	soap_flag_formData1--;
					continue;
				}
			if (soap_flag_verifyFailure1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:verifyFailure", (wchar_t**)&a->ns2__ChinaPaymentReply::verifyFailure, "xsd:string"))
				{	soap_flag_verifyFailure1--;
					continue;
				}
			if (soap_flag_verifyInProcess1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:verifyInProcess", (wchar_t**)&a->ns2__ChinaPaymentReply::verifyInProcess, "xsd:string"))
				{	soap_flag_verifyInProcess1--;
					continue;
				}
			if (soap_flag_verifySuccess1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:verifySuccess", (wchar_t**)&a->ns2__ChinaPaymentReply::verifySuccess, "xsd:string"))
				{	soap_flag_verifySuccess1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__ChinaPaymentReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ChinaPaymentReply, SOAP_TYPE_ns2__ChinaPaymentReply, sizeof(ns2__ChinaPaymentReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ChinaPaymentReply * SOAP_FMAC2 soap_instantiate_ns2__ChinaPaymentReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ChinaPaymentReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ChinaPaymentReply *p;
	size_t k = sizeof(ns2__ChinaPaymentReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ChinaPaymentReply);
		if (p)
			((ns2__ChinaPaymentReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ChinaPaymentReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ChinaPaymentReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ChinaPaymentReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ChinaPaymentReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ChinaPaymentReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:ChinaPaymentReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ChinaPaymentReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ChinaPaymentReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ChinaPaymentReply * SOAP_FMAC4 soap_get_ns2__ChinaPaymentReply(struct soap *soap, ns2__ChinaPaymentReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ChinaPaymentReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CCDCCUpdateReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CCDCCUpdateReply::reasonCode = NULL;
	/* transient soap skipped */
}

void ns2__CCDCCUpdateReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__CCDCCUpdateReply::reasonCode);
#endif
}

int ns2__CCDCCUpdateReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CCDCCUpdateReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CCDCCUpdateReply(struct soap *soap, const char *tag, int id, const ns2__CCDCCUpdateReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CCDCCUpdateReply), type))
		return soap->error;
	if (!a->ns2__CCDCCUpdateReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__CCDCCUpdateReply::reasonCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CCDCCUpdateReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CCDCCUpdateReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CCDCCUpdateReply * SOAP_FMAC4 soap_in_ns2__CCDCCUpdateReply(struct soap *soap, const char *tag, ns2__CCDCCUpdateReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CCDCCUpdateReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CCDCCUpdateReply, sizeof(ns2__CCDCCUpdateReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CCDCCUpdateReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CCDCCUpdateReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__CCDCCUpdateReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__CCDCCUpdateReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CCDCCUpdateReply, SOAP_TYPE_ns2__CCDCCUpdateReply, sizeof(ns2__CCDCCUpdateReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CCDCCUpdateReply * SOAP_FMAC2 soap_instantiate_ns2__CCDCCUpdateReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CCDCCUpdateReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CCDCCUpdateReply *p;
	size_t k = sizeof(ns2__CCDCCUpdateReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CCDCCUpdateReply);
		if (p)
			((ns2__CCDCCUpdateReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CCDCCUpdateReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CCDCCUpdateReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CCDCCUpdateReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CCDCCUpdateReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CCDCCUpdateReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CCDCCUpdateReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CCDCCUpdateReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CCDCCUpdateReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CCDCCUpdateReply * SOAP_FMAC4 soap_get_ns2__CCDCCUpdateReply(struct soap *soap, ns2__CCDCCUpdateReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CCDCCUpdateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CCDCCReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CCDCCReply::reasonCode = NULL;
	this->ns2__CCDCCReply::dccSupported = NULL;
	this->ns2__CCDCCReply::validHours = NULL;
	this->ns2__CCDCCReply::marginRatePercentage = NULL;
	this->ns2__CCDCCReply::reconciliationID = NULL;
	/* transient soap skipped */
}

void ns2__CCDCCReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__CCDCCReply::reasonCode);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__CCDCCReply::dccSupported);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCDCCReply::validHours);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCDCCReply::marginRatePercentage);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCDCCReply::reconciliationID);
#endif
}

int ns2__CCDCCReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CCDCCReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CCDCCReply(struct soap *soap, const char *tag, int id, const ns2__CCDCCReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CCDCCReply), type))
		return soap->error;
	if (!a->ns2__CCDCCReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__CCDCCReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:dccSupported", -1, &a->ns2__CCDCCReply::dccSupported, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:validHours", -1, (wchar_t*const*)&a->ns2__CCDCCReply::validHours, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:marginRatePercentage", -1, (wchar_t*const*)&a->ns2__CCDCCReply::marginRatePercentage, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__CCDCCReply::reconciliationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CCDCCReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CCDCCReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CCDCCReply * SOAP_FMAC4 soap_in_ns2__CCDCCReply(struct soap *soap, const char *tag, ns2__CCDCCReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CCDCCReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CCDCCReply, sizeof(ns2__CCDCCReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CCDCCReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CCDCCReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_dccSupported1 = 1;
	size_t soap_flag_validHours1 = 1;
	size_t soap_flag_marginRatePercentage1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__CCDCCReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_dccSupported1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:dccSupported", &a->ns2__CCDCCReply::dccSupported, "ns2:boolean"))
				{	soap_flag_dccSupported1--;
					continue;
				}
			if (soap_flag_validHours1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:validHours", (wchar_t**)&a->ns2__CCDCCReply::validHours, "xsd:string"))
				{	soap_flag_validHours1--;
					continue;
				}
			if (soap_flag_marginRatePercentage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:marginRatePercentage", (wchar_t**)&a->ns2__CCDCCReply::marginRatePercentage, "xsd:string"))
				{	soap_flag_marginRatePercentage1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__CCDCCReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__CCDCCReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CCDCCReply, SOAP_TYPE_ns2__CCDCCReply, sizeof(ns2__CCDCCReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CCDCCReply * SOAP_FMAC2 soap_instantiate_ns2__CCDCCReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CCDCCReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CCDCCReply *p;
	size_t k = sizeof(ns2__CCDCCReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CCDCCReply);
		if (p)
			((ns2__CCDCCReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CCDCCReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CCDCCReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CCDCCReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CCDCCReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CCDCCReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CCDCCReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CCDCCReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CCDCCReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CCDCCReply * SOAP_FMAC4 soap_get_ns2__CCDCCReply(struct soap *soap, ns2__CCDCCReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CCDCCReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ProfileReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ProfileReply::selectedBy = NULL;
	this->ns2__ProfileReply::name = NULL;
	this->ns2__ProfileReply::destinationQueue = NULL;
	this->ns2__ProfileReply::profileScore = NULL;
	this->ns2__ProfileReply::rulesTriggered = NULL;
	/* transient soap skipped */
}

void ns2__ProfileReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ProfileReply::selectedBy);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ProfileReply::name);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ProfileReply::destinationQueue);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ProfileReply::profileScore);
	soap_serialize_PointerTons2__RuleResultItems(soap, &this->ns2__ProfileReply::rulesTriggered);
#endif
}

int ns2__ProfileReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ProfileReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ProfileReply(struct soap *soap, const char *tag, int id, const ns2__ProfileReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ProfileReply), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:selectedBy", -1, (wchar_t*const*)&a->ns2__ProfileReply::selectedBy, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:name", -1, (wchar_t*const*)&a->ns2__ProfileReply::name, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:destinationQueue", -1, (wchar_t*const*)&a->ns2__ProfileReply::destinationQueue, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:profileScore", -1, (wchar_t*const*)&a->ns2__ProfileReply::profileScore, ""))
		return soap->error;
	if (soap_out_PointerTons2__RuleResultItems(soap, "ns2:rulesTriggered", -1, &a->ns2__ProfileReply::rulesTriggered, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ProfileReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ProfileReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ProfileReply * SOAP_FMAC4 soap_in_ns2__ProfileReply(struct soap *soap, const char *tag, ns2__ProfileReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ProfileReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ProfileReply, sizeof(ns2__ProfileReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ProfileReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ProfileReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_selectedBy1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_destinationQueue1 = 1;
	size_t soap_flag_profileScore1 = 1;
	size_t soap_flag_rulesTriggered1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_selectedBy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:selectedBy", (wchar_t**)&a->ns2__ProfileReply::selectedBy, "xsd:string"))
				{	soap_flag_selectedBy1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:name", (wchar_t**)&a->ns2__ProfileReply::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_destinationQueue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:destinationQueue", (wchar_t**)&a->ns2__ProfileReply::destinationQueue, "xsd:string"))
				{	soap_flag_destinationQueue1--;
					continue;
				}
			if (soap_flag_profileScore1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:profileScore", (wchar_t**)&a->ns2__ProfileReply::profileScore, "xsd:string"))
				{	soap_flag_profileScore1--;
					continue;
				}
			if (soap_flag_rulesTriggered1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RuleResultItems(soap, "ns2:rulesTriggered", &a->ns2__ProfileReply::rulesTriggered, "ns2:RuleResultItems"))
				{	soap_flag_rulesTriggered1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ProfileReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ProfileReply, SOAP_TYPE_ns2__ProfileReply, sizeof(ns2__ProfileReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ProfileReply * SOAP_FMAC2 soap_instantiate_ns2__ProfileReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ProfileReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ProfileReply *p;
	size_t k = sizeof(ns2__ProfileReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ProfileReply);
		if (p)
			((ns2__ProfileReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ProfileReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ProfileReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ProfileReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ProfileReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ProfileReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:ProfileReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ProfileReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ProfileReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ProfileReply * SOAP_FMAC4 soap_get_ns2__ProfileReply(struct soap *soap, ns2__ProfileReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ProfileReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DMEReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DMEReply::eventType = NULL;
	this->ns2__DMEReply::eventInfo = NULL;
	this->ns2__DMEReply::eventHotlistInfo = NULL;
	this->ns2__DMEReply::eventPolicy = NULL;
	this->ns2__DMEReply::additionalFields = NULL;
	/* transient soap skipped */
}

void ns2__DMEReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DMEReply::eventType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DMEReply::eventInfo);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DMEReply::eventHotlistInfo);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DMEReply::eventPolicy);
	soap_serialize_PointerTons2__AdditionalFields(soap, &this->ns2__DMEReply::additionalFields);
#endif
}

int ns2__DMEReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DMEReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DMEReply(struct soap *soap, const char *tag, int id, const ns2__DMEReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DMEReply), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:eventType", -1, (wchar_t*const*)&a->ns2__DMEReply::eventType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:eventInfo", -1, (wchar_t*const*)&a->ns2__DMEReply::eventInfo, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:eventHotlistInfo", -1, (wchar_t*const*)&a->ns2__DMEReply::eventHotlistInfo, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:eventPolicy", -1, (wchar_t*const*)&a->ns2__DMEReply::eventPolicy, ""))
		return soap->error;
	if (soap_out_PointerTons2__AdditionalFields(soap, "ns2:additionalFields", -1, &a->ns2__DMEReply::additionalFields, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DMEReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DMEReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DMEReply * SOAP_FMAC4 soap_in_ns2__DMEReply(struct soap *soap, const char *tag, ns2__DMEReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DMEReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DMEReply, sizeof(ns2__DMEReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DMEReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DMEReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_eventType1 = 1;
	size_t soap_flag_eventInfo1 = 1;
	size_t soap_flag_eventHotlistInfo1 = 1;
	size_t soap_flag_eventPolicy1 = 1;
	size_t soap_flag_additionalFields1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eventType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:eventType", (wchar_t**)&a->ns2__DMEReply::eventType, "xsd:string"))
				{	soap_flag_eventType1--;
					continue;
				}
			if (soap_flag_eventInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:eventInfo", (wchar_t**)&a->ns2__DMEReply::eventInfo, "xsd:string"))
				{	soap_flag_eventInfo1--;
					continue;
				}
			if (soap_flag_eventHotlistInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:eventHotlistInfo", (wchar_t**)&a->ns2__DMEReply::eventHotlistInfo, "xsd:string"))
				{	soap_flag_eventHotlistInfo1--;
					continue;
				}
			if (soap_flag_eventPolicy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:eventPolicy", (wchar_t**)&a->ns2__DMEReply::eventPolicy, "xsd:string"))
				{	soap_flag_eventPolicy1--;
					continue;
				}
			if (soap_flag_additionalFields1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AdditionalFields(soap, "ns2:additionalFields", &a->ns2__DMEReply::additionalFields, "ns2:AdditionalFields"))
				{	soap_flag_additionalFields1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DMEReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DMEReply, SOAP_TYPE_ns2__DMEReply, sizeof(ns2__DMEReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DMEReply * SOAP_FMAC2 soap_instantiate_ns2__DMEReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DMEReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DMEReply *p;
	size_t k = sizeof(ns2__DMEReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DMEReply);
		if (p)
			((ns2__DMEReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DMEReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DMEReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DMEReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DMEReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DMEReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:DMEReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DMEReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DMEReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DMEReply * SOAP_FMAC4 soap_get_ns2__DMEReply(struct soap *soap, ns2__DMEReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DMEReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Field::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Field::provider = NULL;
	this->ns2__Field::name = NULL;
	this->ns2__Field::value = NULL;
	/* transient soap skipped */
}

void ns2__Field::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Field::provider);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Field::name);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Field::value);
#endif
}

int ns2__Field::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Field(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Field(struct soap *soap, const char *tag, int id, const ns2__Field *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Field), type))
		return soap->error;
	if (!a->ns2__Field::provider)
	{	if (soap_element_nil(soap, "ns2:provider"))
			return soap->error;
	}
	else
	if (soap_out_wstring(soap, "ns2:provider", -1, (wchar_t*const*)&a->ns2__Field::provider, ""))
		return soap->error;
	if (!a->ns2__Field::name)
	{	if (soap_element_nil(soap, "ns2:name"))
			return soap->error;
	}
	else
	if (soap_out_wstring(soap, "ns2:name", -1, (wchar_t*const*)&a->ns2__Field::name, ""))
		return soap->error;
	if (!a->ns2__Field::value)
	{	if (soap_element_nil(soap, "ns2:value"))
			return soap->error;
	}
	else
	if (soap_out_wstring(soap, "ns2:value", -1, (wchar_t*const*)&a->ns2__Field::value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Field::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Field(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Field * SOAP_FMAC4 soap_in_ns2__Field(struct soap *soap, const char *tag, ns2__Field *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Field *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Field, sizeof(ns2__Field), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Field)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Field *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_provider1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_provider1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:provider", (wchar_t**)&a->ns2__Field::provider, "xsd:string"))
				{	soap_flag_provider1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:name", (wchar_t**)&a->ns2__Field::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:value", (wchar_t**)&a->ns2__Field::value, "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_provider1 > 0 || soap_flag_name1 > 0 || soap_flag_value1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__Field *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Field, SOAP_TYPE_ns2__Field, sizeof(ns2__Field), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Field * SOAP_FMAC2 soap_instantiate_ns2__Field(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Field(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Field *p;
	size_t k = sizeof(ns2__Field);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Field);
		if (p)
			((ns2__Field*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Field, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Field*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Field location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Field, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Field::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:Field", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Field::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Field(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Field * SOAP_FMAC4 soap_get_ns2__Field(struct soap *soap, ns2__Field *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Field(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__AdditionalFields::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__Field(soap, &this->ns2__AdditionalFields::field);
	/* transient soap skipped */
}

void ns2__AdditionalFields::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__Field(soap, &this->ns2__AdditionalFields::field);
#endif
}

int ns2__AdditionalFields::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AdditionalFields(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AdditionalFields(struct soap *soap, const char *tag, int id, const ns2__AdditionalFields *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AdditionalFields), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__Field(soap, "ns2:field", -1, &a->ns2__AdditionalFields::field, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__AdditionalFields::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AdditionalFields(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AdditionalFields * SOAP_FMAC4 soap_in_ns2__AdditionalFields(struct soap *soap, const char *tag, ns2__AdditionalFields *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AdditionalFields *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AdditionalFields, sizeof(ns2__AdditionalFields), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__AdditionalFields)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__AdditionalFields *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__Field(soap, "ns2:field", &a->ns2__AdditionalFields::field, "ns2:Field"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__AdditionalFields::field.size() > 3000))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns2__AdditionalFields *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AdditionalFields, SOAP_TYPE_ns2__AdditionalFields, sizeof(ns2__AdditionalFields), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__AdditionalFields * SOAP_FMAC2 soap_instantiate_ns2__AdditionalFields(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AdditionalFields(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__AdditionalFields *p;
	size_t k = sizeof(ns2__AdditionalFields);
	if (n < 0)
	{	p = SOAP_NEW(ns2__AdditionalFields);
		if (p)
			((ns2__AdditionalFields*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__AdditionalFields, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__AdditionalFields*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__AdditionalFields location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__AdditionalFields, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__AdditionalFields::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:AdditionalFields", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AdditionalFields::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AdditionalFields(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AdditionalFields * SOAP_FMAC4 soap_get_ns2__AdditionalFields(struct soap *soap, ns2__AdditionalFields *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AdditionalFields(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DecisionReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DecisionReply::casePriority = NULL;
	this->ns2__DecisionReply::activeProfileReply = NULL;
	this->ns2__DecisionReply::velocityInfoCode = NULL;
	this->ns2__DecisionReply::additionalFields = NULL;
	/* transient soap skipped */
}

void ns2__DecisionReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__DecisionReply::casePriority);
	soap_serialize_PointerTons2__ProfileReply(soap, &this->ns2__DecisionReply::activeProfileReply);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DecisionReply::velocityInfoCode);
	soap_serialize_PointerTons2__AdditionalFields(soap, &this->ns2__DecisionReply::additionalFields);
#endif
}

int ns2__DecisionReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DecisionReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DecisionReply(struct soap *soap, const char *tag, int id, const ns2__DecisionReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DecisionReply), type))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:casePriority", -1, &a->ns2__DecisionReply::casePriority, ""))
		return soap->error;
	if (soap_out_PointerTons2__ProfileReply(soap, "ns2:activeProfileReply", -1, &a->ns2__DecisionReply::activeProfileReply, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:velocityInfoCode", -1, (wchar_t*const*)&a->ns2__DecisionReply::velocityInfoCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__AdditionalFields(soap, "ns2:additionalFields", -1, &a->ns2__DecisionReply::additionalFields, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DecisionReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DecisionReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DecisionReply * SOAP_FMAC4 soap_in_ns2__DecisionReply(struct soap *soap, const char *tag, ns2__DecisionReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DecisionReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DecisionReply, sizeof(ns2__DecisionReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DecisionReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DecisionReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_casePriority1 = 1;
	size_t soap_flag_activeProfileReply1 = 1;
	size_t soap_flag_velocityInfoCode1 = 1;
	size_t soap_flag_additionalFields1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_casePriority1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:casePriority", &a->ns2__DecisionReply::casePriority, "xsd:integer"))
				{	soap_flag_casePriority1--;
					continue;
				}
			if (soap_flag_activeProfileReply1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ProfileReply(soap, "ns2:activeProfileReply", &a->ns2__DecisionReply::activeProfileReply, "ns2:ProfileReply"))
				{	soap_flag_activeProfileReply1--;
					continue;
				}
			if (soap_flag_velocityInfoCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:velocityInfoCode", (wchar_t**)&a->ns2__DecisionReply::velocityInfoCode, "xsd:string"))
				{	soap_flag_velocityInfoCode1--;
					continue;
				}
			if (soap_flag_additionalFields1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AdditionalFields(soap, "ns2:additionalFields", &a->ns2__DecisionReply::additionalFields, "ns2:AdditionalFields"))
				{	soap_flag_additionalFields1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DecisionReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DecisionReply, SOAP_TYPE_ns2__DecisionReply, sizeof(ns2__DecisionReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DecisionReply * SOAP_FMAC2 soap_instantiate_ns2__DecisionReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DecisionReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DecisionReply *p;
	size_t k = sizeof(ns2__DecisionReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DecisionReply);
		if (p)
			((ns2__DecisionReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DecisionReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DecisionReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DecisionReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DecisionReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DecisionReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:DecisionReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DecisionReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DecisionReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DecisionReply * SOAP_FMAC4 soap_get_ns2__DecisionReply(struct soap *soap, ns2__DecisionReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DecisionReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__RuleResultItems::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__RuleResultItem(soap, &this->ns2__RuleResultItems::ruleResultItem);
	/* transient soap skipped */
}

void ns2__RuleResultItems::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__RuleResultItem(soap, &this->ns2__RuleResultItems::ruleResultItem);
#endif
}

int ns2__RuleResultItems::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RuleResultItems(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RuleResultItems(struct soap *soap, const char *tag, int id, const ns2__RuleResultItems *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RuleResultItems), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__RuleResultItem(soap, "ns2:ruleResultItem", -1, &a->ns2__RuleResultItems::ruleResultItem, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__RuleResultItems::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RuleResultItems(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RuleResultItems * SOAP_FMAC4 soap_in_ns2__RuleResultItems(struct soap *soap, const char *tag, ns2__RuleResultItems *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RuleResultItems *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RuleResultItems, sizeof(ns2__RuleResultItems), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__RuleResultItems)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__RuleResultItems *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__RuleResultItem(soap, "ns2:ruleResultItem", &a->ns2__RuleResultItems::ruleResultItem, "ns2:RuleResultItem"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__RuleResultItems::ruleResultItem.size() > 1000))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns2__RuleResultItems *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RuleResultItems, SOAP_TYPE_ns2__RuleResultItems, sizeof(ns2__RuleResultItems), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__RuleResultItems * SOAP_FMAC2 soap_instantiate_ns2__RuleResultItems(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RuleResultItems(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__RuleResultItems *p;
	size_t k = sizeof(ns2__RuleResultItems);
	if (n < 0)
	{	p = SOAP_NEW(ns2__RuleResultItems);
		if (p)
			((ns2__RuleResultItems*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__RuleResultItems, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__RuleResultItems*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__RuleResultItems location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__RuleResultItems, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__RuleResultItems::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:RuleResultItems", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RuleResultItems::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RuleResultItems(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RuleResultItems * SOAP_FMAC4 soap_get_ns2__RuleResultItems(struct soap *soap, ns2__RuleResultItems *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RuleResultItems(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__RuleResultItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RuleResultItem::name = NULL;
	this->ns2__RuleResultItem::decision = NULL;
	this->ns2__RuleResultItem::evaluation = NULL;
	this->ns2__RuleResultItem::ruleID = NULL;
	/* transient soap skipped */
}

void ns2__RuleResultItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RuleResultItem::name);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RuleResultItem::decision);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RuleResultItem::evaluation);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__RuleResultItem::ruleID);
#endif
}

int ns2__RuleResultItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RuleResultItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RuleResultItem(struct soap *soap, const char *tag, int id, const ns2__RuleResultItem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RuleResultItem), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:name", -1, (wchar_t*const*)&a->ns2__RuleResultItem::name, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:decision", -1, (wchar_t*const*)&a->ns2__RuleResultItem::decision, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:evaluation", -1, (wchar_t*const*)&a->ns2__RuleResultItem::evaluation, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:ruleID", -1, &a->ns2__RuleResultItem::ruleID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__RuleResultItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RuleResultItem(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RuleResultItem * SOAP_FMAC4 soap_in_ns2__RuleResultItem(struct soap *soap, const char *tag, ns2__RuleResultItem *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RuleResultItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RuleResultItem, sizeof(ns2__RuleResultItem), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__RuleResultItem)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__RuleResultItem *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_name1 = 1;
	size_t soap_flag_decision1 = 1;
	size_t soap_flag_evaluation1 = 1;
	size_t soap_flag_ruleID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:name", (wchar_t**)&a->ns2__RuleResultItem::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_decision1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:decision", (wchar_t**)&a->ns2__RuleResultItem::decision, "xsd:string"))
				{	soap_flag_decision1--;
					continue;
				}
			if (soap_flag_evaluation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:evaluation", (wchar_t**)&a->ns2__RuleResultItem::evaluation, "xsd:string"))
				{	soap_flag_evaluation1--;
					continue;
				}
			if (soap_flag_ruleID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:ruleID", &a->ns2__RuleResultItem::ruleID, "xsd:integer"))
				{	soap_flag_ruleID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RuleResultItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RuleResultItem, SOAP_TYPE_ns2__RuleResultItem, sizeof(ns2__RuleResultItem), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__RuleResultItem * SOAP_FMAC2 soap_instantiate_ns2__RuleResultItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RuleResultItem(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__RuleResultItem *p;
	size_t k = sizeof(ns2__RuleResultItem);
	if (n < 0)
	{	p = SOAP_NEW(ns2__RuleResultItem);
		if (p)
			((ns2__RuleResultItem*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__RuleResultItem, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__RuleResultItem*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__RuleResultItem location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__RuleResultItem, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__RuleResultItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:RuleResultItem", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RuleResultItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RuleResultItem(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RuleResultItem * SOAP_FMAC4 soap_get_ns2__RuleResultItem(struct soap *soap, ns2__RuleResultItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RuleResultItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CaseManagementActionReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CaseManagementActionReply::reasonCode = NULL;
	/* transient soap skipped */
}

void ns2__CaseManagementActionReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__CaseManagementActionReply::reasonCode);
#endif
}

int ns2__CaseManagementActionReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CaseManagementActionReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CaseManagementActionReply(struct soap *soap, const char *tag, int id, const ns2__CaseManagementActionReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CaseManagementActionReply), type))
		return soap->error;
	if (!a->ns2__CaseManagementActionReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__CaseManagementActionReply::reasonCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CaseManagementActionReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CaseManagementActionReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CaseManagementActionReply * SOAP_FMAC4 soap_in_ns2__CaseManagementActionReply(struct soap *soap, const char *tag, ns2__CaseManagementActionReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CaseManagementActionReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CaseManagementActionReply, sizeof(ns2__CaseManagementActionReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CaseManagementActionReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CaseManagementActionReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__CaseManagementActionReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__CaseManagementActionReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CaseManagementActionReply, SOAP_TYPE_ns2__CaseManagementActionReply, sizeof(ns2__CaseManagementActionReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CaseManagementActionReply * SOAP_FMAC2 soap_instantiate_ns2__CaseManagementActionReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CaseManagementActionReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CaseManagementActionReply *p;
	size_t k = sizeof(ns2__CaseManagementActionReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CaseManagementActionReply);
		if (p)
			((ns2__CaseManagementActionReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CaseManagementActionReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CaseManagementActionReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CaseManagementActionReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CaseManagementActionReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CaseManagementActionReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CaseManagementActionReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CaseManagementActionReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CaseManagementActionReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CaseManagementActionReply * SOAP_FMAC4 soap_get_ns2__CaseManagementActionReply(struct soap *soap, ns2__CaseManagementActionReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CaseManagementActionReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__FraudUpdateReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__FraudUpdateReply::reasonCode = NULL;
	/* transient soap skipped */
}

void ns2__FraudUpdateReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__FraudUpdateReply::reasonCode);
#endif
}

int ns2__FraudUpdateReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FraudUpdateReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FraudUpdateReply(struct soap *soap, const char *tag, int id, const ns2__FraudUpdateReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FraudUpdateReply), type))
		return soap->error;
	if (!a->ns2__FraudUpdateReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__FraudUpdateReply::reasonCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__FraudUpdateReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FraudUpdateReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FraudUpdateReply * SOAP_FMAC4 soap_in_ns2__FraudUpdateReply(struct soap *soap, const char *tag, ns2__FraudUpdateReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FraudUpdateReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FraudUpdateReply, sizeof(ns2__FraudUpdateReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__FraudUpdateReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__FraudUpdateReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__FraudUpdateReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__FraudUpdateReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FraudUpdateReply, SOAP_TYPE_ns2__FraudUpdateReply, sizeof(ns2__FraudUpdateReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__FraudUpdateReply * SOAP_FMAC2 soap_instantiate_ns2__FraudUpdateReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FraudUpdateReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__FraudUpdateReply *p;
	size_t k = sizeof(ns2__FraudUpdateReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__FraudUpdateReply);
		if (p)
			((ns2__FraudUpdateReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__FraudUpdateReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__FraudUpdateReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__FraudUpdateReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__FraudUpdateReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__FraudUpdateReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:FraudUpdateReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FraudUpdateReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FraudUpdateReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FraudUpdateReply * SOAP_FMAC4 soap_get_ns2__FraudUpdateReply(struct soap *soap, ns2__FraudUpdateReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FraudUpdateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__RiskUpdateReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RiskUpdateReply::reasonCode = NULL;
	/* transient soap skipped */
}

void ns2__RiskUpdateReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__RiskUpdateReply::reasonCode);
#endif
}

int ns2__RiskUpdateReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RiskUpdateReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RiskUpdateReply(struct soap *soap, const char *tag, int id, const ns2__RiskUpdateReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RiskUpdateReply), type))
		return soap->error;
	if (!a->ns2__RiskUpdateReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__RiskUpdateReply::reasonCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__RiskUpdateReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RiskUpdateReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RiskUpdateReply * SOAP_FMAC4 soap_in_ns2__RiskUpdateReply(struct soap *soap, const char *tag, ns2__RiskUpdateReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RiskUpdateReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RiskUpdateReply, sizeof(ns2__RiskUpdateReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__RiskUpdateReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__RiskUpdateReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__RiskUpdateReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__RiskUpdateReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RiskUpdateReply, SOAP_TYPE_ns2__RiskUpdateReply, sizeof(ns2__RiskUpdateReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__RiskUpdateReply * SOAP_FMAC2 soap_instantiate_ns2__RiskUpdateReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RiskUpdateReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__RiskUpdateReply *p;
	size_t k = sizeof(ns2__RiskUpdateReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__RiskUpdateReply);
		if (p)
			((ns2__RiskUpdateReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__RiskUpdateReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__RiskUpdateReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__RiskUpdateReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__RiskUpdateReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__RiskUpdateReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:RiskUpdateReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RiskUpdateReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RiskUpdateReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RiskUpdateReply * SOAP_FMAC4 soap_get_ns2__RiskUpdateReply(struct soap *soap, ns2__RiskUpdateReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RiskUpdateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalDoRefTransactionReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalDoRefTransactionReply::reasonCode = NULL;
	this->ns2__PayPalDoRefTransactionReply::paypalBillingAgreementId = NULL;
	this->ns2__PayPalDoRefTransactionReply::transactionId = NULL;
	this->ns2__PayPalDoRefTransactionReply::paypalTransactionType = NULL;
	this->ns2__PayPalDoRefTransactionReply::paypalPaymentType = NULL;
	this->ns2__PayPalDoRefTransactionReply::paypalOrderTime = NULL;
	this->ns2__PayPalDoRefTransactionReply::paypalAmount = NULL;
	this->ns2__PayPalDoRefTransactionReply::currency = NULL;
	this->ns2__PayPalDoRefTransactionReply::paypalTaxAmount = NULL;
	this->ns2__PayPalDoRefTransactionReply::paypalExchangeRate = NULL;
	this->ns2__PayPalDoRefTransactionReply::paypalPaymentStatus = NULL;
	this->ns2__PayPalDoRefTransactionReply::paypalPendingReason = NULL;
	this->ns2__PayPalDoRefTransactionReply::paypalReasonCode = NULL;
	this->ns2__PayPalDoRefTransactionReply::errorCode = NULL;
	this->ns2__PayPalDoRefTransactionReply::correlationID = NULL;
	/* transient soap skipped */
}

void ns2__PayPalDoRefTransactionReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionReply::paypalBillingAgreementId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionReply::transactionId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionReply::paypalTransactionType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionReply::paypalPaymentType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionReply::paypalOrderTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionReply::paypalAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionReply::currency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionReply::paypalTaxAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionReply::paypalExchangeRate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionReply::paypalPaymentStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionReply::paypalPendingReason);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionReply::paypalReasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionReply::errorCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionReply::correlationID);
#endif
}

int ns2__PayPalDoRefTransactionReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalDoRefTransactionReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalDoRefTransactionReply(struct soap *soap, const char *tag, int id, const ns2__PayPalDoRefTransactionReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalDoRefTransactionReply), type))
		return soap->error;
	if (!a->ns2__PayPalDoRefTransactionReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalBillingAgreementId", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionReply::paypalBillingAgreementId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionId", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionReply::transactionId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalTransactionType", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionReply::paypalTransactionType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPaymentType", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionReply::paypalPaymentType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalOrderTime", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionReply::paypalOrderTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalAmount", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionReply::paypalAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:currency", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionReply::currency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalTaxAmount", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionReply::paypalTaxAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalExchangeRate", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionReply::paypalExchangeRate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPaymentStatus", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionReply::paypalPaymentStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPendingReason", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionReply::paypalPendingReason, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalReasonCode", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionReply::paypalReasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:errorCode", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionReply::errorCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:correlationID", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionReply::correlationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalDoRefTransactionReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalDoRefTransactionReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalDoRefTransactionReply * SOAP_FMAC4 soap_in_ns2__PayPalDoRefTransactionReply(struct soap *soap, const char *tag, ns2__PayPalDoRefTransactionReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalDoRefTransactionReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalDoRefTransactionReply, sizeof(ns2__PayPalDoRefTransactionReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalDoRefTransactionReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalDoRefTransactionReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_paypalBillingAgreementId1 = 1;
	size_t soap_flag_transactionId1 = 1;
	size_t soap_flag_paypalTransactionType1 = 1;
	size_t soap_flag_paypalPaymentType1 = 1;
	size_t soap_flag_paypalOrderTime1 = 1;
	size_t soap_flag_paypalAmount1 = 1;
	size_t soap_flag_currency1 = 1;
	size_t soap_flag_paypalTaxAmount1 = 1;
	size_t soap_flag_paypalExchangeRate1 = 1;
	size_t soap_flag_paypalPaymentStatus1 = 1;
	size_t soap_flag_paypalPendingReason1 = 1;
	size_t soap_flag_paypalReasonCode1 = 1;
	size_t soap_flag_errorCode1 = 1;
	size_t soap_flag_correlationID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PayPalDoRefTransactionReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_paypalBillingAgreementId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalBillingAgreementId", (wchar_t**)&a->ns2__PayPalDoRefTransactionReply::paypalBillingAgreementId, "xsd:string"))
				{	soap_flag_paypalBillingAgreementId1--;
					continue;
				}
			if (soap_flag_transactionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionId", (wchar_t**)&a->ns2__PayPalDoRefTransactionReply::transactionId, "xsd:string"))
				{	soap_flag_transactionId1--;
					continue;
				}
			if (soap_flag_paypalTransactionType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalTransactionType", (wchar_t**)&a->ns2__PayPalDoRefTransactionReply::paypalTransactionType, "xsd:string"))
				{	soap_flag_paypalTransactionType1--;
					continue;
				}
			if (soap_flag_paypalPaymentType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPaymentType", (wchar_t**)&a->ns2__PayPalDoRefTransactionReply::paypalPaymentType, "xsd:string"))
				{	soap_flag_paypalPaymentType1--;
					continue;
				}
			if (soap_flag_paypalOrderTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalOrderTime", (wchar_t**)&a->ns2__PayPalDoRefTransactionReply::paypalOrderTime, "xsd:string"))
				{	soap_flag_paypalOrderTime1--;
					continue;
				}
			if (soap_flag_paypalAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalAmount", (wchar_t**)&a->ns2__PayPalDoRefTransactionReply::paypalAmount, "xsd:string"))
				{	soap_flag_paypalAmount1--;
					continue;
				}
			if (soap_flag_currency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:currency", (wchar_t**)&a->ns2__PayPalDoRefTransactionReply::currency, "xsd:string"))
				{	soap_flag_currency1--;
					continue;
				}
			if (soap_flag_paypalTaxAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalTaxAmount", (wchar_t**)&a->ns2__PayPalDoRefTransactionReply::paypalTaxAmount, "xsd:string"))
				{	soap_flag_paypalTaxAmount1--;
					continue;
				}
			if (soap_flag_paypalExchangeRate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalExchangeRate", (wchar_t**)&a->ns2__PayPalDoRefTransactionReply::paypalExchangeRate, "xsd:string"))
				{	soap_flag_paypalExchangeRate1--;
					continue;
				}
			if (soap_flag_paypalPaymentStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPaymentStatus", (wchar_t**)&a->ns2__PayPalDoRefTransactionReply::paypalPaymentStatus, "xsd:string"))
				{	soap_flag_paypalPaymentStatus1--;
					continue;
				}
			if (soap_flag_paypalPendingReason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPendingReason", (wchar_t**)&a->ns2__PayPalDoRefTransactionReply::paypalPendingReason, "xsd:string"))
				{	soap_flag_paypalPendingReason1--;
					continue;
				}
			if (soap_flag_paypalReasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalReasonCode", (wchar_t**)&a->ns2__PayPalDoRefTransactionReply::paypalReasonCode, "xsd:string"))
				{	soap_flag_paypalReasonCode1--;
					continue;
				}
			if (soap_flag_errorCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:errorCode", (wchar_t**)&a->ns2__PayPalDoRefTransactionReply::errorCode, "xsd:string"))
				{	soap_flag_errorCode1--;
					continue;
				}
			if (soap_flag_correlationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:correlationID", (wchar_t**)&a->ns2__PayPalDoRefTransactionReply::correlationID, "xsd:string"))
				{	soap_flag_correlationID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PayPalDoRefTransactionReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalDoRefTransactionReply, SOAP_TYPE_ns2__PayPalDoRefTransactionReply, sizeof(ns2__PayPalDoRefTransactionReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalDoRefTransactionReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalDoRefTransactionReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalDoRefTransactionReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalDoRefTransactionReply *p;
	size_t k = sizeof(ns2__PayPalDoRefTransactionReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalDoRefTransactionReply);
		if (p)
			((ns2__PayPalDoRefTransactionReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalDoRefTransactionReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalDoRefTransactionReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalDoRefTransactionReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalDoRefTransactionReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalDoRefTransactionReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalDoRefTransactionReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalDoRefTransactionReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalDoRefTransactionReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalDoRefTransactionReply * SOAP_FMAC4 soap_get_ns2__PayPalDoRefTransactionReply(struct soap *soap, ns2__PayPalDoRefTransactionReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalDoRefTransactionReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalCreateAgreementReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalCreateAgreementReply::reasonCode = NULL;
	this->ns2__PayPalCreateAgreementReply::paypalBillingAgreementId = NULL;
	this->ns2__PayPalCreateAgreementReply::errorCode = NULL;
	this->ns2__PayPalCreateAgreementReply::correlationID = NULL;
	/* transient soap skipped */
}

void ns2__PayPalCreateAgreementReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PayPalCreateAgreementReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalCreateAgreementReply::paypalBillingAgreementId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalCreateAgreementReply::errorCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalCreateAgreementReply::correlationID);
#endif
}

int ns2__PayPalCreateAgreementReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalCreateAgreementReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalCreateAgreementReply(struct soap *soap, const char *tag, int id, const ns2__PayPalCreateAgreementReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalCreateAgreementReply), type))
		return soap->error;
	if (!a->ns2__PayPalCreateAgreementReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PayPalCreateAgreementReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalBillingAgreementId", -1, (wchar_t*const*)&a->ns2__PayPalCreateAgreementReply::paypalBillingAgreementId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:errorCode", -1, (wchar_t*const*)&a->ns2__PayPalCreateAgreementReply::errorCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:correlationID", -1, (wchar_t*const*)&a->ns2__PayPalCreateAgreementReply::correlationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalCreateAgreementReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalCreateAgreementReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalCreateAgreementReply * SOAP_FMAC4 soap_in_ns2__PayPalCreateAgreementReply(struct soap *soap, const char *tag, ns2__PayPalCreateAgreementReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalCreateAgreementReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalCreateAgreementReply, sizeof(ns2__PayPalCreateAgreementReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalCreateAgreementReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalCreateAgreementReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_paypalBillingAgreementId1 = 1;
	size_t soap_flag_errorCode1 = 1;
	size_t soap_flag_correlationID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PayPalCreateAgreementReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_paypalBillingAgreementId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalBillingAgreementId", (wchar_t**)&a->ns2__PayPalCreateAgreementReply::paypalBillingAgreementId, "xsd:string"))
				{	soap_flag_paypalBillingAgreementId1--;
					continue;
				}
			if (soap_flag_errorCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:errorCode", (wchar_t**)&a->ns2__PayPalCreateAgreementReply::errorCode, "xsd:string"))
				{	soap_flag_errorCode1--;
					continue;
				}
			if (soap_flag_correlationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:correlationID", (wchar_t**)&a->ns2__PayPalCreateAgreementReply::correlationID, "xsd:string"))
				{	soap_flag_correlationID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PayPalCreateAgreementReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalCreateAgreementReply, SOAP_TYPE_ns2__PayPalCreateAgreementReply, sizeof(ns2__PayPalCreateAgreementReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalCreateAgreementReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalCreateAgreementReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalCreateAgreementReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalCreateAgreementReply *p;
	size_t k = sizeof(ns2__PayPalCreateAgreementReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalCreateAgreementReply);
		if (p)
			((ns2__PayPalCreateAgreementReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalCreateAgreementReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalCreateAgreementReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalCreateAgreementReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalCreateAgreementReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalCreateAgreementReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalCreateAgreementReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalCreateAgreementReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalCreateAgreementReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalCreateAgreementReply * SOAP_FMAC4 soap_get_ns2__PayPalCreateAgreementReply(struct soap *soap, ns2__PayPalCreateAgreementReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalCreateAgreementReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalUpdateAgreementReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalUpdateAgreementReply::reasonCode = NULL;
	this->ns2__PayPalUpdateAgreementReply::paypalBillingAgreementId = NULL;
	this->ns2__PayPalUpdateAgreementReply::paypalBillingAgreementDesc = NULL;
	this->ns2__PayPalUpdateAgreementReply::paypalBillingAgreementCustom = NULL;
	this->ns2__PayPalUpdateAgreementReply::paypalBillingAgreementStatus = NULL;
	this->ns2__PayPalUpdateAgreementReply::payer = NULL;
	this->ns2__PayPalUpdateAgreementReply::payerId = NULL;
	this->ns2__PayPalUpdateAgreementReply::payerStatus = NULL;
	this->ns2__PayPalUpdateAgreementReply::payerCountry = NULL;
	this->ns2__PayPalUpdateAgreementReply::payerBusiness = NULL;
	this->ns2__PayPalUpdateAgreementReply::payerSalutation = NULL;
	this->ns2__PayPalUpdateAgreementReply::payerFirstname = NULL;
	this->ns2__PayPalUpdateAgreementReply::payerMiddlename = NULL;
	this->ns2__PayPalUpdateAgreementReply::payerLastname = NULL;
	this->ns2__PayPalUpdateAgreementReply::payerSuffix = NULL;
	this->ns2__PayPalUpdateAgreementReply::addressStatus = NULL;
	this->ns2__PayPalUpdateAgreementReply::errorCode = NULL;
	this->ns2__PayPalUpdateAgreementReply::correlationID = NULL;
	/* transient soap skipped */
}

void ns2__PayPalUpdateAgreementReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PayPalUpdateAgreementReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalUpdateAgreementReply::paypalBillingAgreementId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalUpdateAgreementReply::paypalBillingAgreementDesc);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalUpdateAgreementReply::paypalBillingAgreementCustom);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalUpdateAgreementReply::paypalBillingAgreementStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalUpdateAgreementReply::payer);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalUpdateAgreementReply::payerId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalUpdateAgreementReply::payerStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalUpdateAgreementReply::payerCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalUpdateAgreementReply::payerBusiness);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalUpdateAgreementReply::payerSalutation);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalUpdateAgreementReply::payerFirstname);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalUpdateAgreementReply::payerMiddlename);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalUpdateAgreementReply::payerLastname);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalUpdateAgreementReply::payerSuffix);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalUpdateAgreementReply::addressStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalUpdateAgreementReply::errorCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalUpdateAgreementReply::correlationID);
#endif
}

int ns2__PayPalUpdateAgreementReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalUpdateAgreementReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalUpdateAgreementReply(struct soap *soap, const char *tag, int id, const ns2__PayPalUpdateAgreementReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalUpdateAgreementReply), type))
		return soap->error;
	if (!a->ns2__PayPalUpdateAgreementReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PayPalUpdateAgreementReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalBillingAgreementId", -1, (wchar_t*const*)&a->ns2__PayPalUpdateAgreementReply::paypalBillingAgreementId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalBillingAgreementDesc", -1, (wchar_t*const*)&a->ns2__PayPalUpdateAgreementReply::paypalBillingAgreementDesc, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalBillingAgreementCustom", -1, (wchar_t*const*)&a->ns2__PayPalUpdateAgreementReply::paypalBillingAgreementCustom, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalBillingAgreementStatus", -1, (wchar_t*const*)&a->ns2__PayPalUpdateAgreementReply::paypalBillingAgreementStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payer", -1, (wchar_t*const*)&a->ns2__PayPalUpdateAgreementReply::payer, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerId", -1, (wchar_t*const*)&a->ns2__PayPalUpdateAgreementReply::payerId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerStatus", -1, (wchar_t*const*)&a->ns2__PayPalUpdateAgreementReply::payerStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerCountry", -1, (wchar_t*const*)&a->ns2__PayPalUpdateAgreementReply::payerCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerBusiness", -1, (wchar_t*const*)&a->ns2__PayPalUpdateAgreementReply::payerBusiness, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerSalutation", -1, (wchar_t*const*)&a->ns2__PayPalUpdateAgreementReply::payerSalutation, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerFirstname", -1, (wchar_t*const*)&a->ns2__PayPalUpdateAgreementReply::payerFirstname, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerMiddlename", -1, (wchar_t*const*)&a->ns2__PayPalUpdateAgreementReply::payerMiddlename, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerLastname", -1, (wchar_t*const*)&a->ns2__PayPalUpdateAgreementReply::payerLastname, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerSuffix", -1, (wchar_t*const*)&a->ns2__PayPalUpdateAgreementReply::payerSuffix, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:addressStatus", -1, (wchar_t*const*)&a->ns2__PayPalUpdateAgreementReply::addressStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:errorCode", -1, (wchar_t*const*)&a->ns2__PayPalUpdateAgreementReply::errorCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:correlationID", -1, (wchar_t*const*)&a->ns2__PayPalUpdateAgreementReply::correlationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalUpdateAgreementReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalUpdateAgreementReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalUpdateAgreementReply * SOAP_FMAC4 soap_in_ns2__PayPalUpdateAgreementReply(struct soap *soap, const char *tag, ns2__PayPalUpdateAgreementReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalUpdateAgreementReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalUpdateAgreementReply, sizeof(ns2__PayPalUpdateAgreementReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalUpdateAgreementReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalUpdateAgreementReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_paypalBillingAgreementId1 = 1;
	size_t soap_flag_paypalBillingAgreementDesc1 = 1;
	size_t soap_flag_paypalBillingAgreementCustom1 = 1;
	size_t soap_flag_paypalBillingAgreementStatus1 = 1;
	size_t soap_flag_payer1 = 1;
	size_t soap_flag_payerId1 = 1;
	size_t soap_flag_payerStatus1 = 1;
	size_t soap_flag_payerCountry1 = 1;
	size_t soap_flag_payerBusiness1 = 1;
	size_t soap_flag_payerSalutation1 = 1;
	size_t soap_flag_payerFirstname1 = 1;
	size_t soap_flag_payerMiddlename1 = 1;
	size_t soap_flag_payerLastname1 = 1;
	size_t soap_flag_payerSuffix1 = 1;
	size_t soap_flag_addressStatus1 = 1;
	size_t soap_flag_errorCode1 = 1;
	size_t soap_flag_correlationID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PayPalUpdateAgreementReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_paypalBillingAgreementId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalBillingAgreementId", (wchar_t**)&a->ns2__PayPalUpdateAgreementReply::paypalBillingAgreementId, "xsd:string"))
				{	soap_flag_paypalBillingAgreementId1--;
					continue;
				}
			if (soap_flag_paypalBillingAgreementDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalBillingAgreementDesc", (wchar_t**)&a->ns2__PayPalUpdateAgreementReply::paypalBillingAgreementDesc, "xsd:string"))
				{	soap_flag_paypalBillingAgreementDesc1--;
					continue;
				}
			if (soap_flag_paypalBillingAgreementCustom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalBillingAgreementCustom", (wchar_t**)&a->ns2__PayPalUpdateAgreementReply::paypalBillingAgreementCustom, "xsd:string"))
				{	soap_flag_paypalBillingAgreementCustom1--;
					continue;
				}
			if (soap_flag_paypalBillingAgreementStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalBillingAgreementStatus", (wchar_t**)&a->ns2__PayPalUpdateAgreementReply::paypalBillingAgreementStatus, "xsd:string"))
				{	soap_flag_paypalBillingAgreementStatus1--;
					continue;
				}
			if (soap_flag_payer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payer", (wchar_t**)&a->ns2__PayPalUpdateAgreementReply::payer, "xsd:string"))
				{	soap_flag_payer1--;
					continue;
				}
			if (soap_flag_payerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerId", (wchar_t**)&a->ns2__PayPalUpdateAgreementReply::payerId, "xsd:string"))
				{	soap_flag_payerId1--;
					continue;
				}
			if (soap_flag_payerStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerStatus", (wchar_t**)&a->ns2__PayPalUpdateAgreementReply::payerStatus, "xsd:string"))
				{	soap_flag_payerStatus1--;
					continue;
				}
			if (soap_flag_payerCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerCountry", (wchar_t**)&a->ns2__PayPalUpdateAgreementReply::payerCountry, "xsd:string"))
				{	soap_flag_payerCountry1--;
					continue;
				}
			if (soap_flag_payerBusiness1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerBusiness", (wchar_t**)&a->ns2__PayPalUpdateAgreementReply::payerBusiness, "xsd:string"))
				{	soap_flag_payerBusiness1--;
					continue;
				}
			if (soap_flag_payerSalutation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerSalutation", (wchar_t**)&a->ns2__PayPalUpdateAgreementReply::payerSalutation, "xsd:string"))
				{	soap_flag_payerSalutation1--;
					continue;
				}
			if (soap_flag_payerFirstname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerFirstname", (wchar_t**)&a->ns2__PayPalUpdateAgreementReply::payerFirstname, "xsd:string"))
				{	soap_flag_payerFirstname1--;
					continue;
				}
			if (soap_flag_payerMiddlename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerMiddlename", (wchar_t**)&a->ns2__PayPalUpdateAgreementReply::payerMiddlename, "xsd:string"))
				{	soap_flag_payerMiddlename1--;
					continue;
				}
			if (soap_flag_payerLastname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerLastname", (wchar_t**)&a->ns2__PayPalUpdateAgreementReply::payerLastname, "xsd:string"))
				{	soap_flag_payerLastname1--;
					continue;
				}
			if (soap_flag_payerSuffix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerSuffix", (wchar_t**)&a->ns2__PayPalUpdateAgreementReply::payerSuffix, "xsd:string"))
				{	soap_flag_payerSuffix1--;
					continue;
				}
			if (soap_flag_addressStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:addressStatus", (wchar_t**)&a->ns2__PayPalUpdateAgreementReply::addressStatus, "xsd:string"))
				{	soap_flag_addressStatus1--;
					continue;
				}
			if (soap_flag_errorCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:errorCode", (wchar_t**)&a->ns2__PayPalUpdateAgreementReply::errorCode, "xsd:string"))
				{	soap_flag_errorCode1--;
					continue;
				}
			if (soap_flag_correlationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:correlationID", (wchar_t**)&a->ns2__PayPalUpdateAgreementReply::correlationID, "xsd:string"))
				{	soap_flag_correlationID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PayPalUpdateAgreementReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalUpdateAgreementReply, SOAP_TYPE_ns2__PayPalUpdateAgreementReply, sizeof(ns2__PayPalUpdateAgreementReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalUpdateAgreementReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalUpdateAgreementReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalUpdateAgreementReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalUpdateAgreementReply *p;
	size_t k = sizeof(ns2__PayPalUpdateAgreementReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalUpdateAgreementReply);
		if (p)
			((ns2__PayPalUpdateAgreementReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalUpdateAgreementReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalUpdateAgreementReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalUpdateAgreementReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalUpdateAgreementReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalUpdateAgreementReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalUpdateAgreementReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalUpdateAgreementReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalUpdateAgreementReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalUpdateAgreementReply * SOAP_FMAC4 soap_get_ns2__PayPalUpdateAgreementReply(struct soap *soap, ns2__PayPalUpdateAgreementReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalUpdateAgreementReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalAuthorizationReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalAuthorizationReply::reasonCode = NULL;
	this->ns2__PayPalAuthorizationReply::transactionId = NULL;
	this->ns2__PayPalAuthorizationReply::paypalAmount = NULL;
	this->ns2__PayPalAuthorizationReply::amount = NULL;
	this->ns2__PayPalAuthorizationReply::currency = NULL;
	this->ns2__PayPalAuthorizationReply::correlationID = NULL;
	this->ns2__PayPalAuthorizationReply::errorCode = NULL;
	this->ns2__PayPalAuthorizationReply::protectionEligibility = NULL;
	this->ns2__PayPalAuthorizationReply::protectionEligibilityType = NULL;
	/* transient soap skipped */
}

void ns2__PayPalAuthorizationReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PayPalAuthorizationReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthorizationReply::transactionId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthorizationReply::paypalAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthorizationReply::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthorizationReply::currency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthorizationReply::correlationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthorizationReply::errorCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthorizationReply::protectionEligibility);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthorizationReply::protectionEligibilityType);
#endif
}

int ns2__PayPalAuthorizationReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalAuthorizationReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalAuthorizationReply(struct soap *soap, const char *tag, int id, const ns2__PayPalAuthorizationReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalAuthorizationReply), type))
		return soap->error;
	if (!a->ns2__PayPalAuthorizationReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PayPalAuthorizationReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionId", -1, (wchar_t*const*)&a->ns2__PayPalAuthorizationReply::transactionId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalAmount", -1, (wchar_t*const*)&a->ns2__PayPalAuthorizationReply::paypalAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:amount", -1, (wchar_t*const*)&a->ns2__PayPalAuthorizationReply::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:currency", -1, (wchar_t*const*)&a->ns2__PayPalAuthorizationReply::currency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:correlationID", -1, (wchar_t*const*)&a->ns2__PayPalAuthorizationReply::correlationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:errorCode", -1, (wchar_t*const*)&a->ns2__PayPalAuthorizationReply::errorCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:protectionEligibility", -1, (wchar_t*const*)&a->ns2__PayPalAuthorizationReply::protectionEligibility, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:protectionEligibilityType", -1, (wchar_t*const*)&a->ns2__PayPalAuthorizationReply::protectionEligibilityType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalAuthorizationReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalAuthorizationReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalAuthorizationReply * SOAP_FMAC4 soap_in_ns2__PayPalAuthorizationReply(struct soap *soap, const char *tag, ns2__PayPalAuthorizationReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalAuthorizationReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalAuthorizationReply, sizeof(ns2__PayPalAuthorizationReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalAuthorizationReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalAuthorizationReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_transactionId1 = 1;
	size_t soap_flag_paypalAmount1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_currency1 = 1;
	size_t soap_flag_correlationID1 = 1;
	size_t soap_flag_errorCode1 = 1;
	size_t soap_flag_protectionEligibility1 = 1;
	size_t soap_flag_protectionEligibilityType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PayPalAuthorizationReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_transactionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionId", (wchar_t**)&a->ns2__PayPalAuthorizationReply::transactionId, "xsd:string"))
				{	soap_flag_transactionId1--;
					continue;
				}
			if (soap_flag_paypalAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalAmount", (wchar_t**)&a->ns2__PayPalAuthorizationReply::paypalAmount, "xsd:string"))
				{	soap_flag_paypalAmount1--;
					continue;
				}
			if (soap_flag_amount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:amount", (wchar_t**)&a->ns2__PayPalAuthorizationReply::amount, "xsd:string"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_currency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:currency", (wchar_t**)&a->ns2__PayPalAuthorizationReply::currency, "xsd:string"))
				{	soap_flag_currency1--;
					continue;
				}
			if (soap_flag_correlationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:correlationID", (wchar_t**)&a->ns2__PayPalAuthorizationReply::correlationID, "xsd:string"))
				{	soap_flag_correlationID1--;
					continue;
				}
			if (soap_flag_errorCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:errorCode", (wchar_t**)&a->ns2__PayPalAuthorizationReply::errorCode, "xsd:string"))
				{	soap_flag_errorCode1--;
					continue;
				}
			if (soap_flag_protectionEligibility1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:protectionEligibility", (wchar_t**)&a->ns2__PayPalAuthorizationReply::protectionEligibility, "xsd:string"))
				{	soap_flag_protectionEligibility1--;
					continue;
				}
			if (soap_flag_protectionEligibilityType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:protectionEligibilityType", (wchar_t**)&a->ns2__PayPalAuthorizationReply::protectionEligibilityType, "xsd:string"))
				{	soap_flag_protectionEligibilityType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PayPalAuthorizationReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalAuthorizationReply, SOAP_TYPE_ns2__PayPalAuthorizationReply, sizeof(ns2__PayPalAuthorizationReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalAuthorizationReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalAuthorizationReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalAuthorizationReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalAuthorizationReply *p;
	size_t k = sizeof(ns2__PayPalAuthorizationReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalAuthorizationReply);
		if (p)
			((ns2__PayPalAuthorizationReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalAuthorizationReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalAuthorizationReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalAuthorizationReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalAuthorizationReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalAuthorizationReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalAuthorizationReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalAuthorizationReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalAuthorizationReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalAuthorizationReply * SOAP_FMAC4 soap_get_ns2__PayPalAuthorizationReply(struct soap *soap, ns2__PayPalAuthorizationReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalAuthorizationReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalEcOrderSetupReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalEcOrderSetupReply::reasonCode = NULL;
	this->ns2__PayPalEcOrderSetupReply::paypalToken = NULL;
	this->ns2__PayPalEcOrderSetupReply::transactionId = NULL;
	this->ns2__PayPalEcOrderSetupReply::paypalTransactiontype = NULL;
	this->ns2__PayPalEcOrderSetupReply::paymentType = NULL;
	this->ns2__PayPalEcOrderSetupReply::paypalOrderTime = NULL;
	this->ns2__PayPalEcOrderSetupReply::paypalAmount = NULL;
	this->ns2__PayPalEcOrderSetupReply::paypalFeeAmount = NULL;
	this->ns2__PayPalEcOrderSetupReply::paypalTaxAmount = NULL;
	this->ns2__PayPalEcOrderSetupReply::paypalExchangeRate = NULL;
	this->ns2__PayPalEcOrderSetupReply::paypalPaymentStatus = NULL;
	this->ns2__PayPalEcOrderSetupReply::paypalPendingReason = NULL;
	this->ns2__PayPalEcOrderSetupReply::paypalReasonCode = NULL;
	this->ns2__PayPalEcOrderSetupReply::amount = NULL;
	this->ns2__PayPalEcOrderSetupReply::currency = NULL;
	this->ns2__PayPalEcOrderSetupReply::correlationID = NULL;
	this->ns2__PayPalEcOrderSetupReply::errorCode = NULL;
	/* transient soap skipped */
}

void ns2__PayPalEcOrderSetupReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupReply::paypalToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupReply::transactionId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupReply::paypalTransactiontype);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupReply::paymentType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupReply::paypalOrderTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupReply::paypalAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupReply::paypalFeeAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupReply::paypalTaxAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupReply::paypalExchangeRate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupReply::paypalPaymentStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupReply::paypalPendingReason);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupReply::paypalReasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupReply::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupReply::currency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupReply::correlationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupReply::errorCode);
#endif
}

int ns2__PayPalEcOrderSetupReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalEcOrderSetupReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalEcOrderSetupReply(struct soap *soap, const char *tag, int id, const ns2__PayPalEcOrderSetupReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalEcOrderSetupReply), type))
		return soap->error;
	if (!a->ns2__PayPalEcOrderSetupReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalToken", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupReply::paypalToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionId", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupReply::transactionId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalTransactiontype", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupReply::paypalTransactiontype, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentType", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupReply::paymentType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalOrderTime", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupReply::paypalOrderTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalAmount", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupReply::paypalAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalFeeAmount", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupReply::paypalFeeAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalTaxAmount", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupReply::paypalTaxAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalExchangeRate", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupReply::paypalExchangeRate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPaymentStatus", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupReply::paypalPaymentStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPendingReason", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupReply::paypalPendingReason, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalReasonCode", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupReply::paypalReasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:amount", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupReply::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:currency", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupReply::currency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:correlationID", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupReply::correlationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:errorCode", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupReply::errorCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalEcOrderSetupReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalEcOrderSetupReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalEcOrderSetupReply * SOAP_FMAC4 soap_in_ns2__PayPalEcOrderSetupReply(struct soap *soap, const char *tag, ns2__PayPalEcOrderSetupReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalEcOrderSetupReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalEcOrderSetupReply, sizeof(ns2__PayPalEcOrderSetupReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalEcOrderSetupReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalEcOrderSetupReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_paypalToken1 = 1;
	size_t soap_flag_transactionId1 = 1;
	size_t soap_flag_paypalTransactiontype1 = 1;
	size_t soap_flag_paymentType1 = 1;
	size_t soap_flag_paypalOrderTime1 = 1;
	size_t soap_flag_paypalAmount1 = 1;
	size_t soap_flag_paypalFeeAmount1 = 1;
	size_t soap_flag_paypalTaxAmount1 = 1;
	size_t soap_flag_paypalExchangeRate1 = 1;
	size_t soap_flag_paypalPaymentStatus1 = 1;
	size_t soap_flag_paypalPendingReason1 = 1;
	size_t soap_flag_paypalReasonCode1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_currency1 = 1;
	size_t soap_flag_correlationID1 = 1;
	size_t soap_flag_errorCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PayPalEcOrderSetupReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_paypalToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalToken", (wchar_t**)&a->ns2__PayPalEcOrderSetupReply::paypalToken, "xsd:string"))
				{	soap_flag_paypalToken1--;
					continue;
				}
			if (soap_flag_transactionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionId", (wchar_t**)&a->ns2__PayPalEcOrderSetupReply::transactionId, "xsd:string"))
				{	soap_flag_transactionId1--;
					continue;
				}
			if (soap_flag_paypalTransactiontype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalTransactiontype", (wchar_t**)&a->ns2__PayPalEcOrderSetupReply::paypalTransactiontype, "xsd:string"))
				{	soap_flag_paypalTransactiontype1--;
					continue;
				}
			if (soap_flag_paymentType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentType", (wchar_t**)&a->ns2__PayPalEcOrderSetupReply::paymentType, "xsd:string"))
				{	soap_flag_paymentType1--;
					continue;
				}
			if (soap_flag_paypalOrderTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalOrderTime", (wchar_t**)&a->ns2__PayPalEcOrderSetupReply::paypalOrderTime, "xsd:string"))
				{	soap_flag_paypalOrderTime1--;
					continue;
				}
			if (soap_flag_paypalAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalAmount", (wchar_t**)&a->ns2__PayPalEcOrderSetupReply::paypalAmount, "xsd:string"))
				{	soap_flag_paypalAmount1--;
					continue;
				}
			if (soap_flag_paypalFeeAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalFeeAmount", (wchar_t**)&a->ns2__PayPalEcOrderSetupReply::paypalFeeAmount, "xsd:string"))
				{	soap_flag_paypalFeeAmount1--;
					continue;
				}
			if (soap_flag_paypalTaxAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalTaxAmount", (wchar_t**)&a->ns2__PayPalEcOrderSetupReply::paypalTaxAmount, "xsd:string"))
				{	soap_flag_paypalTaxAmount1--;
					continue;
				}
			if (soap_flag_paypalExchangeRate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalExchangeRate", (wchar_t**)&a->ns2__PayPalEcOrderSetupReply::paypalExchangeRate, "xsd:string"))
				{	soap_flag_paypalExchangeRate1--;
					continue;
				}
			if (soap_flag_paypalPaymentStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPaymentStatus", (wchar_t**)&a->ns2__PayPalEcOrderSetupReply::paypalPaymentStatus, "xsd:string"))
				{	soap_flag_paypalPaymentStatus1--;
					continue;
				}
			if (soap_flag_paypalPendingReason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPendingReason", (wchar_t**)&a->ns2__PayPalEcOrderSetupReply::paypalPendingReason, "xsd:string"))
				{	soap_flag_paypalPendingReason1--;
					continue;
				}
			if (soap_flag_paypalReasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalReasonCode", (wchar_t**)&a->ns2__PayPalEcOrderSetupReply::paypalReasonCode, "xsd:string"))
				{	soap_flag_paypalReasonCode1--;
					continue;
				}
			if (soap_flag_amount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:amount", (wchar_t**)&a->ns2__PayPalEcOrderSetupReply::amount, "xsd:string"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_currency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:currency", (wchar_t**)&a->ns2__PayPalEcOrderSetupReply::currency, "xsd:string"))
				{	soap_flag_currency1--;
					continue;
				}
			if (soap_flag_correlationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:correlationID", (wchar_t**)&a->ns2__PayPalEcOrderSetupReply::correlationID, "xsd:string"))
				{	soap_flag_correlationID1--;
					continue;
				}
			if (soap_flag_errorCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:errorCode", (wchar_t**)&a->ns2__PayPalEcOrderSetupReply::errorCode, "xsd:string"))
				{	soap_flag_errorCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PayPalEcOrderSetupReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalEcOrderSetupReply, SOAP_TYPE_ns2__PayPalEcOrderSetupReply, sizeof(ns2__PayPalEcOrderSetupReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalEcOrderSetupReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcOrderSetupReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalEcOrderSetupReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalEcOrderSetupReply *p;
	size_t k = sizeof(ns2__PayPalEcOrderSetupReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalEcOrderSetupReply);
		if (p)
			((ns2__PayPalEcOrderSetupReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalEcOrderSetupReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalEcOrderSetupReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalEcOrderSetupReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalEcOrderSetupReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalEcOrderSetupReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalEcOrderSetupReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalEcOrderSetupReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalEcOrderSetupReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalEcOrderSetupReply * SOAP_FMAC4 soap_get_ns2__PayPalEcOrderSetupReply(struct soap *soap, ns2__PayPalEcOrderSetupReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalEcOrderSetupReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalRefundReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalRefundReply::reasonCode = NULL;
	this->ns2__PayPalRefundReply::transactionId = NULL;
	this->ns2__PayPalRefundReply::paypalNetRefundAmount = NULL;
	this->ns2__PayPalRefundReply::paypalFeeRefundAmount = NULL;
	this->ns2__PayPalRefundReply::paypalGrossRefundAmount = NULL;
	this->ns2__PayPalRefundReply::correlationID = NULL;
	this->ns2__PayPalRefundReply::errorCode = NULL;
	/* transient soap skipped */
}

void ns2__PayPalRefundReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PayPalRefundReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalRefundReply::transactionId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalRefundReply::paypalNetRefundAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalRefundReply::paypalFeeRefundAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalRefundReply::paypalGrossRefundAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalRefundReply::correlationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalRefundReply::errorCode);
#endif
}

int ns2__PayPalRefundReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalRefundReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalRefundReply(struct soap *soap, const char *tag, int id, const ns2__PayPalRefundReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalRefundReply), type))
		return soap->error;
	if (!a->ns2__PayPalRefundReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PayPalRefundReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionId", -1, (wchar_t*const*)&a->ns2__PayPalRefundReply::transactionId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalNetRefundAmount", -1, (wchar_t*const*)&a->ns2__PayPalRefundReply::paypalNetRefundAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalFeeRefundAmount", -1, (wchar_t*const*)&a->ns2__PayPalRefundReply::paypalFeeRefundAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalGrossRefundAmount", -1, (wchar_t*const*)&a->ns2__PayPalRefundReply::paypalGrossRefundAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:correlationID", -1, (wchar_t*const*)&a->ns2__PayPalRefundReply::correlationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:errorCode", -1, (wchar_t*const*)&a->ns2__PayPalRefundReply::errorCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalRefundReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalRefundReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalRefundReply * SOAP_FMAC4 soap_in_ns2__PayPalRefundReply(struct soap *soap, const char *tag, ns2__PayPalRefundReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalRefundReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalRefundReply, sizeof(ns2__PayPalRefundReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalRefundReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalRefundReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_transactionId1 = 1;
	size_t soap_flag_paypalNetRefundAmount1 = 1;
	size_t soap_flag_paypalFeeRefundAmount1 = 1;
	size_t soap_flag_paypalGrossRefundAmount1 = 1;
	size_t soap_flag_correlationID1 = 1;
	size_t soap_flag_errorCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PayPalRefundReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_transactionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionId", (wchar_t**)&a->ns2__PayPalRefundReply::transactionId, "xsd:string"))
				{	soap_flag_transactionId1--;
					continue;
				}
			if (soap_flag_paypalNetRefundAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalNetRefundAmount", (wchar_t**)&a->ns2__PayPalRefundReply::paypalNetRefundAmount, "xsd:string"))
				{	soap_flag_paypalNetRefundAmount1--;
					continue;
				}
			if (soap_flag_paypalFeeRefundAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalFeeRefundAmount", (wchar_t**)&a->ns2__PayPalRefundReply::paypalFeeRefundAmount, "xsd:string"))
				{	soap_flag_paypalFeeRefundAmount1--;
					continue;
				}
			if (soap_flag_paypalGrossRefundAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalGrossRefundAmount", (wchar_t**)&a->ns2__PayPalRefundReply::paypalGrossRefundAmount, "xsd:string"))
				{	soap_flag_paypalGrossRefundAmount1--;
					continue;
				}
			if (soap_flag_correlationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:correlationID", (wchar_t**)&a->ns2__PayPalRefundReply::correlationID, "xsd:string"))
				{	soap_flag_correlationID1--;
					continue;
				}
			if (soap_flag_errorCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:errorCode", (wchar_t**)&a->ns2__PayPalRefundReply::errorCode, "xsd:string"))
				{	soap_flag_errorCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PayPalRefundReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalRefundReply, SOAP_TYPE_ns2__PayPalRefundReply, sizeof(ns2__PayPalRefundReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalRefundReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalRefundReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalRefundReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalRefundReply *p;
	size_t k = sizeof(ns2__PayPalRefundReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalRefundReply);
		if (p)
			((ns2__PayPalRefundReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalRefundReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalRefundReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalRefundReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalRefundReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalRefundReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalRefundReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalRefundReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalRefundReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalRefundReply * SOAP_FMAC4 soap_get_ns2__PayPalRefundReply(struct soap *soap, ns2__PayPalRefundReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalRefundReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalAuthReversalReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalAuthReversalReply::reasonCode = NULL;
	this->ns2__PayPalAuthReversalReply::authorizationId = NULL;
	this->ns2__PayPalAuthReversalReply::correlationID = NULL;
	this->ns2__PayPalAuthReversalReply::errorCode = NULL;
	/* transient soap skipped */
}

void ns2__PayPalAuthReversalReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PayPalAuthReversalReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthReversalReply::authorizationId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthReversalReply::correlationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthReversalReply::errorCode);
#endif
}

int ns2__PayPalAuthReversalReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalAuthReversalReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalAuthReversalReply(struct soap *soap, const char *tag, int id, const ns2__PayPalAuthReversalReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalAuthReversalReply), type))
		return soap->error;
	if (!a->ns2__PayPalAuthReversalReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PayPalAuthReversalReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authorizationId", -1, (wchar_t*const*)&a->ns2__PayPalAuthReversalReply::authorizationId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:correlationID", -1, (wchar_t*const*)&a->ns2__PayPalAuthReversalReply::correlationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:errorCode", -1, (wchar_t*const*)&a->ns2__PayPalAuthReversalReply::errorCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalAuthReversalReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalAuthReversalReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalAuthReversalReply * SOAP_FMAC4 soap_in_ns2__PayPalAuthReversalReply(struct soap *soap, const char *tag, ns2__PayPalAuthReversalReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalAuthReversalReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalAuthReversalReply, sizeof(ns2__PayPalAuthReversalReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalAuthReversalReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalAuthReversalReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_authorizationId1 = 1;
	size_t soap_flag_correlationID1 = 1;
	size_t soap_flag_errorCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PayPalAuthReversalReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_authorizationId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authorizationId", (wchar_t**)&a->ns2__PayPalAuthReversalReply::authorizationId, "xsd:string"))
				{	soap_flag_authorizationId1--;
					continue;
				}
			if (soap_flag_correlationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:correlationID", (wchar_t**)&a->ns2__PayPalAuthReversalReply::correlationID, "xsd:string"))
				{	soap_flag_correlationID1--;
					continue;
				}
			if (soap_flag_errorCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:errorCode", (wchar_t**)&a->ns2__PayPalAuthReversalReply::errorCode, "xsd:string"))
				{	soap_flag_errorCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PayPalAuthReversalReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalAuthReversalReply, SOAP_TYPE_ns2__PayPalAuthReversalReply, sizeof(ns2__PayPalAuthReversalReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalAuthReversalReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalAuthReversalReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalAuthReversalReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalAuthReversalReply *p;
	size_t k = sizeof(ns2__PayPalAuthReversalReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalAuthReversalReply);
		if (p)
			((ns2__PayPalAuthReversalReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalAuthReversalReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalAuthReversalReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalAuthReversalReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalAuthReversalReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalAuthReversalReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalAuthReversalReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalAuthReversalReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalAuthReversalReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalAuthReversalReply * SOAP_FMAC4 soap_get_ns2__PayPalAuthReversalReply(struct soap *soap, ns2__PayPalAuthReversalReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalAuthReversalReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalDoCaptureReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalDoCaptureReply::reasonCode = NULL;
	this->ns2__PayPalDoCaptureReply::authorizationId = NULL;
	this->ns2__PayPalDoCaptureReply::transactionId = NULL;
	this->ns2__PayPalDoCaptureReply::parentTransactionId = NULL;
	this->ns2__PayPalDoCaptureReply::paypalReceiptId = NULL;
	this->ns2__PayPalDoCaptureReply::paypalTransactiontype = NULL;
	this->ns2__PayPalDoCaptureReply::paypalPaymentType = NULL;
	this->ns2__PayPalDoCaptureReply::paypalOrderTime = NULL;
	this->ns2__PayPalDoCaptureReply::paypalPaymentGrossAmount = NULL;
	this->ns2__PayPalDoCaptureReply::paypalFeeAmount = NULL;
	this->ns2__PayPalDoCaptureReply::paypalTaxAmount = NULL;
	this->ns2__PayPalDoCaptureReply::paypalExchangeRate = NULL;
	this->ns2__PayPalDoCaptureReply::paypalPaymentStatus = NULL;
	this->ns2__PayPalDoCaptureReply::amount = NULL;
	this->ns2__PayPalDoCaptureReply::currency = NULL;
	this->ns2__PayPalDoCaptureReply::correlationID = NULL;
	this->ns2__PayPalDoCaptureReply::errorCode = NULL;
	this->ns2__PayPalDoCaptureReply::paypalPendingReason = NULL;
	/* transient soap skipped */
}

void ns2__PayPalDoCaptureReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureReply::authorizationId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureReply::transactionId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureReply::parentTransactionId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureReply::paypalReceiptId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureReply::paypalTransactiontype);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureReply::paypalPaymentType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureReply::paypalOrderTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureReply::paypalPaymentGrossAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureReply::paypalFeeAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureReply::paypalTaxAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureReply::paypalExchangeRate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureReply::paypalPaymentStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureReply::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureReply::currency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureReply::correlationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureReply::errorCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureReply::paypalPendingReason);
#endif
}

int ns2__PayPalDoCaptureReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalDoCaptureReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalDoCaptureReply(struct soap *soap, const char *tag, int id, const ns2__PayPalDoCaptureReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalDoCaptureReply), type))
		return soap->error;
	if (!a->ns2__PayPalDoCaptureReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authorizationId", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureReply::authorizationId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionId", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureReply::transactionId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:parentTransactionId", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureReply::parentTransactionId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalReceiptId", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureReply::paypalReceiptId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalTransactiontype", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureReply::paypalTransactiontype, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPaymentType", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureReply::paypalPaymentType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalOrderTime", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureReply::paypalOrderTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPaymentGrossAmount", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureReply::paypalPaymentGrossAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalFeeAmount", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureReply::paypalFeeAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalTaxAmount", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureReply::paypalTaxAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalExchangeRate", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureReply::paypalExchangeRate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPaymentStatus", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureReply::paypalPaymentStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:amount", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureReply::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:currency", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureReply::currency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:correlationID", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureReply::correlationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:errorCode", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureReply::errorCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPendingReason", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureReply::paypalPendingReason, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalDoCaptureReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalDoCaptureReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalDoCaptureReply * SOAP_FMAC4 soap_in_ns2__PayPalDoCaptureReply(struct soap *soap, const char *tag, ns2__PayPalDoCaptureReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalDoCaptureReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalDoCaptureReply, sizeof(ns2__PayPalDoCaptureReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalDoCaptureReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalDoCaptureReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_authorizationId1 = 1;
	size_t soap_flag_transactionId1 = 1;
	size_t soap_flag_parentTransactionId1 = 1;
	size_t soap_flag_paypalReceiptId1 = 1;
	size_t soap_flag_paypalTransactiontype1 = 1;
	size_t soap_flag_paypalPaymentType1 = 1;
	size_t soap_flag_paypalOrderTime1 = 1;
	size_t soap_flag_paypalPaymentGrossAmount1 = 1;
	size_t soap_flag_paypalFeeAmount1 = 1;
	size_t soap_flag_paypalTaxAmount1 = 1;
	size_t soap_flag_paypalExchangeRate1 = 1;
	size_t soap_flag_paypalPaymentStatus1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_currency1 = 1;
	size_t soap_flag_correlationID1 = 1;
	size_t soap_flag_errorCode1 = 1;
	size_t soap_flag_paypalPendingReason1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PayPalDoCaptureReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_authorizationId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authorizationId", (wchar_t**)&a->ns2__PayPalDoCaptureReply::authorizationId, "xsd:string"))
				{	soap_flag_authorizationId1--;
					continue;
				}
			if (soap_flag_transactionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionId", (wchar_t**)&a->ns2__PayPalDoCaptureReply::transactionId, "xsd:string"))
				{	soap_flag_transactionId1--;
					continue;
				}
			if (soap_flag_parentTransactionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:parentTransactionId", (wchar_t**)&a->ns2__PayPalDoCaptureReply::parentTransactionId, "xsd:string"))
				{	soap_flag_parentTransactionId1--;
					continue;
				}
			if (soap_flag_paypalReceiptId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalReceiptId", (wchar_t**)&a->ns2__PayPalDoCaptureReply::paypalReceiptId, "xsd:string"))
				{	soap_flag_paypalReceiptId1--;
					continue;
				}
			if (soap_flag_paypalTransactiontype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalTransactiontype", (wchar_t**)&a->ns2__PayPalDoCaptureReply::paypalTransactiontype, "xsd:string"))
				{	soap_flag_paypalTransactiontype1--;
					continue;
				}
			if (soap_flag_paypalPaymentType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPaymentType", (wchar_t**)&a->ns2__PayPalDoCaptureReply::paypalPaymentType, "xsd:string"))
				{	soap_flag_paypalPaymentType1--;
					continue;
				}
			if (soap_flag_paypalOrderTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalOrderTime", (wchar_t**)&a->ns2__PayPalDoCaptureReply::paypalOrderTime, "xsd:string"))
				{	soap_flag_paypalOrderTime1--;
					continue;
				}
			if (soap_flag_paypalPaymentGrossAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPaymentGrossAmount", (wchar_t**)&a->ns2__PayPalDoCaptureReply::paypalPaymentGrossAmount, "xsd:string"))
				{	soap_flag_paypalPaymentGrossAmount1--;
					continue;
				}
			if (soap_flag_paypalFeeAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalFeeAmount", (wchar_t**)&a->ns2__PayPalDoCaptureReply::paypalFeeAmount, "xsd:string"))
				{	soap_flag_paypalFeeAmount1--;
					continue;
				}
			if (soap_flag_paypalTaxAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalTaxAmount", (wchar_t**)&a->ns2__PayPalDoCaptureReply::paypalTaxAmount, "xsd:string"))
				{	soap_flag_paypalTaxAmount1--;
					continue;
				}
			if (soap_flag_paypalExchangeRate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalExchangeRate", (wchar_t**)&a->ns2__PayPalDoCaptureReply::paypalExchangeRate, "xsd:string"))
				{	soap_flag_paypalExchangeRate1--;
					continue;
				}
			if (soap_flag_paypalPaymentStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPaymentStatus", (wchar_t**)&a->ns2__PayPalDoCaptureReply::paypalPaymentStatus, "xsd:string"))
				{	soap_flag_paypalPaymentStatus1--;
					continue;
				}
			if (soap_flag_amount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:amount", (wchar_t**)&a->ns2__PayPalDoCaptureReply::amount, "xsd:string"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_currency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:currency", (wchar_t**)&a->ns2__PayPalDoCaptureReply::currency, "xsd:string"))
				{	soap_flag_currency1--;
					continue;
				}
			if (soap_flag_correlationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:correlationID", (wchar_t**)&a->ns2__PayPalDoCaptureReply::correlationID, "xsd:string"))
				{	soap_flag_correlationID1--;
					continue;
				}
			if (soap_flag_errorCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:errorCode", (wchar_t**)&a->ns2__PayPalDoCaptureReply::errorCode, "xsd:string"))
				{	soap_flag_errorCode1--;
					continue;
				}
			if (soap_flag_paypalPendingReason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPendingReason", (wchar_t**)&a->ns2__PayPalDoCaptureReply::paypalPendingReason, "xsd:string"))
				{	soap_flag_paypalPendingReason1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PayPalDoCaptureReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalDoCaptureReply, SOAP_TYPE_ns2__PayPalDoCaptureReply, sizeof(ns2__PayPalDoCaptureReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalDoCaptureReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalDoCaptureReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalDoCaptureReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalDoCaptureReply *p;
	size_t k = sizeof(ns2__PayPalDoCaptureReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalDoCaptureReply);
		if (p)
			((ns2__PayPalDoCaptureReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalDoCaptureReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalDoCaptureReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalDoCaptureReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalDoCaptureReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalDoCaptureReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalDoCaptureReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalDoCaptureReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalDoCaptureReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalDoCaptureReply * SOAP_FMAC4 soap_get_ns2__PayPalDoCaptureReply(struct soap *soap, ns2__PayPalDoCaptureReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalDoCaptureReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalEcDoPaymentReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalEcDoPaymentReply::reasonCode = NULL;
	this->ns2__PayPalEcDoPaymentReply::paypalToken = NULL;
	this->ns2__PayPalEcDoPaymentReply::transactionId = NULL;
	this->ns2__PayPalEcDoPaymentReply::paypalTransactiontype = NULL;
	this->ns2__PayPalEcDoPaymentReply::paymentType = NULL;
	this->ns2__PayPalEcDoPaymentReply::paypalOrderTime = NULL;
	this->ns2__PayPalEcDoPaymentReply::paypalAmount = NULL;
	this->ns2__PayPalEcDoPaymentReply::paypalFeeAmount = NULL;
	this->ns2__PayPalEcDoPaymentReply::paypalTaxAmount = NULL;
	this->ns2__PayPalEcDoPaymentReply::paypalExchangeRate = NULL;
	this->ns2__PayPalEcDoPaymentReply::paypalPaymentStatus = NULL;
	this->ns2__PayPalEcDoPaymentReply::paypalPendingReason = NULL;
	this->ns2__PayPalEcDoPaymentReply::orderId = NULL;
	this->ns2__PayPalEcDoPaymentReply::paypalReasonCode = NULL;
	this->ns2__PayPalEcDoPaymentReply::amount = NULL;
	this->ns2__PayPalEcDoPaymentReply::currency = NULL;
	this->ns2__PayPalEcDoPaymentReply::correlationID = NULL;
	this->ns2__PayPalEcDoPaymentReply::errorCode = NULL;
	this->ns2__PayPalEcDoPaymentReply::paypalBillingAgreementId = NULL;
	/* transient soap skipped */
}

void ns2__PayPalEcDoPaymentReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentReply::paypalToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentReply::transactionId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentReply::paypalTransactiontype);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentReply::paymentType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentReply::paypalOrderTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentReply::paypalAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentReply::paypalFeeAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentReply::paypalTaxAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentReply::paypalExchangeRate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentReply::paypalPaymentStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentReply::paypalPendingReason);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentReply::orderId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentReply::paypalReasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentReply::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentReply::currency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentReply::correlationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentReply::errorCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentReply::paypalBillingAgreementId);
#endif
}

int ns2__PayPalEcDoPaymentReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalEcDoPaymentReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalEcDoPaymentReply(struct soap *soap, const char *tag, int id, const ns2__PayPalEcDoPaymentReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalEcDoPaymentReply), type))
		return soap->error;
	if (!a->ns2__PayPalEcDoPaymentReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalToken", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentReply::paypalToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionId", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentReply::transactionId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalTransactiontype", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentReply::paypalTransactiontype, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentType", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentReply::paymentType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalOrderTime", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentReply::paypalOrderTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalAmount", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentReply::paypalAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalFeeAmount", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentReply::paypalFeeAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalTaxAmount", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentReply::paypalTaxAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalExchangeRate", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentReply::paypalExchangeRate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPaymentStatus", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentReply::paypalPaymentStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPendingReason", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentReply::paypalPendingReason, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderId", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentReply::orderId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalReasonCode", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentReply::paypalReasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:amount", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentReply::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:currency", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentReply::currency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:correlationID", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentReply::correlationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:errorCode", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentReply::errorCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalBillingAgreementId", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentReply::paypalBillingAgreementId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalEcDoPaymentReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalEcDoPaymentReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalEcDoPaymentReply * SOAP_FMAC4 soap_in_ns2__PayPalEcDoPaymentReply(struct soap *soap, const char *tag, ns2__PayPalEcDoPaymentReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalEcDoPaymentReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalEcDoPaymentReply, sizeof(ns2__PayPalEcDoPaymentReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalEcDoPaymentReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalEcDoPaymentReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_paypalToken1 = 1;
	size_t soap_flag_transactionId1 = 1;
	size_t soap_flag_paypalTransactiontype1 = 1;
	size_t soap_flag_paymentType1 = 1;
	size_t soap_flag_paypalOrderTime1 = 1;
	size_t soap_flag_paypalAmount1 = 1;
	size_t soap_flag_paypalFeeAmount1 = 1;
	size_t soap_flag_paypalTaxAmount1 = 1;
	size_t soap_flag_paypalExchangeRate1 = 1;
	size_t soap_flag_paypalPaymentStatus1 = 1;
	size_t soap_flag_paypalPendingReason1 = 1;
	size_t soap_flag_orderId1 = 1;
	size_t soap_flag_paypalReasonCode1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_currency1 = 1;
	size_t soap_flag_correlationID1 = 1;
	size_t soap_flag_errorCode1 = 1;
	size_t soap_flag_paypalBillingAgreementId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PayPalEcDoPaymentReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_paypalToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalToken", (wchar_t**)&a->ns2__PayPalEcDoPaymentReply::paypalToken, "xsd:string"))
				{	soap_flag_paypalToken1--;
					continue;
				}
			if (soap_flag_transactionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionId", (wchar_t**)&a->ns2__PayPalEcDoPaymentReply::transactionId, "xsd:string"))
				{	soap_flag_transactionId1--;
					continue;
				}
			if (soap_flag_paypalTransactiontype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalTransactiontype", (wchar_t**)&a->ns2__PayPalEcDoPaymentReply::paypalTransactiontype, "xsd:string"))
				{	soap_flag_paypalTransactiontype1--;
					continue;
				}
			if (soap_flag_paymentType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentType", (wchar_t**)&a->ns2__PayPalEcDoPaymentReply::paymentType, "xsd:string"))
				{	soap_flag_paymentType1--;
					continue;
				}
			if (soap_flag_paypalOrderTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalOrderTime", (wchar_t**)&a->ns2__PayPalEcDoPaymentReply::paypalOrderTime, "xsd:string"))
				{	soap_flag_paypalOrderTime1--;
					continue;
				}
			if (soap_flag_paypalAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalAmount", (wchar_t**)&a->ns2__PayPalEcDoPaymentReply::paypalAmount, "xsd:string"))
				{	soap_flag_paypalAmount1--;
					continue;
				}
			if (soap_flag_paypalFeeAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalFeeAmount", (wchar_t**)&a->ns2__PayPalEcDoPaymentReply::paypalFeeAmount, "xsd:string"))
				{	soap_flag_paypalFeeAmount1--;
					continue;
				}
			if (soap_flag_paypalTaxAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalTaxAmount", (wchar_t**)&a->ns2__PayPalEcDoPaymentReply::paypalTaxAmount, "xsd:string"))
				{	soap_flag_paypalTaxAmount1--;
					continue;
				}
			if (soap_flag_paypalExchangeRate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalExchangeRate", (wchar_t**)&a->ns2__PayPalEcDoPaymentReply::paypalExchangeRate, "xsd:string"))
				{	soap_flag_paypalExchangeRate1--;
					continue;
				}
			if (soap_flag_paypalPaymentStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPaymentStatus", (wchar_t**)&a->ns2__PayPalEcDoPaymentReply::paypalPaymentStatus, "xsd:string"))
				{	soap_flag_paypalPaymentStatus1--;
					continue;
				}
			if (soap_flag_paypalPendingReason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPendingReason", (wchar_t**)&a->ns2__PayPalEcDoPaymentReply::paypalPendingReason, "xsd:string"))
				{	soap_flag_paypalPendingReason1--;
					continue;
				}
			if (soap_flag_orderId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderId", (wchar_t**)&a->ns2__PayPalEcDoPaymentReply::orderId, "xsd:string"))
				{	soap_flag_orderId1--;
					continue;
				}
			if (soap_flag_paypalReasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalReasonCode", (wchar_t**)&a->ns2__PayPalEcDoPaymentReply::paypalReasonCode, "xsd:string"))
				{	soap_flag_paypalReasonCode1--;
					continue;
				}
			if (soap_flag_amount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:amount", (wchar_t**)&a->ns2__PayPalEcDoPaymentReply::amount, "xsd:string"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_currency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:currency", (wchar_t**)&a->ns2__PayPalEcDoPaymentReply::currency, "xsd:string"))
				{	soap_flag_currency1--;
					continue;
				}
			if (soap_flag_correlationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:correlationID", (wchar_t**)&a->ns2__PayPalEcDoPaymentReply::correlationID, "xsd:string"))
				{	soap_flag_correlationID1--;
					continue;
				}
			if (soap_flag_errorCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:errorCode", (wchar_t**)&a->ns2__PayPalEcDoPaymentReply::errorCode, "xsd:string"))
				{	soap_flag_errorCode1--;
					continue;
				}
			if (soap_flag_paypalBillingAgreementId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalBillingAgreementId", (wchar_t**)&a->ns2__PayPalEcDoPaymentReply::paypalBillingAgreementId, "xsd:string"))
				{	soap_flag_paypalBillingAgreementId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PayPalEcDoPaymentReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalEcDoPaymentReply, SOAP_TYPE_ns2__PayPalEcDoPaymentReply, sizeof(ns2__PayPalEcDoPaymentReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalEcDoPaymentReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcDoPaymentReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalEcDoPaymentReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalEcDoPaymentReply *p;
	size_t k = sizeof(ns2__PayPalEcDoPaymentReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalEcDoPaymentReply);
		if (p)
			((ns2__PayPalEcDoPaymentReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalEcDoPaymentReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalEcDoPaymentReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalEcDoPaymentReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalEcDoPaymentReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalEcDoPaymentReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalEcDoPaymentReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalEcDoPaymentReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalEcDoPaymentReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalEcDoPaymentReply * SOAP_FMAC4 soap_get_ns2__PayPalEcDoPaymentReply(struct soap *soap, ns2__PayPalEcDoPaymentReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalEcDoPaymentReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalEcGetDetailsReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalEcGetDetailsReply::reasonCode = NULL;
	this->ns2__PayPalEcGetDetailsReply::paypalToken = NULL;
	this->ns2__PayPalEcGetDetailsReply::payer = NULL;
	this->ns2__PayPalEcGetDetailsReply::payerId = NULL;
	this->ns2__PayPalEcGetDetailsReply::payerStatus = NULL;
	this->ns2__PayPalEcGetDetailsReply::payerSalutation = NULL;
	this->ns2__PayPalEcGetDetailsReply::payerFirstname = NULL;
	this->ns2__PayPalEcGetDetailsReply::payerMiddlename = NULL;
	this->ns2__PayPalEcGetDetailsReply::payerLastname = NULL;
	this->ns2__PayPalEcGetDetailsReply::payerSuffix = NULL;
	this->ns2__PayPalEcGetDetailsReply::payerCountry = NULL;
	this->ns2__PayPalEcGetDetailsReply::payerBusiness = NULL;
	this->ns2__PayPalEcGetDetailsReply::shipToName = NULL;
	this->ns2__PayPalEcGetDetailsReply::shipToAddress1 = NULL;
	this->ns2__PayPalEcGetDetailsReply::shipToAddress2 = NULL;
	this->ns2__PayPalEcGetDetailsReply::shipToCity = NULL;
	this->ns2__PayPalEcGetDetailsReply::shipToState = NULL;
	this->ns2__PayPalEcGetDetailsReply::shipToCountry = NULL;
	this->ns2__PayPalEcGetDetailsReply::shipToZip = NULL;
	this->ns2__PayPalEcGetDetailsReply::addressStatus = NULL;
	this->ns2__PayPalEcGetDetailsReply::payerPhone = NULL;
	this->ns2__PayPalEcGetDetailsReply::avsCode = NULL;
	this->ns2__PayPalEcGetDetailsReply::street1 = NULL;
	this->ns2__PayPalEcGetDetailsReply::street2 = NULL;
	this->ns2__PayPalEcGetDetailsReply::city = NULL;
	this->ns2__PayPalEcGetDetailsReply::state = NULL;
	this->ns2__PayPalEcGetDetailsReply::postalCode = NULL;
	this->ns2__PayPalEcGetDetailsReply::countryCode = NULL;
	this->ns2__PayPalEcGetDetailsReply::countryName = NULL;
	this->ns2__PayPalEcGetDetailsReply::addressID = NULL;
	this->ns2__PayPalEcGetDetailsReply::errorCode = NULL;
	this->ns2__PayPalEcGetDetailsReply::correlationID = NULL;
	this->ns2__PayPalEcGetDetailsReply::paypalBillingAgreementAcceptedStatus = NULL;
	this->ns2__PayPalEcGetDetailsReply::paypalTaxAmount = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__Item(soap, &this->ns2__PayPalEcGetDetailsReply::item);
	/* transient soap skipped */
}

void ns2__PayPalEcGetDetailsReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::paypalToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::payer);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::payerId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::payerStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::payerSalutation);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::payerFirstname);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::payerMiddlename);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::payerLastname);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::payerSuffix);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::payerCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::payerBusiness);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::shipToName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::shipToAddress1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::shipToAddress2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::shipToCity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::shipToState);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::shipToCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::shipToZip);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::addressStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::payerPhone);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::avsCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::street1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::street2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::city);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::state);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::postalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::countryCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::countryName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::addressID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::errorCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::correlationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::paypalBillingAgreementAcceptedStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsReply::paypalTaxAmount);
	soap_serialize_std__vectorTemplateOfPointerTons2__Item(soap, &this->ns2__PayPalEcGetDetailsReply::item);
#endif
}

int ns2__PayPalEcGetDetailsReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalEcGetDetailsReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalEcGetDetailsReply(struct soap *soap, const char *tag, int id, const ns2__PayPalEcGetDetailsReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalEcGetDetailsReply), type))
		return soap->error;
	if (!a->ns2__PayPalEcGetDetailsReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalToken", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::paypalToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payer", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::payer, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerId", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::payerId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerStatus", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::payerStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerSalutation", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::payerSalutation, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerFirstname", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::payerFirstname, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerMiddlename", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::payerMiddlename, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerLastname", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::payerLastname, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerSuffix", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::payerSuffix, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerCountry", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::payerCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerBusiness", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::payerBusiness, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToName", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::shipToName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToAddress1", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::shipToAddress1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToAddress2", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::shipToAddress2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToCity", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::shipToCity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToState", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::shipToState, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToCountry", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::shipToCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToZip", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::shipToZip, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:addressStatus", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::addressStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerPhone", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::payerPhone, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:avsCode", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::avsCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:street1", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::street1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:street2", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::street2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:city", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::city, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:state", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::state, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:postalCode", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::postalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:countryCode", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::countryCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:countryName", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::countryName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:addressID", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::addressID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:errorCode", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::errorCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:correlationID", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::correlationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalBillingAgreementAcceptedStatus", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::paypalBillingAgreementAcceptedStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalTaxAmount", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsReply::paypalTaxAmount, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__Item(soap, "ns2:item", -1, &a->ns2__PayPalEcGetDetailsReply::item, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalEcGetDetailsReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalEcGetDetailsReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalEcGetDetailsReply * SOAP_FMAC4 soap_in_ns2__PayPalEcGetDetailsReply(struct soap *soap, const char *tag, ns2__PayPalEcGetDetailsReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalEcGetDetailsReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalEcGetDetailsReply, sizeof(ns2__PayPalEcGetDetailsReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalEcGetDetailsReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalEcGetDetailsReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_paypalToken1 = 1;
	size_t soap_flag_payer1 = 1;
	size_t soap_flag_payerId1 = 1;
	size_t soap_flag_payerStatus1 = 1;
	size_t soap_flag_payerSalutation1 = 1;
	size_t soap_flag_payerFirstname1 = 1;
	size_t soap_flag_payerMiddlename1 = 1;
	size_t soap_flag_payerLastname1 = 1;
	size_t soap_flag_payerSuffix1 = 1;
	size_t soap_flag_payerCountry1 = 1;
	size_t soap_flag_payerBusiness1 = 1;
	size_t soap_flag_shipToName1 = 1;
	size_t soap_flag_shipToAddress11 = 1;
	size_t soap_flag_shipToAddress21 = 1;
	size_t soap_flag_shipToCity1 = 1;
	size_t soap_flag_shipToState1 = 1;
	size_t soap_flag_shipToCountry1 = 1;
	size_t soap_flag_shipToZip1 = 1;
	size_t soap_flag_addressStatus1 = 1;
	size_t soap_flag_payerPhone1 = 1;
	size_t soap_flag_avsCode1 = 1;
	size_t soap_flag_street11 = 1;
	size_t soap_flag_street21 = 1;
	size_t soap_flag_city1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_postalCode1 = 1;
	size_t soap_flag_countryCode1 = 1;
	size_t soap_flag_countryName1 = 1;
	size_t soap_flag_addressID1 = 1;
	size_t soap_flag_errorCode1 = 1;
	size_t soap_flag_correlationID1 = 1;
	size_t soap_flag_paypalBillingAgreementAcceptedStatus1 = 1;
	size_t soap_flag_paypalTaxAmount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_paypalToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalToken", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::paypalToken, "xsd:string"))
				{	soap_flag_paypalToken1--;
					continue;
				}
			if (soap_flag_payer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payer", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::payer, "xsd:string"))
				{	soap_flag_payer1--;
					continue;
				}
			if (soap_flag_payerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerId", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::payerId, "xsd:string"))
				{	soap_flag_payerId1--;
					continue;
				}
			if (soap_flag_payerStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerStatus", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::payerStatus, "xsd:string"))
				{	soap_flag_payerStatus1--;
					continue;
				}
			if (soap_flag_payerSalutation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerSalutation", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::payerSalutation, "xsd:string"))
				{	soap_flag_payerSalutation1--;
					continue;
				}
			if (soap_flag_payerFirstname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerFirstname", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::payerFirstname, "xsd:string"))
				{	soap_flag_payerFirstname1--;
					continue;
				}
			if (soap_flag_payerMiddlename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerMiddlename", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::payerMiddlename, "xsd:string"))
				{	soap_flag_payerMiddlename1--;
					continue;
				}
			if (soap_flag_payerLastname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerLastname", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::payerLastname, "xsd:string"))
				{	soap_flag_payerLastname1--;
					continue;
				}
			if (soap_flag_payerSuffix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerSuffix", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::payerSuffix, "xsd:string"))
				{	soap_flag_payerSuffix1--;
					continue;
				}
			if (soap_flag_payerCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerCountry", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::payerCountry, "xsd:string"))
				{	soap_flag_payerCountry1--;
					continue;
				}
			if (soap_flag_payerBusiness1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerBusiness", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::payerBusiness, "xsd:string"))
				{	soap_flag_payerBusiness1--;
					continue;
				}
			if (soap_flag_shipToName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToName", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::shipToName, "xsd:string"))
				{	soap_flag_shipToName1--;
					continue;
				}
			if (soap_flag_shipToAddress11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToAddress1", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::shipToAddress1, "xsd:string"))
				{	soap_flag_shipToAddress11--;
					continue;
				}
			if (soap_flag_shipToAddress21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToAddress2", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::shipToAddress2, "xsd:string"))
				{	soap_flag_shipToAddress21--;
					continue;
				}
			if (soap_flag_shipToCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToCity", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::shipToCity, "xsd:string"))
				{	soap_flag_shipToCity1--;
					continue;
				}
			if (soap_flag_shipToState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToState", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::shipToState, "xsd:string"))
				{	soap_flag_shipToState1--;
					continue;
				}
			if (soap_flag_shipToCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToCountry", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::shipToCountry, "xsd:string"))
				{	soap_flag_shipToCountry1--;
					continue;
				}
			if (soap_flag_shipToZip1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToZip", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::shipToZip, "xsd:string"))
				{	soap_flag_shipToZip1--;
					continue;
				}
			if (soap_flag_addressStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:addressStatus", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::addressStatus, "xsd:string"))
				{	soap_flag_addressStatus1--;
					continue;
				}
			if (soap_flag_payerPhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerPhone", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::payerPhone, "xsd:string"))
				{	soap_flag_payerPhone1--;
					continue;
				}
			if (soap_flag_avsCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:avsCode", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::avsCode, "xsd:string"))
				{	soap_flag_avsCode1--;
					continue;
				}
			if (soap_flag_street11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:street1", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::street1, "xsd:string"))
				{	soap_flag_street11--;
					continue;
				}
			if (soap_flag_street21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:street2", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::street2, "xsd:string"))
				{	soap_flag_street21--;
					continue;
				}
			if (soap_flag_city1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:city", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::city, "xsd:string"))
				{	soap_flag_city1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:state", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::state, "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_postalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:postalCode", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::postalCode, "xsd:string"))
				{	soap_flag_postalCode1--;
					continue;
				}
			if (soap_flag_countryCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:countryCode", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::countryCode, "xsd:string"))
				{	soap_flag_countryCode1--;
					continue;
				}
			if (soap_flag_countryName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:countryName", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::countryName, "xsd:string"))
				{	soap_flag_countryName1--;
					continue;
				}
			if (soap_flag_addressID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:addressID", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::addressID, "xsd:string"))
				{	soap_flag_addressID1--;
					continue;
				}
			if (soap_flag_errorCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:errorCode", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::errorCode, "xsd:string"))
				{	soap_flag_errorCode1--;
					continue;
				}
			if (soap_flag_correlationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:correlationID", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::correlationID, "xsd:string"))
				{	soap_flag_correlationID1--;
					continue;
				}
			if (soap_flag_paypalBillingAgreementAcceptedStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalBillingAgreementAcceptedStatus", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::paypalBillingAgreementAcceptedStatus, "xsd:string"))
				{	soap_flag_paypalBillingAgreementAcceptedStatus1--;
					continue;
				}
			if (soap_flag_paypalTaxAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalTaxAmount", (wchar_t**)&a->ns2__PayPalEcGetDetailsReply::paypalTaxAmount, "xsd:string"))
				{	soap_flag_paypalTaxAmount1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__Item(soap, "ns2:item", &a->ns2__PayPalEcGetDetailsReply::item, "ns2:Item"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0 || a->ns2__PayPalEcGetDetailsReply::item.size() > 1000))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PayPalEcGetDetailsReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalEcGetDetailsReply, SOAP_TYPE_ns2__PayPalEcGetDetailsReply, sizeof(ns2__PayPalEcGetDetailsReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalEcGetDetailsReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcGetDetailsReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalEcGetDetailsReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalEcGetDetailsReply *p;
	size_t k = sizeof(ns2__PayPalEcGetDetailsReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalEcGetDetailsReply);
		if (p)
			((ns2__PayPalEcGetDetailsReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalEcGetDetailsReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalEcGetDetailsReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalEcGetDetailsReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalEcGetDetailsReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalEcGetDetailsReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalEcGetDetailsReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalEcGetDetailsReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalEcGetDetailsReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalEcGetDetailsReply * SOAP_FMAC4 soap_get_ns2__PayPalEcGetDetailsReply(struct soap *soap, ns2__PayPalEcGetDetailsReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalEcGetDetailsReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalEcSetReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalEcSetReply::reasonCode = NULL;
	this->ns2__PayPalEcSetReply::paypalToken = NULL;
	this->ns2__PayPalEcSetReply::amount = NULL;
	this->ns2__PayPalEcSetReply::currency = NULL;
	this->ns2__PayPalEcSetReply::correlationID = NULL;
	this->ns2__PayPalEcSetReply::errorCode = NULL;
	/* transient soap skipped */
}

void ns2__PayPalEcSetReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PayPalEcSetReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetReply::paypalToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetReply::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetReply::currency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetReply::correlationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetReply::errorCode);
#endif
}

int ns2__PayPalEcSetReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalEcSetReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalEcSetReply(struct soap *soap, const char *tag, int id, const ns2__PayPalEcSetReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalEcSetReply), type))
		return soap->error;
	if (!a->ns2__PayPalEcSetReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PayPalEcSetReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalToken", -1, (wchar_t*const*)&a->ns2__PayPalEcSetReply::paypalToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:amount", -1, (wchar_t*const*)&a->ns2__PayPalEcSetReply::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:currency", -1, (wchar_t*const*)&a->ns2__PayPalEcSetReply::currency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:correlationID", -1, (wchar_t*const*)&a->ns2__PayPalEcSetReply::correlationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:errorCode", -1, (wchar_t*const*)&a->ns2__PayPalEcSetReply::errorCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalEcSetReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalEcSetReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalEcSetReply * SOAP_FMAC4 soap_in_ns2__PayPalEcSetReply(struct soap *soap, const char *tag, ns2__PayPalEcSetReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalEcSetReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalEcSetReply, sizeof(ns2__PayPalEcSetReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalEcSetReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalEcSetReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_paypalToken1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_currency1 = 1;
	size_t soap_flag_correlationID1 = 1;
	size_t soap_flag_errorCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PayPalEcSetReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_paypalToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalToken", (wchar_t**)&a->ns2__PayPalEcSetReply::paypalToken, "xsd:string"))
				{	soap_flag_paypalToken1--;
					continue;
				}
			if (soap_flag_amount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:amount", (wchar_t**)&a->ns2__PayPalEcSetReply::amount, "xsd:string"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_currency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:currency", (wchar_t**)&a->ns2__PayPalEcSetReply::currency, "xsd:string"))
				{	soap_flag_currency1--;
					continue;
				}
			if (soap_flag_correlationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:correlationID", (wchar_t**)&a->ns2__PayPalEcSetReply::correlationID, "xsd:string"))
				{	soap_flag_correlationID1--;
					continue;
				}
			if (soap_flag_errorCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:errorCode", (wchar_t**)&a->ns2__PayPalEcSetReply::errorCode, "xsd:string"))
				{	soap_flag_errorCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PayPalEcSetReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalEcSetReply, SOAP_TYPE_ns2__PayPalEcSetReply, sizeof(ns2__PayPalEcSetReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalEcSetReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcSetReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalEcSetReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalEcSetReply *p;
	size_t k = sizeof(ns2__PayPalEcSetReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalEcSetReply);
		if (p)
			((ns2__PayPalEcSetReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalEcSetReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalEcSetReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalEcSetReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalEcSetReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalEcSetReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalEcSetReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalEcSetReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalEcSetReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalEcSetReply * SOAP_FMAC4 soap_get_ns2__PayPalEcSetReply(struct soap *soap, ns2__PayPalEcSetReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalEcSetReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalPreapprovedUpdateReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalPreapprovedUpdateReply::reasonCode = NULL;
	this->ns2__PayPalPreapprovedUpdateReply::requestDateTime = NULL;
	this->ns2__PayPalPreapprovedUpdateReply::reconciliationID = NULL;
	this->ns2__PayPalPreapprovedUpdateReply::payerStatus = NULL;
	this->ns2__PayPalPreapprovedUpdateReply::payerName = NULL;
	this->ns2__PayPalPreapprovedUpdateReply::payerCountry = NULL;
	this->ns2__PayPalPreapprovedUpdateReply::mpStatus = NULL;
	this->ns2__PayPalPreapprovedUpdateReply::payer = NULL;
	this->ns2__PayPalPreapprovedUpdateReply::payerID = NULL;
	this->ns2__PayPalPreapprovedUpdateReply::payerBusiness = NULL;
	this->ns2__PayPalPreapprovedUpdateReply::desc = NULL;
	this->ns2__PayPalPreapprovedUpdateReply::mpMax = NULL;
	this->ns2__PayPalPreapprovedUpdateReply::paymentSourceID = NULL;
	/* transient soap skipped */
}

void ns2__PayPalPreapprovedUpdateReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedUpdateReply::reasonCode);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__PayPalPreapprovedUpdateReply::requestDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedUpdateReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedUpdateReply::payerStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedUpdateReply::payerName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedUpdateReply::payerCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedUpdateReply::mpStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedUpdateReply::payer);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedUpdateReply::payerID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedUpdateReply::payerBusiness);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedUpdateReply::desc);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedUpdateReply::mpMax);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedUpdateReply::paymentSourceID);
#endif
}

int ns2__PayPalPreapprovedUpdateReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalPreapprovedUpdateReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalPreapprovedUpdateReply(struct soap *soap, const char *tag, int id, const ns2__PayPalPreapprovedUpdateReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply), type))
		return soap->error;
	if (!a->ns2__PayPalPreapprovedUpdateReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedUpdateReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__PayPalPreapprovedUpdateReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedUpdateReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerStatus", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedUpdateReply::payerStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerName", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedUpdateReply::payerName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerCountry", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedUpdateReply::payerCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:mpStatus", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedUpdateReply::mpStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payer", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedUpdateReply::payer, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerID", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedUpdateReply::payerID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerBusiness", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedUpdateReply::payerBusiness, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:desc", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedUpdateReply::desc, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:mpMax", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedUpdateReply::mpMax, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentSourceID", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedUpdateReply::paymentSourceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalPreapprovedUpdateReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalPreapprovedUpdateReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalPreapprovedUpdateReply * SOAP_FMAC4 soap_in_ns2__PayPalPreapprovedUpdateReply(struct soap *soap, const char *tag, ns2__PayPalPreapprovedUpdateReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalPreapprovedUpdateReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply, sizeof(ns2__PayPalPreapprovedUpdateReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalPreapprovedUpdateReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_payerStatus1 = 1;
	size_t soap_flag_payerName1 = 1;
	size_t soap_flag_payerCountry1 = 1;
	size_t soap_flag_mpStatus1 = 1;
	size_t soap_flag_payer1 = 1;
	size_t soap_flag_payerID1 = 1;
	size_t soap_flag_payerBusiness1 = 1;
	size_t soap_flag_desc1 = 1;
	size_t soap_flag_mpMax1 = 1;
	size_t soap_flag_paymentSourceID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PayPalPreapprovedUpdateReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__PayPalPreapprovedUpdateReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__PayPalPreapprovedUpdateReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_payerStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerStatus", (wchar_t**)&a->ns2__PayPalPreapprovedUpdateReply::payerStatus, "xsd:string"))
				{	soap_flag_payerStatus1--;
					continue;
				}
			if (soap_flag_payerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerName", (wchar_t**)&a->ns2__PayPalPreapprovedUpdateReply::payerName, "xsd:string"))
				{	soap_flag_payerName1--;
					continue;
				}
			if (soap_flag_payerCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerCountry", (wchar_t**)&a->ns2__PayPalPreapprovedUpdateReply::payerCountry, "xsd:string"))
				{	soap_flag_payerCountry1--;
					continue;
				}
			if (soap_flag_mpStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:mpStatus", (wchar_t**)&a->ns2__PayPalPreapprovedUpdateReply::mpStatus, "xsd:string"))
				{	soap_flag_mpStatus1--;
					continue;
				}
			if (soap_flag_payer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payer", (wchar_t**)&a->ns2__PayPalPreapprovedUpdateReply::payer, "xsd:string"))
				{	soap_flag_payer1--;
					continue;
				}
			if (soap_flag_payerID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerID", (wchar_t**)&a->ns2__PayPalPreapprovedUpdateReply::payerID, "xsd:string"))
				{	soap_flag_payerID1--;
					continue;
				}
			if (soap_flag_payerBusiness1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerBusiness", (wchar_t**)&a->ns2__PayPalPreapprovedUpdateReply::payerBusiness, "xsd:string"))
				{	soap_flag_payerBusiness1--;
					continue;
				}
			if (soap_flag_desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:desc", (wchar_t**)&a->ns2__PayPalPreapprovedUpdateReply::desc, "xsd:string"))
				{	soap_flag_desc1--;
					continue;
				}
			if (soap_flag_mpMax1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:mpMax", (wchar_t**)&a->ns2__PayPalPreapprovedUpdateReply::mpMax, "xsd:string"))
				{	soap_flag_mpMax1--;
					continue;
				}
			if (soap_flag_paymentSourceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentSourceID", (wchar_t**)&a->ns2__PayPalPreapprovedUpdateReply::paymentSourceID, "xsd:string"))
				{	soap_flag_paymentSourceID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PayPalPreapprovedUpdateReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply, SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply, sizeof(ns2__PayPalPreapprovedUpdateReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalPreapprovedUpdateReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalPreapprovedUpdateReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalPreapprovedUpdateReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalPreapprovedUpdateReply *p;
	size_t k = sizeof(ns2__PayPalPreapprovedUpdateReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalPreapprovedUpdateReply);
		if (p)
			((ns2__PayPalPreapprovedUpdateReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalPreapprovedUpdateReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalPreapprovedUpdateReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalPreapprovedUpdateReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalPreapprovedUpdateReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalPreapprovedUpdateReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalPreapprovedUpdateReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalPreapprovedUpdateReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalPreapprovedUpdateReply * SOAP_FMAC4 soap_get_ns2__PayPalPreapprovedUpdateReply(struct soap *soap, ns2__PayPalPreapprovedUpdateReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalPreapprovedUpdateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalPreapprovedPaymentReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalPreapprovedPaymentReply::reasonCode = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::requestDateTime = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::reconciliationID = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::payerStatus = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::payerName = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::transactionType = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::feeAmount = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::payerCountry = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::pendingReason = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::paymentStatus = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::mpStatus = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::payer = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::payerID = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::payerBusiness = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::transactionID = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::desc = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::mpMax = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::paymentType = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::paymentDate = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::paymentGrossAmount = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::settleAmount = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::taxAmount = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::exchangeRate = NULL;
	this->ns2__PayPalPreapprovedPaymentReply::paymentSourceID = NULL;
	/* transient soap skipped */
}

void ns2__PayPalPreapprovedPaymentReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::reasonCode);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__PayPalPreapprovedPaymentReply::requestDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::payerStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::payerName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::transactionType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::feeAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::payerCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::pendingReason);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::paymentStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::mpStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::payer);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::payerID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::payerBusiness);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::transactionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::desc);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::mpMax);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::paymentType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::paymentDate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::paymentGrossAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::settleAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::taxAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::exchangeRate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentReply::paymentSourceID);
#endif
}

int ns2__PayPalPreapprovedPaymentReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalPreapprovedPaymentReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalPreapprovedPaymentReply(struct soap *soap, const char *tag, int id, const ns2__PayPalPreapprovedPaymentReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply), type))
		return soap->error;
	if (!a->ns2__PayPalPreapprovedPaymentReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__PayPalPreapprovedPaymentReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerStatus", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::payerStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerName", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::payerName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionType", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::transactionType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:feeAmount", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::feeAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerCountry", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::payerCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pendingReason", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::pendingReason, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentStatus", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::paymentStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:mpStatus", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::mpStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payer", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::payer, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerID", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::payerID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerBusiness", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::payerBusiness, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionID", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::transactionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:desc", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::desc, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:mpMax", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::mpMax, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentType", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::paymentType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentDate", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::paymentDate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentGrossAmount", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::paymentGrossAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:settleAmount", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::settleAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:taxAmount", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::taxAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:exchangeRate", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::exchangeRate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentSourceID", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentReply::paymentSourceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalPreapprovedPaymentReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalPreapprovedPaymentReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalPreapprovedPaymentReply * SOAP_FMAC4 soap_in_ns2__PayPalPreapprovedPaymentReply(struct soap *soap, const char *tag, ns2__PayPalPreapprovedPaymentReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalPreapprovedPaymentReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply, sizeof(ns2__PayPalPreapprovedPaymentReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalPreapprovedPaymentReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_payerStatus1 = 1;
	size_t soap_flag_payerName1 = 1;
	size_t soap_flag_transactionType1 = 1;
	size_t soap_flag_feeAmount1 = 1;
	size_t soap_flag_payerCountry1 = 1;
	size_t soap_flag_pendingReason1 = 1;
	size_t soap_flag_paymentStatus1 = 1;
	size_t soap_flag_mpStatus1 = 1;
	size_t soap_flag_payer1 = 1;
	size_t soap_flag_payerID1 = 1;
	size_t soap_flag_payerBusiness1 = 1;
	size_t soap_flag_transactionID1 = 1;
	size_t soap_flag_desc1 = 1;
	size_t soap_flag_mpMax1 = 1;
	size_t soap_flag_paymentType1 = 1;
	size_t soap_flag_paymentDate1 = 1;
	size_t soap_flag_paymentGrossAmount1 = 1;
	size_t soap_flag_settleAmount1 = 1;
	size_t soap_flag_taxAmount1 = 1;
	size_t soap_flag_exchangeRate1 = 1;
	size_t soap_flag_paymentSourceID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__PayPalPreapprovedPaymentReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_payerStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerStatus", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::payerStatus, "xsd:string"))
				{	soap_flag_payerStatus1--;
					continue;
				}
			if (soap_flag_payerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerName", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::payerName, "xsd:string"))
				{	soap_flag_payerName1--;
					continue;
				}
			if (soap_flag_transactionType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionType", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::transactionType, "xsd:string"))
				{	soap_flag_transactionType1--;
					continue;
				}
			if (soap_flag_feeAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:feeAmount", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::feeAmount, "xsd:string"))
				{	soap_flag_feeAmount1--;
					continue;
				}
			if (soap_flag_payerCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerCountry", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::payerCountry, "xsd:string"))
				{	soap_flag_payerCountry1--;
					continue;
				}
			if (soap_flag_pendingReason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pendingReason", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::pendingReason, "xsd:string"))
				{	soap_flag_pendingReason1--;
					continue;
				}
			if (soap_flag_paymentStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentStatus", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::paymentStatus, "xsd:string"))
				{	soap_flag_paymentStatus1--;
					continue;
				}
			if (soap_flag_mpStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:mpStatus", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::mpStatus, "xsd:string"))
				{	soap_flag_mpStatus1--;
					continue;
				}
			if (soap_flag_payer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payer", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::payer, "xsd:string"))
				{	soap_flag_payer1--;
					continue;
				}
			if (soap_flag_payerID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerID", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::payerID, "xsd:string"))
				{	soap_flag_payerID1--;
					continue;
				}
			if (soap_flag_payerBusiness1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerBusiness", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::payerBusiness, "xsd:string"))
				{	soap_flag_payerBusiness1--;
					continue;
				}
			if (soap_flag_transactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionID", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::transactionID, "xsd:string"))
				{	soap_flag_transactionID1--;
					continue;
				}
			if (soap_flag_desc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:desc", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::desc, "xsd:string"))
				{	soap_flag_desc1--;
					continue;
				}
			if (soap_flag_mpMax1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:mpMax", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::mpMax, "xsd:string"))
				{	soap_flag_mpMax1--;
					continue;
				}
			if (soap_flag_paymentType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentType", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::paymentType, "xsd:string"))
				{	soap_flag_paymentType1--;
					continue;
				}
			if (soap_flag_paymentDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentDate", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::paymentDate, "xsd:string"))
				{	soap_flag_paymentDate1--;
					continue;
				}
			if (soap_flag_paymentGrossAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentGrossAmount", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::paymentGrossAmount, "xsd:string"))
				{	soap_flag_paymentGrossAmount1--;
					continue;
				}
			if (soap_flag_settleAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:settleAmount", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::settleAmount, "xsd:string"))
				{	soap_flag_settleAmount1--;
					continue;
				}
			if (soap_flag_taxAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:taxAmount", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::taxAmount, "xsd:string"))
				{	soap_flag_taxAmount1--;
					continue;
				}
			if (soap_flag_exchangeRate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:exchangeRate", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::exchangeRate, "xsd:string"))
				{	soap_flag_exchangeRate1--;
					continue;
				}
			if (soap_flag_paymentSourceID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentSourceID", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentReply::paymentSourceID, "xsd:string"))
				{	soap_flag_paymentSourceID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PayPalPreapprovedPaymentReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply, SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply, sizeof(ns2__PayPalPreapprovedPaymentReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalPreapprovedPaymentReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalPreapprovedPaymentReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalPreapprovedPaymentReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalPreapprovedPaymentReply *p;
	size_t k = sizeof(ns2__PayPalPreapprovedPaymentReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalPreapprovedPaymentReply);
		if (p)
			((ns2__PayPalPreapprovedPaymentReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalPreapprovedPaymentReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalPreapprovedPaymentReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalPreapprovedPaymentReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalPreapprovedPaymentReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalPreapprovedPaymentReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalPreapprovedPaymentReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalPreapprovedPaymentReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalPreapprovedPaymentReply * SOAP_FMAC4 soap_get_ns2__PayPalPreapprovedPaymentReply(struct soap *soap, ns2__PayPalPreapprovedPaymentReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalPreapprovedPaymentReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalButtonCreateReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalButtonCreateReply::reasonCode = NULL;
	this->ns2__PayPalButtonCreateReply::encryptedFormData = NULL;
	this->ns2__PayPalButtonCreateReply::unencryptedFormData = NULL;
	this->ns2__PayPalButtonCreateReply::requestDateTime = NULL;
	this->ns2__PayPalButtonCreateReply::reconciliationID = NULL;
	this->ns2__PayPalButtonCreateReply::buttonType = NULL;
	/* transient soap skipped */
}

void ns2__PayPalButtonCreateReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PayPalButtonCreateReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalButtonCreateReply::encryptedFormData);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalButtonCreateReply::unencryptedFormData);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__PayPalButtonCreateReply::requestDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalButtonCreateReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalButtonCreateReply::buttonType);
#endif
}

int ns2__PayPalButtonCreateReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalButtonCreateReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalButtonCreateReply(struct soap *soap, const char *tag, int id, const ns2__PayPalButtonCreateReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalButtonCreateReply), type))
		return soap->error;
	if (!a->ns2__PayPalButtonCreateReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PayPalButtonCreateReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:encryptedFormData", -1, (wchar_t*const*)&a->ns2__PayPalButtonCreateReply::encryptedFormData, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:unencryptedFormData", -1, (wchar_t*const*)&a->ns2__PayPalButtonCreateReply::unencryptedFormData, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__PayPalButtonCreateReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__PayPalButtonCreateReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:buttonType", -1, (wchar_t*const*)&a->ns2__PayPalButtonCreateReply::buttonType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalButtonCreateReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalButtonCreateReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalButtonCreateReply * SOAP_FMAC4 soap_in_ns2__PayPalButtonCreateReply(struct soap *soap, const char *tag, ns2__PayPalButtonCreateReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalButtonCreateReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalButtonCreateReply, sizeof(ns2__PayPalButtonCreateReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalButtonCreateReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalButtonCreateReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_encryptedFormData1 = 1;
	size_t soap_flag_unencryptedFormData1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_buttonType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PayPalButtonCreateReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_encryptedFormData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:encryptedFormData", (wchar_t**)&a->ns2__PayPalButtonCreateReply::encryptedFormData, "xsd:string"))
				{	soap_flag_encryptedFormData1--;
					continue;
				}
			if (soap_flag_unencryptedFormData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:unencryptedFormData", (wchar_t**)&a->ns2__PayPalButtonCreateReply::unencryptedFormData, "xsd:string"))
				{	soap_flag_unencryptedFormData1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__PayPalButtonCreateReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__PayPalButtonCreateReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_buttonType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:buttonType", (wchar_t**)&a->ns2__PayPalButtonCreateReply::buttonType, "xsd:string"))
				{	soap_flag_buttonType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PayPalButtonCreateReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalButtonCreateReply, SOAP_TYPE_ns2__PayPalButtonCreateReply, sizeof(ns2__PayPalButtonCreateReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalButtonCreateReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalButtonCreateReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalButtonCreateReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalButtonCreateReply *p;
	size_t k = sizeof(ns2__PayPalButtonCreateReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalButtonCreateReply);
		if (p)
			((ns2__PayPalButtonCreateReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalButtonCreateReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalButtonCreateReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalButtonCreateReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalButtonCreateReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalButtonCreateReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalButtonCreateReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalButtonCreateReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalButtonCreateReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalButtonCreateReply * SOAP_FMAC4 soap_get_ns2__PayPalButtonCreateReply(struct soap *soap, ns2__PayPalButtonCreateReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalButtonCreateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PinlessDebitReversalReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PinlessDebitReversalReply::reasonCode = NULL;
	this->ns2__PinlessDebitReversalReply::amount = NULL;
	this->ns2__PinlessDebitReversalReply::requestDateTime = NULL;
	this->ns2__PinlessDebitReversalReply::processorResponse = NULL;
	this->ns2__PinlessDebitReversalReply::reconciliationID = NULL;
	/* transient soap skipped */
}

void ns2__PinlessDebitReversalReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PinlessDebitReversalReply::reasonCode);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__PinlessDebitReversalReply::amount);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__PinlessDebitReversalReply::requestDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinlessDebitReversalReply::processorResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinlessDebitReversalReply::reconciliationID);
#endif
}

int ns2__PinlessDebitReversalReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PinlessDebitReversalReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PinlessDebitReversalReply(struct soap *soap, const char *tag, int id, const ns2__PinlessDebitReversalReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PinlessDebitReversalReply), type))
		return soap->error;
	if (!a->ns2__PinlessDebitReversalReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PinlessDebitReversalReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__PinlessDebitReversalReply::amount, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__PinlessDebitReversalReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__PinlessDebitReversalReply::processorResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__PinlessDebitReversalReply::reconciliationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PinlessDebitReversalReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PinlessDebitReversalReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PinlessDebitReversalReply * SOAP_FMAC4 soap_in_ns2__PinlessDebitReversalReply(struct soap *soap, const char *tag, ns2__PinlessDebitReversalReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PinlessDebitReversalReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PinlessDebitReversalReply, sizeof(ns2__PinlessDebitReversalReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PinlessDebitReversalReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PinlessDebitReversalReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PinlessDebitReversalReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__PinlessDebitReversalReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__PinlessDebitReversalReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__PinlessDebitReversalReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__PinlessDebitReversalReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PinlessDebitReversalReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PinlessDebitReversalReply, SOAP_TYPE_ns2__PinlessDebitReversalReply, sizeof(ns2__PinlessDebitReversalReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PinlessDebitReversalReply * SOAP_FMAC2 soap_instantiate_ns2__PinlessDebitReversalReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PinlessDebitReversalReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PinlessDebitReversalReply *p;
	size_t k = sizeof(ns2__PinlessDebitReversalReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PinlessDebitReversalReply);
		if (p)
			((ns2__PinlessDebitReversalReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PinlessDebitReversalReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PinlessDebitReversalReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PinlessDebitReversalReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PinlessDebitReversalReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PinlessDebitReversalReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PinlessDebitReversalReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PinlessDebitReversalReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PinlessDebitReversalReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PinlessDebitReversalReply * SOAP_FMAC4 soap_get_ns2__PinlessDebitReversalReply(struct soap *soap, ns2__PinlessDebitReversalReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PinlessDebitReversalReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PinlessDebitValidateReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PinlessDebitValidateReply::reasonCode = NULL;
	this->ns2__PinlessDebitValidateReply::status = NULL;
	this->ns2__PinlessDebitValidateReply::requestDateTime = NULL;
	/* transient soap skipped */
}

void ns2__PinlessDebitValidateReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PinlessDebitValidateReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinlessDebitValidateReply::status);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__PinlessDebitValidateReply::requestDateTime);
#endif
}

int ns2__PinlessDebitValidateReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PinlessDebitValidateReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PinlessDebitValidateReply(struct soap *soap, const char *tag, int id, const ns2__PinlessDebitValidateReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PinlessDebitValidateReply), type))
		return soap->error;
	if (!a->ns2__PinlessDebitValidateReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PinlessDebitValidateReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:status", -1, (wchar_t*const*)&a->ns2__PinlessDebitValidateReply::status, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__PinlessDebitValidateReply::requestDateTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PinlessDebitValidateReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PinlessDebitValidateReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PinlessDebitValidateReply * SOAP_FMAC4 soap_in_ns2__PinlessDebitValidateReply(struct soap *soap, const char *tag, ns2__PinlessDebitValidateReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PinlessDebitValidateReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PinlessDebitValidateReply, sizeof(ns2__PinlessDebitValidateReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PinlessDebitValidateReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PinlessDebitValidateReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PinlessDebitValidateReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:status", (wchar_t**)&a->ns2__PinlessDebitValidateReply::status, "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__PinlessDebitValidateReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PinlessDebitValidateReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PinlessDebitValidateReply, SOAP_TYPE_ns2__PinlessDebitValidateReply, sizeof(ns2__PinlessDebitValidateReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PinlessDebitValidateReply * SOAP_FMAC2 soap_instantiate_ns2__PinlessDebitValidateReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PinlessDebitValidateReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PinlessDebitValidateReply *p;
	size_t k = sizeof(ns2__PinlessDebitValidateReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PinlessDebitValidateReply);
		if (p)
			((ns2__PinlessDebitValidateReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PinlessDebitValidateReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PinlessDebitValidateReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PinlessDebitValidateReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PinlessDebitValidateReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PinlessDebitValidateReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PinlessDebitValidateReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PinlessDebitValidateReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PinlessDebitValidateReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PinlessDebitValidateReply * SOAP_FMAC4 soap_get_ns2__PinlessDebitValidateReply(struct soap *soap, ns2__PinlessDebitValidateReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PinlessDebitValidateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PinlessDebitReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PinlessDebitReply::reasonCode = NULL;
	this->ns2__PinlessDebitReply::amount = NULL;
	this->ns2__PinlessDebitReply::authorizationCode = NULL;
	this->ns2__PinlessDebitReply::requestDateTime = NULL;
	this->ns2__PinlessDebitReply::processorResponse = NULL;
	this->ns2__PinlessDebitReply::receiptNumber = NULL;
	this->ns2__PinlessDebitReply::reconciliationID = NULL;
	this->ns2__PinlessDebitReply::ownerMerchantID = NULL;
	/* transient soap skipped */
}

void ns2__PinlessDebitReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PinlessDebitReply::reasonCode);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__PinlessDebitReply::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinlessDebitReply::authorizationCode);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__PinlessDebitReply::requestDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinlessDebitReply::processorResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinlessDebitReply::receiptNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinlessDebitReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinlessDebitReply::ownerMerchantID);
#endif
}

int ns2__PinlessDebitReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PinlessDebitReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PinlessDebitReply(struct soap *soap, const char *tag, int id, const ns2__PinlessDebitReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PinlessDebitReply), type))
		return soap->error;
	if (!a->ns2__PinlessDebitReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PinlessDebitReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__PinlessDebitReply::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authorizationCode", -1, (wchar_t*const*)&a->ns2__PinlessDebitReply::authorizationCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__PinlessDebitReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__PinlessDebitReply::processorResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:receiptNumber", -1, (wchar_t*const*)&a->ns2__PinlessDebitReply::receiptNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__PinlessDebitReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ownerMerchantID", -1, (wchar_t*const*)&a->ns2__PinlessDebitReply::ownerMerchantID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PinlessDebitReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PinlessDebitReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PinlessDebitReply * SOAP_FMAC4 soap_in_ns2__PinlessDebitReply(struct soap *soap, const char *tag, ns2__PinlessDebitReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PinlessDebitReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PinlessDebitReply, sizeof(ns2__PinlessDebitReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PinlessDebitReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PinlessDebitReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_authorizationCode1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_receiptNumber1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_ownerMerchantID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PinlessDebitReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__PinlessDebitReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_authorizationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authorizationCode", (wchar_t**)&a->ns2__PinlessDebitReply::authorizationCode, "xsd:string"))
				{	soap_flag_authorizationCode1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__PinlessDebitReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__PinlessDebitReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_receiptNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:receiptNumber", (wchar_t**)&a->ns2__PinlessDebitReply::receiptNumber, "xsd:string"))
				{	soap_flag_receiptNumber1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__PinlessDebitReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_ownerMerchantID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ownerMerchantID", (wchar_t**)&a->ns2__PinlessDebitReply::ownerMerchantID, "xsd:string"))
				{	soap_flag_ownerMerchantID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PinlessDebitReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PinlessDebitReply, SOAP_TYPE_ns2__PinlessDebitReply, sizeof(ns2__PinlessDebitReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PinlessDebitReply * SOAP_FMAC2 soap_instantiate_ns2__PinlessDebitReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PinlessDebitReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PinlessDebitReply *p;
	size_t k = sizeof(ns2__PinlessDebitReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PinlessDebitReply);
		if (p)
			((ns2__PinlessDebitReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PinlessDebitReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PinlessDebitReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PinlessDebitReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PinlessDebitReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PinlessDebitReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PinlessDebitReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PinlessDebitReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PinlessDebitReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PinlessDebitReply * SOAP_FMAC4 soap_get_ns2__PinlessDebitReply(struct soap *soap, ns2__PinlessDebitReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PinlessDebitReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__VoidReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__VoidReply::reasonCode = NULL;
	this->ns2__VoidReply::requestDateTime = NULL;
	this->ns2__VoidReply::amount = NULL;
	this->ns2__VoidReply::currency = NULL;
	/* transient soap skipped */
}

void ns2__VoidReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__VoidReply::reasonCode);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__VoidReply::requestDateTime);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__VoidReply::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VoidReply::currency);
#endif
}

int ns2__VoidReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__VoidReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VoidReply(struct soap *soap, const char *tag, int id, const ns2__VoidReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VoidReply), type))
		return soap->error;
	if (!a->ns2__VoidReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__VoidReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__VoidReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__VoidReply::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:currency", -1, (wchar_t*const*)&a->ns2__VoidReply::currency, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__VoidReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__VoidReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__VoidReply * SOAP_FMAC4 soap_in_ns2__VoidReply(struct soap *soap, const char *tag, ns2__VoidReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__VoidReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VoidReply, sizeof(ns2__VoidReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__VoidReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__VoidReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_currency1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__VoidReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__VoidReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__VoidReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_currency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:currency", (wchar_t**)&a->ns2__VoidReply::currency, "xsd:string"))
				{	soap_flag_currency1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__VoidReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VoidReply, SOAP_TYPE_ns2__VoidReply, sizeof(ns2__VoidReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__VoidReply * SOAP_FMAC2 soap_instantiate_ns2__VoidReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__VoidReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__VoidReply *p;
	size_t k = sizeof(ns2__VoidReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__VoidReply);
		if (p)
			((ns2__VoidReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__VoidReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__VoidReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__VoidReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__VoidReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__VoidReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:VoidReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__VoidReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__VoidReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__VoidReply * SOAP_FMAC4 soap_get_ns2__VoidReply(struct soap *soap, ns2__VoidReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VoidReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalCreditReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalCreditReply::reasonCode = NULL;
	this->ns2__PayPalCreditReply::amount = NULL;
	this->ns2__PayPalCreditReply::requestDateTime = NULL;
	this->ns2__PayPalCreditReply::reconciliationID = NULL;
	this->ns2__PayPalCreditReply::processorResponse = NULL;
	/* transient soap skipped */
}

void ns2__PayPalCreditReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PayPalCreditReply::reasonCode);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__PayPalCreditReply::amount);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__PayPalCreditReply::requestDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalCreditReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalCreditReply::processorResponse);
#endif
}

int ns2__PayPalCreditReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalCreditReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalCreditReply(struct soap *soap, const char *tag, int id, const ns2__PayPalCreditReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalCreditReply), type))
		return soap->error;
	if (!a->ns2__PayPalCreditReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PayPalCreditReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__PayPalCreditReply::amount, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__PayPalCreditReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__PayPalCreditReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__PayPalCreditReply::processorResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalCreditReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalCreditReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalCreditReply * SOAP_FMAC4 soap_in_ns2__PayPalCreditReply(struct soap *soap, const char *tag, ns2__PayPalCreditReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalCreditReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalCreditReply, sizeof(ns2__PayPalCreditReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalCreditReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalCreditReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PayPalCreditReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__PayPalCreditReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__PayPalCreditReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__PayPalCreditReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__PayPalCreditReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PayPalCreditReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalCreditReply, SOAP_TYPE_ns2__PayPalCreditReply, sizeof(ns2__PayPalCreditReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalCreditReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalCreditReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalCreditReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalCreditReply *p;
	size_t k = sizeof(ns2__PayPalCreditReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalCreditReply);
		if (p)
			((ns2__PayPalCreditReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalCreditReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalCreditReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalCreditReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalCreditReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalCreditReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalCreditReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalCreditReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalCreditReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalCreditReply * SOAP_FMAC4 soap_get_ns2__PayPalCreditReply(struct soap *soap, ns2__PayPalCreditReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalCreditReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalPaymentReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalPaymentReply::reasonCode = NULL;
	this->ns2__PayPalPaymentReply::secureData = NULL;
	this->ns2__PayPalPaymentReply::amount = NULL;
	this->ns2__PayPalPaymentReply::requestDateTime = NULL;
	this->ns2__PayPalPaymentReply::reconciliationID = NULL;
	/* transient soap skipped */
}

void ns2__PayPalPaymentReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PayPalPaymentReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPaymentReply::secureData);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__PayPalPaymentReply::amount);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__PayPalPaymentReply::requestDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPaymentReply::reconciliationID);
#endif
}

int ns2__PayPalPaymentReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalPaymentReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalPaymentReply(struct soap *soap, const char *tag, int id, const ns2__PayPalPaymentReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalPaymentReply), type))
		return soap->error;
	if (!a->ns2__PayPalPaymentReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PayPalPaymentReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:secureData", -1, (wchar_t*const*)&a->ns2__PayPalPaymentReply::secureData, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__PayPalPaymentReply::amount, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__PayPalPaymentReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__PayPalPaymentReply::reconciliationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalPaymentReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalPaymentReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalPaymentReply * SOAP_FMAC4 soap_in_ns2__PayPalPaymentReply(struct soap *soap, const char *tag, ns2__PayPalPaymentReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalPaymentReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalPaymentReply, sizeof(ns2__PayPalPaymentReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalPaymentReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalPaymentReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_secureData1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PayPalPaymentReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_secureData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:secureData", (wchar_t**)&a->ns2__PayPalPaymentReply::secureData, "xsd:string"))
				{	soap_flag_secureData1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__PayPalPaymentReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__PayPalPaymentReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__PayPalPaymentReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PayPalPaymentReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalPaymentReply, SOAP_TYPE_ns2__PayPalPaymentReply, sizeof(ns2__PayPalPaymentReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalPaymentReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalPaymentReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalPaymentReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalPaymentReply *p;
	size_t k = sizeof(ns2__PayPalPaymentReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalPaymentReply);
		if (p)
			((ns2__PayPalPaymentReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalPaymentReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalPaymentReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalPaymentReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalPaymentReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalPaymentReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalPaymentReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalPaymentReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalPaymentReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalPaymentReply * SOAP_FMAC4 soap_get_ns2__PayPalPaymentReply(struct soap *soap, ns2__PayPalPaymentReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalPaymentReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PaySubscriptionDeleteReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PaySubscriptionDeleteReply::reasonCode = NULL;
	this->ns2__PaySubscriptionDeleteReply::subscriptionID = NULL;
	/* transient soap skipped */
}

void ns2__PaySubscriptionDeleteReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PaySubscriptionDeleteReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionDeleteReply::subscriptionID);
#endif
}

int ns2__PaySubscriptionDeleteReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PaySubscriptionDeleteReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PaySubscriptionDeleteReply(struct soap *soap, const char *tag, int id, const ns2__PaySubscriptionDeleteReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PaySubscriptionDeleteReply), type))
		return soap->error;
	if (!a->ns2__PaySubscriptionDeleteReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PaySubscriptionDeleteReply::reasonCode, ""))
		return soap->error;
	if (!a->ns2__PaySubscriptionDeleteReply::subscriptionID)
	{	if (soap_element_nil(soap, "ns2:subscriptionID"))
			return soap->error;
	}
	else
	if (soap_out_wstring(soap, "ns2:subscriptionID", -1, (wchar_t*const*)&a->ns2__PaySubscriptionDeleteReply::subscriptionID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PaySubscriptionDeleteReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PaySubscriptionDeleteReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PaySubscriptionDeleteReply * SOAP_FMAC4 soap_in_ns2__PaySubscriptionDeleteReply(struct soap *soap, const char *tag, ns2__PaySubscriptionDeleteReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PaySubscriptionDeleteReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PaySubscriptionDeleteReply, sizeof(ns2__PaySubscriptionDeleteReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PaySubscriptionDeleteReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PaySubscriptionDeleteReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_subscriptionID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PaySubscriptionDeleteReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_subscriptionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:subscriptionID", (wchar_t**)&a->ns2__PaySubscriptionDeleteReply::subscriptionID, "xsd:string"))
				{	soap_flag_subscriptionID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0 || soap_flag_subscriptionID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PaySubscriptionDeleteReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PaySubscriptionDeleteReply, SOAP_TYPE_ns2__PaySubscriptionDeleteReply, sizeof(ns2__PaySubscriptionDeleteReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PaySubscriptionDeleteReply * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionDeleteReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PaySubscriptionDeleteReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PaySubscriptionDeleteReply *p;
	size_t k = sizeof(ns2__PaySubscriptionDeleteReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PaySubscriptionDeleteReply);
		if (p)
			((ns2__PaySubscriptionDeleteReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PaySubscriptionDeleteReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PaySubscriptionDeleteReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PaySubscriptionDeleteReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PaySubscriptionDeleteReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PaySubscriptionDeleteReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PaySubscriptionDeleteReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PaySubscriptionDeleteReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PaySubscriptionDeleteReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PaySubscriptionDeleteReply * SOAP_FMAC4 soap_get_ns2__PaySubscriptionDeleteReply(struct soap *soap, ns2__PaySubscriptionDeleteReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PaySubscriptionDeleteReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PaySubscriptionRetrieveReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PaySubscriptionRetrieveReply::reasonCode = NULL;
	this->ns2__PaySubscriptionRetrieveReply::approvalRequired = NULL;
	this->ns2__PaySubscriptionRetrieveReply::automaticRenew = NULL;
	this->ns2__PaySubscriptionRetrieveReply::cardAccountNumber = NULL;
	this->ns2__PaySubscriptionRetrieveReply::cardExpirationMonth = NULL;
	this->ns2__PaySubscriptionRetrieveReply::cardExpirationYear = NULL;
	this->ns2__PaySubscriptionRetrieveReply::cardIssueNumber = NULL;
	this->ns2__PaySubscriptionRetrieveReply::cardStartMonth = NULL;
	this->ns2__PaySubscriptionRetrieveReply::cardStartYear = NULL;
	this->ns2__PaySubscriptionRetrieveReply::cardType = NULL;
	this->ns2__PaySubscriptionRetrieveReply::checkAccountNumber = NULL;
	this->ns2__PaySubscriptionRetrieveReply::checkAccountType = NULL;
	this->ns2__PaySubscriptionRetrieveReply::checkBankTransitNumber = NULL;
	this->ns2__PaySubscriptionRetrieveReply::checkSecCode = NULL;
	this->ns2__PaySubscriptionRetrieveReply::checkAuthenticateID = NULL;
	this->ns2__PaySubscriptionRetrieveReply::city = NULL;
	this->ns2__PaySubscriptionRetrieveReply::comments = NULL;
	this->ns2__PaySubscriptionRetrieveReply::companyName = NULL;
	this->ns2__PaySubscriptionRetrieveReply::country = NULL;
	this->ns2__PaySubscriptionRetrieveReply::currency = NULL;
	this->ns2__PaySubscriptionRetrieveReply::customerAccountID = NULL;
	this->ns2__PaySubscriptionRetrieveReply::email = NULL;
	this->ns2__PaySubscriptionRetrieveReply::endDate = NULL;
	this->ns2__PaySubscriptionRetrieveReply::firstName = NULL;
	this->ns2__PaySubscriptionRetrieveReply::frequency = NULL;
	this->ns2__PaySubscriptionRetrieveReply::lastName = NULL;
	this->ns2__PaySubscriptionRetrieveReply::merchantReferenceCode = NULL;
	this->ns2__PaySubscriptionRetrieveReply::paymentMethod = NULL;
	this->ns2__PaySubscriptionRetrieveReply::paymentsRemaining = NULL;
	this->ns2__PaySubscriptionRetrieveReply::phoneNumber = NULL;
	this->ns2__PaySubscriptionRetrieveReply::postalCode = NULL;
	this->ns2__PaySubscriptionRetrieveReply::recurringAmount = NULL;
	this->ns2__PaySubscriptionRetrieveReply::setupAmount = NULL;
	this->ns2__PaySubscriptionRetrieveReply::startDate = NULL;
	this->ns2__PaySubscriptionRetrieveReply::state = NULL;
	this->ns2__PaySubscriptionRetrieveReply::status = NULL;
	this->ns2__PaySubscriptionRetrieveReply::street1 = NULL;
	this->ns2__PaySubscriptionRetrieveReply::street2 = NULL;
	this->ns2__PaySubscriptionRetrieveReply::subscriptionID = NULL;
	this->ns2__PaySubscriptionRetrieveReply::subscriptionIDNew = NULL;
	this->ns2__PaySubscriptionRetrieveReply::title = NULL;
	this->ns2__PaySubscriptionRetrieveReply::totalPayments = NULL;
	this->ns2__PaySubscriptionRetrieveReply::shipToFirstName = NULL;
	this->ns2__PaySubscriptionRetrieveReply::shipToLastName = NULL;
	this->ns2__PaySubscriptionRetrieveReply::shipToStreet1 = NULL;
	this->ns2__PaySubscriptionRetrieveReply::shipToStreet2 = NULL;
	this->ns2__PaySubscriptionRetrieveReply::shipToCity = NULL;
	this->ns2__PaySubscriptionRetrieveReply::shipToState = NULL;
	this->ns2__PaySubscriptionRetrieveReply::shipToPostalCode = NULL;
	this->ns2__PaySubscriptionRetrieveReply::shipToCompany = NULL;
	this->ns2__PaySubscriptionRetrieveReply::shipToCountry = NULL;
	this->ns2__PaySubscriptionRetrieveReply::billPayment = NULL;
	this->ns2__PaySubscriptionRetrieveReply::merchantDefinedDataField1 = NULL;
	this->ns2__PaySubscriptionRetrieveReply::merchantDefinedDataField2 = NULL;
	this->ns2__PaySubscriptionRetrieveReply::merchantDefinedDataField3 = NULL;
	this->ns2__PaySubscriptionRetrieveReply::merchantDefinedDataField4 = NULL;
	this->ns2__PaySubscriptionRetrieveReply::merchantSecureDataField1 = NULL;
	this->ns2__PaySubscriptionRetrieveReply::merchantSecureDataField2 = NULL;
	this->ns2__PaySubscriptionRetrieveReply::merchantSecureDataField3 = NULL;
	this->ns2__PaySubscriptionRetrieveReply::merchantSecureDataField4 = NULL;
	this->ns2__PaySubscriptionRetrieveReply::ownerMerchantID = NULL;
	this->ns2__PaySubscriptionRetrieveReply::companyTaxID = NULL;
	this->ns2__PaySubscriptionRetrieveReply::driversLicenseNumber = NULL;
	this->ns2__PaySubscriptionRetrieveReply::driversLicenseState = NULL;
	this->ns2__PaySubscriptionRetrieveReply::dateOfBirth = NULL;
	/* transient soap skipped */
}

void ns2__PaySubscriptionRetrieveReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::approvalRequired);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::automaticRenew);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::cardAccountNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::cardExpirationMonth);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::cardExpirationYear);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::cardIssueNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::cardStartMonth);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::cardStartYear);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::cardType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::checkAccountNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::checkAccountType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::checkBankTransitNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::checkSecCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::checkAuthenticateID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::city);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::comments);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::companyName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::country);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::currency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::customerAccountID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::email);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::endDate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::firstName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::frequency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::lastName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::merchantReferenceCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::paymentMethod);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::paymentsRemaining);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::phoneNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::postalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::recurringAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::setupAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::startDate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::state);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::status);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::street1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::street2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::subscriptionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::subscriptionIDNew);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::title);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::totalPayments);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::shipToFirstName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::shipToLastName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::shipToStreet1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::shipToStreet2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::shipToCity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::shipToState);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::shipToPostalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::shipToCompany);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::shipToCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::billPayment);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::merchantDefinedDataField1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::merchantDefinedDataField2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::merchantDefinedDataField3);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::merchantDefinedDataField4);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::merchantSecureDataField1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::merchantSecureDataField2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::merchantSecureDataField3);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::merchantSecureDataField4);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::ownerMerchantID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::companyTaxID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::driversLicenseNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::driversLicenseState);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionRetrieveReply::dateOfBirth);
#endif
}

int ns2__PaySubscriptionRetrieveReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PaySubscriptionRetrieveReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PaySubscriptionRetrieveReply(struct soap *soap, const char *tag, int id, const ns2__PaySubscriptionRetrieveReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PaySubscriptionRetrieveReply), type))
		return soap->error;
	if (!a->ns2__PaySubscriptionRetrieveReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:approvalRequired", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::approvalRequired, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:automaticRenew", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::automaticRenew, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardAccountNumber", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::cardAccountNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardExpirationMonth", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::cardExpirationMonth, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardExpirationYear", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::cardExpirationYear, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardIssueNumber", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::cardIssueNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardStartMonth", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::cardStartMonth, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardStartYear", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::cardStartYear, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardType", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::cardType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:checkAccountNumber", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::checkAccountNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:checkAccountType", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::checkAccountType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:checkBankTransitNumber", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::checkBankTransitNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:checkSecCode", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::checkSecCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:checkAuthenticateID", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::checkAuthenticateID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:city", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::city, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:comments", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::comments, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:companyName", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::companyName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:country", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::country, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:currency", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::currency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:customerAccountID", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::customerAccountID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:email", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::email, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:endDate", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::endDate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:firstName", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::firstName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:frequency", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::frequency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:lastName", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::lastName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantReferenceCode", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::merchantReferenceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentMethod", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::paymentMethod, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentsRemaining", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::paymentsRemaining, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:phoneNumber", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::phoneNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:postalCode", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::postalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:recurringAmount", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::recurringAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:setupAmount", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::setupAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:startDate", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::startDate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:state", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::state, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:status", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::status, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:street1", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::street1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:street2", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::street2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:subscriptionID", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::subscriptionID, ""))
		return soap->error;
	if (!a->ns2__PaySubscriptionRetrieveReply::subscriptionIDNew)
	{	if (soap_element_nil(soap, "ns2:subscriptionIDNew"))
			return soap->error;
	}
	else
	if (soap_out_wstring(soap, "ns2:subscriptionIDNew", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::subscriptionIDNew, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:title", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::title, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:totalPayments", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::totalPayments, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToFirstName", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::shipToFirstName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToLastName", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::shipToLastName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToStreet1", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::shipToStreet1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToStreet2", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::shipToStreet2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToCity", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::shipToCity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToState", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::shipToState, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToPostalCode", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::shipToPostalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToCompany", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::shipToCompany, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToCountry", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::shipToCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:billPayment", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::billPayment, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantDefinedDataField1", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::merchantDefinedDataField1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantDefinedDataField2", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::merchantDefinedDataField2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantDefinedDataField3", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::merchantDefinedDataField3, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantDefinedDataField4", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::merchantDefinedDataField4, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantSecureDataField1", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::merchantSecureDataField1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantSecureDataField2", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::merchantSecureDataField2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantSecureDataField3", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::merchantSecureDataField3, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantSecureDataField4", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::merchantSecureDataField4, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ownerMerchantID", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::ownerMerchantID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:companyTaxID", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::companyTaxID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:driversLicenseNumber", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::driversLicenseNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:driversLicenseState", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::driversLicenseState, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:dateOfBirth", -1, (wchar_t*const*)&a->ns2__PaySubscriptionRetrieveReply::dateOfBirth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PaySubscriptionRetrieveReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PaySubscriptionRetrieveReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PaySubscriptionRetrieveReply * SOAP_FMAC4 soap_in_ns2__PaySubscriptionRetrieveReply(struct soap *soap, const char *tag, ns2__PaySubscriptionRetrieveReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PaySubscriptionRetrieveReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PaySubscriptionRetrieveReply, sizeof(ns2__PaySubscriptionRetrieveReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PaySubscriptionRetrieveReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PaySubscriptionRetrieveReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_approvalRequired1 = 1;
	size_t soap_flag_automaticRenew1 = 1;
	size_t soap_flag_cardAccountNumber1 = 1;
	size_t soap_flag_cardExpirationMonth1 = 1;
	size_t soap_flag_cardExpirationYear1 = 1;
	size_t soap_flag_cardIssueNumber1 = 1;
	size_t soap_flag_cardStartMonth1 = 1;
	size_t soap_flag_cardStartYear1 = 1;
	size_t soap_flag_cardType1 = 1;
	size_t soap_flag_checkAccountNumber1 = 1;
	size_t soap_flag_checkAccountType1 = 1;
	size_t soap_flag_checkBankTransitNumber1 = 1;
	size_t soap_flag_checkSecCode1 = 1;
	size_t soap_flag_checkAuthenticateID1 = 1;
	size_t soap_flag_city1 = 1;
	size_t soap_flag_comments1 = 1;
	size_t soap_flag_companyName1 = 1;
	size_t soap_flag_country1 = 1;
	size_t soap_flag_currency1 = 1;
	size_t soap_flag_customerAccountID1 = 1;
	size_t soap_flag_email1 = 1;
	size_t soap_flag_endDate1 = 1;
	size_t soap_flag_firstName1 = 1;
	size_t soap_flag_frequency1 = 1;
	size_t soap_flag_lastName1 = 1;
	size_t soap_flag_merchantReferenceCode1 = 1;
	size_t soap_flag_paymentMethod1 = 1;
	size_t soap_flag_paymentsRemaining1 = 1;
	size_t soap_flag_phoneNumber1 = 1;
	size_t soap_flag_postalCode1 = 1;
	size_t soap_flag_recurringAmount1 = 1;
	size_t soap_flag_setupAmount1 = 1;
	size_t soap_flag_startDate1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_street11 = 1;
	size_t soap_flag_street21 = 1;
	size_t soap_flag_subscriptionID1 = 1;
	size_t soap_flag_subscriptionIDNew1 = 1;
	size_t soap_flag_title1 = 1;
	size_t soap_flag_totalPayments1 = 1;
	size_t soap_flag_shipToFirstName1 = 1;
	size_t soap_flag_shipToLastName1 = 1;
	size_t soap_flag_shipToStreet11 = 1;
	size_t soap_flag_shipToStreet21 = 1;
	size_t soap_flag_shipToCity1 = 1;
	size_t soap_flag_shipToState1 = 1;
	size_t soap_flag_shipToPostalCode1 = 1;
	size_t soap_flag_shipToCompany1 = 1;
	size_t soap_flag_shipToCountry1 = 1;
	size_t soap_flag_billPayment1 = 1;
	size_t soap_flag_merchantDefinedDataField11 = 1;
	size_t soap_flag_merchantDefinedDataField21 = 1;
	size_t soap_flag_merchantDefinedDataField31 = 1;
	size_t soap_flag_merchantDefinedDataField41 = 1;
	size_t soap_flag_merchantSecureDataField11 = 1;
	size_t soap_flag_merchantSecureDataField21 = 1;
	size_t soap_flag_merchantSecureDataField31 = 1;
	size_t soap_flag_merchantSecureDataField41 = 1;
	size_t soap_flag_ownerMerchantID1 = 1;
	size_t soap_flag_companyTaxID1 = 1;
	size_t soap_flag_driversLicenseNumber1 = 1;
	size_t soap_flag_driversLicenseState1 = 1;
	size_t soap_flag_dateOfBirth1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_approvalRequired1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:approvalRequired", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::approvalRequired, "xsd:string"))
				{	soap_flag_approvalRequired1--;
					continue;
				}
			if (soap_flag_automaticRenew1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:automaticRenew", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::automaticRenew, "xsd:string"))
				{	soap_flag_automaticRenew1--;
					continue;
				}
			if (soap_flag_cardAccountNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardAccountNumber", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::cardAccountNumber, "xsd:string"))
				{	soap_flag_cardAccountNumber1--;
					continue;
				}
			if (soap_flag_cardExpirationMonth1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardExpirationMonth", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::cardExpirationMonth, "xsd:string"))
				{	soap_flag_cardExpirationMonth1--;
					continue;
				}
			if (soap_flag_cardExpirationYear1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardExpirationYear", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::cardExpirationYear, "xsd:string"))
				{	soap_flag_cardExpirationYear1--;
					continue;
				}
			if (soap_flag_cardIssueNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardIssueNumber", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::cardIssueNumber, "xsd:string"))
				{	soap_flag_cardIssueNumber1--;
					continue;
				}
			if (soap_flag_cardStartMonth1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardStartMonth", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::cardStartMonth, "xsd:string"))
				{	soap_flag_cardStartMonth1--;
					continue;
				}
			if (soap_flag_cardStartYear1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardStartYear", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::cardStartYear, "xsd:string"))
				{	soap_flag_cardStartYear1--;
					continue;
				}
			if (soap_flag_cardType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardType", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::cardType, "xsd:string"))
				{	soap_flag_cardType1--;
					continue;
				}
			if (soap_flag_checkAccountNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:checkAccountNumber", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::checkAccountNumber, "xsd:string"))
				{	soap_flag_checkAccountNumber1--;
					continue;
				}
			if (soap_flag_checkAccountType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:checkAccountType", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::checkAccountType, "xsd:string"))
				{	soap_flag_checkAccountType1--;
					continue;
				}
			if (soap_flag_checkBankTransitNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:checkBankTransitNumber", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::checkBankTransitNumber, "xsd:string"))
				{	soap_flag_checkBankTransitNumber1--;
					continue;
				}
			if (soap_flag_checkSecCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:checkSecCode", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::checkSecCode, "xsd:string"))
				{	soap_flag_checkSecCode1--;
					continue;
				}
			if (soap_flag_checkAuthenticateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:checkAuthenticateID", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::checkAuthenticateID, "xsd:string"))
				{	soap_flag_checkAuthenticateID1--;
					continue;
				}
			if (soap_flag_city1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:city", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::city, "xsd:string"))
				{	soap_flag_city1--;
					continue;
				}
			if (soap_flag_comments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:comments", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::comments, "xsd:string"))
				{	soap_flag_comments1--;
					continue;
				}
			if (soap_flag_companyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:companyName", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::companyName, "xsd:string"))
				{	soap_flag_companyName1--;
					continue;
				}
			if (soap_flag_country1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:country", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::country, "xsd:string"))
				{	soap_flag_country1--;
					continue;
				}
			if (soap_flag_currency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:currency", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::currency, "xsd:string"))
				{	soap_flag_currency1--;
					continue;
				}
			if (soap_flag_customerAccountID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:customerAccountID", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::customerAccountID, "xsd:string"))
				{	soap_flag_customerAccountID1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:email", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::email, "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			if (soap_flag_endDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:endDate", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::endDate, "xsd:string"))
				{	soap_flag_endDate1--;
					continue;
				}
			if (soap_flag_firstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:firstName", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::firstName, "xsd:string"))
				{	soap_flag_firstName1--;
					continue;
				}
			if (soap_flag_frequency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:frequency", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::frequency, "xsd:string"))
				{	soap_flag_frequency1--;
					continue;
				}
			if (soap_flag_lastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:lastName", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::lastName, "xsd:string"))
				{	soap_flag_lastName1--;
					continue;
				}
			if (soap_flag_merchantReferenceCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantReferenceCode", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::merchantReferenceCode, "xsd:string"))
				{	soap_flag_merchantReferenceCode1--;
					continue;
				}
			if (soap_flag_paymentMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentMethod", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::paymentMethod, "xsd:string"))
				{	soap_flag_paymentMethod1--;
					continue;
				}
			if (soap_flag_paymentsRemaining1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentsRemaining", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::paymentsRemaining, "xsd:string"))
				{	soap_flag_paymentsRemaining1--;
					continue;
				}
			if (soap_flag_phoneNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:phoneNumber", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::phoneNumber, "xsd:string"))
				{	soap_flag_phoneNumber1--;
					continue;
				}
			if (soap_flag_postalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:postalCode", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::postalCode, "xsd:string"))
				{	soap_flag_postalCode1--;
					continue;
				}
			if (soap_flag_recurringAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:recurringAmount", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::recurringAmount, "xsd:string"))
				{	soap_flag_recurringAmount1--;
					continue;
				}
			if (soap_flag_setupAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:setupAmount", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::setupAmount, "xsd:string"))
				{	soap_flag_setupAmount1--;
					continue;
				}
			if (soap_flag_startDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:startDate", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::startDate, "xsd:string"))
				{	soap_flag_startDate1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:state", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::state, "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:status", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::status, "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_street11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:street1", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::street1, "xsd:string"))
				{	soap_flag_street11--;
					continue;
				}
			if (soap_flag_street21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:street2", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::street2, "xsd:string"))
				{	soap_flag_street21--;
					continue;
				}
			if (soap_flag_subscriptionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:subscriptionID", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::subscriptionID, "xsd:string"))
				{	soap_flag_subscriptionID1--;
					continue;
				}
			if (soap_flag_subscriptionIDNew1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:subscriptionIDNew", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::subscriptionIDNew, "xsd:string"))
				{	soap_flag_subscriptionIDNew1--;
					continue;
				}
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:title", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::title, "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			if (soap_flag_totalPayments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:totalPayments", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::totalPayments, "xsd:string"))
				{	soap_flag_totalPayments1--;
					continue;
				}
			if (soap_flag_shipToFirstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToFirstName", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::shipToFirstName, "xsd:string"))
				{	soap_flag_shipToFirstName1--;
					continue;
				}
			if (soap_flag_shipToLastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToLastName", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::shipToLastName, "xsd:string"))
				{	soap_flag_shipToLastName1--;
					continue;
				}
			if (soap_flag_shipToStreet11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToStreet1", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::shipToStreet1, "xsd:string"))
				{	soap_flag_shipToStreet11--;
					continue;
				}
			if (soap_flag_shipToStreet21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToStreet2", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::shipToStreet2, "xsd:string"))
				{	soap_flag_shipToStreet21--;
					continue;
				}
			if (soap_flag_shipToCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToCity", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::shipToCity, "xsd:string"))
				{	soap_flag_shipToCity1--;
					continue;
				}
			if (soap_flag_shipToState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToState", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::shipToState, "xsd:string"))
				{	soap_flag_shipToState1--;
					continue;
				}
			if (soap_flag_shipToPostalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToPostalCode", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::shipToPostalCode, "xsd:string"))
				{	soap_flag_shipToPostalCode1--;
					continue;
				}
			if (soap_flag_shipToCompany1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToCompany", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::shipToCompany, "xsd:string"))
				{	soap_flag_shipToCompany1--;
					continue;
				}
			if (soap_flag_shipToCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToCountry", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::shipToCountry, "xsd:string"))
				{	soap_flag_shipToCountry1--;
					continue;
				}
			if (soap_flag_billPayment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:billPayment", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::billPayment, "xsd:string"))
				{	soap_flag_billPayment1--;
					continue;
				}
			if (soap_flag_merchantDefinedDataField11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantDefinedDataField1", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::merchantDefinedDataField1, "xsd:string"))
				{	soap_flag_merchantDefinedDataField11--;
					continue;
				}
			if (soap_flag_merchantDefinedDataField21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantDefinedDataField2", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::merchantDefinedDataField2, "xsd:string"))
				{	soap_flag_merchantDefinedDataField21--;
					continue;
				}
			if (soap_flag_merchantDefinedDataField31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantDefinedDataField3", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::merchantDefinedDataField3, "xsd:string"))
				{	soap_flag_merchantDefinedDataField31--;
					continue;
				}
			if (soap_flag_merchantDefinedDataField41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantDefinedDataField4", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::merchantDefinedDataField4, "xsd:string"))
				{	soap_flag_merchantDefinedDataField41--;
					continue;
				}
			if (soap_flag_merchantSecureDataField11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantSecureDataField1", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::merchantSecureDataField1, "xsd:string"))
				{	soap_flag_merchantSecureDataField11--;
					continue;
				}
			if (soap_flag_merchantSecureDataField21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantSecureDataField2", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::merchantSecureDataField2, "xsd:string"))
				{	soap_flag_merchantSecureDataField21--;
					continue;
				}
			if (soap_flag_merchantSecureDataField31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantSecureDataField3", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::merchantSecureDataField3, "xsd:string"))
				{	soap_flag_merchantSecureDataField31--;
					continue;
				}
			if (soap_flag_merchantSecureDataField41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantSecureDataField4", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::merchantSecureDataField4, "xsd:string"))
				{	soap_flag_merchantSecureDataField41--;
					continue;
				}
			if (soap_flag_ownerMerchantID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ownerMerchantID", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::ownerMerchantID, "xsd:string"))
				{	soap_flag_ownerMerchantID1--;
					continue;
				}
			if (soap_flag_companyTaxID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:companyTaxID", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::companyTaxID, "xsd:string"))
				{	soap_flag_companyTaxID1--;
					continue;
				}
			if (soap_flag_driversLicenseNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:driversLicenseNumber", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::driversLicenseNumber, "xsd:string"))
				{	soap_flag_driversLicenseNumber1--;
					continue;
				}
			if (soap_flag_driversLicenseState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:driversLicenseState", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::driversLicenseState, "xsd:string"))
				{	soap_flag_driversLicenseState1--;
					continue;
				}
			if (soap_flag_dateOfBirth1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:dateOfBirth", (wchar_t**)&a->ns2__PaySubscriptionRetrieveReply::dateOfBirth, "xsd:string"))
				{	soap_flag_dateOfBirth1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0 || soap_flag_subscriptionIDNew1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PaySubscriptionRetrieveReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PaySubscriptionRetrieveReply, SOAP_TYPE_ns2__PaySubscriptionRetrieveReply, sizeof(ns2__PaySubscriptionRetrieveReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PaySubscriptionRetrieveReply * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionRetrieveReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PaySubscriptionRetrieveReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PaySubscriptionRetrieveReply *p;
	size_t k = sizeof(ns2__PaySubscriptionRetrieveReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PaySubscriptionRetrieveReply);
		if (p)
			((ns2__PaySubscriptionRetrieveReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PaySubscriptionRetrieveReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PaySubscriptionRetrieveReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PaySubscriptionRetrieveReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PaySubscriptionRetrieveReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PaySubscriptionRetrieveReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PaySubscriptionRetrieveReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PaySubscriptionRetrieveReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PaySubscriptionRetrieveReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PaySubscriptionRetrieveReply * SOAP_FMAC4 soap_get_ns2__PaySubscriptionRetrieveReply(struct soap *soap, ns2__PaySubscriptionRetrieveReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PaySubscriptionRetrieveReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PaySubscriptionEventUpdateReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PaySubscriptionEventUpdateReply::reasonCode = NULL;
	this->ns2__PaySubscriptionEventUpdateReply::ownerMerchantID = NULL;
	/* transient soap skipped */
}

void ns2__PaySubscriptionEventUpdateReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PaySubscriptionEventUpdateReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionEventUpdateReply::ownerMerchantID);
#endif
}

int ns2__PaySubscriptionEventUpdateReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PaySubscriptionEventUpdateReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PaySubscriptionEventUpdateReply(struct soap *soap, const char *tag, int id, const ns2__PaySubscriptionEventUpdateReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply), type))
		return soap->error;
	if (!a->ns2__PaySubscriptionEventUpdateReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PaySubscriptionEventUpdateReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ownerMerchantID", -1, (wchar_t*const*)&a->ns2__PaySubscriptionEventUpdateReply::ownerMerchantID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PaySubscriptionEventUpdateReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PaySubscriptionEventUpdateReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PaySubscriptionEventUpdateReply * SOAP_FMAC4 soap_in_ns2__PaySubscriptionEventUpdateReply(struct soap *soap, const char *tag, ns2__PaySubscriptionEventUpdateReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PaySubscriptionEventUpdateReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply, sizeof(ns2__PaySubscriptionEventUpdateReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PaySubscriptionEventUpdateReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_ownerMerchantID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PaySubscriptionEventUpdateReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_ownerMerchantID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ownerMerchantID", (wchar_t**)&a->ns2__PaySubscriptionEventUpdateReply::ownerMerchantID, "xsd:string"))
				{	soap_flag_ownerMerchantID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PaySubscriptionEventUpdateReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply, SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply, sizeof(ns2__PaySubscriptionEventUpdateReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PaySubscriptionEventUpdateReply * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionEventUpdateReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PaySubscriptionEventUpdateReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PaySubscriptionEventUpdateReply *p;
	size_t k = sizeof(ns2__PaySubscriptionEventUpdateReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PaySubscriptionEventUpdateReply);
		if (p)
			((ns2__PaySubscriptionEventUpdateReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PaySubscriptionEventUpdateReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PaySubscriptionEventUpdateReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PaySubscriptionEventUpdateReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PaySubscriptionEventUpdateReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PaySubscriptionEventUpdateReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PaySubscriptionEventUpdateReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PaySubscriptionEventUpdateReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PaySubscriptionEventUpdateReply * SOAP_FMAC4 soap_get_ns2__PaySubscriptionEventUpdateReply(struct soap *soap, ns2__PaySubscriptionEventUpdateReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PaySubscriptionEventUpdateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PaySubscriptionUpdateReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PaySubscriptionUpdateReply::reasonCode = NULL;
	this->ns2__PaySubscriptionUpdateReply::subscriptionID = NULL;
	this->ns2__PaySubscriptionUpdateReply::subscriptionIDNew = NULL;
	this->ns2__PaySubscriptionUpdateReply::ownerMerchantID = NULL;
	/* transient soap skipped */
}

void ns2__PaySubscriptionUpdateReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PaySubscriptionUpdateReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionUpdateReply::subscriptionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionUpdateReply::subscriptionIDNew);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionUpdateReply::ownerMerchantID);
#endif
}

int ns2__PaySubscriptionUpdateReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PaySubscriptionUpdateReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PaySubscriptionUpdateReply(struct soap *soap, const char *tag, int id, const ns2__PaySubscriptionUpdateReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PaySubscriptionUpdateReply), type))
		return soap->error;
	if (!a->ns2__PaySubscriptionUpdateReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PaySubscriptionUpdateReply::reasonCode, ""))
		return soap->error;
	if (!a->ns2__PaySubscriptionUpdateReply::subscriptionID)
	{	if (soap_element_nil(soap, "ns2:subscriptionID"))
			return soap->error;
	}
	else
	if (soap_out_wstring(soap, "ns2:subscriptionID", -1, (wchar_t*const*)&a->ns2__PaySubscriptionUpdateReply::subscriptionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:subscriptionIDNew", -1, (wchar_t*const*)&a->ns2__PaySubscriptionUpdateReply::subscriptionIDNew, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ownerMerchantID", -1, (wchar_t*const*)&a->ns2__PaySubscriptionUpdateReply::ownerMerchantID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PaySubscriptionUpdateReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PaySubscriptionUpdateReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PaySubscriptionUpdateReply * SOAP_FMAC4 soap_in_ns2__PaySubscriptionUpdateReply(struct soap *soap, const char *tag, ns2__PaySubscriptionUpdateReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PaySubscriptionUpdateReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PaySubscriptionUpdateReply, sizeof(ns2__PaySubscriptionUpdateReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PaySubscriptionUpdateReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PaySubscriptionUpdateReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_subscriptionID1 = 1;
	size_t soap_flag_subscriptionIDNew1 = 1;
	size_t soap_flag_ownerMerchantID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PaySubscriptionUpdateReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_subscriptionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:subscriptionID", (wchar_t**)&a->ns2__PaySubscriptionUpdateReply::subscriptionID, "xsd:string"))
				{	soap_flag_subscriptionID1--;
					continue;
				}
			if (soap_flag_subscriptionIDNew1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:subscriptionIDNew", (wchar_t**)&a->ns2__PaySubscriptionUpdateReply::subscriptionIDNew, "xsd:string"))
				{	soap_flag_subscriptionIDNew1--;
					continue;
				}
			if (soap_flag_ownerMerchantID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ownerMerchantID", (wchar_t**)&a->ns2__PaySubscriptionUpdateReply::ownerMerchantID, "xsd:string"))
				{	soap_flag_ownerMerchantID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0 || soap_flag_subscriptionID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PaySubscriptionUpdateReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PaySubscriptionUpdateReply, SOAP_TYPE_ns2__PaySubscriptionUpdateReply, sizeof(ns2__PaySubscriptionUpdateReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PaySubscriptionUpdateReply * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionUpdateReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PaySubscriptionUpdateReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PaySubscriptionUpdateReply *p;
	size_t k = sizeof(ns2__PaySubscriptionUpdateReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PaySubscriptionUpdateReply);
		if (p)
			((ns2__PaySubscriptionUpdateReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PaySubscriptionUpdateReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PaySubscriptionUpdateReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PaySubscriptionUpdateReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PaySubscriptionUpdateReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PaySubscriptionUpdateReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PaySubscriptionUpdateReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PaySubscriptionUpdateReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PaySubscriptionUpdateReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PaySubscriptionUpdateReply * SOAP_FMAC4 soap_get_ns2__PaySubscriptionUpdateReply(struct soap *soap, ns2__PaySubscriptionUpdateReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PaySubscriptionUpdateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PaySubscriptionCreateReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PaySubscriptionCreateReply::reasonCode = NULL;
	this->ns2__PaySubscriptionCreateReply::subscriptionID = NULL;
	/* transient soap skipped */
}

void ns2__PaySubscriptionCreateReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PaySubscriptionCreateReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionCreateReply::subscriptionID);
#endif
}

int ns2__PaySubscriptionCreateReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PaySubscriptionCreateReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PaySubscriptionCreateReply(struct soap *soap, const char *tag, int id, const ns2__PaySubscriptionCreateReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PaySubscriptionCreateReply), type))
		return soap->error;
	if (!a->ns2__PaySubscriptionCreateReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PaySubscriptionCreateReply::reasonCode, ""))
		return soap->error;
	if (!a->ns2__PaySubscriptionCreateReply::subscriptionID)
	{	if (soap_element_nil(soap, "ns2:subscriptionID"))
			return soap->error;
	}
	else
	if (soap_out_wstring(soap, "ns2:subscriptionID", -1, (wchar_t*const*)&a->ns2__PaySubscriptionCreateReply::subscriptionID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PaySubscriptionCreateReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PaySubscriptionCreateReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PaySubscriptionCreateReply * SOAP_FMAC4 soap_in_ns2__PaySubscriptionCreateReply(struct soap *soap, const char *tag, ns2__PaySubscriptionCreateReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PaySubscriptionCreateReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PaySubscriptionCreateReply, sizeof(ns2__PaySubscriptionCreateReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PaySubscriptionCreateReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PaySubscriptionCreateReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_subscriptionID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PaySubscriptionCreateReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_subscriptionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:subscriptionID", (wchar_t**)&a->ns2__PaySubscriptionCreateReply::subscriptionID, "xsd:string"))
				{	soap_flag_subscriptionID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0 || soap_flag_subscriptionID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PaySubscriptionCreateReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PaySubscriptionCreateReply, SOAP_TYPE_ns2__PaySubscriptionCreateReply, sizeof(ns2__PaySubscriptionCreateReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PaySubscriptionCreateReply * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionCreateReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PaySubscriptionCreateReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PaySubscriptionCreateReply *p;
	size_t k = sizeof(ns2__PaySubscriptionCreateReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PaySubscriptionCreateReply);
		if (p)
			((ns2__PaySubscriptionCreateReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PaySubscriptionCreateReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PaySubscriptionCreateReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PaySubscriptionCreateReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PaySubscriptionCreateReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PaySubscriptionCreateReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PaySubscriptionCreateReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PaySubscriptionCreateReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PaySubscriptionCreateReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PaySubscriptionCreateReply * SOAP_FMAC4 soap_get_ns2__PaySubscriptionCreateReply(struct soap *soap, ns2__PaySubscriptionCreateReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PaySubscriptionCreateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DirectDebitRefundReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DirectDebitRefundReply::reasonCode = NULL;
	this->ns2__DirectDebitRefundReply::amount = NULL;
	this->ns2__DirectDebitRefundReply::requestDateTime = NULL;
	this->ns2__DirectDebitRefundReply::reconciliationID = NULL;
	this->ns2__DirectDebitRefundReply::processorResponse = NULL;
	this->ns2__DirectDebitRefundReply::processorTransactionID = NULL;
	this->ns2__DirectDebitRefundReply::iban = NULL;
	/* transient soap skipped */
}

void ns2__DirectDebitRefundReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__DirectDebitRefundReply::reasonCode);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__DirectDebitRefundReply::amount);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__DirectDebitRefundReply::requestDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitRefundReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitRefundReply::processorResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitRefundReply::processorTransactionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitRefundReply::iban);
#endif
}

int ns2__DirectDebitRefundReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DirectDebitRefundReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DirectDebitRefundReply(struct soap *soap, const char *tag, int id, const ns2__DirectDebitRefundReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DirectDebitRefundReply), type))
		return soap->error;
	if (!a->ns2__DirectDebitRefundReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__DirectDebitRefundReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__DirectDebitRefundReply::amount, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__DirectDebitRefundReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__DirectDebitRefundReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__DirectDebitRefundReply::processorResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorTransactionID", -1, (wchar_t*const*)&a->ns2__DirectDebitRefundReply::processorTransactionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:iban", -1, (wchar_t*const*)&a->ns2__DirectDebitRefundReply::iban, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DirectDebitRefundReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DirectDebitRefundReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DirectDebitRefundReply * SOAP_FMAC4 soap_in_ns2__DirectDebitRefundReply(struct soap *soap, const char *tag, ns2__DirectDebitRefundReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DirectDebitRefundReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DirectDebitRefundReply, sizeof(ns2__DirectDebitRefundReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DirectDebitRefundReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DirectDebitRefundReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_processorTransactionID1 = 1;
	size_t soap_flag_iban1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__DirectDebitRefundReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__DirectDebitRefundReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__DirectDebitRefundReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__DirectDebitRefundReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__DirectDebitRefundReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_processorTransactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorTransactionID", (wchar_t**)&a->ns2__DirectDebitRefundReply::processorTransactionID, "xsd:string"))
				{	soap_flag_processorTransactionID1--;
					continue;
				}
			if (soap_flag_iban1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:iban", (wchar_t**)&a->ns2__DirectDebitRefundReply::iban, "xsd:string"))
				{	soap_flag_iban1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__DirectDebitRefundReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DirectDebitRefundReply, SOAP_TYPE_ns2__DirectDebitRefundReply, sizeof(ns2__DirectDebitRefundReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DirectDebitRefundReply * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitRefundReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DirectDebitRefundReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DirectDebitRefundReply *p;
	size_t k = sizeof(ns2__DirectDebitRefundReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DirectDebitRefundReply);
		if (p)
			((ns2__DirectDebitRefundReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DirectDebitRefundReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DirectDebitRefundReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DirectDebitRefundReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DirectDebitRefundReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DirectDebitRefundReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:DirectDebitRefundReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DirectDebitRefundReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DirectDebitRefundReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DirectDebitRefundReply * SOAP_FMAC4 soap_get_ns2__DirectDebitRefundReply(struct soap *soap, ns2__DirectDebitRefundReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DirectDebitRefundReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DirectDebitValidateReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DirectDebitValidateReply::reasonCode = NULL;
	this->ns2__DirectDebitValidateReply::amount = NULL;
	this->ns2__DirectDebitValidateReply::requestDateTime = NULL;
	this->ns2__DirectDebitValidateReply::reconciliationID = NULL;
	this->ns2__DirectDebitValidateReply::processorResponse = NULL;
	this->ns2__DirectDebitValidateReply::iban = NULL;
	this->ns2__DirectDebitValidateReply::bankSwiftCode = NULL;
	/* transient soap skipped */
}

void ns2__DirectDebitValidateReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__DirectDebitValidateReply::reasonCode);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__DirectDebitValidateReply::amount);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__DirectDebitValidateReply::requestDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitValidateReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitValidateReply::processorResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitValidateReply::iban);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitValidateReply::bankSwiftCode);
#endif
}

int ns2__DirectDebitValidateReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DirectDebitValidateReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DirectDebitValidateReply(struct soap *soap, const char *tag, int id, const ns2__DirectDebitValidateReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DirectDebitValidateReply), type))
		return soap->error;
	if (!a->ns2__DirectDebitValidateReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__DirectDebitValidateReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__DirectDebitValidateReply::amount, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__DirectDebitValidateReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__DirectDebitValidateReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__DirectDebitValidateReply::processorResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:iban", -1, (wchar_t*const*)&a->ns2__DirectDebitValidateReply::iban, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:bankSwiftCode", -1, (wchar_t*const*)&a->ns2__DirectDebitValidateReply::bankSwiftCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DirectDebitValidateReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DirectDebitValidateReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DirectDebitValidateReply * SOAP_FMAC4 soap_in_ns2__DirectDebitValidateReply(struct soap *soap, const char *tag, ns2__DirectDebitValidateReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DirectDebitValidateReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DirectDebitValidateReply, sizeof(ns2__DirectDebitValidateReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DirectDebitValidateReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DirectDebitValidateReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_iban1 = 1;
	size_t soap_flag_bankSwiftCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__DirectDebitValidateReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__DirectDebitValidateReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__DirectDebitValidateReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__DirectDebitValidateReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__DirectDebitValidateReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_iban1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:iban", (wchar_t**)&a->ns2__DirectDebitValidateReply::iban, "xsd:string"))
				{	soap_flag_iban1--;
					continue;
				}
			if (soap_flag_bankSwiftCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:bankSwiftCode", (wchar_t**)&a->ns2__DirectDebitValidateReply::bankSwiftCode, "xsd:string"))
				{	soap_flag_bankSwiftCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__DirectDebitValidateReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DirectDebitValidateReply, SOAP_TYPE_ns2__DirectDebitValidateReply, sizeof(ns2__DirectDebitValidateReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DirectDebitValidateReply * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitValidateReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DirectDebitValidateReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DirectDebitValidateReply *p;
	size_t k = sizeof(ns2__DirectDebitValidateReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DirectDebitValidateReply);
		if (p)
			((ns2__DirectDebitValidateReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DirectDebitValidateReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DirectDebitValidateReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DirectDebitValidateReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DirectDebitValidateReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DirectDebitValidateReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:DirectDebitValidateReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DirectDebitValidateReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DirectDebitValidateReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DirectDebitValidateReply * SOAP_FMAC4 soap_get_ns2__DirectDebitValidateReply(struct soap *soap, ns2__DirectDebitValidateReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DirectDebitValidateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DirectDebitReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DirectDebitReply::reasonCode = NULL;
	this->ns2__DirectDebitReply::amount = NULL;
	this->ns2__DirectDebitReply::requestDateTime = NULL;
	this->ns2__DirectDebitReply::reconciliationID = NULL;
	this->ns2__DirectDebitReply::processorResponse = NULL;
	this->ns2__DirectDebitReply::processorTransactionID = NULL;
	this->ns2__DirectDebitReply::mandateAuthenticationDate = NULL;
	this->ns2__DirectDebitReply::mandateID = NULL;
	this->ns2__DirectDebitReply::iban = NULL;
	/* transient soap skipped */
}

void ns2__DirectDebitReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__DirectDebitReply::reasonCode);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__DirectDebitReply::amount);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__DirectDebitReply::requestDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitReply::processorResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitReply::processorTransactionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitReply::mandateAuthenticationDate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitReply::mandateID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitReply::iban);
#endif
}

int ns2__DirectDebitReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DirectDebitReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DirectDebitReply(struct soap *soap, const char *tag, int id, const ns2__DirectDebitReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DirectDebitReply), type))
		return soap->error;
	if (!a->ns2__DirectDebitReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__DirectDebitReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__DirectDebitReply::amount, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__DirectDebitReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__DirectDebitReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__DirectDebitReply::processorResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorTransactionID", -1, (wchar_t*const*)&a->ns2__DirectDebitReply::processorTransactionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:mandateAuthenticationDate", -1, (wchar_t*const*)&a->ns2__DirectDebitReply::mandateAuthenticationDate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:mandateID", -1, (wchar_t*const*)&a->ns2__DirectDebitReply::mandateID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:iban", -1, (wchar_t*const*)&a->ns2__DirectDebitReply::iban, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DirectDebitReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DirectDebitReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DirectDebitReply * SOAP_FMAC4 soap_in_ns2__DirectDebitReply(struct soap *soap, const char *tag, ns2__DirectDebitReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DirectDebitReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DirectDebitReply, sizeof(ns2__DirectDebitReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DirectDebitReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DirectDebitReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_processorTransactionID1 = 1;
	size_t soap_flag_mandateAuthenticationDate1 = 1;
	size_t soap_flag_mandateID1 = 1;
	size_t soap_flag_iban1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__DirectDebitReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__DirectDebitReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__DirectDebitReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__DirectDebitReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__DirectDebitReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_processorTransactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorTransactionID", (wchar_t**)&a->ns2__DirectDebitReply::processorTransactionID, "xsd:string"))
				{	soap_flag_processorTransactionID1--;
					continue;
				}
			if (soap_flag_mandateAuthenticationDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:mandateAuthenticationDate", (wchar_t**)&a->ns2__DirectDebitReply::mandateAuthenticationDate, "xsd:string"))
				{	soap_flag_mandateAuthenticationDate1--;
					continue;
				}
			if (soap_flag_mandateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:mandateID", (wchar_t**)&a->ns2__DirectDebitReply::mandateID, "xsd:string"))
				{	soap_flag_mandateID1--;
					continue;
				}
			if (soap_flag_iban1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:iban", (wchar_t**)&a->ns2__DirectDebitReply::iban, "xsd:string"))
				{	soap_flag_iban1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__DirectDebitReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DirectDebitReply, SOAP_TYPE_ns2__DirectDebitReply, sizeof(ns2__DirectDebitReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DirectDebitReply * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DirectDebitReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DirectDebitReply *p;
	size_t k = sizeof(ns2__DirectDebitReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DirectDebitReply);
		if (p)
			((ns2__DirectDebitReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DirectDebitReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DirectDebitReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DirectDebitReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DirectDebitReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DirectDebitReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:DirectDebitReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DirectDebitReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DirectDebitReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DirectDebitReply * SOAP_FMAC4 soap_get_ns2__DirectDebitReply(struct soap *soap, ns2__DirectDebitReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DirectDebitReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__BankTransferRefundReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__BankTransferRefundReply::reasonCode = NULL;
	this->ns2__BankTransferRefundReply::amount = NULL;
	this->ns2__BankTransferRefundReply::requestDateTime = NULL;
	this->ns2__BankTransferRefundReply::reconciliationID = NULL;
	this->ns2__BankTransferRefundReply::processorResponse = NULL;
	this->ns2__BankTransferRefundReply::iban = NULL;
	/* transient soap skipped */
}

void ns2__BankTransferRefundReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__BankTransferRefundReply::reasonCode);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__BankTransferRefundReply::amount);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__BankTransferRefundReply::requestDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferRefundReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferRefundReply::processorResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferRefundReply::iban);
#endif
}

int ns2__BankTransferRefundReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__BankTransferRefundReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BankTransferRefundReply(struct soap *soap, const char *tag, int id, const ns2__BankTransferRefundReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BankTransferRefundReply), type))
		return soap->error;
	if (!a->ns2__BankTransferRefundReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__BankTransferRefundReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__BankTransferRefundReply::amount, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__BankTransferRefundReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__BankTransferRefundReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__BankTransferRefundReply::processorResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:iban", -1, (wchar_t*const*)&a->ns2__BankTransferRefundReply::iban, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__BankTransferRefundReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__BankTransferRefundReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__BankTransferRefundReply * SOAP_FMAC4 soap_in_ns2__BankTransferRefundReply(struct soap *soap, const char *tag, ns2__BankTransferRefundReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__BankTransferRefundReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BankTransferRefundReply, sizeof(ns2__BankTransferRefundReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__BankTransferRefundReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__BankTransferRefundReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_iban1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__BankTransferRefundReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__BankTransferRefundReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__BankTransferRefundReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__BankTransferRefundReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__BankTransferRefundReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_iban1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:iban", (wchar_t**)&a->ns2__BankTransferRefundReply::iban, "xsd:string"))
				{	soap_flag_iban1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__BankTransferRefundReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BankTransferRefundReply, SOAP_TYPE_ns2__BankTransferRefundReply, sizeof(ns2__BankTransferRefundReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__BankTransferRefundReply * SOAP_FMAC2 soap_instantiate_ns2__BankTransferRefundReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__BankTransferRefundReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__BankTransferRefundReply *p;
	size_t k = sizeof(ns2__BankTransferRefundReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__BankTransferRefundReply);
		if (p)
			((ns2__BankTransferRefundReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__BankTransferRefundReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__BankTransferRefundReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__BankTransferRefundReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__BankTransferRefundReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__BankTransferRefundReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:BankTransferRefundReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__BankTransferRefundReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__BankTransferRefundReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__BankTransferRefundReply * SOAP_FMAC4 soap_get_ns2__BankTransferRefundReply(struct soap *soap, ns2__BankTransferRefundReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BankTransferRefundReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DirectDebitMandateReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DirectDebitMandateReply::reasonCode = NULL;
	this->ns2__DirectDebitMandateReply::mandateID = NULL;
	this->ns2__DirectDebitMandateReply::mandateMaturationDate = NULL;
	this->ns2__DirectDebitMandateReply::requestDateTime = NULL;
	this->ns2__DirectDebitMandateReply::reconciliationID = NULL;
	this->ns2__DirectDebitMandateReply::processorResponse = NULL;
	/* transient soap skipped */
}

void ns2__DirectDebitMandateReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__DirectDebitMandateReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitMandateReply::mandateID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitMandateReply::mandateMaturationDate);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__DirectDebitMandateReply::requestDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitMandateReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitMandateReply::processorResponse);
#endif
}

int ns2__DirectDebitMandateReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DirectDebitMandateReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DirectDebitMandateReply(struct soap *soap, const char *tag, int id, const ns2__DirectDebitMandateReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DirectDebitMandateReply), type))
		return soap->error;
	if (!a->ns2__DirectDebitMandateReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__DirectDebitMandateReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:mandateID", -1, (wchar_t*const*)&a->ns2__DirectDebitMandateReply::mandateID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:mandateMaturationDate", -1, (wchar_t*const*)&a->ns2__DirectDebitMandateReply::mandateMaturationDate, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__DirectDebitMandateReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__DirectDebitMandateReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__DirectDebitMandateReply::processorResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DirectDebitMandateReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DirectDebitMandateReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DirectDebitMandateReply * SOAP_FMAC4 soap_in_ns2__DirectDebitMandateReply(struct soap *soap, const char *tag, ns2__DirectDebitMandateReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DirectDebitMandateReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DirectDebitMandateReply, sizeof(ns2__DirectDebitMandateReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DirectDebitMandateReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DirectDebitMandateReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_mandateID1 = 1;
	size_t soap_flag_mandateMaturationDate1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__DirectDebitMandateReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_mandateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:mandateID", (wchar_t**)&a->ns2__DirectDebitMandateReply::mandateID, "xsd:string"))
				{	soap_flag_mandateID1--;
					continue;
				}
			if (soap_flag_mandateMaturationDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:mandateMaturationDate", (wchar_t**)&a->ns2__DirectDebitMandateReply::mandateMaturationDate, "xsd:string"))
				{	soap_flag_mandateMaturationDate1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__DirectDebitMandateReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__DirectDebitMandateReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__DirectDebitMandateReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__DirectDebitMandateReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DirectDebitMandateReply, SOAP_TYPE_ns2__DirectDebitMandateReply, sizeof(ns2__DirectDebitMandateReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DirectDebitMandateReply * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitMandateReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DirectDebitMandateReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DirectDebitMandateReply *p;
	size_t k = sizeof(ns2__DirectDebitMandateReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DirectDebitMandateReply);
		if (p)
			((ns2__DirectDebitMandateReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DirectDebitMandateReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DirectDebitMandateReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DirectDebitMandateReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DirectDebitMandateReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DirectDebitMandateReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:DirectDebitMandateReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DirectDebitMandateReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DirectDebitMandateReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DirectDebitMandateReply * SOAP_FMAC4 soap_get_ns2__DirectDebitMandateReply(struct soap *soap, ns2__DirectDebitMandateReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DirectDebitMandateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__BankTransferRealTimeReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__BankTransferRealTimeReply::reasonCode = NULL;
	this->ns2__BankTransferRealTimeReply::formMethod = NULL;
	this->ns2__BankTransferRealTimeReply::formAction = NULL;
	this->ns2__BankTransferRealTimeReply::requestDateTime = NULL;
	this->ns2__BankTransferRealTimeReply::reconciliationID = NULL;
	this->ns2__BankTransferRealTimeReply::paymentReference = NULL;
	this->ns2__BankTransferRealTimeReply::amount = NULL;
	/* transient soap skipped */
}

void ns2__BankTransferRealTimeReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__BankTransferRealTimeReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferRealTimeReply::formMethod);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferRealTimeReply::formAction);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__BankTransferRealTimeReply::requestDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferRealTimeReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferRealTimeReply::paymentReference);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__BankTransferRealTimeReply::amount);
#endif
}

int ns2__BankTransferRealTimeReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__BankTransferRealTimeReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BankTransferRealTimeReply(struct soap *soap, const char *tag, int id, const ns2__BankTransferRealTimeReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BankTransferRealTimeReply), type))
		return soap->error;
	if (!a->ns2__BankTransferRealTimeReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__BankTransferRealTimeReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:formMethod", -1, (wchar_t*const*)&a->ns2__BankTransferRealTimeReply::formMethod, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:formAction", -1, (wchar_t*const*)&a->ns2__BankTransferRealTimeReply::formAction, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__BankTransferRealTimeReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__BankTransferRealTimeReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentReference", -1, (wchar_t*const*)&a->ns2__BankTransferRealTimeReply::paymentReference, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__BankTransferRealTimeReply::amount, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__BankTransferRealTimeReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__BankTransferRealTimeReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__BankTransferRealTimeReply * SOAP_FMAC4 soap_in_ns2__BankTransferRealTimeReply(struct soap *soap, const char *tag, ns2__BankTransferRealTimeReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__BankTransferRealTimeReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BankTransferRealTimeReply, sizeof(ns2__BankTransferRealTimeReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__BankTransferRealTimeReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__BankTransferRealTimeReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_formMethod1 = 1;
	size_t soap_flag_formAction1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_paymentReference1 = 1;
	size_t soap_flag_amount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__BankTransferRealTimeReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_formMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:formMethod", (wchar_t**)&a->ns2__BankTransferRealTimeReply::formMethod, "xsd:string"))
				{	soap_flag_formMethod1--;
					continue;
				}
			if (soap_flag_formAction1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:formAction", (wchar_t**)&a->ns2__BankTransferRealTimeReply::formAction, "xsd:string"))
				{	soap_flag_formAction1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__BankTransferRealTimeReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__BankTransferRealTimeReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_paymentReference1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentReference", (wchar_t**)&a->ns2__BankTransferRealTimeReply::paymentReference, "xsd:string"))
				{	soap_flag_paymentReference1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__BankTransferRealTimeReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__BankTransferRealTimeReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BankTransferRealTimeReply, SOAP_TYPE_ns2__BankTransferRealTimeReply, sizeof(ns2__BankTransferRealTimeReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__BankTransferRealTimeReply * SOAP_FMAC2 soap_instantiate_ns2__BankTransferRealTimeReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__BankTransferRealTimeReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__BankTransferRealTimeReply *p;
	size_t k = sizeof(ns2__BankTransferRealTimeReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__BankTransferRealTimeReply);
		if (p)
			((ns2__BankTransferRealTimeReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__BankTransferRealTimeReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__BankTransferRealTimeReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__BankTransferRealTimeReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__BankTransferRealTimeReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__BankTransferRealTimeReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:BankTransferRealTimeReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__BankTransferRealTimeReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__BankTransferRealTimeReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__BankTransferRealTimeReply * SOAP_FMAC4 soap_get_ns2__BankTransferRealTimeReply(struct soap *soap, ns2__BankTransferRealTimeReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BankTransferRealTimeReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__BankTransferReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__BankTransferReply::reasonCode = NULL;
	this->ns2__BankTransferReply::accountHolder = NULL;
	this->ns2__BankTransferReply::accountNumber = NULL;
	this->ns2__BankTransferReply::amount = NULL;
	this->ns2__BankTransferReply::bankName = NULL;
	this->ns2__BankTransferReply::bankCity = NULL;
	this->ns2__BankTransferReply::bankCountry = NULL;
	this->ns2__BankTransferReply::paymentReference = NULL;
	this->ns2__BankTransferReply::processorResponse = NULL;
	this->ns2__BankTransferReply::bankSwiftCode = NULL;
	this->ns2__BankTransferReply::bankSpecialID = NULL;
	this->ns2__BankTransferReply::requestDateTime = NULL;
	this->ns2__BankTransferReply::reconciliationID = NULL;
	this->ns2__BankTransferReply::iban = NULL;
	this->ns2__BankTransferReply::bankCode = NULL;
	this->ns2__BankTransferReply::branchCode = NULL;
	/* transient soap skipped */
}

void ns2__BankTransferReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__BankTransferReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferReply::accountHolder);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferReply::accountNumber);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__BankTransferReply::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferReply::bankName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferReply::bankCity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferReply::bankCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferReply::paymentReference);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferReply::processorResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferReply::bankSwiftCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferReply::bankSpecialID);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__BankTransferReply::requestDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferReply::iban);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferReply::bankCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferReply::branchCode);
#endif
}

int ns2__BankTransferReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__BankTransferReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BankTransferReply(struct soap *soap, const char *tag, int id, const ns2__BankTransferReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BankTransferReply), type))
		return soap->error;
	if (!a->ns2__BankTransferReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__BankTransferReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:accountHolder", -1, (wchar_t*const*)&a->ns2__BankTransferReply::accountHolder, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:accountNumber", -1, (wchar_t*const*)&a->ns2__BankTransferReply::accountNumber, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__BankTransferReply::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:bankName", -1, (wchar_t*const*)&a->ns2__BankTransferReply::bankName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:bankCity", -1, (wchar_t*const*)&a->ns2__BankTransferReply::bankCity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:bankCountry", -1, (wchar_t*const*)&a->ns2__BankTransferReply::bankCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentReference", -1, (wchar_t*const*)&a->ns2__BankTransferReply::paymentReference, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__BankTransferReply::processorResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:bankSwiftCode", -1, (wchar_t*const*)&a->ns2__BankTransferReply::bankSwiftCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:bankSpecialID", -1, (wchar_t*const*)&a->ns2__BankTransferReply::bankSpecialID, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__BankTransferReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__BankTransferReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:iban", -1, (wchar_t*const*)&a->ns2__BankTransferReply::iban, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:bankCode", -1, (wchar_t*const*)&a->ns2__BankTransferReply::bankCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:branchCode", -1, (wchar_t*const*)&a->ns2__BankTransferReply::branchCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__BankTransferReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__BankTransferReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__BankTransferReply * SOAP_FMAC4 soap_in_ns2__BankTransferReply(struct soap *soap, const char *tag, ns2__BankTransferReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__BankTransferReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BankTransferReply, sizeof(ns2__BankTransferReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__BankTransferReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__BankTransferReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_accountHolder1 = 1;
	size_t soap_flag_accountNumber1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_bankName1 = 1;
	size_t soap_flag_bankCity1 = 1;
	size_t soap_flag_bankCountry1 = 1;
	size_t soap_flag_paymentReference1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_bankSwiftCode1 = 1;
	size_t soap_flag_bankSpecialID1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_iban1 = 1;
	size_t soap_flag_bankCode1 = 1;
	size_t soap_flag_branchCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__BankTransferReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_accountHolder1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:accountHolder", (wchar_t**)&a->ns2__BankTransferReply::accountHolder, "xsd:string"))
				{	soap_flag_accountHolder1--;
					continue;
				}
			if (soap_flag_accountNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:accountNumber", (wchar_t**)&a->ns2__BankTransferReply::accountNumber, "xsd:string"))
				{	soap_flag_accountNumber1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__BankTransferReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_bankName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:bankName", (wchar_t**)&a->ns2__BankTransferReply::bankName, "xsd:string"))
				{	soap_flag_bankName1--;
					continue;
				}
			if (soap_flag_bankCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:bankCity", (wchar_t**)&a->ns2__BankTransferReply::bankCity, "xsd:string"))
				{	soap_flag_bankCity1--;
					continue;
				}
			if (soap_flag_bankCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:bankCountry", (wchar_t**)&a->ns2__BankTransferReply::bankCountry, "xsd:string"))
				{	soap_flag_bankCountry1--;
					continue;
				}
			if (soap_flag_paymentReference1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentReference", (wchar_t**)&a->ns2__BankTransferReply::paymentReference, "xsd:string"))
				{	soap_flag_paymentReference1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__BankTransferReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_bankSwiftCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:bankSwiftCode", (wchar_t**)&a->ns2__BankTransferReply::bankSwiftCode, "xsd:string"))
				{	soap_flag_bankSwiftCode1--;
					continue;
				}
			if (soap_flag_bankSpecialID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:bankSpecialID", (wchar_t**)&a->ns2__BankTransferReply::bankSpecialID, "xsd:string"))
				{	soap_flag_bankSpecialID1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__BankTransferReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__BankTransferReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_iban1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:iban", (wchar_t**)&a->ns2__BankTransferReply::iban, "xsd:string"))
				{	soap_flag_iban1--;
					continue;
				}
			if (soap_flag_bankCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:bankCode", (wchar_t**)&a->ns2__BankTransferReply::bankCode, "xsd:string"))
				{	soap_flag_bankCode1--;
					continue;
				}
			if (soap_flag_branchCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:branchCode", (wchar_t**)&a->ns2__BankTransferReply::branchCode, "xsd:string"))
				{	soap_flag_branchCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__BankTransferReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BankTransferReply, SOAP_TYPE_ns2__BankTransferReply, sizeof(ns2__BankTransferReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__BankTransferReply * SOAP_FMAC2 soap_instantiate_ns2__BankTransferReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__BankTransferReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__BankTransferReply *p;
	size_t k = sizeof(ns2__BankTransferReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__BankTransferReply);
		if (p)
			((ns2__BankTransferReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__BankTransferReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__BankTransferReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__BankTransferReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__BankTransferReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__BankTransferReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:BankTransferReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__BankTransferReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__BankTransferReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__BankTransferReply * SOAP_FMAC4 soap_get_ns2__BankTransferReply(struct soap *soap, ns2__BankTransferReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BankTransferReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__FXRatesReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__FXRatesReply::reasonCode = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__FXQuote(soap, &this->ns2__FXRatesReply::quote);
	/* transient soap skipped */
}

void ns2__FXRatesReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__FXRatesReply::reasonCode);
	soap_serialize_std__vectorTemplateOfPointerTons2__FXQuote(soap, &this->ns2__FXRatesReply::quote);
#endif
}

int ns2__FXRatesReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FXRatesReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FXRatesReply(struct soap *soap, const char *tag, int id, const ns2__FXRatesReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FXRatesReply), type))
		return soap->error;
	if (!a->ns2__FXRatesReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__FXRatesReply::reasonCode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__FXQuote(soap, "ns2:quote", -1, &a->ns2__FXRatesReply::quote, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__FXRatesReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FXRatesReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FXRatesReply * SOAP_FMAC4 soap_in_ns2__FXRatesReply(struct soap *soap, const char *tag, ns2__FXRatesReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FXRatesReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FXRatesReply, sizeof(ns2__FXRatesReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__FXRatesReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__FXRatesReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__FXRatesReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__FXQuote(soap, "ns2:quote", &a->ns2__FXRatesReply::quote, "ns2:FXQuote"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0 || a->ns2__FXRatesReply::quote.size() > 999))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__FXRatesReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FXRatesReply, SOAP_TYPE_ns2__FXRatesReply, sizeof(ns2__FXRatesReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__FXRatesReply * SOAP_FMAC2 soap_instantiate_ns2__FXRatesReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FXRatesReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__FXRatesReply *p;
	size_t k = sizeof(ns2__FXRatesReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__FXRatesReply);
		if (p)
			((ns2__FXRatesReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__FXRatesReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__FXRatesReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__FXRatesReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__FXRatesReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__FXRatesReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:FXRatesReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FXRatesReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FXRatesReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FXRatesReply * SOAP_FMAC4 soap_get_ns2__FXRatesReply(struct soap *soap, ns2__FXRatesReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FXRatesReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__FXQuote::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__FXQuote::id = NULL;
	this->ns2__FXQuote::rate = NULL;
	this->ns2__FXQuote::type = NULL;
	this->ns2__FXQuote::expirationDateTime = NULL;
	this->ns2__FXQuote::currency = NULL;
	this->ns2__FXQuote::fundingCurrency = NULL;
	this->ns2__FXQuote::receivedDateTime = NULL;
	/* transient soap skipped */
}

void ns2__FXQuote::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__FXQuote::id);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__FXQuote::rate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__FXQuote::type);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__FXQuote::expirationDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__FXQuote::currency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__FXQuote::fundingCurrency);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__FXQuote::receivedDateTime);
#endif
}

int ns2__FXQuote::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FXQuote(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FXQuote(struct soap *soap, const char *tag, int id, const ns2__FXQuote *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FXQuote), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:id", -1, (wchar_t*const*)&a->ns2__FXQuote::id, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:rate", -1, (wchar_t*const*)&a->ns2__FXQuote::rate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:type", -1, (wchar_t*const*)&a->ns2__FXQuote::type, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:expirationDateTime", -1, &a->ns2__FXQuote::expirationDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:currency", -1, (wchar_t*const*)&a->ns2__FXQuote::currency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:fundingCurrency", -1, (wchar_t*const*)&a->ns2__FXQuote::fundingCurrency, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:receivedDateTime", -1, &a->ns2__FXQuote::receivedDateTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__FXQuote::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FXQuote(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FXQuote * SOAP_FMAC4 soap_in_ns2__FXQuote(struct soap *soap, const char *tag, ns2__FXQuote *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FXQuote *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FXQuote, sizeof(ns2__FXQuote), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__FXQuote)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__FXQuote *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_id1 = 1;
	size_t soap_flag_rate1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_expirationDateTime1 = 1;
	size_t soap_flag_currency1 = 1;
	size_t soap_flag_fundingCurrency1 = 1;
	size_t soap_flag_receivedDateTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:id", (wchar_t**)&a->ns2__FXQuote::id, "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_rate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:rate", (wchar_t**)&a->ns2__FXQuote::rate, "xsd:string"))
				{	soap_flag_rate1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:type", (wchar_t**)&a->ns2__FXQuote::type, "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_expirationDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:expirationDateTime", &a->ns2__FXQuote::expirationDateTime, "ns2:dateTime"))
				{	soap_flag_expirationDateTime1--;
					continue;
				}
			if (soap_flag_currency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:currency", (wchar_t**)&a->ns2__FXQuote::currency, "xsd:string"))
				{	soap_flag_currency1--;
					continue;
				}
			if (soap_flag_fundingCurrency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:fundingCurrency", (wchar_t**)&a->ns2__FXQuote::fundingCurrency, "xsd:string"))
				{	soap_flag_fundingCurrency1--;
					continue;
				}
			if (soap_flag_receivedDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:receivedDateTime", &a->ns2__FXQuote::receivedDateTime, "ns2:dateTime"))
				{	soap_flag_receivedDateTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__FXQuote *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FXQuote, SOAP_TYPE_ns2__FXQuote, sizeof(ns2__FXQuote), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__FXQuote * SOAP_FMAC2 soap_instantiate_ns2__FXQuote(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FXQuote(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__FXQuote *p;
	size_t k = sizeof(ns2__FXQuote);
	if (n < 0)
	{	p = SOAP_NEW(ns2__FXQuote);
		if (p)
			((ns2__FXQuote*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__FXQuote, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__FXQuote*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__FXQuote location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__FXQuote, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__FXQuote::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:FXQuote", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FXQuote::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FXQuote(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FXQuote * SOAP_FMAC4 soap_get_ns2__FXQuote(struct soap *soap, ns2__FXQuote *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FXQuote(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ExportReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ExportReply::reasonCode = NULL;
	this->ns2__ExportReply::ipCountryConfidence = NULL;
	this->ns2__ExportReply::infoCode = NULL;
	/* transient soap skipped */
}

void ns2__ExportReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__ExportReply::reasonCode);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__ExportReply::ipCountryConfidence);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ExportReply::infoCode);
#endif
}

int ns2__ExportReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ExportReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ExportReply(struct soap *soap, const char *tag, int id, const ns2__ExportReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ExportReply), type))
		return soap->error;
	if (!a->ns2__ExportReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__ExportReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:ipCountryConfidence", -1, &a->ns2__ExportReply::ipCountryConfidence, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:infoCode", -1, (wchar_t*const*)&a->ns2__ExportReply::infoCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ExportReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ExportReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ExportReply * SOAP_FMAC4 soap_in_ns2__ExportReply(struct soap *soap, const char *tag, ns2__ExportReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ExportReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ExportReply, sizeof(ns2__ExportReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ExportReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ExportReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_ipCountryConfidence1 = 1;
	size_t soap_flag_infoCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__ExportReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_ipCountryConfidence1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:ipCountryConfidence", &a->ns2__ExportReply::ipCountryConfidence, "xsd:integer"))
				{	soap_flag_ipCountryConfidence1--;
					continue;
				}
			if (soap_flag_infoCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:infoCode", (wchar_t**)&a->ns2__ExportReply::infoCode, "xsd:string"))
				{	soap_flag_infoCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__ExportReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ExportReply, SOAP_TYPE_ns2__ExportReply, sizeof(ns2__ExportReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ExportReply * SOAP_FMAC2 soap_instantiate_ns2__ExportReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ExportReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ExportReply *p;
	size_t k = sizeof(ns2__ExportReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ExportReply);
		if (p)
			((ns2__ExportReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ExportReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ExportReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ExportReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ExportReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ExportReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:ExportReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ExportReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ExportReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ExportReply * SOAP_FMAC4 soap_get_ns2__ExportReply(struct soap *soap, ns2__ExportReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ExportReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DeniedPartiesMatch::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DeniedPartiesMatch::list = NULL;
	soap_default_std__vectorTemplateOfwstring(soap, &this->ns2__DeniedPartiesMatch::name);
	soap_default_std__vectorTemplateOfwstring(soap, &this->ns2__DeniedPartiesMatch::address);
	soap_default_std__vectorTemplateOfwstring(soap, &this->ns2__DeniedPartiesMatch::program);
	/* transient soap skipped */
}

void ns2__DeniedPartiesMatch::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeniedPartiesMatch::list);
	soap_serialize_std__vectorTemplateOfwstring(soap, &this->ns2__DeniedPartiesMatch::name);
	soap_serialize_std__vectorTemplateOfwstring(soap, &this->ns2__DeniedPartiesMatch::address);
	soap_serialize_std__vectorTemplateOfwstring(soap, &this->ns2__DeniedPartiesMatch::program);
#endif
}

int ns2__DeniedPartiesMatch::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DeniedPartiesMatch(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DeniedPartiesMatch(struct soap *soap, const char *tag, int id, const ns2__DeniedPartiesMatch *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DeniedPartiesMatch), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:list", -1, (wchar_t*const*)&a->ns2__DeniedPartiesMatch::list, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwstring(soap, "ns2:name", -1, &a->ns2__DeniedPartiesMatch::name, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwstring(soap, "ns2:address", -1, &a->ns2__DeniedPartiesMatch::address, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwstring(soap, "ns2:program", -1, &a->ns2__DeniedPartiesMatch::program, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DeniedPartiesMatch::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DeniedPartiesMatch(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DeniedPartiesMatch * SOAP_FMAC4 soap_in_ns2__DeniedPartiesMatch(struct soap *soap, const char *tag, ns2__DeniedPartiesMatch *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DeniedPartiesMatch *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DeniedPartiesMatch, sizeof(ns2__DeniedPartiesMatch), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DeniedPartiesMatch)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DeniedPartiesMatch *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_list1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_list1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:list", (wchar_t**)&a->ns2__DeniedPartiesMatch::list, "xsd:string"))
				{	soap_flag_list1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfwstring(soap, "ns2:name", &a->ns2__DeniedPartiesMatch::name, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfwstring(soap, "ns2:address", &a->ns2__DeniedPartiesMatch::address, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfwstring(soap, "ns2:program", &a->ns2__DeniedPartiesMatch::program, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__DeniedPartiesMatch::name.size() > 100 || a->ns2__DeniedPartiesMatch::address.size() > 100 || a->ns2__DeniedPartiesMatch::program.size() > 100))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns2__DeniedPartiesMatch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DeniedPartiesMatch, SOAP_TYPE_ns2__DeniedPartiesMatch, sizeof(ns2__DeniedPartiesMatch), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DeniedPartiesMatch * SOAP_FMAC2 soap_instantiate_ns2__DeniedPartiesMatch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DeniedPartiesMatch(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DeniedPartiesMatch *p;
	size_t k = sizeof(ns2__DeniedPartiesMatch);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DeniedPartiesMatch);
		if (p)
			((ns2__DeniedPartiesMatch*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DeniedPartiesMatch, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DeniedPartiesMatch*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DeniedPartiesMatch location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DeniedPartiesMatch, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DeniedPartiesMatch::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:DeniedPartiesMatch", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DeniedPartiesMatch::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DeniedPartiesMatch(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DeniedPartiesMatch * SOAP_FMAC4 soap_get_ns2__DeniedPartiesMatch(struct soap *soap, ns2__DeniedPartiesMatch *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DeniedPartiesMatch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DAVReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DAVReply::reasonCode = NULL;
	this->ns2__DAVReply::addressType = NULL;
	this->ns2__DAVReply::apartmentInfo = NULL;
	this->ns2__DAVReply::barCode = NULL;
	this->ns2__DAVReply::barCodeCheckDigit = NULL;
	this->ns2__DAVReply::careOf = NULL;
	this->ns2__DAVReply::cityInfo = NULL;
	this->ns2__DAVReply::countryInfo = NULL;
	this->ns2__DAVReply::directionalInfo = NULL;
	this->ns2__DAVReply::lvrInfo = NULL;
	this->ns2__DAVReply::matchScore = NULL;
	this->ns2__DAVReply::standardizedAddress1 = NULL;
	this->ns2__DAVReply::standardizedAddress2 = NULL;
	this->ns2__DAVReply::standardizedAddress3 = NULL;
	this->ns2__DAVReply::standardizedAddress4 = NULL;
	this->ns2__DAVReply::standardizedAddressNoApt = NULL;
	this->ns2__DAVReply::standardizedCity = NULL;
	this->ns2__DAVReply::standardizedCounty = NULL;
	this->ns2__DAVReply::standardizedCSP = NULL;
	this->ns2__DAVReply::standardizedState = NULL;
	this->ns2__DAVReply::standardizedPostalCode = NULL;
	this->ns2__DAVReply::standardizedCountry = NULL;
	this->ns2__DAVReply::standardizedISOCountry = NULL;
	this->ns2__DAVReply::stateInfo = NULL;
	this->ns2__DAVReply::streetInfo = NULL;
	this->ns2__DAVReply::suffixInfo = NULL;
	this->ns2__DAVReply::postalCodeInfo = NULL;
	this->ns2__DAVReply::overallInfo = NULL;
	this->ns2__DAVReply::usInfo = NULL;
	this->ns2__DAVReply::caInfo = NULL;
	this->ns2__DAVReply::intlInfo = NULL;
	this->ns2__DAVReply::usErrorInfo = NULL;
	this->ns2__DAVReply::caErrorInfo = NULL;
	this->ns2__DAVReply::intlErrorInfo = NULL;
	/* transient soap skipped */
}

void ns2__DAVReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__DAVReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::addressType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::apartmentInfo);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::barCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::barCodeCheckDigit);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::careOf);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::cityInfo);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::countryInfo);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::directionalInfo);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::lvrInfo);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__DAVReply::matchScore);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::standardizedAddress1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::standardizedAddress2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::standardizedAddress3);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::standardizedAddress4);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::standardizedAddressNoApt);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::standardizedCity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::standardizedCounty);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::standardizedCSP);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::standardizedState);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::standardizedPostalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::standardizedCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::standardizedISOCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::stateInfo);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::streetInfo);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::suffixInfo);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::postalCodeInfo);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::overallInfo);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::usInfo);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::caInfo);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::intlInfo);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::usErrorInfo);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::caErrorInfo);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DAVReply::intlErrorInfo);
#endif
}

int ns2__DAVReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DAVReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DAVReply(struct soap *soap, const char *tag, int id, const ns2__DAVReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DAVReply), type))
		return soap->error;
	if (!a->ns2__DAVReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__DAVReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:addressType", -1, (wchar_t*const*)&a->ns2__DAVReply::addressType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:apartmentInfo", -1, (wchar_t*const*)&a->ns2__DAVReply::apartmentInfo, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:barCode", -1, (wchar_t*const*)&a->ns2__DAVReply::barCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:barCodeCheckDigit", -1, (wchar_t*const*)&a->ns2__DAVReply::barCodeCheckDigit, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:careOf", -1, (wchar_t*const*)&a->ns2__DAVReply::careOf, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cityInfo", -1, (wchar_t*const*)&a->ns2__DAVReply::cityInfo, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:countryInfo", -1, (wchar_t*const*)&a->ns2__DAVReply::countryInfo, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:directionalInfo", -1, (wchar_t*const*)&a->ns2__DAVReply::directionalInfo, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:lvrInfo", -1, (wchar_t*const*)&a->ns2__DAVReply::lvrInfo, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:matchScore", -1, &a->ns2__DAVReply::matchScore, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:standardizedAddress1", -1, (wchar_t*const*)&a->ns2__DAVReply::standardizedAddress1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:standardizedAddress2", -1, (wchar_t*const*)&a->ns2__DAVReply::standardizedAddress2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:standardizedAddress3", -1, (wchar_t*const*)&a->ns2__DAVReply::standardizedAddress3, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:standardizedAddress4", -1, (wchar_t*const*)&a->ns2__DAVReply::standardizedAddress4, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:standardizedAddressNoApt", -1, (wchar_t*const*)&a->ns2__DAVReply::standardizedAddressNoApt, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:standardizedCity", -1, (wchar_t*const*)&a->ns2__DAVReply::standardizedCity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:standardizedCounty", -1, (wchar_t*const*)&a->ns2__DAVReply::standardizedCounty, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:standardizedCSP", -1, (wchar_t*const*)&a->ns2__DAVReply::standardizedCSP, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:standardizedState", -1, (wchar_t*const*)&a->ns2__DAVReply::standardizedState, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:standardizedPostalCode", -1, (wchar_t*const*)&a->ns2__DAVReply::standardizedPostalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:standardizedCountry", -1, (wchar_t*const*)&a->ns2__DAVReply::standardizedCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:standardizedISOCountry", -1, (wchar_t*const*)&a->ns2__DAVReply::standardizedISOCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:stateInfo", -1, (wchar_t*const*)&a->ns2__DAVReply::stateInfo, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:streetInfo", -1, (wchar_t*const*)&a->ns2__DAVReply::streetInfo, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:suffixInfo", -1, (wchar_t*const*)&a->ns2__DAVReply::suffixInfo, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:postalCodeInfo", -1, (wchar_t*const*)&a->ns2__DAVReply::postalCodeInfo, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:overallInfo", -1, (wchar_t*const*)&a->ns2__DAVReply::overallInfo, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:usInfo", -1, (wchar_t*const*)&a->ns2__DAVReply::usInfo, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:caInfo", -1, (wchar_t*const*)&a->ns2__DAVReply::caInfo, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:intlInfo", -1, (wchar_t*const*)&a->ns2__DAVReply::intlInfo, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:usErrorInfo", -1, (wchar_t*const*)&a->ns2__DAVReply::usErrorInfo, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:caErrorInfo", -1, (wchar_t*const*)&a->ns2__DAVReply::caErrorInfo, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:intlErrorInfo", -1, (wchar_t*const*)&a->ns2__DAVReply::intlErrorInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DAVReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DAVReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DAVReply * SOAP_FMAC4 soap_in_ns2__DAVReply(struct soap *soap, const char *tag, ns2__DAVReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DAVReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DAVReply, sizeof(ns2__DAVReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DAVReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DAVReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_addressType1 = 1;
	size_t soap_flag_apartmentInfo1 = 1;
	size_t soap_flag_barCode1 = 1;
	size_t soap_flag_barCodeCheckDigit1 = 1;
	size_t soap_flag_careOf1 = 1;
	size_t soap_flag_cityInfo1 = 1;
	size_t soap_flag_countryInfo1 = 1;
	size_t soap_flag_directionalInfo1 = 1;
	size_t soap_flag_lvrInfo1 = 1;
	size_t soap_flag_matchScore1 = 1;
	size_t soap_flag_standardizedAddress11 = 1;
	size_t soap_flag_standardizedAddress21 = 1;
	size_t soap_flag_standardizedAddress31 = 1;
	size_t soap_flag_standardizedAddress41 = 1;
	size_t soap_flag_standardizedAddressNoApt1 = 1;
	size_t soap_flag_standardizedCity1 = 1;
	size_t soap_flag_standardizedCounty1 = 1;
	size_t soap_flag_standardizedCSP1 = 1;
	size_t soap_flag_standardizedState1 = 1;
	size_t soap_flag_standardizedPostalCode1 = 1;
	size_t soap_flag_standardizedCountry1 = 1;
	size_t soap_flag_standardizedISOCountry1 = 1;
	size_t soap_flag_stateInfo1 = 1;
	size_t soap_flag_streetInfo1 = 1;
	size_t soap_flag_suffixInfo1 = 1;
	size_t soap_flag_postalCodeInfo1 = 1;
	size_t soap_flag_overallInfo1 = 1;
	size_t soap_flag_usInfo1 = 1;
	size_t soap_flag_caInfo1 = 1;
	size_t soap_flag_intlInfo1 = 1;
	size_t soap_flag_usErrorInfo1 = 1;
	size_t soap_flag_caErrorInfo1 = 1;
	size_t soap_flag_intlErrorInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__DAVReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_addressType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:addressType", (wchar_t**)&a->ns2__DAVReply::addressType, "xsd:string"))
				{	soap_flag_addressType1--;
					continue;
				}
			if (soap_flag_apartmentInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:apartmentInfo", (wchar_t**)&a->ns2__DAVReply::apartmentInfo, "xsd:string"))
				{	soap_flag_apartmentInfo1--;
					continue;
				}
			if (soap_flag_barCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:barCode", (wchar_t**)&a->ns2__DAVReply::barCode, "xsd:string"))
				{	soap_flag_barCode1--;
					continue;
				}
			if (soap_flag_barCodeCheckDigit1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:barCodeCheckDigit", (wchar_t**)&a->ns2__DAVReply::barCodeCheckDigit, "xsd:string"))
				{	soap_flag_barCodeCheckDigit1--;
					continue;
				}
			if (soap_flag_careOf1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:careOf", (wchar_t**)&a->ns2__DAVReply::careOf, "xsd:string"))
				{	soap_flag_careOf1--;
					continue;
				}
			if (soap_flag_cityInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cityInfo", (wchar_t**)&a->ns2__DAVReply::cityInfo, "xsd:string"))
				{	soap_flag_cityInfo1--;
					continue;
				}
			if (soap_flag_countryInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:countryInfo", (wchar_t**)&a->ns2__DAVReply::countryInfo, "xsd:string"))
				{	soap_flag_countryInfo1--;
					continue;
				}
			if (soap_flag_directionalInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:directionalInfo", (wchar_t**)&a->ns2__DAVReply::directionalInfo, "xsd:string"))
				{	soap_flag_directionalInfo1--;
					continue;
				}
			if (soap_flag_lvrInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:lvrInfo", (wchar_t**)&a->ns2__DAVReply::lvrInfo, "xsd:string"))
				{	soap_flag_lvrInfo1--;
					continue;
				}
			if (soap_flag_matchScore1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:matchScore", &a->ns2__DAVReply::matchScore, "xsd:integer"))
				{	soap_flag_matchScore1--;
					continue;
				}
			if (soap_flag_standardizedAddress11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:standardizedAddress1", (wchar_t**)&a->ns2__DAVReply::standardizedAddress1, "xsd:string"))
				{	soap_flag_standardizedAddress11--;
					continue;
				}
			if (soap_flag_standardizedAddress21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:standardizedAddress2", (wchar_t**)&a->ns2__DAVReply::standardizedAddress2, "xsd:string"))
				{	soap_flag_standardizedAddress21--;
					continue;
				}
			if (soap_flag_standardizedAddress31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:standardizedAddress3", (wchar_t**)&a->ns2__DAVReply::standardizedAddress3, "xsd:string"))
				{	soap_flag_standardizedAddress31--;
					continue;
				}
			if (soap_flag_standardizedAddress41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:standardizedAddress4", (wchar_t**)&a->ns2__DAVReply::standardizedAddress4, "xsd:string"))
				{	soap_flag_standardizedAddress41--;
					continue;
				}
			if (soap_flag_standardizedAddressNoApt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:standardizedAddressNoApt", (wchar_t**)&a->ns2__DAVReply::standardizedAddressNoApt, "xsd:string"))
				{	soap_flag_standardizedAddressNoApt1--;
					continue;
				}
			if (soap_flag_standardizedCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:standardizedCity", (wchar_t**)&a->ns2__DAVReply::standardizedCity, "xsd:string"))
				{	soap_flag_standardizedCity1--;
					continue;
				}
			if (soap_flag_standardizedCounty1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:standardizedCounty", (wchar_t**)&a->ns2__DAVReply::standardizedCounty, "xsd:string"))
				{	soap_flag_standardizedCounty1--;
					continue;
				}
			if (soap_flag_standardizedCSP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:standardizedCSP", (wchar_t**)&a->ns2__DAVReply::standardizedCSP, "xsd:string"))
				{	soap_flag_standardizedCSP1--;
					continue;
				}
			if (soap_flag_standardizedState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:standardizedState", (wchar_t**)&a->ns2__DAVReply::standardizedState, "xsd:string"))
				{	soap_flag_standardizedState1--;
					continue;
				}
			if (soap_flag_standardizedPostalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:standardizedPostalCode", (wchar_t**)&a->ns2__DAVReply::standardizedPostalCode, "xsd:string"))
				{	soap_flag_standardizedPostalCode1--;
					continue;
				}
			if (soap_flag_standardizedCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:standardizedCountry", (wchar_t**)&a->ns2__DAVReply::standardizedCountry, "xsd:string"))
				{	soap_flag_standardizedCountry1--;
					continue;
				}
			if (soap_flag_standardizedISOCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:standardizedISOCountry", (wchar_t**)&a->ns2__DAVReply::standardizedISOCountry, "xsd:string"))
				{	soap_flag_standardizedISOCountry1--;
					continue;
				}
			if (soap_flag_stateInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:stateInfo", (wchar_t**)&a->ns2__DAVReply::stateInfo, "xsd:string"))
				{	soap_flag_stateInfo1--;
					continue;
				}
			if (soap_flag_streetInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:streetInfo", (wchar_t**)&a->ns2__DAVReply::streetInfo, "xsd:string"))
				{	soap_flag_streetInfo1--;
					continue;
				}
			if (soap_flag_suffixInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:suffixInfo", (wchar_t**)&a->ns2__DAVReply::suffixInfo, "xsd:string"))
				{	soap_flag_suffixInfo1--;
					continue;
				}
			if (soap_flag_postalCodeInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:postalCodeInfo", (wchar_t**)&a->ns2__DAVReply::postalCodeInfo, "xsd:string"))
				{	soap_flag_postalCodeInfo1--;
					continue;
				}
			if (soap_flag_overallInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:overallInfo", (wchar_t**)&a->ns2__DAVReply::overallInfo, "xsd:string"))
				{	soap_flag_overallInfo1--;
					continue;
				}
			if (soap_flag_usInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:usInfo", (wchar_t**)&a->ns2__DAVReply::usInfo, "xsd:string"))
				{	soap_flag_usInfo1--;
					continue;
				}
			if (soap_flag_caInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:caInfo", (wchar_t**)&a->ns2__DAVReply::caInfo, "xsd:string"))
				{	soap_flag_caInfo1--;
					continue;
				}
			if (soap_flag_intlInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:intlInfo", (wchar_t**)&a->ns2__DAVReply::intlInfo, "xsd:string"))
				{	soap_flag_intlInfo1--;
					continue;
				}
			if (soap_flag_usErrorInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:usErrorInfo", (wchar_t**)&a->ns2__DAVReply::usErrorInfo, "xsd:string"))
				{	soap_flag_usErrorInfo1--;
					continue;
				}
			if (soap_flag_caErrorInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:caErrorInfo", (wchar_t**)&a->ns2__DAVReply::caErrorInfo, "xsd:string"))
				{	soap_flag_caErrorInfo1--;
					continue;
				}
			if (soap_flag_intlErrorInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:intlErrorInfo", (wchar_t**)&a->ns2__DAVReply::intlErrorInfo, "xsd:string"))
				{	soap_flag_intlErrorInfo1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__DAVReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DAVReply, SOAP_TYPE_ns2__DAVReply, sizeof(ns2__DAVReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DAVReply * SOAP_FMAC2 soap_instantiate_ns2__DAVReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DAVReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DAVReply *p;
	size_t k = sizeof(ns2__DAVReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DAVReply);
		if (p)
			((ns2__DAVReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DAVReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DAVReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DAVReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DAVReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DAVReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:DAVReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DAVReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DAVReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DAVReply * SOAP_FMAC4 soap_get_ns2__DAVReply(struct soap *soap, ns2__DAVReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DAVReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__AFSReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__AFSReply::reasonCode = NULL;
	this->ns2__AFSReply::afsResult = NULL;
	this->ns2__AFSReply::hostSeverity = NULL;
	this->ns2__AFSReply::consumerLocalTime = NULL;
	this->ns2__AFSReply::afsFactorCode = NULL;
	this->ns2__AFSReply::addressInfoCode = NULL;
	this->ns2__AFSReply::hotlistInfoCode = NULL;
	this->ns2__AFSReply::internetInfoCode = NULL;
	this->ns2__AFSReply::phoneInfoCode = NULL;
	this->ns2__AFSReply::suspiciousInfoCode = NULL;
	this->ns2__AFSReply::velocityInfoCode = NULL;
	this->ns2__AFSReply::identityInfoCode = NULL;
	this->ns2__AFSReply::ipCountry = NULL;
	this->ns2__AFSReply::ipState = NULL;
	this->ns2__AFSReply::ipCity = NULL;
	this->ns2__AFSReply::ipRoutingMethod = NULL;
	this->ns2__AFSReply::ipAnonymizerStatus = NULL;
	this->ns2__AFSReply::scoreModelUsed = NULL;
	this->ns2__AFSReply::cardBin = NULL;
	this->ns2__AFSReply::binCountry = NULL;
	this->ns2__AFSReply::cardAccountType = NULL;
	this->ns2__AFSReply::cardScheme = NULL;
	this->ns2__AFSReply::cardIssuer = NULL;
	this->ns2__AFSReply::deviceFingerprint = NULL;
	/* transient soap skipped */
}

void ns2__AFSReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__AFSReply::reasonCode);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__AFSReply::afsResult);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__AFSReply::hostSeverity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSReply::consumerLocalTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSReply::afsFactorCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSReply::addressInfoCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSReply::hotlistInfoCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSReply::internetInfoCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSReply::phoneInfoCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSReply::suspiciousInfoCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSReply::velocityInfoCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSReply::identityInfoCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSReply::ipCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSReply::ipState);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSReply::ipCity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSReply::ipRoutingMethod);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSReply::ipAnonymizerStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSReply::scoreModelUsed);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSReply::cardBin);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSReply::binCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSReply::cardAccountType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSReply::cardScheme);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSReply::cardIssuer);
	soap_serialize_PointerTons2__DeviceFingerprint(soap, &this->ns2__AFSReply::deviceFingerprint);
#endif
}

int ns2__AFSReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AFSReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AFSReply(struct soap *soap, const char *tag, int id, const ns2__AFSReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AFSReply), type))
		return soap->error;
	if (!a->ns2__AFSReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__AFSReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:afsResult", -1, &a->ns2__AFSReply::afsResult, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:hostSeverity", -1, &a->ns2__AFSReply::hostSeverity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:consumerLocalTime", -1, (wchar_t*const*)&a->ns2__AFSReply::consumerLocalTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:afsFactorCode", -1, (wchar_t*const*)&a->ns2__AFSReply::afsFactorCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:addressInfoCode", -1, (wchar_t*const*)&a->ns2__AFSReply::addressInfoCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:hotlistInfoCode", -1, (wchar_t*const*)&a->ns2__AFSReply::hotlistInfoCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:internetInfoCode", -1, (wchar_t*const*)&a->ns2__AFSReply::internetInfoCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:phoneInfoCode", -1, (wchar_t*const*)&a->ns2__AFSReply::phoneInfoCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:suspiciousInfoCode", -1, (wchar_t*const*)&a->ns2__AFSReply::suspiciousInfoCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:velocityInfoCode", -1, (wchar_t*const*)&a->ns2__AFSReply::velocityInfoCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:identityInfoCode", -1, (wchar_t*const*)&a->ns2__AFSReply::identityInfoCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ipCountry", -1, (wchar_t*const*)&a->ns2__AFSReply::ipCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ipState", -1, (wchar_t*const*)&a->ns2__AFSReply::ipState, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ipCity", -1, (wchar_t*const*)&a->ns2__AFSReply::ipCity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ipRoutingMethod", -1, (wchar_t*const*)&a->ns2__AFSReply::ipRoutingMethod, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ipAnonymizerStatus", -1, (wchar_t*const*)&a->ns2__AFSReply::ipAnonymizerStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:scoreModelUsed", -1, (wchar_t*const*)&a->ns2__AFSReply::scoreModelUsed, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardBin", -1, (wchar_t*const*)&a->ns2__AFSReply::cardBin, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:binCountry", -1, (wchar_t*const*)&a->ns2__AFSReply::binCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardAccountType", -1, (wchar_t*const*)&a->ns2__AFSReply::cardAccountType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardScheme", -1, (wchar_t*const*)&a->ns2__AFSReply::cardScheme, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardIssuer", -1, (wchar_t*const*)&a->ns2__AFSReply::cardIssuer, ""))
		return soap->error;
	if (soap_out_PointerTons2__DeviceFingerprint(soap, "ns2:deviceFingerprint", -1, &a->ns2__AFSReply::deviceFingerprint, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__AFSReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AFSReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AFSReply * SOAP_FMAC4 soap_in_ns2__AFSReply(struct soap *soap, const char *tag, ns2__AFSReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AFSReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AFSReply, sizeof(ns2__AFSReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__AFSReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__AFSReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_afsResult1 = 1;
	size_t soap_flag_hostSeverity1 = 1;
	size_t soap_flag_consumerLocalTime1 = 1;
	size_t soap_flag_afsFactorCode1 = 1;
	size_t soap_flag_addressInfoCode1 = 1;
	size_t soap_flag_hotlistInfoCode1 = 1;
	size_t soap_flag_internetInfoCode1 = 1;
	size_t soap_flag_phoneInfoCode1 = 1;
	size_t soap_flag_suspiciousInfoCode1 = 1;
	size_t soap_flag_velocityInfoCode1 = 1;
	size_t soap_flag_identityInfoCode1 = 1;
	size_t soap_flag_ipCountry1 = 1;
	size_t soap_flag_ipState1 = 1;
	size_t soap_flag_ipCity1 = 1;
	size_t soap_flag_ipRoutingMethod1 = 1;
	size_t soap_flag_ipAnonymizerStatus1 = 1;
	size_t soap_flag_scoreModelUsed1 = 1;
	size_t soap_flag_cardBin1 = 1;
	size_t soap_flag_binCountry1 = 1;
	size_t soap_flag_cardAccountType1 = 1;
	size_t soap_flag_cardScheme1 = 1;
	size_t soap_flag_cardIssuer1 = 1;
	size_t soap_flag_deviceFingerprint1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__AFSReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_afsResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:afsResult", &a->ns2__AFSReply::afsResult, "xsd:integer"))
				{	soap_flag_afsResult1--;
					continue;
				}
			if (soap_flag_hostSeverity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:hostSeverity", &a->ns2__AFSReply::hostSeverity, "xsd:integer"))
				{	soap_flag_hostSeverity1--;
					continue;
				}
			if (soap_flag_consumerLocalTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:consumerLocalTime", (wchar_t**)&a->ns2__AFSReply::consumerLocalTime, "xsd:string"))
				{	soap_flag_consumerLocalTime1--;
					continue;
				}
			if (soap_flag_afsFactorCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:afsFactorCode", (wchar_t**)&a->ns2__AFSReply::afsFactorCode, "xsd:string"))
				{	soap_flag_afsFactorCode1--;
					continue;
				}
			if (soap_flag_addressInfoCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:addressInfoCode", (wchar_t**)&a->ns2__AFSReply::addressInfoCode, "xsd:string"))
				{	soap_flag_addressInfoCode1--;
					continue;
				}
			if (soap_flag_hotlistInfoCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:hotlistInfoCode", (wchar_t**)&a->ns2__AFSReply::hotlistInfoCode, "xsd:string"))
				{	soap_flag_hotlistInfoCode1--;
					continue;
				}
			if (soap_flag_internetInfoCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:internetInfoCode", (wchar_t**)&a->ns2__AFSReply::internetInfoCode, "xsd:string"))
				{	soap_flag_internetInfoCode1--;
					continue;
				}
			if (soap_flag_phoneInfoCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:phoneInfoCode", (wchar_t**)&a->ns2__AFSReply::phoneInfoCode, "xsd:string"))
				{	soap_flag_phoneInfoCode1--;
					continue;
				}
			if (soap_flag_suspiciousInfoCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:suspiciousInfoCode", (wchar_t**)&a->ns2__AFSReply::suspiciousInfoCode, "xsd:string"))
				{	soap_flag_suspiciousInfoCode1--;
					continue;
				}
			if (soap_flag_velocityInfoCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:velocityInfoCode", (wchar_t**)&a->ns2__AFSReply::velocityInfoCode, "xsd:string"))
				{	soap_flag_velocityInfoCode1--;
					continue;
				}
			if (soap_flag_identityInfoCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:identityInfoCode", (wchar_t**)&a->ns2__AFSReply::identityInfoCode, "xsd:string"))
				{	soap_flag_identityInfoCode1--;
					continue;
				}
			if (soap_flag_ipCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ipCountry", (wchar_t**)&a->ns2__AFSReply::ipCountry, "xsd:string"))
				{	soap_flag_ipCountry1--;
					continue;
				}
			if (soap_flag_ipState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ipState", (wchar_t**)&a->ns2__AFSReply::ipState, "xsd:string"))
				{	soap_flag_ipState1--;
					continue;
				}
			if (soap_flag_ipCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ipCity", (wchar_t**)&a->ns2__AFSReply::ipCity, "xsd:string"))
				{	soap_flag_ipCity1--;
					continue;
				}
			if (soap_flag_ipRoutingMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ipRoutingMethod", (wchar_t**)&a->ns2__AFSReply::ipRoutingMethod, "xsd:string"))
				{	soap_flag_ipRoutingMethod1--;
					continue;
				}
			if (soap_flag_ipAnonymizerStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ipAnonymizerStatus", (wchar_t**)&a->ns2__AFSReply::ipAnonymizerStatus, "xsd:string"))
				{	soap_flag_ipAnonymizerStatus1--;
					continue;
				}
			if (soap_flag_scoreModelUsed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:scoreModelUsed", (wchar_t**)&a->ns2__AFSReply::scoreModelUsed, "xsd:string"))
				{	soap_flag_scoreModelUsed1--;
					continue;
				}
			if (soap_flag_cardBin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardBin", (wchar_t**)&a->ns2__AFSReply::cardBin, "xsd:string"))
				{	soap_flag_cardBin1--;
					continue;
				}
			if (soap_flag_binCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:binCountry", (wchar_t**)&a->ns2__AFSReply::binCountry, "xsd:string"))
				{	soap_flag_binCountry1--;
					continue;
				}
			if (soap_flag_cardAccountType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardAccountType", (wchar_t**)&a->ns2__AFSReply::cardAccountType, "xsd:string"))
				{	soap_flag_cardAccountType1--;
					continue;
				}
			if (soap_flag_cardScheme1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardScheme", (wchar_t**)&a->ns2__AFSReply::cardScheme, "xsd:string"))
				{	soap_flag_cardScheme1--;
					continue;
				}
			if (soap_flag_cardIssuer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardIssuer", (wchar_t**)&a->ns2__AFSReply::cardIssuer, "xsd:string"))
				{	soap_flag_cardIssuer1--;
					continue;
				}
			if (soap_flag_deviceFingerprint1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DeviceFingerprint(soap, "ns2:deviceFingerprint", &a->ns2__AFSReply::deviceFingerprint, "ns2:DeviceFingerprint"))
				{	soap_flag_deviceFingerprint1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__AFSReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AFSReply, SOAP_TYPE_ns2__AFSReply, sizeof(ns2__AFSReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__AFSReply * SOAP_FMAC2 soap_instantiate_ns2__AFSReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AFSReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__AFSReply *p;
	size_t k = sizeof(ns2__AFSReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__AFSReply);
		if (p)
			((ns2__AFSReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__AFSReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__AFSReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__AFSReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__AFSReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__AFSReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:AFSReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AFSReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AFSReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AFSReply * SOAP_FMAC4 soap_get_ns2__AFSReply(struct soap *soap, ns2__AFSReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AFSReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DeviceFingerprint::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DeviceFingerprint::cookiesEnabled = NULL;
	this->ns2__DeviceFingerprint::flashEnabled = NULL;
	this->ns2__DeviceFingerprint::hash = NULL;
	this->ns2__DeviceFingerprint::imagesEnabled = NULL;
	this->ns2__DeviceFingerprint::javascriptEnabled = NULL;
	this->ns2__DeviceFingerprint::proxyIPAddress = NULL;
	this->ns2__DeviceFingerprint::proxyIPAddressActivities = NULL;
	this->ns2__DeviceFingerprint::proxyIPAddressAttributes = NULL;
	this->ns2__DeviceFingerprint::proxyServerType = NULL;
	this->ns2__DeviceFingerprint::trueIPAddress = NULL;
	this->ns2__DeviceFingerprint::trueIPAddressActivities = NULL;
	this->ns2__DeviceFingerprint::trueIPAddressAttributes = NULL;
	this->ns2__DeviceFingerprint::trueIPAddressCity = NULL;
	this->ns2__DeviceFingerprint::trueIPAddressCountry = NULL;
	this->ns2__DeviceFingerprint::smartID = NULL;
	this->ns2__DeviceFingerprint::smartIDConfidenceLevel = NULL;
	this->ns2__DeviceFingerprint::screenResolution = NULL;
	this->ns2__DeviceFingerprint::browserLanguage = NULL;
	this->ns2__DeviceFingerprint::agentType = NULL;
	this->ns2__DeviceFingerprint::dateTime = NULL;
	this->ns2__DeviceFingerprint::profileDuration = NULL;
	this->ns2__DeviceFingerprint::profiledURL = NULL;
	this->ns2__DeviceFingerprint::timeOnPage = NULL;
	this->ns2__DeviceFingerprint::deviceMatch = NULL;
	this->ns2__DeviceFingerprint::firstEncounter = NULL;
	this->ns2__DeviceFingerprint::flashOS = NULL;
	this->ns2__DeviceFingerprint::flashVersion = NULL;
	this->ns2__DeviceFingerprint::deviceLatitude = NULL;
	this->ns2__DeviceFingerprint::deviceLongitude = NULL;
	this->ns2__DeviceFingerprint::gpsAccuracy = NULL;
	this->ns2__DeviceFingerprint::jbRoot = NULL;
	this->ns2__DeviceFingerprint::jbRootReason = NULL;
	/* transient soap skipped */
}

void ns2__DeviceFingerprint::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__DeviceFingerprint::cookiesEnabled);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__DeviceFingerprint::flashEnabled);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::hash);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__DeviceFingerprint::imagesEnabled);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__DeviceFingerprint::javascriptEnabled);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::proxyIPAddress);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::proxyIPAddressActivities);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::proxyIPAddressAttributes);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::proxyServerType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::trueIPAddress);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::trueIPAddressActivities);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::trueIPAddressAttributes);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::trueIPAddressCity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::trueIPAddressCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::smartID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::smartIDConfidenceLevel);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::screenResolution);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::browserLanguage);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::agentType);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__DeviceFingerprint::dateTime);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__DeviceFingerprint::profileDuration);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::profiledURL);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__DeviceFingerprint::timeOnPage);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::deviceMatch);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::firstEncounter);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::flashOS);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::flashVersion);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::deviceLatitude);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::deviceLongitude);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::gpsAccuracy);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__DeviceFingerprint::jbRoot);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DeviceFingerprint::jbRootReason);
#endif
}

int ns2__DeviceFingerprint::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DeviceFingerprint(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DeviceFingerprint(struct soap *soap, const char *tag, int id, const ns2__DeviceFingerprint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DeviceFingerprint), type))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:cookiesEnabled", -1, &a->ns2__DeviceFingerprint::cookiesEnabled, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:flashEnabled", -1, &a->ns2__DeviceFingerprint::flashEnabled, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:hash", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::hash, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:imagesEnabled", -1, &a->ns2__DeviceFingerprint::imagesEnabled, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:javascriptEnabled", -1, &a->ns2__DeviceFingerprint::javascriptEnabled, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:proxyIPAddress", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::proxyIPAddress, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:proxyIPAddressActivities", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::proxyIPAddressActivities, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:proxyIPAddressAttributes", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::proxyIPAddressAttributes, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:proxyServerType", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::proxyServerType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:trueIPAddress", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::trueIPAddress, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:trueIPAddressActivities", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::trueIPAddressActivities, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:trueIPAddressAttributes", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::trueIPAddressAttributes, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:trueIPAddressCity", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::trueIPAddressCity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:trueIPAddressCountry", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::trueIPAddressCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:smartID", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::smartID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:smartIDConfidenceLevel", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::smartIDConfidenceLevel, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:screenResolution", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::screenResolution, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:browserLanguage", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::browserLanguage, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:agentType", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::agentType, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:dateTime", -1, &a->ns2__DeviceFingerprint::dateTime, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:profileDuration", -1, &a->ns2__DeviceFingerprint::profileDuration, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:profiledURL", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::profiledURL, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:timeOnPage", -1, &a->ns2__DeviceFingerprint::timeOnPage, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:deviceMatch", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::deviceMatch, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:firstEncounter", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::firstEncounter, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:flashOS", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::flashOS, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:flashVersion", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::flashVersion, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:deviceLatitude", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::deviceLatitude, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:deviceLongitude", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::deviceLongitude, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:gpsAccuracy", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::gpsAccuracy, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:jbRoot", -1, &a->ns2__DeviceFingerprint::jbRoot, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:jbRootReason", -1, (wchar_t*const*)&a->ns2__DeviceFingerprint::jbRootReason, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DeviceFingerprint::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DeviceFingerprint(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DeviceFingerprint * SOAP_FMAC4 soap_in_ns2__DeviceFingerprint(struct soap *soap, const char *tag, ns2__DeviceFingerprint *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DeviceFingerprint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DeviceFingerprint, sizeof(ns2__DeviceFingerprint), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DeviceFingerprint)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DeviceFingerprint *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_cookiesEnabled1 = 1;
	size_t soap_flag_flashEnabled1 = 1;
	size_t soap_flag_hash1 = 1;
	size_t soap_flag_imagesEnabled1 = 1;
	size_t soap_flag_javascriptEnabled1 = 1;
	size_t soap_flag_proxyIPAddress1 = 1;
	size_t soap_flag_proxyIPAddressActivities1 = 1;
	size_t soap_flag_proxyIPAddressAttributes1 = 1;
	size_t soap_flag_proxyServerType1 = 1;
	size_t soap_flag_trueIPAddress1 = 1;
	size_t soap_flag_trueIPAddressActivities1 = 1;
	size_t soap_flag_trueIPAddressAttributes1 = 1;
	size_t soap_flag_trueIPAddressCity1 = 1;
	size_t soap_flag_trueIPAddressCountry1 = 1;
	size_t soap_flag_smartID1 = 1;
	size_t soap_flag_smartIDConfidenceLevel1 = 1;
	size_t soap_flag_screenResolution1 = 1;
	size_t soap_flag_browserLanguage1 = 1;
	size_t soap_flag_agentType1 = 1;
	size_t soap_flag_dateTime1 = 1;
	size_t soap_flag_profileDuration1 = 1;
	size_t soap_flag_profiledURL1 = 1;
	size_t soap_flag_timeOnPage1 = 1;
	size_t soap_flag_deviceMatch1 = 1;
	size_t soap_flag_firstEncounter1 = 1;
	size_t soap_flag_flashOS1 = 1;
	size_t soap_flag_flashVersion1 = 1;
	size_t soap_flag_deviceLatitude1 = 1;
	size_t soap_flag_deviceLongitude1 = 1;
	size_t soap_flag_gpsAccuracy1 = 1;
	size_t soap_flag_jbRoot1 = 1;
	size_t soap_flag_jbRootReason1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookiesEnabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:cookiesEnabled", &a->ns2__DeviceFingerprint::cookiesEnabled, "ns2:boolean"))
				{	soap_flag_cookiesEnabled1--;
					continue;
				}
			if (soap_flag_flashEnabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:flashEnabled", &a->ns2__DeviceFingerprint::flashEnabled, "ns2:boolean"))
				{	soap_flag_flashEnabled1--;
					continue;
				}
			if (soap_flag_hash1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:hash", (wchar_t**)&a->ns2__DeviceFingerprint::hash, "xsd:string"))
				{	soap_flag_hash1--;
					continue;
				}
			if (soap_flag_imagesEnabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:imagesEnabled", &a->ns2__DeviceFingerprint::imagesEnabled, "ns2:boolean"))
				{	soap_flag_imagesEnabled1--;
					continue;
				}
			if (soap_flag_javascriptEnabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:javascriptEnabled", &a->ns2__DeviceFingerprint::javascriptEnabled, "ns2:boolean"))
				{	soap_flag_javascriptEnabled1--;
					continue;
				}
			if (soap_flag_proxyIPAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:proxyIPAddress", (wchar_t**)&a->ns2__DeviceFingerprint::proxyIPAddress, "xsd:string"))
				{	soap_flag_proxyIPAddress1--;
					continue;
				}
			if (soap_flag_proxyIPAddressActivities1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:proxyIPAddressActivities", (wchar_t**)&a->ns2__DeviceFingerprint::proxyIPAddressActivities, "xsd:string"))
				{	soap_flag_proxyIPAddressActivities1--;
					continue;
				}
			if (soap_flag_proxyIPAddressAttributes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:proxyIPAddressAttributes", (wchar_t**)&a->ns2__DeviceFingerprint::proxyIPAddressAttributes, "xsd:string"))
				{	soap_flag_proxyIPAddressAttributes1--;
					continue;
				}
			if (soap_flag_proxyServerType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:proxyServerType", (wchar_t**)&a->ns2__DeviceFingerprint::proxyServerType, "xsd:string"))
				{	soap_flag_proxyServerType1--;
					continue;
				}
			if (soap_flag_trueIPAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:trueIPAddress", (wchar_t**)&a->ns2__DeviceFingerprint::trueIPAddress, "xsd:string"))
				{	soap_flag_trueIPAddress1--;
					continue;
				}
			if (soap_flag_trueIPAddressActivities1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:trueIPAddressActivities", (wchar_t**)&a->ns2__DeviceFingerprint::trueIPAddressActivities, "xsd:string"))
				{	soap_flag_trueIPAddressActivities1--;
					continue;
				}
			if (soap_flag_trueIPAddressAttributes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:trueIPAddressAttributes", (wchar_t**)&a->ns2__DeviceFingerprint::trueIPAddressAttributes, "xsd:string"))
				{	soap_flag_trueIPAddressAttributes1--;
					continue;
				}
			if (soap_flag_trueIPAddressCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:trueIPAddressCity", (wchar_t**)&a->ns2__DeviceFingerprint::trueIPAddressCity, "xsd:string"))
				{	soap_flag_trueIPAddressCity1--;
					continue;
				}
			if (soap_flag_trueIPAddressCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:trueIPAddressCountry", (wchar_t**)&a->ns2__DeviceFingerprint::trueIPAddressCountry, "xsd:string"))
				{	soap_flag_trueIPAddressCountry1--;
					continue;
				}
			if (soap_flag_smartID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:smartID", (wchar_t**)&a->ns2__DeviceFingerprint::smartID, "xsd:string"))
				{	soap_flag_smartID1--;
					continue;
				}
			if (soap_flag_smartIDConfidenceLevel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:smartIDConfidenceLevel", (wchar_t**)&a->ns2__DeviceFingerprint::smartIDConfidenceLevel, "xsd:string"))
				{	soap_flag_smartIDConfidenceLevel1--;
					continue;
				}
			if (soap_flag_screenResolution1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:screenResolution", (wchar_t**)&a->ns2__DeviceFingerprint::screenResolution, "xsd:string"))
				{	soap_flag_screenResolution1--;
					continue;
				}
			if (soap_flag_browserLanguage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:browserLanguage", (wchar_t**)&a->ns2__DeviceFingerprint::browserLanguage, "xsd:string"))
				{	soap_flag_browserLanguage1--;
					continue;
				}
			if (soap_flag_agentType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:agentType", (wchar_t**)&a->ns2__DeviceFingerprint::agentType, "xsd:string"))
				{	soap_flag_agentType1--;
					continue;
				}
			if (soap_flag_dateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:dateTime", &a->ns2__DeviceFingerprint::dateTime, "ns2:dateTime"))
				{	soap_flag_dateTime1--;
					continue;
				}
			if (soap_flag_profileDuration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:profileDuration", &a->ns2__DeviceFingerprint::profileDuration, "xsd:integer"))
				{	soap_flag_profileDuration1--;
					continue;
				}
			if (soap_flag_profiledURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:profiledURL", (wchar_t**)&a->ns2__DeviceFingerprint::profiledURL, "xsd:string"))
				{	soap_flag_profiledURL1--;
					continue;
				}
			if (soap_flag_timeOnPage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:timeOnPage", &a->ns2__DeviceFingerprint::timeOnPage, "xsd:integer"))
				{	soap_flag_timeOnPage1--;
					continue;
				}
			if (soap_flag_deviceMatch1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:deviceMatch", (wchar_t**)&a->ns2__DeviceFingerprint::deviceMatch, "xsd:string"))
				{	soap_flag_deviceMatch1--;
					continue;
				}
			if (soap_flag_firstEncounter1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:firstEncounter", (wchar_t**)&a->ns2__DeviceFingerprint::firstEncounter, "xsd:string"))
				{	soap_flag_firstEncounter1--;
					continue;
				}
			if (soap_flag_flashOS1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:flashOS", (wchar_t**)&a->ns2__DeviceFingerprint::flashOS, "xsd:string"))
				{	soap_flag_flashOS1--;
					continue;
				}
			if (soap_flag_flashVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:flashVersion", (wchar_t**)&a->ns2__DeviceFingerprint::flashVersion, "xsd:string"))
				{	soap_flag_flashVersion1--;
					continue;
				}
			if (soap_flag_deviceLatitude1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:deviceLatitude", (wchar_t**)&a->ns2__DeviceFingerprint::deviceLatitude, "xsd:string"))
				{	soap_flag_deviceLatitude1--;
					continue;
				}
			if (soap_flag_deviceLongitude1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:deviceLongitude", (wchar_t**)&a->ns2__DeviceFingerprint::deviceLongitude, "xsd:string"))
				{	soap_flag_deviceLongitude1--;
					continue;
				}
			if (soap_flag_gpsAccuracy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:gpsAccuracy", (wchar_t**)&a->ns2__DeviceFingerprint::gpsAccuracy, "xsd:string"))
				{	soap_flag_gpsAccuracy1--;
					continue;
				}
			if (soap_flag_jbRoot1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:jbRoot", &a->ns2__DeviceFingerprint::jbRoot, "xsd:integer"))
				{	soap_flag_jbRoot1--;
					continue;
				}
			if (soap_flag_jbRootReason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:jbRootReason", (wchar_t**)&a->ns2__DeviceFingerprint::jbRootReason, "xsd:string"))
				{	soap_flag_jbRootReason1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DeviceFingerprint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DeviceFingerprint, SOAP_TYPE_ns2__DeviceFingerprint, sizeof(ns2__DeviceFingerprint), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DeviceFingerprint * SOAP_FMAC2 soap_instantiate_ns2__DeviceFingerprint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DeviceFingerprint(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DeviceFingerprint *p;
	size_t k = sizeof(ns2__DeviceFingerprint);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DeviceFingerprint);
		if (p)
			((ns2__DeviceFingerprint*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DeviceFingerprint, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DeviceFingerprint*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DeviceFingerprint location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DeviceFingerprint, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DeviceFingerprint::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:DeviceFingerprint", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DeviceFingerprint::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DeviceFingerprint(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DeviceFingerprint * SOAP_FMAC4 soap_get_ns2__DeviceFingerprint(struct soap *soap, ns2__DeviceFingerprint *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DeviceFingerprint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaxReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TaxReply::reasonCode = NULL;
	this->ns2__TaxReply::currency = NULL;
	this->ns2__TaxReply::grandTotalAmount = NULL;
	this->ns2__TaxReply::totalCityTaxAmount = NULL;
	this->ns2__TaxReply::city = NULL;
	this->ns2__TaxReply::totalCountyTaxAmount = NULL;
	this->ns2__TaxReply::county = NULL;
	this->ns2__TaxReply::totalDistrictTaxAmount = NULL;
	this->ns2__TaxReply::totalStateTaxAmount = NULL;
	this->ns2__TaxReply::state = NULL;
	this->ns2__TaxReply::totalTaxAmount = NULL;
	this->ns2__TaxReply::postalCode = NULL;
	this->ns2__TaxReply::geocode = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__TaxReplyItem(soap, &this->ns2__TaxReply::item);
	/* transient soap skipped */
}

void ns2__TaxReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__TaxReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxReply::currency);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__TaxReply::grandTotalAmount);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__TaxReply::totalCityTaxAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxReply::city);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__TaxReply::totalCountyTaxAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxReply::county);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__TaxReply::totalDistrictTaxAmount);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__TaxReply::totalStateTaxAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxReply::state);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__TaxReply::totalTaxAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxReply::postalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxReply::geocode);
	soap_serialize_std__vectorTemplateOfPointerTons2__TaxReplyItem(soap, &this->ns2__TaxReply::item);
#endif
}

int ns2__TaxReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaxReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaxReply(struct soap *soap, const char *tag, int id, const ns2__TaxReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaxReply), type))
		return soap->error;
	if (!a->ns2__TaxReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__TaxReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:currency", -1, (wchar_t*const*)&a->ns2__TaxReply::currency, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:grandTotalAmount", -1, &a->ns2__TaxReply::grandTotalAmount, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:totalCityTaxAmount", -1, &a->ns2__TaxReply::totalCityTaxAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:city", -1, (wchar_t*const*)&a->ns2__TaxReply::city, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:totalCountyTaxAmount", -1, &a->ns2__TaxReply::totalCountyTaxAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:county", -1, (wchar_t*const*)&a->ns2__TaxReply::county, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:totalDistrictTaxAmount", -1, &a->ns2__TaxReply::totalDistrictTaxAmount, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:totalStateTaxAmount", -1, &a->ns2__TaxReply::totalStateTaxAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:state", -1, (wchar_t*const*)&a->ns2__TaxReply::state, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:totalTaxAmount", -1, &a->ns2__TaxReply::totalTaxAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:postalCode", -1, (wchar_t*const*)&a->ns2__TaxReply::postalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:geocode", -1, (wchar_t*const*)&a->ns2__TaxReply::geocode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__TaxReplyItem(soap, "ns2:item", -1, &a->ns2__TaxReply::item, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaxReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaxReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaxReply * SOAP_FMAC4 soap_in_ns2__TaxReply(struct soap *soap, const char *tag, ns2__TaxReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaxReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaxReply, sizeof(ns2__TaxReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaxReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaxReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_currency1 = 1;
	size_t soap_flag_grandTotalAmount1 = 1;
	size_t soap_flag_totalCityTaxAmount1 = 1;
	size_t soap_flag_city1 = 1;
	size_t soap_flag_totalCountyTaxAmount1 = 1;
	size_t soap_flag_county1 = 1;
	size_t soap_flag_totalDistrictTaxAmount1 = 1;
	size_t soap_flag_totalStateTaxAmount1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_totalTaxAmount1 = 1;
	size_t soap_flag_postalCode1 = 1;
	size_t soap_flag_geocode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__TaxReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_currency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:currency", (wchar_t**)&a->ns2__TaxReply::currency, "xsd:string"))
				{	soap_flag_currency1--;
					continue;
				}
			if (soap_flag_grandTotalAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:grandTotalAmount", &a->ns2__TaxReply::grandTotalAmount, "ns2:amount"))
				{	soap_flag_grandTotalAmount1--;
					continue;
				}
			if (soap_flag_totalCityTaxAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:totalCityTaxAmount", &a->ns2__TaxReply::totalCityTaxAmount, "ns2:amount"))
				{	soap_flag_totalCityTaxAmount1--;
					continue;
				}
			if (soap_flag_city1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:city", (wchar_t**)&a->ns2__TaxReply::city, "xsd:string"))
				{	soap_flag_city1--;
					continue;
				}
			if (soap_flag_totalCountyTaxAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:totalCountyTaxAmount", &a->ns2__TaxReply::totalCountyTaxAmount, "ns2:amount"))
				{	soap_flag_totalCountyTaxAmount1--;
					continue;
				}
			if (soap_flag_county1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:county", (wchar_t**)&a->ns2__TaxReply::county, "xsd:string"))
				{	soap_flag_county1--;
					continue;
				}
			if (soap_flag_totalDistrictTaxAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:totalDistrictTaxAmount", &a->ns2__TaxReply::totalDistrictTaxAmount, "ns2:amount"))
				{	soap_flag_totalDistrictTaxAmount1--;
					continue;
				}
			if (soap_flag_totalStateTaxAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:totalStateTaxAmount", &a->ns2__TaxReply::totalStateTaxAmount, "ns2:amount"))
				{	soap_flag_totalStateTaxAmount1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:state", (wchar_t**)&a->ns2__TaxReply::state, "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_totalTaxAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:totalTaxAmount", &a->ns2__TaxReply::totalTaxAmount, "ns2:amount"))
				{	soap_flag_totalTaxAmount1--;
					continue;
				}
			if (soap_flag_postalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:postalCode", (wchar_t**)&a->ns2__TaxReply::postalCode, "xsd:string"))
				{	soap_flag_postalCode1--;
					continue;
				}
			if (soap_flag_geocode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:geocode", (wchar_t**)&a->ns2__TaxReply::geocode, "xsd:string"))
				{	soap_flag_geocode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__TaxReplyItem(soap, "ns2:item", &a->ns2__TaxReply::item, "ns2:TaxReplyItem"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0 || a->ns2__TaxReply::item.size() > 1000))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__TaxReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaxReply, SOAP_TYPE_ns2__TaxReply, sizeof(ns2__TaxReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaxReply * SOAP_FMAC2 soap_instantiate_ns2__TaxReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaxReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaxReply *p;
	size_t k = sizeof(ns2__TaxReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaxReply);
		if (p)
			((ns2__TaxReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaxReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaxReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaxReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaxReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaxReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:TaxReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaxReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaxReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaxReply * SOAP_FMAC4 soap_get_ns2__TaxReply(struct soap *soap, ns2__TaxReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaxReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaxReplyItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TaxReplyItem::cityTaxAmount = NULL;
	this->ns2__TaxReplyItem::countyTaxAmount = NULL;
	this->ns2__TaxReplyItem::districtTaxAmount = NULL;
	this->ns2__TaxReplyItem::stateTaxAmount = NULL;
	this->ns2__TaxReplyItem::totalTaxAmount = NULL;
	this->ns2__TaxReplyItem::id = NULL;
	/* transient soap skipped */
}

void ns2__TaxReplyItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__amount(soap, &this->ns2__TaxReplyItem::cityTaxAmount);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__TaxReplyItem::countyTaxAmount);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__TaxReplyItem::districtTaxAmount);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__TaxReplyItem::stateTaxAmount);
	soap_serialize_ns2__amount(soap, (wchar_t*const*)&this->ns2__TaxReplyItem::totalTaxAmount);
#endif
}

int ns2__TaxReplyItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaxReplyItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaxReplyItem(struct soap *soap, const char *tag, int id, const ns2__TaxReplyItem *a, const char *type)
{
	if (((ns2__TaxReplyItem*)a)->id)
		soap_set_attr(soap, "id", soap_xsd__integer2s(soap, ((ns2__TaxReplyItem*)a)->id), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaxReplyItem), type))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:cityTaxAmount", -1, &a->ns2__TaxReplyItem::cityTaxAmount, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:countyTaxAmount", -1, &a->ns2__TaxReplyItem::countyTaxAmount, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:districtTaxAmount", -1, &a->ns2__TaxReplyItem::districtTaxAmount, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:stateTaxAmount", -1, &a->ns2__TaxReplyItem::stateTaxAmount, ""))
		return soap->error;
	if (!a->ns2__TaxReplyItem::totalTaxAmount)
	{	if (soap_element_nil(soap, "ns2:totalTaxAmount"))
			return soap->error;
	}
	else
	if (soap_out_ns2__amount(soap, "ns2:totalTaxAmount", -1, (wchar_t*const*)&a->ns2__TaxReplyItem::totalTaxAmount, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaxReplyItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaxReplyItem(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaxReplyItem * SOAP_FMAC4 soap_in_ns2__TaxReplyItem(struct soap *soap, const char *tag, ns2__TaxReplyItem *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaxReplyItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaxReplyItem, sizeof(ns2__TaxReplyItem), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaxReplyItem)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaxReplyItem *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2xsd__integer(soap, soap_attr_value(soap, "id", 1), &((ns2__TaxReplyItem*)a)->id))
		return NULL;
	size_t soap_flag_cityTaxAmount1 = 1;
	size_t soap_flag_countyTaxAmount1 = 1;
	size_t soap_flag_districtTaxAmount1 = 1;
	size_t soap_flag_stateTaxAmount1 = 1;
	size_t soap_flag_totalTaxAmount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cityTaxAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:cityTaxAmount", &a->ns2__TaxReplyItem::cityTaxAmount, "ns2:amount"))
				{	soap_flag_cityTaxAmount1--;
					continue;
				}
			if (soap_flag_countyTaxAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:countyTaxAmount", &a->ns2__TaxReplyItem::countyTaxAmount, "ns2:amount"))
				{	soap_flag_countyTaxAmount1--;
					continue;
				}
			if (soap_flag_districtTaxAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:districtTaxAmount", &a->ns2__TaxReplyItem::districtTaxAmount, "ns2:amount"))
				{	soap_flag_districtTaxAmount1--;
					continue;
				}
			if (soap_flag_stateTaxAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:stateTaxAmount", &a->ns2__TaxReplyItem::stateTaxAmount, "ns2:amount"))
				{	soap_flag_stateTaxAmount1--;
					continue;
				}
			if (soap_flag_totalTaxAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__amount(soap, "ns2:totalTaxAmount", (wchar_t**)&a->ns2__TaxReplyItem::totalTaxAmount, "ns2:amount"))
				{	soap_flag_totalTaxAmount1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_totalTaxAmount1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__TaxReplyItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaxReplyItem, SOAP_TYPE_ns2__TaxReplyItem, sizeof(ns2__TaxReplyItem), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaxReplyItem * SOAP_FMAC2 soap_instantiate_ns2__TaxReplyItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaxReplyItem(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaxReplyItem *p;
	size_t k = sizeof(ns2__TaxReplyItem);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaxReplyItem);
		if (p)
			((ns2__TaxReplyItem*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaxReplyItem, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaxReplyItem*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaxReplyItem location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaxReplyItem, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaxReplyItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:TaxReplyItem", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaxReplyItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaxReplyItem(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaxReplyItem * SOAP_FMAC4 soap_get_ns2__TaxReplyItem(struct soap *soap, ns2__TaxReplyItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaxReplyItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayerAuthValidateReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayerAuthValidateReply::reasonCode = NULL;
	this->ns2__PayerAuthValidateReply::authenticationResult = NULL;
	this->ns2__PayerAuthValidateReply::authenticationStatusMessage = NULL;
	this->ns2__PayerAuthValidateReply::cavv = NULL;
	this->ns2__PayerAuthValidateReply::cavvAlgorithm = NULL;
	this->ns2__PayerAuthValidateReply::commerceIndicator = NULL;
	this->ns2__PayerAuthValidateReply::eci = NULL;
	this->ns2__PayerAuthValidateReply::eciRaw = NULL;
	this->ns2__PayerAuthValidateReply::xid = NULL;
	this->ns2__PayerAuthValidateReply::ucafAuthenticationData = NULL;
	this->ns2__PayerAuthValidateReply::ucafCollectionIndicator = NULL;
	this->ns2__PayerAuthValidateReply::paresStatus = NULL;
	/* transient soap skipped */
}

void ns2__PayerAuthValidateReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PayerAuthValidateReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthValidateReply::authenticationResult);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthValidateReply::authenticationStatusMessage);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthValidateReply::cavv);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthValidateReply::cavvAlgorithm);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthValidateReply::commerceIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthValidateReply::eci);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthValidateReply::eciRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthValidateReply::xid);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthValidateReply::ucafAuthenticationData);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthValidateReply::ucafCollectionIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthValidateReply::paresStatus);
#endif
}

int ns2__PayerAuthValidateReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayerAuthValidateReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayerAuthValidateReply(struct soap *soap, const char *tag, int id, const ns2__PayerAuthValidateReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayerAuthValidateReply), type))
		return soap->error;
	if (!a->ns2__PayerAuthValidateReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PayerAuthValidateReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authenticationResult", -1, (wchar_t*const*)&a->ns2__PayerAuthValidateReply::authenticationResult, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authenticationStatusMessage", -1, (wchar_t*const*)&a->ns2__PayerAuthValidateReply::authenticationStatusMessage, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cavv", -1, (wchar_t*const*)&a->ns2__PayerAuthValidateReply::cavv, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cavvAlgorithm", -1, (wchar_t*const*)&a->ns2__PayerAuthValidateReply::cavvAlgorithm, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:commerceIndicator", -1, (wchar_t*const*)&a->ns2__PayerAuthValidateReply::commerceIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:eci", -1, (wchar_t*const*)&a->ns2__PayerAuthValidateReply::eci, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:eciRaw", -1, (wchar_t*const*)&a->ns2__PayerAuthValidateReply::eciRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:xid", -1, (wchar_t*const*)&a->ns2__PayerAuthValidateReply::xid, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ucafAuthenticationData", -1, (wchar_t*const*)&a->ns2__PayerAuthValidateReply::ucafAuthenticationData, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ucafCollectionIndicator", -1, (wchar_t*const*)&a->ns2__PayerAuthValidateReply::ucafCollectionIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paresStatus", -1, (wchar_t*const*)&a->ns2__PayerAuthValidateReply::paresStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayerAuthValidateReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayerAuthValidateReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayerAuthValidateReply * SOAP_FMAC4 soap_in_ns2__PayerAuthValidateReply(struct soap *soap, const char *tag, ns2__PayerAuthValidateReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayerAuthValidateReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayerAuthValidateReply, sizeof(ns2__PayerAuthValidateReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayerAuthValidateReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayerAuthValidateReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_authenticationResult1 = 1;
	size_t soap_flag_authenticationStatusMessage1 = 1;
	size_t soap_flag_cavv1 = 1;
	size_t soap_flag_cavvAlgorithm1 = 1;
	size_t soap_flag_commerceIndicator1 = 1;
	size_t soap_flag_eci1 = 1;
	size_t soap_flag_eciRaw1 = 1;
	size_t soap_flag_xid1 = 1;
	size_t soap_flag_ucafAuthenticationData1 = 1;
	size_t soap_flag_ucafCollectionIndicator1 = 1;
	size_t soap_flag_paresStatus1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PayerAuthValidateReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_authenticationResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authenticationResult", (wchar_t**)&a->ns2__PayerAuthValidateReply::authenticationResult, "xsd:string"))
				{	soap_flag_authenticationResult1--;
					continue;
				}
			if (soap_flag_authenticationStatusMessage1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authenticationStatusMessage", (wchar_t**)&a->ns2__PayerAuthValidateReply::authenticationStatusMessage, "xsd:string"))
				{	soap_flag_authenticationStatusMessage1--;
					continue;
				}
			if (soap_flag_cavv1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cavv", (wchar_t**)&a->ns2__PayerAuthValidateReply::cavv, "xsd:string"))
				{	soap_flag_cavv1--;
					continue;
				}
			if (soap_flag_cavvAlgorithm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cavvAlgorithm", (wchar_t**)&a->ns2__PayerAuthValidateReply::cavvAlgorithm, "xsd:string"))
				{	soap_flag_cavvAlgorithm1--;
					continue;
				}
			if (soap_flag_commerceIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:commerceIndicator", (wchar_t**)&a->ns2__PayerAuthValidateReply::commerceIndicator, "xsd:string"))
				{	soap_flag_commerceIndicator1--;
					continue;
				}
			if (soap_flag_eci1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:eci", (wchar_t**)&a->ns2__PayerAuthValidateReply::eci, "xsd:string"))
				{	soap_flag_eci1--;
					continue;
				}
			if (soap_flag_eciRaw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:eciRaw", (wchar_t**)&a->ns2__PayerAuthValidateReply::eciRaw, "xsd:string"))
				{	soap_flag_eciRaw1--;
					continue;
				}
			if (soap_flag_xid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:xid", (wchar_t**)&a->ns2__PayerAuthValidateReply::xid, "xsd:string"))
				{	soap_flag_xid1--;
					continue;
				}
			if (soap_flag_ucafAuthenticationData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ucafAuthenticationData", (wchar_t**)&a->ns2__PayerAuthValidateReply::ucafAuthenticationData, "xsd:string"))
				{	soap_flag_ucafAuthenticationData1--;
					continue;
				}
			if (soap_flag_ucafCollectionIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ucafCollectionIndicator", (wchar_t**)&a->ns2__PayerAuthValidateReply::ucafCollectionIndicator, "xsd:string"))
				{	soap_flag_ucafCollectionIndicator1--;
					continue;
				}
			if (soap_flag_paresStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paresStatus", (wchar_t**)&a->ns2__PayerAuthValidateReply::paresStatus, "xsd:string"))
				{	soap_flag_paresStatus1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PayerAuthValidateReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayerAuthValidateReply, SOAP_TYPE_ns2__PayerAuthValidateReply, sizeof(ns2__PayerAuthValidateReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayerAuthValidateReply * SOAP_FMAC2 soap_instantiate_ns2__PayerAuthValidateReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayerAuthValidateReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayerAuthValidateReply *p;
	size_t k = sizeof(ns2__PayerAuthValidateReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayerAuthValidateReply);
		if (p)
			((ns2__PayerAuthValidateReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayerAuthValidateReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayerAuthValidateReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayerAuthValidateReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayerAuthValidateReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayerAuthValidateReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayerAuthValidateReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayerAuthValidateReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayerAuthValidateReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayerAuthValidateReply * SOAP_FMAC4 soap_get_ns2__PayerAuthValidateReply(struct soap *soap, ns2__PayerAuthValidateReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayerAuthValidateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayerAuthEnrollReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayerAuthEnrollReply::reasonCode = NULL;
	this->ns2__PayerAuthEnrollReply::acsURL = NULL;
	this->ns2__PayerAuthEnrollReply::commerceIndicator = NULL;
	this->ns2__PayerAuthEnrollReply::eci = NULL;
	this->ns2__PayerAuthEnrollReply::paReq = NULL;
	this->ns2__PayerAuthEnrollReply::proxyPAN = NULL;
	this->ns2__PayerAuthEnrollReply::xid = NULL;
	this->ns2__PayerAuthEnrollReply::proofXML = NULL;
	this->ns2__PayerAuthEnrollReply::ucafCollectionIndicator = NULL;
	this->ns2__PayerAuthEnrollReply::veresEnrolled = NULL;
	this->ns2__PayerAuthEnrollReply::authenticationPath = NULL;
	/* transient soap skipped */
}

void ns2__PayerAuthEnrollReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollReply::acsURL);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollReply::commerceIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollReply::eci);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollReply::paReq);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollReply::proxyPAN);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollReply::xid);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollReply::proofXML);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollReply::ucafCollectionIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollReply::veresEnrolled);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollReply::authenticationPath);
#endif
}

int ns2__PayerAuthEnrollReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayerAuthEnrollReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayerAuthEnrollReply(struct soap *soap, const char *tag, int id, const ns2__PayerAuthEnrollReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayerAuthEnrollReply), type))
		return soap->error;
	if (!a->ns2__PayerAuthEnrollReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:acsURL", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollReply::acsURL, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:commerceIndicator", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollReply::commerceIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:eci", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollReply::eci, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paReq", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollReply::paReq, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:proxyPAN", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollReply::proxyPAN, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:xid", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollReply::xid, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:proofXML", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollReply::proofXML, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ucafCollectionIndicator", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollReply::ucafCollectionIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:veresEnrolled", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollReply::veresEnrolled, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authenticationPath", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollReply::authenticationPath, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayerAuthEnrollReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayerAuthEnrollReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayerAuthEnrollReply * SOAP_FMAC4 soap_in_ns2__PayerAuthEnrollReply(struct soap *soap, const char *tag, ns2__PayerAuthEnrollReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayerAuthEnrollReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayerAuthEnrollReply, sizeof(ns2__PayerAuthEnrollReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayerAuthEnrollReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayerAuthEnrollReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_acsURL1 = 1;
	size_t soap_flag_commerceIndicator1 = 1;
	size_t soap_flag_eci1 = 1;
	size_t soap_flag_paReq1 = 1;
	size_t soap_flag_proxyPAN1 = 1;
	size_t soap_flag_xid1 = 1;
	size_t soap_flag_proofXML1 = 1;
	size_t soap_flag_ucafCollectionIndicator1 = 1;
	size_t soap_flag_veresEnrolled1 = 1;
	size_t soap_flag_authenticationPath1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PayerAuthEnrollReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_acsURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:acsURL", (wchar_t**)&a->ns2__PayerAuthEnrollReply::acsURL, "xsd:string"))
				{	soap_flag_acsURL1--;
					continue;
				}
			if (soap_flag_commerceIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:commerceIndicator", (wchar_t**)&a->ns2__PayerAuthEnrollReply::commerceIndicator, "xsd:string"))
				{	soap_flag_commerceIndicator1--;
					continue;
				}
			if (soap_flag_eci1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:eci", (wchar_t**)&a->ns2__PayerAuthEnrollReply::eci, "xsd:string"))
				{	soap_flag_eci1--;
					continue;
				}
			if (soap_flag_paReq1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paReq", (wchar_t**)&a->ns2__PayerAuthEnrollReply::paReq, "xsd:string"))
				{	soap_flag_paReq1--;
					continue;
				}
			if (soap_flag_proxyPAN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:proxyPAN", (wchar_t**)&a->ns2__PayerAuthEnrollReply::proxyPAN, "xsd:string"))
				{	soap_flag_proxyPAN1--;
					continue;
				}
			if (soap_flag_xid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:xid", (wchar_t**)&a->ns2__PayerAuthEnrollReply::xid, "xsd:string"))
				{	soap_flag_xid1--;
					continue;
				}
			if (soap_flag_proofXML1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:proofXML", (wchar_t**)&a->ns2__PayerAuthEnrollReply::proofXML, "xsd:string"))
				{	soap_flag_proofXML1--;
					continue;
				}
			if (soap_flag_ucafCollectionIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ucafCollectionIndicator", (wchar_t**)&a->ns2__PayerAuthEnrollReply::ucafCollectionIndicator, "xsd:string"))
				{	soap_flag_ucafCollectionIndicator1--;
					continue;
				}
			if (soap_flag_veresEnrolled1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:veresEnrolled", (wchar_t**)&a->ns2__PayerAuthEnrollReply::veresEnrolled, "xsd:string"))
				{	soap_flag_veresEnrolled1--;
					continue;
				}
			if (soap_flag_authenticationPath1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authenticationPath", (wchar_t**)&a->ns2__PayerAuthEnrollReply::authenticationPath, "xsd:string"))
				{	soap_flag_authenticationPath1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PayerAuthEnrollReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayerAuthEnrollReply, SOAP_TYPE_ns2__PayerAuthEnrollReply, sizeof(ns2__PayerAuthEnrollReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayerAuthEnrollReply * SOAP_FMAC2 soap_instantiate_ns2__PayerAuthEnrollReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayerAuthEnrollReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayerAuthEnrollReply *p;
	size_t k = sizeof(ns2__PayerAuthEnrollReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayerAuthEnrollReply);
		if (p)
			((ns2__PayerAuthEnrollReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayerAuthEnrollReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayerAuthEnrollReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayerAuthEnrollReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayerAuthEnrollReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayerAuthEnrollReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayerAuthEnrollReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayerAuthEnrollReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayerAuthEnrollReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayerAuthEnrollReply * SOAP_FMAC4 soap_get_ns2__PayerAuthEnrollReply(struct soap *soap, ns2__PayerAuthEnrollReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayerAuthEnrollReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ECAuthenticateReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ECAuthenticateReply::reasonCode = NULL;
	this->ns2__ECAuthenticateReply::requestDateTime = NULL;
	this->ns2__ECAuthenticateReply::processorResponse = NULL;
	this->ns2__ECAuthenticateReply::reconciliationID = NULL;
	this->ns2__ECAuthenticateReply::checkpointSummary = NULL;
	this->ns2__ECAuthenticateReply::fraudShieldIndicators = NULL;
	/* transient soap skipped */
}

void ns2__ECAuthenticateReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__ECAuthenticateReply::reasonCode);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__ECAuthenticateReply::requestDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECAuthenticateReply::processorResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECAuthenticateReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECAuthenticateReply::checkpointSummary);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECAuthenticateReply::fraudShieldIndicators);
#endif
}

int ns2__ECAuthenticateReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ECAuthenticateReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ECAuthenticateReply(struct soap *soap, const char *tag, int id, const ns2__ECAuthenticateReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ECAuthenticateReply), type))
		return soap->error;
	if (!a->ns2__ECAuthenticateReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__ECAuthenticateReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__ECAuthenticateReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__ECAuthenticateReply::processorResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__ECAuthenticateReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:checkpointSummary", -1, (wchar_t*const*)&a->ns2__ECAuthenticateReply::checkpointSummary, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:fraudShieldIndicators", -1, (wchar_t*const*)&a->ns2__ECAuthenticateReply::fraudShieldIndicators, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ECAuthenticateReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ECAuthenticateReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ECAuthenticateReply * SOAP_FMAC4 soap_in_ns2__ECAuthenticateReply(struct soap *soap, const char *tag, ns2__ECAuthenticateReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ECAuthenticateReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ECAuthenticateReply, sizeof(ns2__ECAuthenticateReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ECAuthenticateReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ECAuthenticateReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_checkpointSummary1 = 1;
	size_t soap_flag_fraudShieldIndicators1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__ECAuthenticateReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__ECAuthenticateReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__ECAuthenticateReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__ECAuthenticateReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_checkpointSummary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:checkpointSummary", (wchar_t**)&a->ns2__ECAuthenticateReply::checkpointSummary, "xsd:string"))
				{	soap_flag_checkpointSummary1--;
					continue;
				}
			if (soap_flag_fraudShieldIndicators1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:fraudShieldIndicators", (wchar_t**)&a->ns2__ECAuthenticateReply::fraudShieldIndicators, "xsd:string"))
				{	soap_flag_fraudShieldIndicators1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__ECAuthenticateReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ECAuthenticateReply, SOAP_TYPE_ns2__ECAuthenticateReply, sizeof(ns2__ECAuthenticateReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ECAuthenticateReply * SOAP_FMAC2 soap_instantiate_ns2__ECAuthenticateReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ECAuthenticateReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ECAuthenticateReply *p;
	size_t k = sizeof(ns2__ECAuthenticateReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ECAuthenticateReply);
		if (p)
			((ns2__ECAuthenticateReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ECAuthenticateReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ECAuthenticateReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ECAuthenticateReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ECAuthenticateReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ECAuthenticateReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:ECAuthenticateReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ECAuthenticateReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ECAuthenticateReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ECAuthenticateReply * SOAP_FMAC4 soap_get_ns2__ECAuthenticateReply(struct soap *soap, ns2__ECAuthenticateReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ECAuthenticateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ECCreditReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ECCreditReply::reasonCode = NULL;
	this->ns2__ECCreditReply::settlementMethod = NULL;
	this->ns2__ECCreditReply::requestDateTime = NULL;
	this->ns2__ECCreditReply::amount = NULL;
	this->ns2__ECCreditReply::processorTransactionID = NULL;
	this->ns2__ECCreditReply::reconciliationID = NULL;
	this->ns2__ECCreditReply::processorResponse = NULL;
	this->ns2__ECCreditReply::verificationCode = NULL;
	this->ns2__ECCreditReply::verificationCodeRaw = NULL;
	this->ns2__ECCreditReply::correctedAccountNumber = NULL;
	this->ns2__ECCreditReply::correctedRoutingNumber = NULL;
	this->ns2__ECCreditReply::ownerMerchantID = NULL;
	/* transient soap skipped */
}

void ns2__ECCreditReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__ECCreditReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECCreditReply::settlementMethod);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__ECCreditReply::requestDateTime);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__ECCreditReply::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECCreditReply::processorTransactionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECCreditReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECCreditReply::processorResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECCreditReply::verificationCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECCreditReply::verificationCodeRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECCreditReply::correctedAccountNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECCreditReply::correctedRoutingNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECCreditReply::ownerMerchantID);
#endif
}

int ns2__ECCreditReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ECCreditReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ECCreditReply(struct soap *soap, const char *tag, int id, const ns2__ECCreditReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ECCreditReply), type))
		return soap->error;
	if (!a->ns2__ECCreditReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__ECCreditReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:settlementMethod", -1, (wchar_t*const*)&a->ns2__ECCreditReply::settlementMethod, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__ECCreditReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__ECCreditReply::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorTransactionID", -1, (wchar_t*const*)&a->ns2__ECCreditReply::processorTransactionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__ECCreditReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__ECCreditReply::processorResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:verificationCode", -1, (wchar_t*const*)&a->ns2__ECCreditReply::verificationCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:verificationCodeRaw", -1, (wchar_t*const*)&a->ns2__ECCreditReply::verificationCodeRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:correctedAccountNumber", -1, (wchar_t*const*)&a->ns2__ECCreditReply::correctedAccountNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:correctedRoutingNumber", -1, (wchar_t*const*)&a->ns2__ECCreditReply::correctedRoutingNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ownerMerchantID", -1, (wchar_t*const*)&a->ns2__ECCreditReply::ownerMerchantID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ECCreditReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ECCreditReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ECCreditReply * SOAP_FMAC4 soap_in_ns2__ECCreditReply(struct soap *soap, const char *tag, ns2__ECCreditReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ECCreditReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ECCreditReply, sizeof(ns2__ECCreditReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ECCreditReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ECCreditReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_settlementMethod1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_processorTransactionID1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_verificationCode1 = 1;
	size_t soap_flag_verificationCodeRaw1 = 1;
	size_t soap_flag_correctedAccountNumber1 = 1;
	size_t soap_flag_correctedRoutingNumber1 = 1;
	size_t soap_flag_ownerMerchantID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__ECCreditReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_settlementMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:settlementMethod", (wchar_t**)&a->ns2__ECCreditReply::settlementMethod, "xsd:string"))
				{	soap_flag_settlementMethod1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__ECCreditReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__ECCreditReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_processorTransactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorTransactionID", (wchar_t**)&a->ns2__ECCreditReply::processorTransactionID, "xsd:string"))
				{	soap_flag_processorTransactionID1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__ECCreditReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__ECCreditReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_verificationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:verificationCode", (wchar_t**)&a->ns2__ECCreditReply::verificationCode, "xsd:string"))
				{	soap_flag_verificationCode1--;
					continue;
				}
			if (soap_flag_verificationCodeRaw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:verificationCodeRaw", (wchar_t**)&a->ns2__ECCreditReply::verificationCodeRaw, "xsd:string"))
				{	soap_flag_verificationCodeRaw1--;
					continue;
				}
			if (soap_flag_correctedAccountNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:correctedAccountNumber", (wchar_t**)&a->ns2__ECCreditReply::correctedAccountNumber, "xsd:string"))
				{	soap_flag_correctedAccountNumber1--;
					continue;
				}
			if (soap_flag_correctedRoutingNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:correctedRoutingNumber", (wchar_t**)&a->ns2__ECCreditReply::correctedRoutingNumber, "xsd:string"))
				{	soap_flag_correctedRoutingNumber1--;
					continue;
				}
			if (soap_flag_ownerMerchantID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ownerMerchantID", (wchar_t**)&a->ns2__ECCreditReply::ownerMerchantID, "xsd:string"))
				{	soap_flag_ownerMerchantID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__ECCreditReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ECCreditReply, SOAP_TYPE_ns2__ECCreditReply, sizeof(ns2__ECCreditReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ECCreditReply * SOAP_FMAC2 soap_instantiate_ns2__ECCreditReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ECCreditReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ECCreditReply *p;
	size_t k = sizeof(ns2__ECCreditReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ECCreditReply);
		if (p)
			((ns2__ECCreditReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ECCreditReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ECCreditReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ECCreditReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ECCreditReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ECCreditReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:ECCreditReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ECCreditReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ECCreditReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ECCreditReply * SOAP_FMAC4 soap_get_ns2__ECCreditReply(struct soap *soap, ns2__ECCreditReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ECCreditReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ECDebitReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ECDebitReply::reasonCode = NULL;
	this->ns2__ECDebitReply::settlementMethod = NULL;
	this->ns2__ECDebitReply::requestDateTime = NULL;
	this->ns2__ECDebitReply::amount = NULL;
	this->ns2__ECDebitReply::verificationLevel = NULL;
	this->ns2__ECDebitReply::processorTransactionID = NULL;
	this->ns2__ECDebitReply::reconciliationID = NULL;
	this->ns2__ECDebitReply::processorResponse = NULL;
	this->ns2__ECDebitReply::avsCode = NULL;
	this->ns2__ECDebitReply::avsCodeRaw = NULL;
	this->ns2__ECDebitReply::verificationCode = NULL;
	this->ns2__ECDebitReply::verificationCodeRaw = NULL;
	this->ns2__ECDebitReply::correctedAccountNumber = NULL;
	this->ns2__ECDebitReply::correctedRoutingNumber = NULL;
	this->ns2__ECDebitReply::ownerMerchantID = NULL;
	/* transient soap skipped */
}

void ns2__ECDebitReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__ECDebitReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECDebitReply::settlementMethod);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__ECDebitReply::requestDateTime);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__ECDebitReply::amount);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__ECDebitReply::verificationLevel);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECDebitReply::processorTransactionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECDebitReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECDebitReply::processorResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECDebitReply::avsCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECDebitReply::avsCodeRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECDebitReply::verificationCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECDebitReply::verificationCodeRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECDebitReply::correctedAccountNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECDebitReply::correctedRoutingNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECDebitReply::ownerMerchantID);
#endif
}

int ns2__ECDebitReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ECDebitReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ECDebitReply(struct soap *soap, const char *tag, int id, const ns2__ECDebitReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ECDebitReply), type))
		return soap->error;
	if (!a->ns2__ECDebitReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__ECDebitReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:settlementMethod", -1, (wchar_t*const*)&a->ns2__ECDebitReply::settlementMethod, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__ECDebitReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__ECDebitReply::amount, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:verificationLevel", -1, &a->ns2__ECDebitReply::verificationLevel, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorTransactionID", -1, (wchar_t*const*)&a->ns2__ECDebitReply::processorTransactionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__ECDebitReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__ECDebitReply::processorResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:avsCode", -1, (wchar_t*const*)&a->ns2__ECDebitReply::avsCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:avsCodeRaw", -1, (wchar_t*const*)&a->ns2__ECDebitReply::avsCodeRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:verificationCode", -1, (wchar_t*const*)&a->ns2__ECDebitReply::verificationCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:verificationCodeRaw", -1, (wchar_t*const*)&a->ns2__ECDebitReply::verificationCodeRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:correctedAccountNumber", -1, (wchar_t*const*)&a->ns2__ECDebitReply::correctedAccountNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:correctedRoutingNumber", -1, (wchar_t*const*)&a->ns2__ECDebitReply::correctedRoutingNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ownerMerchantID", -1, (wchar_t*const*)&a->ns2__ECDebitReply::ownerMerchantID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ECDebitReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ECDebitReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ECDebitReply * SOAP_FMAC4 soap_in_ns2__ECDebitReply(struct soap *soap, const char *tag, ns2__ECDebitReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ECDebitReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ECDebitReply, sizeof(ns2__ECDebitReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ECDebitReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ECDebitReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_settlementMethod1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_verificationLevel1 = 1;
	size_t soap_flag_processorTransactionID1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_avsCode1 = 1;
	size_t soap_flag_avsCodeRaw1 = 1;
	size_t soap_flag_verificationCode1 = 1;
	size_t soap_flag_verificationCodeRaw1 = 1;
	size_t soap_flag_correctedAccountNumber1 = 1;
	size_t soap_flag_correctedRoutingNumber1 = 1;
	size_t soap_flag_ownerMerchantID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__ECDebitReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_settlementMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:settlementMethod", (wchar_t**)&a->ns2__ECDebitReply::settlementMethod, "xsd:string"))
				{	soap_flag_settlementMethod1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__ECDebitReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__ECDebitReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_verificationLevel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:verificationLevel", &a->ns2__ECDebitReply::verificationLevel, "xsd:integer"))
				{	soap_flag_verificationLevel1--;
					continue;
				}
			if (soap_flag_processorTransactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorTransactionID", (wchar_t**)&a->ns2__ECDebitReply::processorTransactionID, "xsd:string"))
				{	soap_flag_processorTransactionID1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__ECDebitReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__ECDebitReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_avsCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:avsCode", (wchar_t**)&a->ns2__ECDebitReply::avsCode, "xsd:string"))
				{	soap_flag_avsCode1--;
					continue;
				}
			if (soap_flag_avsCodeRaw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:avsCodeRaw", (wchar_t**)&a->ns2__ECDebitReply::avsCodeRaw, "xsd:string"))
				{	soap_flag_avsCodeRaw1--;
					continue;
				}
			if (soap_flag_verificationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:verificationCode", (wchar_t**)&a->ns2__ECDebitReply::verificationCode, "xsd:string"))
				{	soap_flag_verificationCode1--;
					continue;
				}
			if (soap_flag_verificationCodeRaw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:verificationCodeRaw", (wchar_t**)&a->ns2__ECDebitReply::verificationCodeRaw, "xsd:string"))
				{	soap_flag_verificationCodeRaw1--;
					continue;
				}
			if (soap_flag_correctedAccountNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:correctedAccountNumber", (wchar_t**)&a->ns2__ECDebitReply::correctedAccountNumber, "xsd:string"))
				{	soap_flag_correctedAccountNumber1--;
					continue;
				}
			if (soap_flag_correctedRoutingNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:correctedRoutingNumber", (wchar_t**)&a->ns2__ECDebitReply::correctedRoutingNumber, "xsd:string"))
				{	soap_flag_correctedRoutingNumber1--;
					continue;
				}
			if (soap_flag_ownerMerchantID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ownerMerchantID", (wchar_t**)&a->ns2__ECDebitReply::ownerMerchantID, "xsd:string"))
				{	soap_flag_ownerMerchantID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__ECDebitReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ECDebitReply, SOAP_TYPE_ns2__ECDebitReply, sizeof(ns2__ECDebitReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ECDebitReply * SOAP_FMAC2 soap_instantiate_ns2__ECDebitReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ECDebitReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ECDebitReply *p;
	size_t k = sizeof(ns2__ECDebitReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ECDebitReply);
		if (p)
			((ns2__ECDebitReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ECDebitReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ECDebitReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ECDebitReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ECDebitReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ECDebitReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:ECDebitReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ECDebitReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ECDebitReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ECDebitReply * SOAP_FMAC4 soap_get_ns2__ECDebitReply(struct soap *soap, ns2__ECDebitReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ECDebitReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CCAutoAuthReversalReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CCAutoAuthReversalReply::reasonCode = NULL;
	this->ns2__CCAutoAuthReversalReply::processorResponse = NULL;
	this->ns2__CCAutoAuthReversalReply::result = NULL;
	/* transient soap skipped */
}

void ns2__CCAutoAuthReversalReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__CCAutoAuthReversalReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAutoAuthReversalReply::processorResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAutoAuthReversalReply::result);
#endif
}

int ns2__CCAutoAuthReversalReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CCAutoAuthReversalReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CCAutoAuthReversalReply(struct soap *soap, const char *tag, int id, const ns2__CCAutoAuthReversalReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CCAutoAuthReversalReply), type))
		return soap->error;
	if (!a->ns2__CCAutoAuthReversalReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__CCAutoAuthReversalReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__CCAutoAuthReversalReply::processorResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:result", -1, (wchar_t*const*)&a->ns2__CCAutoAuthReversalReply::result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CCAutoAuthReversalReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CCAutoAuthReversalReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CCAutoAuthReversalReply * SOAP_FMAC4 soap_in_ns2__CCAutoAuthReversalReply(struct soap *soap, const char *tag, ns2__CCAutoAuthReversalReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CCAutoAuthReversalReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CCAutoAuthReversalReply, sizeof(ns2__CCAutoAuthReversalReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CCAutoAuthReversalReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CCAutoAuthReversalReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__CCAutoAuthReversalReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__CCAutoAuthReversalReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_result1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:result", (wchar_t**)&a->ns2__CCAutoAuthReversalReply::result, "xsd:string"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__CCAutoAuthReversalReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CCAutoAuthReversalReply, SOAP_TYPE_ns2__CCAutoAuthReversalReply, sizeof(ns2__CCAutoAuthReversalReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CCAutoAuthReversalReply * SOAP_FMAC2 soap_instantiate_ns2__CCAutoAuthReversalReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CCAutoAuthReversalReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CCAutoAuthReversalReply *p;
	size_t k = sizeof(ns2__CCAutoAuthReversalReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CCAutoAuthReversalReply);
		if (p)
			((ns2__CCAutoAuthReversalReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CCAutoAuthReversalReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CCAutoAuthReversalReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CCAutoAuthReversalReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CCAutoAuthReversalReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CCAutoAuthReversalReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CCAutoAuthReversalReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CCAutoAuthReversalReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CCAutoAuthReversalReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CCAutoAuthReversalReply * SOAP_FMAC4 soap_get_ns2__CCAutoAuthReversalReply(struct soap *soap, ns2__CCAutoAuthReversalReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CCAutoAuthReversalReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CCAuthReversalReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CCAuthReversalReply::reasonCode = NULL;
	this->ns2__CCAuthReversalReply::amount = NULL;
	this->ns2__CCAuthReversalReply::authorizationCode = NULL;
	this->ns2__CCAuthReversalReply::processorResponse = NULL;
	this->ns2__CCAuthReversalReply::requestDateTime = NULL;
	this->ns2__CCAuthReversalReply::forwardCode = NULL;
	this->ns2__CCAuthReversalReply::reconciliationID = NULL;
	this->ns2__CCAuthReversalReply::processorTransactionID = NULL;
	this->ns2__CCAuthReversalReply::paymentCardService = NULL;
	this->ns2__CCAuthReversalReply::paymentCardServiceResult = NULL;
	/* transient soap skipped */
}

void ns2__CCAuthReversalReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__CCAuthReversalReply::reasonCode);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__CCAuthReversalReply::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReversalReply::authorizationCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReversalReply::processorResponse);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__CCAuthReversalReply::requestDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReversalReply::forwardCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReversalReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReversalReply::processorTransactionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReversalReply::paymentCardService);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReversalReply::paymentCardServiceResult);
#endif
}

int ns2__CCAuthReversalReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CCAuthReversalReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CCAuthReversalReply(struct soap *soap, const char *tag, int id, const ns2__CCAuthReversalReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CCAuthReversalReply), type))
		return soap->error;
	if (!a->ns2__CCAuthReversalReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__CCAuthReversalReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__CCAuthReversalReply::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authorizationCode", -1, (wchar_t*const*)&a->ns2__CCAuthReversalReply::authorizationCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__CCAuthReversalReply::processorResponse, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__CCAuthReversalReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:forwardCode", -1, (wchar_t*const*)&a->ns2__CCAuthReversalReply::forwardCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__CCAuthReversalReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorTransactionID", -1, (wchar_t*const*)&a->ns2__CCAuthReversalReply::processorTransactionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentCardService", -1, (wchar_t*const*)&a->ns2__CCAuthReversalReply::paymentCardService, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentCardServiceResult", -1, (wchar_t*const*)&a->ns2__CCAuthReversalReply::paymentCardServiceResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CCAuthReversalReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CCAuthReversalReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CCAuthReversalReply * SOAP_FMAC4 soap_in_ns2__CCAuthReversalReply(struct soap *soap, const char *tag, ns2__CCAuthReversalReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CCAuthReversalReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CCAuthReversalReply, sizeof(ns2__CCAuthReversalReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CCAuthReversalReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CCAuthReversalReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_authorizationCode1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_forwardCode1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_processorTransactionID1 = 1;
	size_t soap_flag_paymentCardService1 = 1;
	size_t soap_flag_paymentCardServiceResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__CCAuthReversalReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__CCAuthReversalReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_authorizationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authorizationCode", (wchar_t**)&a->ns2__CCAuthReversalReply::authorizationCode, "xsd:string"))
				{	soap_flag_authorizationCode1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__CCAuthReversalReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__CCAuthReversalReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_forwardCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:forwardCode", (wchar_t**)&a->ns2__CCAuthReversalReply::forwardCode, "xsd:string"))
				{	soap_flag_forwardCode1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__CCAuthReversalReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_processorTransactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorTransactionID", (wchar_t**)&a->ns2__CCAuthReversalReply::processorTransactionID, "xsd:string"))
				{	soap_flag_processorTransactionID1--;
					continue;
				}
			if (soap_flag_paymentCardService1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentCardService", (wchar_t**)&a->ns2__CCAuthReversalReply::paymentCardService, "xsd:string"))
				{	soap_flag_paymentCardService1--;
					continue;
				}
			if (soap_flag_paymentCardServiceResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentCardServiceResult", (wchar_t**)&a->ns2__CCAuthReversalReply::paymentCardServiceResult, "xsd:string"))
				{	soap_flag_paymentCardServiceResult1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__CCAuthReversalReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CCAuthReversalReply, SOAP_TYPE_ns2__CCAuthReversalReply, sizeof(ns2__CCAuthReversalReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CCAuthReversalReply * SOAP_FMAC2 soap_instantiate_ns2__CCAuthReversalReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CCAuthReversalReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CCAuthReversalReply *p;
	size_t k = sizeof(ns2__CCAuthReversalReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CCAuthReversalReply);
		if (p)
			((ns2__CCAuthReversalReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CCAuthReversalReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CCAuthReversalReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CCAuthReversalReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CCAuthReversalReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CCAuthReversalReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CCAuthReversalReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CCAuthReversalReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CCAuthReversalReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CCAuthReversalReply * SOAP_FMAC4 soap_get_ns2__CCAuthReversalReply(struct soap *soap, ns2__CCAuthReversalReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CCAuthReversalReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PinDebitReversalReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PinDebitReversalReply::reasonCode = NULL;
	this->ns2__PinDebitReversalReply::processorResponse = NULL;
	this->ns2__PinDebitReversalReply::reconciliationID = NULL;
	this->ns2__PinDebitReversalReply::amount = NULL;
	this->ns2__PinDebitReversalReply::dateTime = NULL;
	/* transient soap skipped */
}

void ns2__PinDebitReversalReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PinDebitReversalReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitReversalReply::processorResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitReversalReply::reconciliationID);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__PinDebitReversalReply::amount);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__PinDebitReversalReply::dateTime);
#endif
}

int ns2__PinDebitReversalReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PinDebitReversalReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PinDebitReversalReply(struct soap *soap, const char *tag, int id, const ns2__PinDebitReversalReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PinDebitReversalReply), type))
		return soap->error;
	if (!a->ns2__PinDebitReversalReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PinDebitReversalReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__PinDebitReversalReply::processorResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__PinDebitReversalReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__PinDebitReversalReply::amount, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:dateTime", -1, &a->ns2__PinDebitReversalReply::dateTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PinDebitReversalReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PinDebitReversalReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PinDebitReversalReply * SOAP_FMAC4 soap_in_ns2__PinDebitReversalReply(struct soap *soap, const char *tag, ns2__PinDebitReversalReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PinDebitReversalReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PinDebitReversalReply, sizeof(ns2__PinDebitReversalReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PinDebitReversalReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PinDebitReversalReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_dateTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PinDebitReversalReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__PinDebitReversalReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__PinDebitReversalReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__PinDebitReversalReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_dateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:dateTime", &a->ns2__PinDebitReversalReply::dateTime, "ns2:dateTime"))
				{	soap_flag_dateTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PinDebitReversalReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PinDebitReversalReply, SOAP_TYPE_ns2__PinDebitReversalReply, sizeof(ns2__PinDebitReversalReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PinDebitReversalReply * SOAP_FMAC2 soap_instantiate_ns2__PinDebitReversalReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PinDebitReversalReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PinDebitReversalReply *p;
	size_t k = sizeof(ns2__PinDebitReversalReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PinDebitReversalReply);
		if (p)
			((ns2__PinDebitReversalReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PinDebitReversalReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PinDebitReversalReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PinDebitReversalReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PinDebitReversalReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PinDebitReversalReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PinDebitReversalReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PinDebitReversalReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PinDebitReversalReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PinDebitReversalReply * SOAP_FMAC4 soap_get_ns2__PinDebitReversalReply(struct soap *soap, ns2__PinDebitReversalReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PinDebitReversalReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PinDebitCreditReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PinDebitCreditReply::reasonCode = NULL;
	this->ns2__PinDebitCreditReply::processorResponse = NULL;
	this->ns2__PinDebitCreditReply::authorizationCode = NULL;
	this->ns2__PinDebitCreditReply::reconciliationID = NULL;
	this->ns2__PinDebitCreditReply::networkCode = NULL;
	this->ns2__PinDebitCreditReply::transactionID = NULL;
	this->ns2__PinDebitCreditReply::amount = NULL;
	this->ns2__PinDebitCreditReply::dateTime = NULL;
	/* transient soap skipped */
}

void ns2__PinDebitCreditReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PinDebitCreditReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitCreditReply::processorResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitCreditReply::authorizationCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitCreditReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitCreditReply::networkCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitCreditReply::transactionID);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__PinDebitCreditReply::amount);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__PinDebitCreditReply::dateTime);
#endif
}

int ns2__PinDebitCreditReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PinDebitCreditReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PinDebitCreditReply(struct soap *soap, const char *tag, int id, const ns2__PinDebitCreditReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PinDebitCreditReply), type))
		return soap->error;
	if (!a->ns2__PinDebitCreditReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PinDebitCreditReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__PinDebitCreditReply::processorResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authorizationCode", -1, (wchar_t*const*)&a->ns2__PinDebitCreditReply::authorizationCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__PinDebitCreditReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:networkCode", -1, (wchar_t*const*)&a->ns2__PinDebitCreditReply::networkCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionID", -1, (wchar_t*const*)&a->ns2__PinDebitCreditReply::transactionID, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__PinDebitCreditReply::amount, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:dateTime", -1, &a->ns2__PinDebitCreditReply::dateTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PinDebitCreditReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PinDebitCreditReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PinDebitCreditReply * SOAP_FMAC4 soap_in_ns2__PinDebitCreditReply(struct soap *soap, const char *tag, ns2__PinDebitCreditReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PinDebitCreditReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PinDebitCreditReply, sizeof(ns2__PinDebitCreditReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PinDebitCreditReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PinDebitCreditReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_authorizationCode1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_networkCode1 = 1;
	size_t soap_flag_transactionID1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_dateTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PinDebitCreditReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__PinDebitCreditReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_authorizationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authorizationCode", (wchar_t**)&a->ns2__PinDebitCreditReply::authorizationCode, "xsd:string"))
				{	soap_flag_authorizationCode1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__PinDebitCreditReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_networkCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:networkCode", (wchar_t**)&a->ns2__PinDebitCreditReply::networkCode, "xsd:string"))
				{	soap_flag_networkCode1--;
					continue;
				}
			if (soap_flag_transactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionID", (wchar_t**)&a->ns2__PinDebitCreditReply::transactionID, "xsd:string"))
				{	soap_flag_transactionID1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__PinDebitCreditReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_dateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:dateTime", &a->ns2__PinDebitCreditReply::dateTime, "ns2:dateTime"))
				{	soap_flag_dateTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PinDebitCreditReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PinDebitCreditReply, SOAP_TYPE_ns2__PinDebitCreditReply, sizeof(ns2__PinDebitCreditReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PinDebitCreditReply * SOAP_FMAC2 soap_instantiate_ns2__PinDebitCreditReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PinDebitCreditReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PinDebitCreditReply *p;
	size_t k = sizeof(ns2__PinDebitCreditReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PinDebitCreditReply);
		if (p)
			((ns2__PinDebitCreditReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PinDebitCreditReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PinDebitCreditReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PinDebitCreditReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PinDebitCreditReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PinDebitCreditReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PinDebitCreditReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PinDebitCreditReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PinDebitCreditReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PinDebitCreditReply * SOAP_FMAC4 soap_get_ns2__PinDebitCreditReply(struct soap *soap, ns2__PinDebitCreditReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PinDebitCreditReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PinDebitPurchaseReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PinDebitPurchaseReply::reasonCode = NULL;
	this->ns2__PinDebitPurchaseReply::processorResponse = NULL;
	this->ns2__PinDebitPurchaseReply::authorizationCode = NULL;
	this->ns2__PinDebitPurchaseReply::reconciliationID = NULL;
	this->ns2__PinDebitPurchaseReply::networkCode = NULL;
	this->ns2__PinDebitPurchaseReply::transactionID = NULL;
	this->ns2__PinDebitPurchaseReply::requestAmount = NULL;
	this->ns2__PinDebitPurchaseReply::requestCurrency = NULL;
	this->ns2__PinDebitPurchaseReply::amount = NULL;
	this->ns2__PinDebitPurchaseReply::dateTime = NULL;
	this->ns2__PinDebitPurchaseReply::accountType = NULL;
	this->ns2__PinDebitPurchaseReply::amountType = NULL;
	this->ns2__PinDebitPurchaseReply::accountBalance = NULL;
	this->ns2__PinDebitPurchaseReply::accountBalanceCurrency = NULL;
	this->ns2__PinDebitPurchaseReply::accountBalanceSign = NULL;
	/* transient soap skipped */
}

void ns2__PinDebitPurchaseReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__PinDebitPurchaseReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitPurchaseReply::processorResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitPurchaseReply::authorizationCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitPurchaseReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitPurchaseReply::networkCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitPurchaseReply::transactionID);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__PinDebitPurchaseReply::requestAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitPurchaseReply::requestCurrency);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__PinDebitPurchaseReply::amount);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__PinDebitPurchaseReply::dateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitPurchaseReply::accountType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitPurchaseReply::amountType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitPurchaseReply::accountBalance);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitPurchaseReply::accountBalanceCurrency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitPurchaseReply::accountBalanceSign);
#endif
}

int ns2__PinDebitPurchaseReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PinDebitPurchaseReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PinDebitPurchaseReply(struct soap *soap, const char *tag, int id, const ns2__PinDebitPurchaseReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PinDebitPurchaseReply), type))
		return soap->error;
	if (!a->ns2__PinDebitPurchaseReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__PinDebitPurchaseReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__PinDebitPurchaseReply::processorResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authorizationCode", -1, (wchar_t*const*)&a->ns2__PinDebitPurchaseReply::authorizationCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__PinDebitPurchaseReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:networkCode", -1, (wchar_t*const*)&a->ns2__PinDebitPurchaseReply::networkCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionID", -1, (wchar_t*const*)&a->ns2__PinDebitPurchaseReply::transactionID, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:requestAmount", -1, &a->ns2__PinDebitPurchaseReply::requestAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:requestCurrency", -1, (wchar_t*const*)&a->ns2__PinDebitPurchaseReply::requestCurrency, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__PinDebitPurchaseReply::amount, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:dateTime", -1, &a->ns2__PinDebitPurchaseReply::dateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:accountType", -1, (wchar_t*const*)&a->ns2__PinDebitPurchaseReply::accountType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:amountType", -1, (wchar_t*const*)&a->ns2__PinDebitPurchaseReply::amountType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:accountBalance", -1, (wchar_t*const*)&a->ns2__PinDebitPurchaseReply::accountBalance, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:accountBalanceCurrency", -1, (wchar_t*const*)&a->ns2__PinDebitPurchaseReply::accountBalanceCurrency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:accountBalanceSign", -1, (wchar_t*const*)&a->ns2__PinDebitPurchaseReply::accountBalanceSign, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PinDebitPurchaseReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PinDebitPurchaseReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PinDebitPurchaseReply * SOAP_FMAC4 soap_in_ns2__PinDebitPurchaseReply(struct soap *soap, const char *tag, ns2__PinDebitPurchaseReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PinDebitPurchaseReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PinDebitPurchaseReply, sizeof(ns2__PinDebitPurchaseReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PinDebitPurchaseReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PinDebitPurchaseReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_authorizationCode1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_networkCode1 = 1;
	size_t soap_flag_transactionID1 = 1;
	size_t soap_flag_requestAmount1 = 1;
	size_t soap_flag_requestCurrency1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_dateTime1 = 1;
	size_t soap_flag_accountType1 = 1;
	size_t soap_flag_amountType1 = 1;
	size_t soap_flag_accountBalance1 = 1;
	size_t soap_flag_accountBalanceCurrency1 = 1;
	size_t soap_flag_accountBalanceSign1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__PinDebitPurchaseReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__PinDebitPurchaseReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_authorizationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authorizationCode", (wchar_t**)&a->ns2__PinDebitPurchaseReply::authorizationCode, "xsd:string"))
				{	soap_flag_authorizationCode1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__PinDebitPurchaseReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_networkCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:networkCode", (wchar_t**)&a->ns2__PinDebitPurchaseReply::networkCode, "xsd:string"))
				{	soap_flag_networkCode1--;
					continue;
				}
			if (soap_flag_transactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionID", (wchar_t**)&a->ns2__PinDebitPurchaseReply::transactionID, "xsd:string"))
				{	soap_flag_transactionID1--;
					continue;
				}
			if (soap_flag_requestAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:requestAmount", &a->ns2__PinDebitPurchaseReply::requestAmount, "ns2:amount"))
				{	soap_flag_requestAmount1--;
					continue;
				}
			if (soap_flag_requestCurrency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:requestCurrency", (wchar_t**)&a->ns2__PinDebitPurchaseReply::requestCurrency, "xsd:string"))
				{	soap_flag_requestCurrency1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__PinDebitPurchaseReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_dateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:dateTime", &a->ns2__PinDebitPurchaseReply::dateTime, "ns2:dateTime"))
				{	soap_flag_dateTime1--;
					continue;
				}
			if (soap_flag_accountType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:accountType", (wchar_t**)&a->ns2__PinDebitPurchaseReply::accountType, "xsd:string"))
				{	soap_flag_accountType1--;
					continue;
				}
			if (soap_flag_amountType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:amountType", (wchar_t**)&a->ns2__PinDebitPurchaseReply::amountType, "xsd:string"))
				{	soap_flag_amountType1--;
					continue;
				}
			if (soap_flag_accountBalance1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:accountBalance", (wchar_t**)&a->ns2__PinDebitPurchaseReply::accountBalance, "xsd:string"))
				{	soap_flag_accountBalance1--;
					continue;
				}
			if (soap_flag_accountBalanceCurrency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:accountBalanceCurrency", (wchar_t**)&a->ns2__PinDebitPurchaseReply::accountBalanceCurrency, "xsd:string"))
				{	soap_flag_accountBalanceCurrency1--;
					continue;
				}
			if (soap_flag_accountBalanceSign1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:accountBalanceSign", (wchar_t**)&a->ns2__PinDebitPurchaseReply::accountBalanceSign, "xsd:string"))
				{	soap_flag_accountBalanceSign1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__PinDebitPurchaseReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PinDebitPurchaseReply, SOAP_TYPE_ns2__PinDebitPurchaseReply, sizeof(ns2__PinDebitPurchaseReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PinDebitPurchaseReply * SOAP_FMAC2 soap_instantiate_ns2__PinDebitPurchaseReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PinDebitPurchaseReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PinDebitPurchaseReply *p;
	size_t k = sizeof(ns2__PinDebitPurchaseReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PinDebitPurchaseReply);
		if (p)
			((ns2__PinDebitPurchaseReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PinDebitPurchaseReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PinDebitPurchaseReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PinDebitPurchaseReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PinDebitPurchaseReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PinDebitPurchaseReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PinDebitPurchaseReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PinDebitPurchaseReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PinDebitPurchaseReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PinDebitPurchaseReply * SOAP_FMAC4 soap_get_ns2__PinDebitPurchaseReply(struct soap *soap, ns2__PinDebitPurchaseReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PinDebitPurchaseReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CCCreditReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CCCreditReply::reasonCode = NULL;
	this->ns2__CCCreditReply::requestDateTime = NULL;
	this->ns2__CCCreditReply::amount = NULL;
	this->ns2__CCCreditReply::reconciliationID = NULL;
	this->ns2__CCCreditReply::purchasingLevel3Enabled = NULL;
	this->ns2__CCCreditReply::enhancedDataEnabled = NULL;
	this->ns2__CCCreditReply::authorizationXID = NULL;
	this->ns2__CCCreditReply::forwardCode = NULL;
	this->ns2__CCCreditReply::ownerMerchantID = NULL;
	/* transient soap skipped */
}

void ns2__CCCreditReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__CCCreditReply::reasonCode);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__CCCreditReply::requestDateTime);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__CCCreditReply::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCreditReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCreditReply::purchasingLevel3Enabled);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCreditReply::enhancedDataEnabled);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCreditReply::authorizationXID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCreditReply::forwardCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCreditReply::ownerMerchantID);
#endif
}

int ns2__CCCreditReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CCCreditReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CCCreditReply(struct soap *soap, const char *tag, int id, const ns2__CCCreditReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CCCreditReply), type))
		return soap->error;
	if (!a->ns2__CCCreditReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__CCCreditReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__CCCreditReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__CCCreditReply::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__CCCreditReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:purchasingLevel3Enabled", -1, (wchar_t*const*)&a->ns2__CCCreditReply::purchasingLevel3Enabled, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:enhancedDataEnabled", -1, (wchar_t*const*)&a->ns2__CCCreditReply::enhancedDataEnabled, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authorizationXID", -1, (wchar_t*const*)&a->ns2__CCCreditReply::authorizationXID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:forwardCode", -1, (wchar_t*const*)&a->ns2__CCCreditReply::forwardCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ownerMerchantID", -1, (wchar_t*const*)&a->ns2__CCCreditReply::ownerMerchantID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CCCreditReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CCCreditReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CCCreditReply * SOAP_FMAC4 soap_in_ns2__CCCreditReply(struct soap *soap, const char *tag, ns2__CCCreditReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CCCreditReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CCCreditReply, sizeof(ns2__CCCreditReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CCCreditReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CCCreditReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_purchasingLevel3Enabled1 = 1;
	size_t soap_flag_enhancedDataEnabled1 = 1;
	size_t soap_flag_authorizationXID1 = 1;
	size_t soap_flag_forwardCode1 = 1;
	size_t soap_flag_ownerMerchantID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__CCCreditReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__CCCreditReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__CCCreditReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__CCCreditReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_purchasingLevel3Enabled1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:purchasingLevel3Enabled", (wchar_t**)&a->ns2__CCCreditReply::purchasingLevel3Enabled, "xsd:string"))
				{	soap_flag_purchasingLevel3Enabled1--;
					continue;
				}
			if (soap_flag_enhancedDataEnabled1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:enhancedDataEnabled", (wchar_t**)&a->ns2__CCCreditReply::enhancedDataEnabled, "xsd:string"))
				{	soap_flag_enhancedDataEnabled1--;
					continue;
				}
			if (soap_flag_authorizationXID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authorizationXID", (wchar_t**)&a->ns2__CCCreditReply::authorizationXID, "xsd:string"))
				{	soap_flag_authorizationXID1--;
					continue;
				}
			if (soap_flag_forwardCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:forwardCode", (wchar_t**)&a->ns2__CCCreditReply::forwardCode, "xsd:string"))
				{	soap_flag_forwardCode1--;
					continue;
				}
			if (soap_flag_ownerMerchantID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ownerMerchantID", (wchar_t**)&a->ns2__CCCreditReply::ownerMerchantID, "xsd:string"))
				{	soap_flag_ownerMerchantID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__CCCreditReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CCCreditReply, SOAP_TYPE_ns2__CCCreditReply, sizeof(ns2__CCCreditReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CCCreditReply * SOAP_FMAC2 soap_instantiate_ns2__CCCreditReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CCCreditReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CCCreditReply *p;
	size_t k = sizeof(ns2__CCCreditReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CCCreditReply);
		if (p)
			((ns2__CCCreditReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CCCreditReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CCCreditReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CCCreditReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CCCreditReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CCCreditReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CCCreditReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CCCreditReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CCCreditReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CCCreditReply * SOAP_FMAC4 soap_get_ns2__CCCreditReply(struct soap *soap, ns2__CCCreditReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CCCreditReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ServiceFeeCalculateReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ServiceFeeCalculateReply::reasonCode = NULL;
	this->ns2__ServiceFeeCalculateReply::amount = NULL;
	this->ns2__ServiceFeeCalculateReply::requestDateTime = NULL;
	/* transient soap skipped */
}

void ns2__ServiceFeeCalculateReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__ServiceFeeCalculateReply::reasonCode);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__ServiceFeeCalculateReply::amount);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__ServiceFeeCalculateReply::requestDateTime);
#endif
}

int ns2__ServiceFeeCalculateReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ServiceFeeCalculateReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ServiceFeeCalculateReply(struct soap *soap, const char *tag, int id, const ns2__ServiceFeeCalculateReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ServiceFeeCalculateReply), type))
		return soap->error;
	if (!a->ns2__ServiceFeeCalculateReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__ServiceFeeCalculateReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__ServiceFeeCalculateReply::amount, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__ServiceFeeCalculateReply::requestDateTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ServiceFeeCalculateReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ServiceFeeCalculateReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ServiceFeeCalculateReply * SOAP_FMAC4 soap_in_ns2__ServiceFeeCalculateReply(struct soap *soap, const char *tag, ns2__ServiceFeeCalculateReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ServiceFeeCalculateReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ServiceFeeCalculateReply, sizeof(ns2__ServiceFeeCalculateReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ServiceFeeCalculateReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ServiceFeeCalculateReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__ServiceFeeCalculateReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__ServiceFeeCalculateReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__ServiceFeeCalculateReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__ServiceFeeCalculateReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ServiceFeeCalculateReply, SOAP_TYPE_ns2__ServiceFeeCalculateReply, sizeof(ns2__ServiceFeeCalculateReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ServiceFeeCalculateReply * SOAP_FMAC2 soap_instantiate_ns2__ServiceFeeCalculateReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ServiceFeeCalculateReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ServiceFeeCalculateReply *p;
	size_t k = sizeof(ns2__ServiceFeeCalculateReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ServiceFeeCalculateReply);
		if (p)
			((ns2__ServiceFeeCalculateReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ServiceFeeCalculateReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ServiceFeeCalculateReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ServiceFeeCalculateReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ServiceFeeCalculateReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ServiceFeeCalculateReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:ServiceFeeCalculateReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ServiceFeeCalculateReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ServiceFeeCalculateReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ServiceFeeCalculateReply * SOAP_FMAC4 soap_get_ns2__ServiceFeeCalculateReply(struct soap *soap, ns2__ServiceFeeCalculateReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ServiceFeeCalculateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CCCaptureReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CCCaptureReply::reasonCode = NULL;
	this->ns2__CCCaptureReply::requestDateTime = NULL;
	this->ns2__CCCaptureReply::amount = NULL;
	this->ns2__CCCaptureReply::reconciliationID = NULL;
	this->ns2__CCCaptureReply::fundingTotals = NULL;
	this->ns2__CCCaptureReply::fxQuoteID = NULL;
	this->ns2__CCCaptureReply::fxQuoteRate = NULL;
	this->ns2__CCCaptureReply::fxQuoteType = NULL;
	this->ns2__CCCaptureReply::fxQuoteExpirationDateTime = NULL;
	this->ns2__CCCaptureReply::purchasingLevel3Enabled = NULL;
	this->ns2__CCCaptureReply::enhancedDataEnabled = NULL;
	/* transient soap skipped */
}

void ns2__CCCaptureReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__CCCaptureReply::reasonCode);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__CCCaptureReply::requestDateTime);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__CCCaptureReply::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureReply::reconciliationID);
	soap_serialize_PointerTons2__FundingTotals(soap, &this->ns2__CCCaptureReply::fundingTotals);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureReply::fxQuoteID);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__CCCaptureReply::fxQuoteRate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureReply::fxQuoteType);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__CCCaptureReply::fxQuoteExpirationDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureReply::purchasingLevel3Enabled);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureReply::enhancedDataEnabled);
#endif
}

int ns2__CCCaptureReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CCCaptureReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CCCaptureReply(struct soap *soap, const char *tag, int id, const ns2__CCCaptureReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CCCaptureReply), type))
		return soap->error;
	if (!a->ns2__CCCaptureReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__CCCaptureReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__CCCaptureReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__CCCaptureReply::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__CCCaptureReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_PointerTons2__FundingTotals(soap, "ns2:fundingTotals", -1, &a->ns2__CCCaptureReply::fundingTotals, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:fxQuoteID", -1, (wchar_t*const*)&a->ns2__CCCaptureReply::fxQuoteID, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:fxQuoteRate", -1, &a->ns2__CCCaptureReply::fxQuoteRate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:fxQuoteType", -1, (wchar_t*const*)&a->ns2__CCCaptureReply::fxQuoteType, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:fxQuoteExpirationDateTime", -1, &a->ns2__CCCaptureReply::fxQuoteExpirationDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:purchasingLevel3Enabled", -1, (wchar_t*const*)&a->ns2__CCCaptureReply::purchasingLevel3Enabled, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:enhancedDataEnabled", -1, (wchar_t*const*)&a->ns2__CCCaptureReply::enhancedDataEnabled, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CCCaptureReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CCCaptureReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CCCaptureReply * SOAP_FMAC4 soap_in_ns2__CCCaptureReply(struct soap *soap, const char *tag, ns2__CCCaptureReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CCCaptureReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CCCaptureReply, sizeof(ns2__CCCaptureReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CCCaptureReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CCCaptureReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_fundingTotals1 = 1;
	size_t soap_flag_fxQuoteID1 = 1;
	size_t soap_flag_fxQuoteRate1 = 1;
	size_t soap_flag_fxQuoteType1 = 1;
	size_t soap_flag_fxQuoteExpirationDateTime1 = 1;
	size_t soap_flag_purchasingLevel3Enabled1 = 1;
	size_t soap_flag_enhancedDataEnabled1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__CCCaptureReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__CCCaptureReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__CCCaptureReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__CCCaptureReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_fundingTotals1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FundingTotals(soap, "ns2:fundingTotals", &a->ns2__CCCaptureReply::fundingTotals, "ns2:FundingTotals"))
				{	soap_flag_fundingTotals1--;
					continue;
				}
			if (soap_flag_fxQuoteID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:fxQuoteID", (wchar_t**)&a->ns2__CCCaptureReply::fxQuoteID, "xsd:string"))
				{	soap_flag_fxQuoteID1--;
					continue;
				}
			if (soap_flag_fxQuoteRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:fxQuoteRate", &a->ns2__CCCaptureReply::fxQuoteRate, "ns2:dateTime"))
				{	soap_flag_fxQuoteRate1--;
					continue;
				}
			if (soap_flag_fxQuoteType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:fxQuoteType", (wchar_t**)&a->ns2__CCCaptureReply::fxQuoteType, "xsd:string"))
				{	soap_flag_fxQuoteType1--;
					continue;
				}
			if (soap_flag_fxQuoteExpirationDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:fxQuoteExpirationDateTime", &a->ns2__CCCaptureReply::fxQuoteExpirationDateTime, "ns2:dateTime"))
				{	soap_flag_fxQuoteExpirationDateTime1--;
					continue;
				}
			if (soap_flag_purchasingLevel3Enabled1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:purchasingLevel3Enabled", (wchar_t**)&a->ns2__CCCaptureReply::purchasingLevel3Enabled, "xsd:string"))
				{	soap_flag_purchasingLevel3Enabled1--;
					continue;
				}
			if (soap_flag_enhancedDataEnabled1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:enhancedDataEnabled", (wchar_t**)&a->ns2__CCCaptureReply::enhancedDataEnabled, "xsd:string"))
				{	soap_flag_enhancedDataEnabled1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__CCCaptureReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CCCaptureReply, SOAP_TYPE_ns2__CCCaptureReply, sizeof(ns2__CCCaptureReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CCCaptureReply * SOAP_FMAC2 soap_instantiate_ns2__CCCaptureReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CCCaptureReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CCCaptureReply *p;
	size_t k = sizeof(ns2__CCCaptureReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CCCaptureReply);
		if (p)
			((ns2__CCCaptureReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CCCaptureReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CCCaptureReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CCCaptureReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CCCaptureReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CCCaptureReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CCCaptureReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CCCaptureReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CCCaptureReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CCCaptureReply * SOAP_FMAC4 soap_get_ns2__CCCaptureReply(struct soap *soap, ns2__CCCaptureReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CCCaptureReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CCIncrementalAuthReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CCIncrementalAuthReply::reasonCode = NULL;
	this->ns2__CCIncrementalAuthReply::amount = NULL;
	this->ns2__CCIncrementalAuthReply::authorizationCode = NULL;
	this->ns2__CCIncrementalAuthReply::processorResponse = NULL;
	this->ns2__CCIncrementalAuthReply::authorizedDateTime = NULL;
	this->ns2__CCIncrementalAuthReply::reconciliationID = NULL;
	this->ns2__CCIncrementalAuthReply::paymentNetworkTransactionID = NULL;
	this->ns2__CCIncrementalAuthReply::cardCategory = NULL;
	/* transient soap skipped */
}

void ns2__CCIncrementalAuthReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__CCIncrementalAuthReply::reasonCode);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__CCIncrementalAuthReply::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCIncrementalAuthReply::authorizationCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCIncrementalAuthReply::processorResponse);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__CCIncrementalAuthReply::authorizedDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCIncrementalAuthReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCIncrementalAuthReply::paymentNetworkTransactionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCIncrementalAuthReply::cardCategory);
#endif
}

int ns2__CCIncrementalAuthReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CCIncrementalAuthReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CCIncrementalAuthReply(struct soap *soap, const char *tag, int id, const ns2__CCIncrementalAuthReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CCIncrementalAuthReply), type))
		return soap->error;
	if (!a->ns2__CCIncrementalAuthReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__CCIncrementalAuthReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__CCIncrementalAuthReply::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authorizationCode", -1, (wchar_t*const*)&a->ns2__CCIncrementalAuthReply::authorizationCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__CCIncrementalAuthReply::processorResponse, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:authorizedDateTime", -1, &a->ns2__CCIncrementalAuthReply::authorizedDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__CCIncrementalAuthReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentNetworkTransactionID", -1, (wchar_t*const*)&a->ns2__CCIncrementalAuthReply::paymentNetworkTransactionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardCategory", -1, (wchar_t*const*)&a->ns2__CCIncrementalAuthReply::cardCategory, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CCIncrementalAuthReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CCIncrementalAuthReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CCIncrementalAuthReply * SOAP_FMAC4 soap_in_ns2__CCIncrementalAuthReply(struct soap *soap, const char *tag, ns2__CCIncrementalAuthReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CCIncrementalAuthReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CCIncrementalAuthReply, sizeof(ns2__CCIncrementalAuthReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CCIncrementalAuthReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CCIncrementalAuthReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_authorizationCode1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_authorizedDateTime1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_paymentNetworkTransactionID1 = 1;
	size_t soap_flag_cardCategory1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__CCIncrementalAuthReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__CCIncrementalAuthReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_authorizationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authorizationCode", (wchar_t**)&a->ns2__CCIncrementalAuthReply::authorizationCode, "xsd:string"))
				{	soap_flag_authorizationCode1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__CCIncrementalAuthReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_authorizedDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:authorizedDateTime", &a->ns2__CCIncrementalAuthReply::authorizedDateTime, "ns2:dateTime"))
				{	soap_flag_authorizedDateTime1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__CCIncrementalAuthReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_paymentNetworkTransactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentNetworkTransactionID", (wchar_t**)&a->ns2__CCIncrementalAuthReply::paymentNetworkTransactionID, "xsd:string"))
				{	soap_flag_paymentNetworkTransactionID1--;
					continue;
				}
			if (soap_flag_cardCategory1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardCategory", (wchar_t**)&a->ns2__CCIncrementalAuthReply::cardCategory, "xsd:string"))
				{	soap_flag_cardCategory1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__CCIncrementalAuthReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CCIncrementalAuthReply, SOAP_TYPE_ns2__CCIncrementalAuthReply, sizeof(ns2__CCIncrementalAuthReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CCIncrementalAuthReply * SOAP_FMAC2 soap_instantiate_ns2__CCIncrementalAuthReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CCIncrementalAuthReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CCIncrementalAuthReply *p;
	size_t k = sizeof(ns2__CCIncrementalAuthReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CCIncrementalAuthReply);
		if (p)
			((ns2__CCIncrementalAuthReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CCIncrementalAuthReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CCIncrementalAuthReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CCIncrementalAuthReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CCIncrementalAuthReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CCIncrementalAuthReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CCIncrementalAuthReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CCIncrementalAuthReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CCIncrementalAuthReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CCIncrementalAuthReply * SOAP_FMAC4 soap_get_ns2__CCIncrementalAuthReply(struct soap *soap, ns2__CCIncrementalAuthReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CCIncrementalAuthReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CCSaleReversalReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CCSaleReversalReply::reasonCode = NULL;
	this->ns2__CCSaleReversalReply::amount = NULL;
	this->ns2__CCSaleReversalReply::authorizationCode = NULL;
	this->ns2__CCSaleReversalReply::processorResponse = NULL;
	this->ns2__CCSaleReversalReply::reconciliationID = NULL;
	this->ns2__CCSaleReversalReply::requestDateTime = NULL;
	/* transient soap skipped */
}

void ns2__CCSaleReversalReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__CCSaleReversalReply::reasonCode);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__CCSaleReversalReply::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleReversalReply::authorizationCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleReversalReply::processorResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleReversalReply::reconciliationID);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__CCSaleReversalReply::requestDateTime);
#endif
}

int ns2__CCSaleReversalReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CCSaleReversalReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CCSaleReversalReply(struct soap *soap, const char *tag, int id, const ns2__CCSaleReversalReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CCSaleReversalReply), type))
		return soap->error;
	if (!a->ns2__CCSaleReversalReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__CCSaleReversalReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__CCSaleReversalReply::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authorizationCode", -1, (wchar_t*const*)&a->ns2__CCSaleReversalReply::authorizationCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__CCSaleReversalReply::processorResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__CCSaleReversalReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__CCSaleReversalReply::requestDateTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CCSaleReversalReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CCSaleReversalReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CCSaleReversalReply * SOAP_FMAC4 soap_in_ns2__CCSaleReversalReply(struct soap *soap, const char *tag, ns2__CCSaleReversalReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CCSaleReversalReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CCSaleReversalReply, sizeof(ns2__CCSaleReversalReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CCSaleReversalReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CCSaleReversalReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_authorizationCode1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__CCSaleReversalReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__CCSaleReversalReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_authorizationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authorizationCode", (wchar_t**)&a->ns2__CCSaleReversalReply::authorizationCode, "xsd:string"))
				{	soap_flag_authorizationCode1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__CCSaleReversalReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__CCSaleReversalReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__CCSaleReversalReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__CCSaleReversalReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CCSaleReversalReply, SOAP_TYPE_ns2__CCSaleReversalReply, sizeof(ns2__CCSaleReversalReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CCSaleReversalReply * SOAP_FMAC2 soap_instantiate_ns2__CCSaleReversalReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CCSaleReversalReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CCSaleReversalReply *p;
	size_t k = sizeof(ns2__CCSaleReversalReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CCSaleReversalReply);
		if (p)
			((ns2__CCSaleReversalReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CCSaleReversalReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CCSaleReversalReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CCSaleReversalReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CCSaleReversalReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CCSaleReversalReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CCSaleReversalReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CCSaleReversalReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CCSaleReversalReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CCSaleReversalReply * SOAP_FMAC4 soap_get_ns2__CCSaleReversalReply(struct soap *soap, ns2__CCSaleReversalReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CCSaleReversalReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CCSaleCreditReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CCSaleCreditReply::reasonCode = NULL;
	this->ns2__CCSaleCreditReply::amount = NULL;
	this->ns2__CCSaleCreditReply::authorizationCode = NULL;
	this->ns2__CCSaleCreditReply::processorResponse = NULL;
	this->ns2__CCSaleCreditReply::authorizedDateTime = NULL;
	this->ns2__CCSaleCreditReply::reconciliationID = NULL;
	this->ns2__CCSaleCreditReply::paymentNetworkTransactionID = NULL;
	/* transient soap skipped */
}

void ns2__CCSaleCreditReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__CCSaleCreditReply::reasonCode);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__CCSaleCreditReply::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleCreditReply::authorizationCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleCreditReply::processorResponse);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__CCSaleCreditReply::authorizedDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleCreditReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleCreditReply::paymentNetworkTransactionID);
#endif
}

int ns2__CCSaleCreditReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CCSaleCreditReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CCSaleCreditReply(struct soap *soap, const char *tag, int id, const ns2__CCSaleCreditReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CCSaleCreditReply), type))
		return soap->error;
	if (!a->ns2__CCSaleCreditReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__CCSaleCreditReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__CCSaleCreditReply::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authorizationCode", -1, (wchar_t*const*)&a->ns2__CCSaleCreditReply::authorizationCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__CCSaleCreditReply::processorResponse, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:authorizedDateTime", -1, &a->ns2__CCSaleCreditReply::authorizedDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__CCSaleCreditReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentNetworkTransactionID", -1, (wchar_t*const*)&a->ns2__CCSaleCreditReply::paymentNetworkTransactionID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CCSaleCreditReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CCSaleCreditReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CCSaleCreditReply * SOAP_FMAC4 soap_in_ns2__CCSaleCreditReply(struct soap *soap, const char *tag, ns2__CCSaleCreditReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CCSaleCreditReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CCSaleCreditReply, sizeof(ns2__CCSaleCreditReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CCSaleCreditReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CCSaleCreditReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_authorizationCode1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_authorizedDateTime1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_paymentNetworkTransactionID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__CCSaleCreditReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__CCSaleCreditReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_authorizationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authorizationCode", (wchar_t**)&a->ns2__CCSaleCreditReply::authorizationCode, "xsd:string"))
				{	soap_flag_authorizationCode1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__CCSaleCreditReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_authorizedDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:authorizedDateTime", &a->ns2__CCSaleCreditReply::authorizedDateTime, "ns2:dateTime"))
				{	soap_flag_authorizedDateTime1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__CCSaleCreditReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_paymentNetworkTransactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentNetworkTransactionID", (wchar_t**)&a->ns2__CCSaleCreditReply::paymentNetworkTransactionID, "xsd:string"))
				{	soap_flag_paymentNetworkTransactionID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__CCSaleCreditReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CCSaleCreditReply, SOAP_TYPE_ns2__CCSaleCreditReply, sizeof(ns2__CCSaleCreditReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CCSaleCreditReply * SOAP_FMAC2 soap_instantiate_ns2__CCSaleCreditReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CCSaleCreditReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CCSaleCreditReply *p;
	size_t k = sizeof(ns2__CCSaleCreditReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CCSaleCreditReply);
		if (p)
			((ns2__CCSaleCreditReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CCSaleCreditReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CCSaleCreditReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CCSaleCreditReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CCSaleCreditReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CCSaleCreditReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CCSaleCreditReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CCSaleCreditReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CCSaleCreditReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CCSaleCreditReply * SOAP_FMAC4 soap_get_ns2__CCSaleCreditReply(struct soap *soap, ns2__CCSaleCreditReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CCSaleCreditReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CCSaleReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CCSaleReply::reasonCode = NULL;
	this->ns2__CCSaleReply::amount = NULL;
	this->ns2__CCSaleReply::authorizationCode = NULL;
	this->ns2__CCSaleReply::processorResponse = NULL;
	this->ns2__CCSaleReply::avsCode = NULL;
	this->ns2__CCSaleReply::avsCodeRaw = NULL;
	this->ns2__CCSaleReply::cvCode = NULL;
	this->ns2__CCSaleReply::cvCodeRaw = NULL;
	this->ns2__CCSaleReply::cavvResponseCode = NULL;
	this->ns2__CCSaleReply::cavvResponseCodeRaw = NULL;
	this->ns2__CCSaleReply::cardGroup = NULL;
	this->ns2__CCSaleReply::paymentNetworkTransactionID = NULL;
	this->ns2__CCSaleReply::cardCategory = NULL;
	this->ns2__CCSaleReply::accountBalance = NULL;
	this->ns2__CCSaleReply::authorizedDateTime = NULL;
	this->ns2__CCSaleReply::requestAmount = NULL;
	this->ns2__CCSaleReply::reconciliationID = NULL;
	this->ns2__CCSaleReply::accountBalanceCurrency = NULL;
	this->ns2__CCSaleReply::accountBalanceSign = NULL;
	/* transient soap skipped */
}

void ns2__CCSaleReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__CCSaleReply::reasonCode);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__CCSaleReply::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleReply::authorizationCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleReply::processorResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleReply::avsCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleReply::avsCodeRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleReply::cvCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleReply::cvCodeRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleReply::cavvResponseCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleReply::cavvResponseCodeRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleReply::cardGroup);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleReply::paymentNetworkTransactionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleReply::cardCategory);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__CCSaleReply::accountBalance);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__CCSaleReply::authorizedDateTime);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__CCSaleReply::requestAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleReply::accountBalanceCurrency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleReply::accountBalanceSign);
#endif
}

int ns2__CCSaleReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CCSaleReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CCSaleReply(struct soap *soap, const char *tag, int id, const ns2__CCSaleReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CCSaleReply), type))
		return soap->error;
	if (!a->ns2__CCSaleReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__CCSaleReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__CCSaleReply::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authorizationCode", -1, (wchar_t*const*)&a->ns2__CCSaleReply::authorizationCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__CCSaleReply::processorResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:avsCode", -1, (wchar_t*const*)&a->ns2__CCSaleReply::avsCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:avsCodeRaw", -1, (wchar_t*const*)&a->ns2__CCSaleReply::avsCodeRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cvCode", -1, (wchar_t*const*)&a->ns2__CCSaleReply::cvCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cvCodeRaw", -1, (wchar_t*const*)&a->ns2__CCSaleReply::cvCodeRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cavvResponseCode", -1, (wchar_t*const*)&a->ns2__CCSaleReply::cavvResponseCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cavvResponseCodeRaw", -1, (wchar_t*const*)&a->ns2__CCSaleReply::cavvResponseCodeRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardGroup", -1, (wchar_t*const*)&a->ns2__CCSaleReply::cardGroup, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentNetworkTransactionID", -1, (wchar_t*const*)&a->ns2__CCSaleReply::paymentNetworkTransactionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardCategory", -1, (wchar_t*const*)&a->ns2__CCSaleReply::cardCategory, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:accountBalance", -1, &a->ns2__CCSaleReply::accountBalance, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:authorizedDateTime", -1, &a->ns2__CCSaleReply::authorizedDateTime, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:requestAmount", -1, &a->ns2__CCSaleReply::requestAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__CCSaleReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:accountBalanceCurrency", -1, (wchar_t*const*)&a->ns2__CCSaleReply::accountBalanceCurrency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:accountBalanceSign", -1, (wchar_t*const*)&a->ns2__CCSaleReply::accountBalanceSign, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CCSaleReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CCSaleReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CCSaleReply * SOAP_FMAC4 soap_in_ns2__CCSaleReply(struct soap *soap, const char *tag, ns2__CCSaleReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CCSaleReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CCSaleReply, sizeof(ns2__CCSaleReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CCSaleReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CCSaleReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_authorizationCode1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_avsCode1 = 1;
	size_t soap_flag_avsCodeRaw1 = 1;
	size_t soap_flag_cvCode1 = 1;
	size_t soap_flag_cvCodeRaw1 = 1;
	size_t soap_flag_cavvResponseCode1 = 1;
	size_t soap_flag_cavvResponseCodeRaw1 = 1;
	size_t soap_flag_cardGroup1 = 1;
	size_t soap_flag_paymentNetworkTransactionID1 = 1;
	size_t soap_flag_cardCategory1 = 1;
	size_t soap_flag_accountBalance1 = 1;
	size_t soap_flag_authorizedDateTime1 = 1;
	size_t soap_flag_requestAmount1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_accountBalanceCurrency1 = 1;
	size_t soap_flag_accountBalanceSign1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__CCSaleReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__CCSaleReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_authorizationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authorizationCode", (wchar_t**)&a->ns2__CCSaleReply::authorizationCode, "xsd:string"))
				{	soap_flag_authorizationCode1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__CCSaleReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_avsCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:avsCode", (wchar_t**)&a->ns2__CCSaleReply::avsCode, "xsd:string"))
				{	soap_flag_avsCode1--;
					continue;
				}
			if (soap_flag_avsCodeRaw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:avsCodeRaw", (wchar_t**)&a->ns2__CCSaleReply::avsCodeRaw, "xsd:string"))
				{	soap_flag_avsCodeRaw1--;
					continue;
				}
			if (soap_flag_cvCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cvCode", (wchar_t**)&a->ns2__CCSaleReply::cvCode, "xsd:string"))
				{	soap_flag_cvCode1--;
					continue;
				}
			if (soap_flag_cvCodeRaw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cvCodeRaw", (wchar_t**)&a->ns2__CCSaleReply::cvCodeRaw, "xsd:string"))
				{	soap_flag_cvCodeRaw1--;
					continue;
				}
			if (soap_flag_cavvResponseCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cavvResponseCode", (wchar_t**)&a->ns2__CCSaleReply::cavvResponseCode, "xsd:string"))
				{	soap_flag_cavvResponseCode1--;
					continue;
				}
			if (soap_flag_cavvResponseCodeRaw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cavvResponseCodeRaw", (wchar_t**)&a->ns2__CCSaleReply::cavvResponseCodeRaw, "xsd:string"))
				{	soap_flag_cavvResponseCodeRaw1--;
					continue;
				}
			if (soap_flag_cardGroup1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardGroup", (wchar_t**)&a->ns2__CCSaleReply::cardGroup, "xsd:string"))
				{	soap_flag_cardGroup1--;
					continue;
				}
			if (soap_flag_paymentNetworkTransactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentNetworkTransactionID", (wchar_t**)&a->ns2__CCSaleReply::paymentNetworkTransactionID, "xsd:string"))
				{	soap_flag_paymentNetworkTransactionID1--;
					continue;
				}
			if (soap_flag_cardCategory1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardCategory", (wchar_t**)&a->ns2__CCSaleReply::cardCategory, "xsd:string"))
				{	soap_flag_cardCategory1--;
					continue;
				}
			if (soap_flag_accountBalance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:accountBalance", &a->ns2__CCSaleReply::accountBalance, "ns2:amount"))
				{	soap_flag_accountBalance1--;
					continue;
				}
			if (soap_flag_authorizedDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:authorizedDateTime", &a->ns2__CCSaleReply::authorizedDateTime, "ns2:dateTime"))
				{	soap_flag_authorizedDateTime1--;
					continue;
				}
			if (soap_flag_requestAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:requestAmount", &a->ns2__CCSaleReply::requestAmount, "ns2:amount"))
				{	soap_flag_requestAmount1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__CCSaleReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_accountBalanceCurrency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:accountBalanceCurrency", (wchar_t**)&a->ns2__CCSaleReply::accountBalanceCurrency, "xsd:string"))
				{	soap_flag_accountBalanceCurrency1--;
					continue;
				}
			if (soap_flag_accountBalanceSign1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:accountBalanceSign", (wchar_t**)&a->ns2__CCSaleReply::accountBalanceSign, "xsd:string"))
				{	soap_flag_accountBalanceSign1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__CCSaleReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CCSaleReply, SOAP_TYPE_ns2__CCSaleReply, sizeof(ns2__CCSaleReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CCSaleReply * SOAP_FMAC2 soap_instantiate_ns2__CCSaleReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CCSaleReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CCSaleReply *p;
	size_t k = sizeof(ns2__CCSaleReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CCSaleReply);
		if (p)
			((ns2__CCSaleReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CCSaleReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CCSaleReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CCSaleReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CCSaleReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CCSaleReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CCSaleReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CCSaleReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CCSaleReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CCSaleReply * SOAP_FMAC4 soap_get_ns2__CCSaleReply(struct soap *soap, ns2__CCSaleReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CCSaleReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__VerificationReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__VerificationReply::reasonCode = NULL;
	this->ns2__VerificationReply::processorTransactionID = NULL;
	this->ns2__VerificationReply::processorResponse = NULL;
	this->ns2__VerificationReply::verifiedDateTime = NULL;
	this->ns2__VerificationReply::reconciliationID = NULL;
	/* transient soap skipped */
}

void ns2__VerificationReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__VerificationReply::reasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VerificationReply::processorTransactionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VerificationReply::processorResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VerificationReply::verifiedDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VerificationReply::reconciliationID);
#endif
}

int ns2__VerificationReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__VerificationReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VerificationReply(struct soap *soap, const char *tag, int id, const ns2__VerificationReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VerificationReply), type))
		return soap->error;
	if (!a->ns2__VerificationReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__VerificationReply::reasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorTransactionID", -1, (wchar_t*const*)&a->ns2__VerificationReply::processorTransactionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__VerificationReply::processorResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:verifiedDateTime", -1, (wchar_t*const*)&a->ns2__VerificationReply::verifiedDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__VerificationReply::reconciliationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__VerificationReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__VerificationReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__VerificationReply * SOAP_FMAC4 soap_in_ns2__VerificationReply(struct soap *soap, const char *tag, ns2__VerificationReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__VerificationReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VerificationReply, sizeof(ns2__VerificationReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__VerificationReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__VerificationReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_processorTransactionID1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_verifiedDateTime1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__VerificationReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_processorTransactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorTransactionID", (wchar_t**)&a->ns2__VerificationReply::processorTransactionID, "xsd:string"))
				{	soap_flag_processorTransactionID1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__VerificationReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_verifiedDateTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:verifiedDateTime", (wchar_t**)&a->ns2__VerificationReply::verifiedDateTime, "xsd:string"))
				{	soap_flag_verifiedDateTime1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__VerificationReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__VerificationReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VerificationReply, SOAP_TYPE_ns2__VerificationReply, sizeof(ns2__VerificationReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__VerificationReply * SOAP_FMAC2 soap_instantiate_ns2__VerificationReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__VerificationReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__VerificationReply *p;
	size_t k = sizeof(ns2__VerificationReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__VerificationReply);
		if (p)
			((ns2__VerificationReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__VerificationReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__VerificationReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__VerificationReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__VerificationReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__VerificationReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:VerificationReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__VerificationReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__VerificationReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__VerificationReply * SOAP_FMAC4 soap_get_ns2__VerificationReply(struct soap *soap, ns2__VerificationReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VerificationReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__OCTReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__OCTReply::reasonCode = NULL;
	this->ns2__OCTReply::requestDateTime = NULL;
	this->ns2__OCTReply::reconciliationID = NULL;
	this->ns2__OCTReply::processorResponse = NULL;
	this->ns2__OCTReply::approvalCode = NULL;
	this->ns2__OCTReply::amount = NULL;
	this->ns2__OCTReply::paymentNetworkTransactionID = NULL;
	/* transient soap skipped */
}

void ns2__OCTReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__OCTReply::reasonCode);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__OCTReply::requestDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__OCTReply::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__OCTReply::processorResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__OCTReply::approvalCode);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__OCTReply::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__OCTReply::paymentNetworkTransactionID);
#endif
}

int ns2__OCTReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__OCTReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OCTReply(struct soap *soap, const char *tag, int id, const ns2__OCTReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OCTReply), type))
		return soap->error;
	if (!a->ns2__OCTReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__OCTReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:requestDateTime", -1, &a->ns2__OCTReply::requestDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__OCTReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__OCTReply::processorResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:approvalCode", -1, (wchar_t*const*)&a->ns2__OCTReply::approvalCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__OCTReply::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentNetworkTransactionID", -1, (wchar_t*const*)&a->ns2__OCTReply::paymentNetworkTransactionID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__OCTReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__OCTReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__OCTReply * SOAP_FMAC4 soap_in_ns2__OCTReply(struct soap *soap, const char *tag, ns2__OCTReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__OCTReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OCTReply, sizeof(ns2__OCTReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__OCTReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__OCTReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_requestDateTime1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_approvalCode1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_paymentNetworkTransactionID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__OCTReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_requestDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:requestDateTime", &a->ns2__OCTReply::requestDateTime, "ns2:dateTime"))
				{	soap_flag_requestDateTime1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__OCTReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__OCTReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_approvalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:approvalCode", (wchar_t**)&a->ns2__OCTReply::approvalCode, "xsd:string"))
				{	soap_flag_approvalCode1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__OCTReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_paymentNetworkTransactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentNetworkTransactionID", (wchar_t**)&a->ns2__OCTReply::paymentNetworkTransactionID, "xsd:string"))
				{	soap_flag_paymentNetworkTransactionID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__OCTReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OCTReply, SOAP_TYPE_ns2__OCTReply, sizeof(ns2__OCTReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__OCTReply * SOAP_FMAC2 soap_instantiate_ns2__OCTReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__OCTReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__OCTReply *p;
	size_t k = sizeof(ns2__OCTReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__OCTReply);
		if (p)
			((ns2__OCTReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__OCTReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__OCTReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__OCTReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__OCTReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__OCTReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:OCTReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__OCTReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__OCTReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__OCTReply * SOAP_FMAC4 soap_get_ns2__OCTReply(struct soap *soap, ns2__OCTReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OCTReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CCAuthReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CCAuthReply::reasonCode = NULL;
	this->ns2__CCAuthReply::amount = NULL;
	this->ns2__CCAuthReply::authorizationCode = NULL;
	this->ns2__CCAuthReply::avsCode = NULL;
	this->ns2__CCAuthReply::avsCodeRaw = NULL;
	this->ns2__CCAuthReply::cvCode = NULL;
	this->ns2__CCAuthReply::cvCodeRaw = NULL;
	this->ns2__CCAuthReply::personalIDCode = NULL;
	this->ns2__CCAuthReply::authorizedDateTime = NULL;
	this->ns2__CCAuthReply::processorResponse = NULL;
	this->ns2__CCAuthReply::bmlAccountNumber = NULL;
	this->ns2__CCAuthReply::authFactorCode = NULL;
	this->ns2__CCAuthReply::reconciliationID = NULL;
	this->ns2__CCAuthReply::fundingTotals = NULL;
	this->ns2__CCAuthReply::fxQuoteID = NULL;
	this->ns2__CCAuthReply::fxQuoteRate = NULL;
	this->ns2__CCAuthReply::fxQuoteType = NULL;
	this->ns2__CCAuthReply::fxQuoteExpirationDateTime = NULL;
	this->ns2__CCAuthReply::authRecord = NULL;
	this->ns2__CCAuthReply::merchantAdviceCode = NULL;
	this->ns2__CCAuthReply::merchantAdviceCodeRaw = NULL;
	this->ns2__CCAuthReply::cavvResponseCode = NULL;
	this->ns2__CCAuthReply::cavvResponseCodeRaw = NULL;
	this->ns2__CCAuthReply::authenticationXID = NULL;
	this->ns2__CCAuthReply::authorizationXID = NULL;
	this->ns2__CCAuthReply::processorCardType = NULL;
	this->ns2__CCAuthReply::accountBalance = NULL;
	this->ns2__CCAuthReply::forwardCode = NULL;
	this->ns2__CCAuthReply::enhancedDataEnabled = NULL;
	this->ns2__CCAuthReply::referralResponseNumber = NULL;
	this->ns2__CCAuthReply::subResponseCode = NULL;
	this->ns2__CCAuthReply::approvedAmount = NULL;
	this->ns2__CCAuthReply::creditLine = NULL;
	this->ns2__CCAuthReply::approvedTerms = NULL;
	this->ns2__CCAuthReply::paymentNetworkTransactionID = NULL;
	this->ns2__CCAuthReply::cardCategory = NULL;
	this->ns2__CCAuthReply::ownerMerchantID = NULL;
	this->ns2__CCAuthReply::requestAmount = NULL;
	this->ns2__CCAuthReply::requestCurrency = NULL;
	this->ns2__CCAuthReply::accountBalanceCurrency = NULL;
	this->ns2__CCAuthReply::accountBalanceSign = NULL;
	this->ns2__CCAuthReply::amountType = NULL;
	this->ns2__CCAuthReply::accountType = NULL;
	this->ns2__CCAuthReply::affluenceIndicator = NULL;
	this->ns2__CCAuthReply::evEmail = NULL;
	this->ns2__CCAuthReply::evPhoneNumber = NULL;
	this->ns2__CCAuthReply::evPostalCode = NULL;
	this->ns2__CCAuthReply::evName = NULL;
	this->ns2__CCAuthReply::evStreet = NULL;
	this->ns2__CCAuthReply::evEmailRaw = NULL;
	this->ns2__CCAuthReply::evPhoneNumberRaw = NULL;
	this->ns2__CCAuthReply::evPostalCodeRaw = NULL;
	this->ns2__CCAuthReply::evNameRaw = NULL;
	this->ns2__CCAuthReply::evStreetRaw = NULL;
	this->ns2__CCAuthReply::cardGroup = NULL;
	this->ns2__CCAuthReply::posData = NULL;
	this->ns2__CCAuthReply::transactionID = NULL;
	this->ns2__CCAuthReply::cardIssuerCountry = NULL;
	this->ns2__CCAuthReply::cardRegulated = NULL;
	this->ns2__CCAuthReply::cardCommercial = NULL;
	this->ns2__CCAuthReply::cardPrepaid = NULL;
	this->ns2__CCAuthReply::cardPayroll = NULL;
	this->ns2__CCAuthReply::cardHealthcare = NULL;
	this->ns2__CCAuthReply::cardSignatureDebit = NULL;
	this->ns2__CCAuthReply::cardPINlessDebit = NULL;
	this->ns2__CCAuthReply::cardLevel3Eligible = NULL;
	this->ns2__CCAuthReply::processorTransactionID = NULL;
	this->ns2__CCAuthReply::providerReasonCode = NULL;
	this->ns2__CCAuthReply::providerReasonDescription = NULL;
	this->ns2__CCAuthReply::providerPassThroughData = NULL;
	this->ns2__CCAuthReply::providerCVNResponseCode = NULL;
	this->ns2__CCAuthReply::providerAVSResponseCode = NULL;
	this->ns2__CCAuthReply::providerAcquirerBankCode = NULL;
	this->ns2__CCAuthReply::paymentCardService = NULL;
	this->ns2__CCAuthReply::paymentCardServiceResult = NULL;
	this->ns2__CCAuthReply::transactionQualification = NULL;
	/* transient soap skipped */
}

void ns2__CCAuthReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__integer(soap, (wchar_t*const*)&this->ns2__CCAuthReply::reasonCode);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__CCAuthReply::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::authorizationCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::avsCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::avsCodeRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::cvCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::cvCodeRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::personalIDCode);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__CCAuthReply::authorizedDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::processorResponse);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::bmlAccountNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::authFactorCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::reconciliationID);
	soap_serialize_PointerTons2__FundingTotals(soap, &this->ns2__CCAuthReply::fundingTotals);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::fxQuoteID);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__CCAuthReply::fxQuoteRate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::fxQuoteType);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__CCAuthReply::fxQuoteExpirationDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::authRecord);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::merchantAdviceCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::merchantAdviceCodeRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::cavvResponseCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::cavvResponseCodeRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::authenticationXID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::authorizationXID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::processorCardType);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__CCAuthReply::accountBalance);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::forwardCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::enhancedDataEnabled);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::referralResponseNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::subResponseCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::approvedAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::creditLine);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::approvedTerms);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::paymentNetworkTransactionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::cardCategory);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::ownerMerchantID);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__CCAuthReply::requestAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::requestCurrency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::accountBalanceCurrency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::accountBalanceSign);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::amountType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::accountType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::affluenceIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::evEmail);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::evPhoneNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::evPostalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::evName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::evStreet);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::evEmailRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::evPhoneNumberRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::evPostalCodeRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::evNameRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::evStreetRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::cardGroup);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::posData);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::transactionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::cardIssuerCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::cardRegulated);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::cardCommercial);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::cardPrepaid);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::cardPayroll);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::cardHealthcare);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::cardSignatureDebit);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::cardPINlessDebit);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::cardLevel3Eligible);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::processorTransactionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::providerReasonCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::providerReasonDescription);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::providerPassThroughData);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::providerCVNResponseCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::providerAVSResponseCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::providerAcquirerBankCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::paymentCardService);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::paymentCardServiceResult);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReply::transactionQualification);
#endif
}

int ns2__CCAuthReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CCAuthReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CCAuthReply(struct soap *soap, const char *tag, int id, const ns2__CCAuthReply *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CCAuthReply), type))
		return soap->error;
	if (!a->ns2__CCAuthReply::reasonCode)
	{	if (soap_element_nil(soap, "ns2:reasonCode"))
			return soap->error;
	}
	else
	if (soap_out_xsd__integer(soap, "ns2:reasonCode", -1, (wchar_t*const*)&a->ns2__CCAuthReply::reasonCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__CCAuthReply::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authorizationCode", -1, (wchar_t*const*)&a->ns2__CCAuthReply::authorizationCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:avsCode", -1, (wchar_t*const*)&a->ns2__CCAuthReply::avsCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:avsCodeRaw", -1, (wchar_t*const*)&a->ns2__CCAuthReply::avsCodeRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cvCode", -1, (wchar_t*const*)&a->ns2__CCAuthReply::cvCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cvCodeRaw", -1, (wchar_t*const*)&a->ns2__CCAuthReply::cvCodeRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:personalIDCode", -1, (wchar_t*const*)&a->ns2__CCAuthReply::personalIDCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:authorizedDateTime", -1, &a->ns2__CCAuthReply::authorizedDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorResponse", -1, (wchar_t*const*)&a->ns2__CCAuthReply::processorResponse, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:bmlAccountNumber", -1, (wchar_t*const*)&a->ns2__CCAuthReply::bmlAccountNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authFactorCode", -1, (wchar_t*const*)&a->ns2__CCAuthReply::authFactorCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__CCAuthReply::reconciliationID, ""))
		return soap->error;
	if (soap_out_PointerTons2__FundingTotals(soap, "ns2:fundingTotals", -1, &a->ns2__CCAuthReply::fundingTotals, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:fxQuoteID", -1, (wchar_t*const*)&a->ns2__CCAuthReply::fxQuoteID, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:fxQuoteRate", -1, &a->ns2__CCAuthReply::fxQuoteRate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:fxQuoteType", -1, (wchar_t*const*)&a->ns2__CCAuthReply::fxQuoteType, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:fxQuoteExpirationDateTime", -1, &a->ns2__CCAuthReply::fxQuoteExpirationDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authRecord", -1, (wchar_t*const*)&a->ns2__CCAuthReply::authRecord, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantAdviceCode", -1, (wchar_t*const*)&a->ns2__CCAuthReply::merchantAdviceCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantAdviceCodeRaw", -1, (wchar_t*const*)&a->ns2__CCAuthReply::merchantAdviceCodeRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cavvResponseCode", -1, (wchar_t*const*)&a->ns2__CCAuthReply::cavvResponseCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cavvResponseCodeRaw", -1, (wchar_t*const*)&a->ns2__CCAuthReply::cavvResponseCodeRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authenticationXID", -1, (wchar_t*const*)&a->ns2__CCAuthReply::authenticationXID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authorizationXID", -1, (wchar_t*const*)&a->ns2__CCAuthReply::authorizationXID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorCardType", -1, (wchar_t*const*)&a->ns2__CCAuthReply::processorCardType, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:accountBalance", -1, &a->ns2__CCAuthReply::accountBalance, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:forwardCode", -1, (wchar_t*const*)&a->ns2__CCAuthReply::forwardCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:enhancedDataEnabled", -1, (wchar_t*const*)&a->ns2__CCAuthReply::enhancedDataEnabled, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:referralResponseNumber", -1, (wchar_t*const*)&a->ns2__CCAuthReply::referralResponseNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:subResponseCode", -1, (wchar_t*const*)&a->ns2__CCAuthReply::subResponseCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:approvedAmount", -1, (wchar_t*const*)&a->ns2__CCAuthReply::approvedAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:creditLine", -1, (wchar_t*const*)&a->ns2__CCAuthReply::creditLine, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:approvedTerms", -1, (wchar_t*const*)&a->ns2__CCAuthReply::approvedTerms, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentNetworkTransactionID", -1, (wchar_t*const*)&a->ns2__CCAuthReply::paymentNetworkTransactionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardCategory", -1, (wchar_t*const*)&a->ns2__CCAuthReply::cardCategory, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ownerMerchantID", -1, (wchar_t*const*)&a->ns2__CCAuthReply::ownerMerchantID, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:requestAmount", -1, &a->ns2__CCAuthReply::requestAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:requestCurrency", -1, (wchar_t*const*)&a->ns2__CCAuthReply::requestCurrency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:accountBalanceCurrency", -1, (wchar_t*const*)&a->ns2__CCAuthReply::accountBalanceCurrency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:accountBalanceSign", -1, (wchar_t*const*)&a->ns2__CCAuthReply::accountBalanceSign, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:amountType", -1, (wchar_t*const*)&a->ns2__CCAuthReply::amountType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:accountType", -1, (wchar_t*const*)&a->ns2__CCAuthReply::accountType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:affluenceIndicator", -1, (wchar_t*const*)&a->ns2__CCAuthReply::affluenceIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:evEmail", -1, (wchar_t*const*)&a->ns2__CCAuthReply::evEmail, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:evPhoneNumber", -1, (wchar_t*const*)&a->ns2__CCAuthReply::evPhoneNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:evPostalCode", -1, (wchar_t*const*)&a->ns2__CCAuthReply::evPostalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:evName", -1, (wchar_t*const*)&a->ns2__CCAuthReply::evName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:evStreet", -1, (wchar_t*const*)&a->ns2__CCAuthReply::evStreet, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:evEmailRaw", -1, (wchar_t*const*)&a->ns2__CCAuthReply::evEmailRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:evPhoneNumberRaw", -1, (wchar_t*const*)&a->ns2__CCAuthReply::evPhoneNumberRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:evPostalCodeRaw", -1, (wchar_t*const*)&a->ns2__CCAuthReply::evPostalCodeRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:evNameRaw", -1, (wchar_t*const*)&a->ns2__CCAuthReply::evNameRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:evStreetRaw", -1, (wchar_t*const*)&a->ns2__CCAuthReply::evStreetRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardGroup", -1, (wchar_t*const*)&a->ns2__CCAuthReply::cardGroup, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:posData", -1, (wchar_t*const*)&a->ns2__CCAuthReply::posData, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionID", -1, (wchar_t*const*)&a->ns2__CCAuthReply::transactionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardIssuerCountry", -1, (wchar_t*const*)&a->ns2__CCAuthReply::cardIssuerCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardRegulated", -1, (wchar_t*const*)&a->ns2__CCAuthReply::cardRegulated, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardCommercial", -1, (wchar_t*const*)&a->ns2__CCAuthReply::cardCommercial, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardPrepaid", -1, (wchar_t*const*)&a->ns2__CCAuthReply::cardPrepaid, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardPayroll", -1, (wchar_t*const*)&a->ns2__CCAuthReply::cardPayroll, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardHealthcare", -1, (wchar_t*const*)&a->ns2__CCAuthReply::cardHealthcare, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardSignatureDebit", -1, (wchar_t*const*)&a->ns2__CCAuthReply::cardSignatureDebit, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardPINlessDebit", -1, (wchar_t*const*)&a->ns2__CCAuthReply::cardPINlessDebit, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardLevel3Eligible", -1, (wchar_t*const*)&a->ns2__CCAuthReply::cardLevel3Eligible, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorTransactionID", -1, (wchar_t*const*)&a->ns2__CCAuthReply::processorTransactionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:providerReasonCode", -1, (wchar_t*const*)&a->ns2__CCAuthReply::providerReasonCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:providerReasonDescription", -1, (wchar_t*const*)&a->ns2__CCAuthReply::providerReasonDescription, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:providerPassThroughData", -1, (wchar_t*const*)&a->ns2__CCAuthReply::providerPassThroughData, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:providerCVNResponseCode", -1, (wchar_t*const*)&a->ns2__CCAuthReply::providerCVNResponseCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:providerAVSResponseCode", -1, (wchar_t*const*)&a->ns2__CCAuthReply::providerAVSResponseCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:providerAcquirerBankCode", -1, (wchar_t*const*)&a->ns2__CCAuthReply::providerAcquirerBankCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentCardService", -1, (wchar_t*const*)&a->ns2__CCAuthReply::paymentCardService, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentCardServiceResult", -1, (wchar_t*const*)&a->ns2__CCAuthReply::paymentCardServiceResult, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionQualification", -1, (wchar_t*const*)&a->ns2__CCAuthReply::transactionQualification, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CCAuthReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CCAuthReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CCAuthReply * SOAP_FMAC4 soap_in_ns2__CCAuthReply(struct soap *soap, const char *tag, ns2__CCAuthReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CCAuthReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CCAuthReply, sizeof(ns2__CCAuthReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CCAuthReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CCAuthReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_reasonCode1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_authorizationCode1 = 1;
	size_t soap_flag_avsCode1 = 1;
	size_t soap_flag_avsCodeRaw1 = 1;
	size_t soap_flag_cvCode1 = 1;
	size_t soap_flag_cvCodeRaw1 = 1;
	size_t soap_flag_personalIDCode1 = 1;
	size_t soap_flag_authorizedDateTime1 = 1;
	size_t soap_flag_processorResponse1 = 1;
	size_t soap_flag_bmlAccountNumber1 = 1;
	size_t soap_flag_authFactorCode1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_fundingTotals1 = 1;
	size_t soap_flag_fxQuoteID1 = 1;
	size_t soap_flag_fxQuoteRate1 = 1;
	size_t soap_flag_fxQuoteType1 = 1;
	size_t soap_flag_fxQuoteExpirationDateTime1 = 1;
	size_t soap_flag_authRecord1 = 1;
	size_t soap_flag_merchantAdviceCode1 = 1;
	size_t soap_flag_merchantAdviceCodeRaw1 = 1;
	size_t soap_flag_cavvResponseCode1 = 1;
	size_t soap_flag_cavvResponseCodeRaw1 = 1;
	size_t soap_flag_authenticationXID1 = 1;
	size_t soap_flag_authorizationXID1 = 1;
	size_t soap_flag_processorCardType1 = 1;
	size_t soap_flag_accountBalance1 = 1;
	size_t soap_flag_forwardCode1 = 1;
	size_t soap_flag_enhancedDataEnabled1 = 1;
	size_t soap_flag_referralResponseNumber1 = 1;
	size_t soap_flag_subResponseCode1 = 1;
	size_t soap_flag_approvedAmount1 = 1;
	size_t soap_flag_creditLine1 = 1;
	size_t soap_flag_approvedTerms1 = 1;
	size_t soap_flag_paymentNetworkTransactionID1 = 1;
	size_t soap_flag_cardCategory1 = 1;
	size_t soap_flag_ownerMerchantID1 = 1;
	size_t soap_flag_requestAmount1 = 1;
	size_t soap_flag_requestCurrency1 = 1;
	size_t soap_flag_accountBalanceCurrency1 = 1;
	size_t soap_flag_accountBalanceSign1 = 1;
	size_t soap_flag_amountType1 = 1;
	size_t soap_flag_accountType1 = 1;
	size_t soap_flag_affluenceIndicator1 = 1;
	size_t soap_flag_evEmail1 = 1;
	size_t soap_flag_evPhoneNumber1 = 1;
	size_t soap_flag_evPostalCode1 = 1;
	size_t soap_flag_evName1 = 1;
	size_t soap_flag_evStreet1 = 1;
	size_t soap_flag_evEmailRaw1 = 1;
	size_t soap_flag_evPhoneNumberRaw1 = 1;
	size_t soap_flag_evPostalCodeRaw1 = 1;
	size_t soap_flag_evNameRaw1 = 1;
	size_t soap_flag_evStreetRaw1 = 1;
	size_t soap_flag_cardGroup1 = 1;
	size_t soap_flag_posData1 = 1;
	size_t soap_flag_transactionID1 = 1;
	size_t soap_flag_cardIssuerCountry1 = 1;
	size_t soap_flag_cardRegulated1 = 1;
	size_t soap_flag_cardCommercial1 = 1;
	size_t soap_flag_cardPrepaid1 = 1;
	size_t soap_flag_cardPayroll1 = 1;
	size_t soap_flag_cardHealthcare1 = 1;
	size_t soap_flag_cardSignatureDebit1 = 1;
	size_t soap_flag_cardPINlessDebit1 = 1;
	size_t soap_flag_cardLevel3Eligible1 = 1;
	size_t soap_flag_processorTransactionID1 = 1;
	size_t soap_flag_providerReasonCode1 = 1;
	size_t soap_flag_providerReasonDescription1 = 1;
	size_t soap_flag_providerPassThroughData1 = 1;
	size_t soap_flag_providerCVNResponseCode1 = 1;
	size_t soap_flag_providerAVSResponseCode1 = 1;
	size_t soap_flag_providerAcquirerBankCode1 = 1;
	size_t soap_flag_paymentCardService1 = 1;
	size_t soap_flag_paymentCardServiceResult1 = 1;
	size_t soap_flag_transactionQualification1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "ns2:reasonCode", (wchar_t**)&a->ns2__CCAuthReply::reasonCode, "xsd:integer"))
				{	soap_flag_reasonCode1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__CCAuthReply::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_authorizationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authorizationCode", (wchar_t**)&a->ns2__CCAuthReply::authorizationCode, "xsd:string"))
				{	soap_flag_authorizationCode1--;
					continue;
				}
			if (soap_flag_avsCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:avsCode", (wchar_t**)&a->ns2__CCAuthReply::avsCode, "xsd:string"))
				{	soap_flag_avsCode1--;
					continue;
				}
			if (soap_flag_avsCodeRaw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:avsCodeRaw", (wchar_t**)&a->ns2__CCAuthReply::avsCodeRaw, "xsd:string"))
				{	soap_flag_avsCodeRaw1--;
					continue;
				}
			if (soap_flag_cvCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cvCode", (wchar_t**)&a->ns2__CCAuthReply::cvCode, "xsd:string"))
				{	soap_flag_cvCode1--;
					continue;
				}
			if (soap_flag_cvCodeRaw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cvCodeRaw", (wchar_t**)&a->ns2__CCAuthReply::cvCodeRaw, "xsd:string"))
				{	soap_flag_cvCodeRaw1--;
					continue;
				}
			if (soap_flag_personalIDCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:personalIDCode", (wchar_t**)&a->ns2__CCAuthReply::personalIDCode, "xsd:string"))
				{	soap_flag_personalIDCode1--;
					continue;
				}
			if (soap_flag_authorizedDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:authorizedDateTime", &a->ns2__CCAuthReply::authorizedDateTime, "ns2:dateTime"))
				{	soap_flag_authorizedDateTime1--;
					continue;
				}
			if (soap_flag_processorResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorResponse", (wchar_t**)&a->ns2__CCAuthReply::processorResponse, "xsd:string"))
				{	soap_flag_processorResponse1--;
					continue;
				}
			if (soap_flag_bmlAccountNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:bmlAccountNumber", (wchar_t**)&a->ns2__CCAuthReply::bmlAccountNumber, "xsd:string"))
				{	soap_flag_bmlAccountNumber1--;
					continue;
				}
			if (soap_flag_authFactorCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authFactorCode", (wchar_t**)&a->ns2__CCAuthReply::authFactorCode, "xsd:string"))
				{	soap_flag_authFactorCode1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__CCAuthReply::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_fundingTotals1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FundingTotals(soap, "ns2:fundingTotals", &a->ns2__CCAuthReply::fundingTotals, "ns2:FundingTotals"))
				{	soap_flag_fundingTotals1--;
					continue;
				}
			if (soap_flag_fxQuoteID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:fxQuoteID", (wchar_t**)&a->ns2__CCAuthReply::fxQuoteID, "xsd:string"))
				{	soap_flag_fxQuoteID1--;
					continue;
				}
			if (soap_flag_fxQuoteRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:fxQuoteRate", &a->ns2__CCAuthReply::fxQuoteRate, "ns2:dateTime"))
				{	soap_flag_fxQuoteRate1--;
					continue;
				}
			if (soap_flag_fxQuoteType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:fxQuoteType", (wchar_t**)&a->ns2__CCAuthReply::fxQuoteType, "xsd:string"))
				{	soap_flag_fxQuoteType1--;
					continue;
				}
			if (soap_flag_fxQuoteExpirationDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:fxQuoteExpirationDateTime", &a->ns2__CCAuthReply::fxQuoteExpirationDateTime, "ns2:dateTime"))
				{	soap_flag_fxQuoteExpirationDateTime1--;
					continue;
				}
			if (soap_flag_authRecord1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authRecord", (wchar_t**)&a->ns2__CCAuthReply::authRecord, "xsd:string"))
				{	soap_flag_authRecord1--;
					continue;
				}
			if (soap_flag_merchantAdviceCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantAdviceCode", (wchar_t**)&a->ns2__CCAuthReply::merchantAdviceCode, "xsd:string"))
				{	soap_flag_merchantAdviceCode1--;
					continue;
				}
			if (soap_flag_merchantAdviceCodeRaw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantAdviceCodeRaw", (wchar_t**)&a->ns2__CCAuthReply::merchantAdviceCodeRaw, "xsd:string"))
				{	soap_flag_merchantAdviceCodeRaw1--;
					continue;
				}
			if (soap_flag_cavvResponseCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cavvResponseCode", (wchar_t**)&a->ns2__CCAuthReply::cavvResponseCode, "xsd:string"))
				{	soap_flag_cavvResponseCode1--;
					continue;
				}
			if (soap_flag_cavvResponseCodeRaw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cavvResponseCodeRaw", (wchar_t**)&a->ns2__CCAuthReply::cavvResponseCodeRaw, "xsd:string"))
				{	soap_flag_cavvResponseCodeRaw1--;
					continue;
				}
			if (soap_flag_authenticationXID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authenticationXID", (wchar_t**)&a->ns2__CCAuthReply::authenticationXID, "xsd:string"))
				{	soap_flag_authenticationXID1--;
					continue;
				}
			if (soap_flag_authorizationXID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authorizationXID", (wchar_t**)&a->ns2__CCAuthReply::authorizationXID, "xsd:string"))
				{	soap_flag_authorizationXID1--;
					continue;
				}
			if (soap_flag_processorCardType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorCardType", (wchar_t**)&a->ns2__CCAuthReply::processorCardType, "xsd:string"))
				{	soap_flag_processorCardType1--;
					continue;
				}
			if (soap_flag_accountBalance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:accountBalance", &a->ns2__CCAuthReply::accountBalance, "ns2:amount"))
				{	soap_flag_accountBalance1--;
					continue;
				}
			if (soap_flag_forwardCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:forwardCode", (wchar_t**)&a->ns2__CCAuthReply::forwardCode, "xsd:string"))
				{	soap_flag_forwardCode1--;
					continue;
				}
			if (soap_flag_enhancedDataEnabled1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:enhancedDataEnabled", (wchar_t**)&a->ns2__CCAuthReply::enhancedDataEnabled, "xsd:string"))
				{	soap_flag_enhancedDataEnabled1--;
					continue;
				}
			if (soap_flag_referralResponseNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:referralResponseNumber", (wchar_t**)&a->ns2__CCAuthReply::referralResponseNumber, "xsd:string"))
				{	soap_flag_referralResponseNumber1--;
					continue;
				}
			if (soap_flag_subResponseCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:subResponseCode", (wchar_t**)&a->ns2__CCAuthReply::subResponseCode, "xsd:string"))
				{	soap_flag_subResponseCode1--;
					continue;
				}
			if (soap_flag_approvedAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:approvedAmount", (wchar_t**)&a->ns2__CCAuthReply::approvedAmount, "xsd:string"))
				{	soap_flag_approvedAmount1--;
					continue;
				}
			if (soap_flag_creditLine1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:creditLine", (wchar_t**)&a->ns2__CCAuthReply::creditLine, "xsd:string"))
				{	soap_flag_creditLine1--;
					continue;
				}
			if (soap_flag_approvedTerms1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:approvedTerms", (wchar_t**)&a->ns2__CCAuthReply::approvedTerms, "xsd:string"))
				{	soap_flag_approvedTerms1--;
					continue;
				}
			if (soap_flag_paymentNetworkTransactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentNetworkTransactionID", (wchar_t**)&a->ns2__CCAuthReply::paymentNetworkTransactionID, "xsd:string"))
				{	soap_flag_paymentNetworkTransactionID1--;
					continue;
				}
			if (soap_flag_cardCategory1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardCategory", (wchar_t**)&a->ns2__CCAuthReply::cardCategory, "xsd:string"))
				{	soap_flag_cardCategory1--;
					continue;
				}
			if (soap_flag_ownerMerchantID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ownerMerchantID", (wchar_t**)&a->ns2__CCAuthReply::ownerMerchantID, "xsd:string"))
				{	soap_flag_ownerMerchantID1--;
					continue;
				}
			if (soap_flag_requestAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:requestAmount", &a->ns2__CCAuthReply::requestAmount, "ns2:amount"))
				{	soap_flag_requestAmount1--;
					continue;
				}
			if (soap_flag_requestCurrency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:requestCurrency", (wchar_t**)&a->ns2__CCAuthReply::requestCurrency, "xsd:string"))
				{	soap_flag_requestCurrency1--;
					continue;
				}
			if (soap_flag_accountBalanceCurrency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:accountBalanceCurrency", (wchar_t**)&a->ns2__CCAuthReply::accountBalanceCurrency, "xsd:string"))
				{	soap_flag_accountBalanceCurrency1--;
					continue;
				}
			if (soap_flag_accountBalanceSign1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:accountBalanceSign", (wchar_t**)&a->ns2__CCAuthReply::accountBalanceSign, "xsd:string"))
				{	soap_flag_accountBalanceSign1--;
					continue;
				}
			if (soap_flag_amountType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:amountType", (wchar_t**)&a->ns2__CCAuthReply::amountType, "xsd:string"))
				{	soap_flag_amountType1--;
					continue;
				}
			if (soap_flag_accountType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:accountType", (wchar_t**)&a->ns2__CCAuthReply::accountType, "xsd:string"))
				{	soap_flag_accountType1--;
					continue;
				}
			if (soap_flag_affluenceIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:affluenceIndicator", (wchar_t**)&a->ns2__CCAuthReply::affluenceIndicator, "xsd:string"))
				{	soap_flag_affluenceIndicator1--;
					continue;
				}
			if (soap_flag_evEmail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:evEmail", (wchar_t**)&a->ns2__CCAuthReply::evEmail, "xsd:string"))
				{	soap_flag_evEmail1--;
					continue;
				}
			if (soap_flag_evPhoneNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:evPhoneNumber", (wchar_t**)&a->ns2__CCAuthReply::evPhoneNumber, "xsd:string"))
				{	soap_flag_evPhoneNumber1--;
					continue;
				}
			if (soap_flag_evPostalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:evPostalCode", (wchar_t**)&a->ns2__CCAuthReply::evPostalCode, "xsd:string"))
				{	soap_flag_evPostalCode1--;
					continue;
				}
			if (soap_flag_evName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:evName", (wchar_t**)&a->ns2__CCAuthReply::evName, "xsd:string"))
				{	soap_flag_evName1--;
					continue;
				}
			if (soap_flag_evStreet1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:evStreet", (wchar_t**)&a->ns2__CCAuthReply::evStreet, "xsd:string"))
				{	soap_flag_evStreet1--;
					continue;
				}
			if (soap_flag_evEmailRaw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:evEmailRaw", (wchar_t**)&a->ns2__CCAuthReply::evEmailRaw, "xsd:string"))
				{	soap_flag_evEmailRaw1--;
					continue;
				}
			if (soap_flag_evPhoneNumberRaw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:evPhoneNumberRaw", (wchar_t**)&a->ns2__CCAuthReply::evPhoneNumberRaw, "xsd:string"))
				{	soap_flag_evPhoneNumberRaw1--;
					continue;
				}
			if (soap_flag_evPostalCodeRaw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:evPostalCodeRaw", (wchar_t**)&a->ns2__CCAuthReply::evPostalCodeRaw, "xsd:string"))
				{	soap_flag_evPostalCodeRaw1--;
					continue;
				}
			if (soap_flag_evNameRaw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:evNameRaw", (wchar_t**)&a->ns2__CCAuthReply::evNameRaw, "xsd:string"))
				{	soap_flag_evNameRaw1--;
					continue;
				}
			if (soap_flag_evStreetRaw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:evStreetRaw", (wchar_t**)&a->ns2__CCAuthReply::evStreetRaw, "xsd:string"))
				{	soap_flag_evStreetRaw1--;
					continue;
				}
			if (soap_flag_cardGroup1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardGroup", (wchar_t**)&a->ns2__CCAuthReply::cardGroup, "xsd:string"))
				{	soap_flag_cardGroup1--;
					continue;
				}
			if (soap_flag_posData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:posData", (wchar_t**)&a->ns2__CCAuthReply::posData, "xsd:string"))
				{	soap_flag_posData1--;
					continue;
				}
			if (soap_flag_transactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionID", (wchar_t**)&a->ns2__CCAuthReply::transactionID, "xsd:string"))
				{	soap_flag_transactionID1--;
					continue;
				}
			if (soap_flag_cardIssuerCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardIssuerCountry", (wchar_t**)&a->ns2__CCAuthReply::cardIssuerCountry, "xsd:string"))
				{	soap_flag_cardIssuerCountry1--;
					continue;
				}
			if (soap_flag_cardRegulated1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardRegulated", (wchar_t**)&a->ns2__CCAuthReply::cardRegulated, "xsd:string"))
				{	soap_flag_cardRegulated1--;
					continue;
				}
			if (soap_flag_cardCommercial1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardCommercial", (wchar_t**)&a->ns2__CCAuthReply::cardCommercial, "xsd:string"))
				{	soap_flag_cardCommercial1--;
					continue;
				}
			if (soap_flag_cardPrepaid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardPrepaid", (wchar_t**)&a->ns2__CCAuthReply::cardPrepaid, "xsd:string"))
				{	soap_flag_cardPrepaid1--;
					continue;
				}
			if (soap_flag_cardPayroll1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardPayroll", (wchar_t**)&a->ns2__CCAuthReply::cardPayroll, "xsd:string"))
				{	soap_flag_cardPayroll1--;
					continue;
				}
			if (soap_flag_cardHealthcare1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardHealthcare", (wchar_t**)&a->ns2__CCAuthReply::cardHealthcare, "xsd:string"))
				{	soap_flag_cardHealthcare1--;
					continue;
				}
			if (soap_flag_cardSignatureDebit1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardSignatureDebit", (wchar_t**)&a->ns2__CCAuthReply::cardSignatureDebit, "xsd:string"))
				{	soap_flag_cardSignatureDebit1--;
					continue;
				}
			if (soap_flag_cardPINlessDebit1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardPINlessDebit", (wchar_t**)&a->ns2__CCAuthReply::cardPINlessDebit, "xsd:string"))
				{	soap_flag_cardPINlessDebit1--;
					continue;
				}
			if (soap_flag_cardLevel3Eligible1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardLevel3Eligible", (wchar_t**)&a->ns2__CCAuthReply::cardLevel3Eligible, "xsd:string"))
				{	soap_flag_cardLevel3Eligible1--;
					continue;
				}
			if (soap_flag_processorTransactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorTransactionID", (wchar_t**)&a->ns2__CCAuthReply::processorTransactionID, "xsd:string"))
				{	soap_flag_processorTransactionID1--;
					continue;
				}
			if (soap_flag_providerReasonCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:providerReasonCode", (wchar_t**)&a->ns2__CCAuthReply::providerReasonCode, "xsd:string"))
				{	soap_flag_providerReasonCode1--;
					continue;
				}
			if (soap_flag_providerReasonDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:providerReasonDescription", (wchar_t**)&a->ns2__CCAuthReply::providerReasonDescription, "xsd:string"))
				{	soap_flag_providerReasonDescription1--;
					continue;
				}
			if (soap_flag_providerPassThroughData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:providerPassThroughData", (wchar_t**)&a->ns2__CCAuthReply::providerPassThroughData, "xsd:string"))
				{	soap_flag_providerPassThroughData1--;
					continue;
				}
			if (soap_flag_providerCVNResponseCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:providerCVNResponseCode", (wchar_t**)&a->ns2__CCAuthReply::providerCVNResponseCode, "xsd:string"))
				{	soap_flag_providerCVNResponseCode1--;
					continue;
				}
			if (soap_flag_providerAVSResponseCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:providerAVSResponseCode", (wchar_t**)&a->ns2__CCAuthReply::providerAVSResponseCode, "xsd:string"))
				{	soap_flag_providerAVSResponseCode1--;
					continue;
				}
			if (soap_flag_providerAcquirerBankCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:providerAcquirerBankCode", (wchar_t**)&a->ns2__CCAuthReply::providerAcquirerBankCode, "xsd:string"))
				{	soap_flag_providerAcquirerBankCode1--;
					continue;
				}
			if (soap_flag_paymentCardService1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentCardService", (wchar_t**)&a->ns2__CCAuthReply::paymentCardService, "xsd:string"))
				{	soap_flag_paymentCardService1--;
					continue;
				}
			if (soap_flag_paymentCardServiceResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentCardServiceResult", (wchar_t**)&a->ns2__CCAuthReply::paymentCardServiceResult, "xsd:string"))
				{	soap_flag_paymentCardServiceResult1--;
					continue;
				}
			if (soap_flag_transactionQualification1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionQualification", (wchar_t**)&a->ns2__CCAuthReply::transactionQualification, "xsd:string"))
				{	soap_flag_transactionQualification1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reasonCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns2__CCAuthReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CCAuthReply, SOAP_TYPE_ns2__CCAuthReply, sizeof(ns2__CCAuthReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CCAuthReply * SOAP_FMAC2 soap_instantiate_ns2__CCAuthReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CCAuthReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CCAuthReply *p;
	size_t k = sizeof(ns2__CCAuthReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CCAuthReply);
		if (p)
			((ns2__CCAuthReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CCAuthReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CCAuthReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CCAuthReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CCAuthReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CCAuthReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CCAuthReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CCAuthReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CCAuthReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CCAuthReply * SOAP_FMAC4 soap_get_ns2__CCAuthReply(struct soap *soap, ns2__CCAuthReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CCAuthReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PromotionGroupReply::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PromotionGroupReply::discountApplied = NULL;
	this->ns2__PromotionGroupReply::id = NULL;
	/* transient soap skipped */
}

void ns2__PromotionGroupReply::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__amount(soap, &this->ns2__PromotionGroupReply::discountApplied);
#endif
}

int ns2__PromotionGroupReply::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PromotionGroupReply(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PromotionGroupReply(struct soap *soap, const char *tag, int id, const ns2__PromotionGroupReply *a, const char *type)
{
	if (((ns2__PromotionGroupReply*)a)->id)
		if (*((ns2__PromotionGroupReply*)a)->id)
			soap_set_attr(soap, "id", soap_xsd__integer2s(soap, *((ns2__PromotionGroupReply*)a)->id), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PromotionGroupReply), type))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:discountApplied", -1, &a->ns2__PromotionGroupReply::discountApplied, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PromotionGroupReply::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PromotionGroupReply(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PromotionGroupReply * SOAP_FMAC4 soap_in_ns2__PromotionGroupReply(struct soap *soap, const char *tag, ns2__PromotionGroupReply *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PromotionGroupReply *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PromotionGroupReply, sizeof(ns2__PromotionGroupReply), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PromotionGroupReply)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PromotionGroupReply *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "id", 0);
		if (t)
		{
			if (!(((ns2__PromotionGroupReply*)a)->id = (wchar_t **)soap_malloc(soap, sizeof(wchar_t *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__integer(soap, t, ((ns2__PromotionGroupReply*)a)->id))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_discountApplied1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_discountApplied1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:discountApplied", &a->ns2__PromotionGroupReply::discountApplied, "ns2:amount"))
				{	soap_flag_discountApplied1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PromotionGroupReply *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PromotionGroupReply, SOAP_TYPE_ns2__PromotionGroupReply, sizeof(ns2__PromotionGroupReply), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PromotionGroupReply * SOAP_FMAC2 soap_instantiate_ns2__PromotionGroupReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PromotionGroupReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PromotionGroupReply *p;
	size_t k = sizeof(ns2__PromotionGroupReply);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PromotionGroupReply);
		if (p)
			((ns2__PromotionGroupReply*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PromotionGroupReply, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PromotionGroupReply*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PromotionGroupReply location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PromotionGroupReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PromotionGroupReply::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PromotionGroupReply", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PromotionGroupReply::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PromotionGroupReply(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PromotionGroupReply * SOAP_FMAC4 soap_get_ns2__PromotionGroupReply(struct soap *soap, ns2__PromotionGroupReply *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PromotionGroupReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PromotionGroup::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PromotionGroup::subtotalAmount = NULL;
	this->ns2__PromotionGroup::taxRate = NULL;
	this->ns2__PromotionGroup::id = NULL;
	/* transient soap skipped */
}

void ns2__PromotionGroup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__amount(soap, &this->ns2__PromotionGroup::subtotalAmount);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__PromotionGroup::taxRate);
#endif
}

int ns2__PromotionGroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PromotionGroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PromotionGroup(struct soap *soap, const char *tag, int id, const ns2__PromotionGroup *a, const char *type)
{
	if (((ns2__PromotionGroup*)a)->id)
		if (*((ns2__PromotionGroup*)a)->id)
			soap_set_attr(soap, "id", soap_xsd__integer2s(soap, *((ns2__PromotionGroup*)a)->id), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PromotionGroup), type))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:subtotalAmount", -1, &a->ns2__PromotionGroup::subtotalAmount, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:taxRate", -1, &a->ns2__PromotionGroup::taxRate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PromotionGroup::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PromotionGroup(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PromotionGroup * SOAP_FMAC4 soap_in_ns2__PromotionGroup(struct soap *soap, const char *tag, ns2__PromotionGroup *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PromotionGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PromotionGroup, sizeof(ns2__PromotionGroup), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PromotionGroup)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PromotionGroup *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "id", 0);
		if (t)
		{
			if (!(((ns2__PromotionGroup*)a)->id = (wchar_t **)soap_malloc(soap, sizeof(wchar_t *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__integer(soap, t, ((ns2__PromotionGroup*)a)->id))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_subtotalAmount1 = 1;
	size_t soap_flag_taxRate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_subtotalAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:subtotalAmount", &a->ns2__PromotionGroup::subtotalAmount, "ns2:amount"))
				{	soap_flag_subtotalAmount1--;
					continue;
				}
			if (soap_flag_taxRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:taxRate", &a->ns2__PromotionGroup::taxRate, "ns2:amount"))
				{	soap_flag_taxRate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PromotionGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PromotionGroup, SOAP_TYPE_ns2__PromotionGroup, sizeof(ns2__PromotionGroup), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PromotionGroup * SOAP_FMAC2 soap_instantiate_ns2__PromotionGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PromotionGroup(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PromotionGroup *p;
	size_t k = sizeof(ns2__PromotionGroup);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PromotionGroup);
		if (p)
			((ns2__PromotionGroup*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PromotionGroup, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PromotionGroup*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PromotionGroup location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PromotionGroup, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PromotionGroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PromotionGroup", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PromotionGroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PromotionGroup(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PromotionGroup * SOAP_FMAC4 soap_get_ns2__PromotionGroup(struct soap *soap, ns2__PromotionGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PromotionGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Promotion::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Promotion::discountedAmount = NULL;
	this->ns2__Promotion::type = NULL;
	this->ns2__Promotion::code = NULL;
	this->ns2__Promotion::receiptData = NULL;
	this->ns2__Promotion::discountApplied = NULL;
	this->ns2__Promotion::description = NULL;
	/* transient soap skipped */
}

void ns2__Promotion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Promotion::discountedAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Promotion::type);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Promotion::code);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Promotion::receiptData);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Promotion::discountApplied);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Promotion::description);
#endif
}

int ns2__Promotion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Promotion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Promotion(struct soap *soap, const char *tag, int id, const ns2__Promotion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Promotion), type))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:discountedAmount", -1, &a->ns2__Promotion::discountedAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:type", -1, (wchar_t*const*)&a->ns2__Promotion::type, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:code", -1, (wchar_t*const*)&a->ns2__Promotion::code, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:receiptData", -1, (wchar_t*const*)&a->ns2__Promotion::receiptData, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:discountApplied", -1, &a->ns2__Promotion::discountApplied, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:description", -1, (wchar_t*const*)&a->ns2__Promotion::description, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Promotion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Promotion(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Promotion * SOAP_FMAC4 soap_in_ns2__Promotion(struct soap *soap, const char *tag, ns2__Promotion *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Promotion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Promotion, sizeof(ns2__Promotion), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Promotion)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Promotion *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_discountedAmount1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_code1 = 1;
	size_t soap_flag_receiptData1 = 1;
	size_t soap_flag_discountApplied1 = 1;
	size_t soap_flag_description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_discountedAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:discountedAmount", &a->ns2__Promotion::discountedAmount, "ns2:amount"))
				{	soap_flag_discountedAmount1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:type", (wchar_t**)&a->ns2__Promotion::type, "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:code", (wchar_t**)&a->ns2__Promotion::code, "xsd:string"))
				{	soap_flag_code1--;
					continue;
				}
			if (soap_flag_receiptData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:receiptData", (wchar_t**)&a->ns2__Promotion::receiptData, "xsd:string"))
				{	soap_flag_receiptData1--;
					continue;
				}
			if (soap_flag_discountApplied1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:discountApplied", &a->ns2__Promotion::discountApplied, "ns2:amount"))
				{	soap_flag_discountApplied1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:description", (wchar_t**)&a->ns2__Promotion::description, "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Promotion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Promotion, SOAP_TYPE_ns2__Promotion, sizeof(ns2__Promotion), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Promotion * SOAP_FMAC2 soap_instantiate_ns2__Promotion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Promotion(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Promotion *p;
	size_t k = sizeof(ns2__Promotion);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Promotion);
		if (p)
			((ns2__Promotion*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Promotion, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Promotion*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Promotion location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Promotion, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Promotion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:Promotion", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Promotion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Promotion(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Promotion * SOAP_FMAC4 soap_get_ns2__Promotion(struct soap *soap, ns2__Promotion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Promotion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DCC::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DCC::dccIndicator = NULL;
	this->ns2__DCC::referenceNumber = NULL;
	/* transient soap skipped */
}

void ns2__DCC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__DCC::dccIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DCC::referenceNumber);
#endif
}

int ns2__DCC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DCC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DCC(struct soap *soap, const char *tag, int id, const ns2__DCC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DCC), type))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:dccIndicator", -1, &a->ns2__DCC::dccIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:referenceNumber", -1, (wchar_t*const*)&a->ns2__DCC::referenceNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DCC::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DCC(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DCC * SOAP_FMAC4 soap_in_ns2__DCC(struct soap *soap, const char *tag, ns2__DCC *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DCC *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DCC, sizeof(ns2__DCC), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DCC)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DCC *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dccIndicator1 = 1;
	size_t soap_flag_referenceNumber1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dccIndicator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:dccIndicator", &a->ns2__DCC::dccIndicator, "xsd:integer"))
				{	soap_flag_dccIndicator1--;
					continue;
				}
			if (soap_flag_referenceNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:referenceNumber", (wchar_t**)&a->ns2__DCC::referenceNumber, "xsd:string"))
				{	soap_flag_referenceNumber1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DCC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DCC, SOAP_TYPE_ns2__DCC, sizeof(ns2__DCC), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DCC * SOAP_FMAC2 soap_instantiate_ns2__DCC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DCC(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DCC *p;
	size_t k = sizeof(ns2__DCC);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DCC);
		if (p)
			((ns2__DCC*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DCC, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DCC*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DCC location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DCC, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DCC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:DCC", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DCC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DCC(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DCC * SOAP_FMAC4 soap_get_ns2__DCC(struct soap *soap, ns2__DCC *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DCC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DecryptVisaCheckoutDataService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DecryptVisaCheckoutDataService::run = NULL;
	/* transient soap skipped */
}

void ns2__DecryptVisaCheckoutDataService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__DecryptVisaCheckoutDataService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DecryptVisaCheckoutDataService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DecryptVisaCheckoutDataService(struct soap *soap, const char *tag, int id, const ns2__DecryptVisaCheckoutDataService *a, const char *type)
{
	if (((ns2__DecryptVisaCheckoutDataService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__DecryptVisaCheckoutDataService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DecryptVisaCheckoutDataService), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DecryptVisaCheckoutDataService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DecryptVisaCheckoutDataService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DecryptVisaCheckoutDataService * SOAP_FMAC4 soap_in_ns2__DecryptVisaCheckoutDataService(struct soap *soap, const char *tag, ns2__DecryptVisaCheckoutDataService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DecryptVisaCheckoutDataService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DecryptVisaCheckoutDataService, sizeof(ns2__DecryptVisaCheckoutDataService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DecryptVisaCheckoutDataService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DecryptVisaCheckoutDataService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__DecryptVisaCheckoutDataService*)a)->run))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DecryptVisaCheckoutDataService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DecryptVisaCheckoutDataService, SOAP_TYPE_ns2__DecryptVisaCheckoutDataService, sizeof(ns2__DecryptVisaCheckoutDataService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DecryptVisaCheckoutDataService * SOAP_FMAC2 soap_instantiate_ns2__DecryptVisaCheckoutDataService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DecryptVisaCheckoutDataService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DecryptVisaCheckoutDataService *p;
	size_t k = sizeof(ns2__DecryptVisaCheckoutDataService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DecryptVisaCheckoutDataService);
		if (p)
			((ns2__DecryptVisaCheckoutDataService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DecryptVisaCheckoutDataService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DecryptVisaCheckoutDataService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DecryptVisaCheckoutDataService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DecryptVisaCheckoutDataService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DecryptVisaCheckoutDataService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:DecryptVisaCheckoutDataService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DecryptVisaCheckoutDataService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DecryptVisaCheckoutDataService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DecryptVisaCheckoutDataService * SOAP_FMAC4 soap_get_ns2__DecryptVisaCheckoutDataService(struct soap *soap, ns2__DecryptVisaCheckoutDataService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DecryptVisaCheckoutDataService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__VC::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__VC::orderID = NULL;
	/* transient soap skipped */
}

void ns2__VC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VC::orderID);
#endif
}

int ns2__VC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__VC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VC(struct soap *soap, const char *tag, int id, const ns2__VC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VC), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderID", -1, (wchar_t*const*)&a->ns2__VC::orderID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__VC::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__VC(soap, tag, this, type);
}

SOAP_FMAC3 ns2__VC * SOAP_FMAC4 soap_in_ns2__VC(struct soap *soap, const char *tag, ns2__VC *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__VC *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VC, sizeof(ns2__VC), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__VC)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__VC *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_orderID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_orderID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderID", (wchar_t**)&a->ns2__VC::orderID, "xsd:string"))
				{	soap_flag_orderID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__VC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VC, SOAP_TYPE_ns2__VC, sizeof(ns2__VC), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__VC * SOAP_FMAC2 soap_instantiate_ns2__VC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__VC(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__VC *p;
	size_t k = sizeof(ns2__VC);
	if (n < 0)
	{	p = SOAP_NEW(ns2__VC);
		if (p)
			((ns2__VC*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__VC, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__VC*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__VC location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__VC, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__VC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:VC", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__VC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__VC(soap, this, tag, type);
}

SOAP_FMAC3 ns2__VC * SOAP_FMAC4 soap_get_ns2__VC(struct soap *soap, ns2__VC *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__RequestMessage::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RequestMessage::merchantID = NULL;
	this->ns2__RequestMessage::merchantReferenceCode = NULL;
	this->ns2__RequestMessage::debtIndicator = NULL;
	this->ns2__RequestMessage::clientLibrary = NULL;
	this->ns2__RequestMessage::clientLibraryVersion = NULL;
	this->ns2__RequestMessage::clientEnvironment = NULL;
	this->ns2__RequestMessage::clientSecurityLibraryVersion = NULL;
	this->ns2__RequestMessage::clientApplication = NULL;
	this->ns2__RequestMessage::clientApplicationVersion = NULL;
	this->ns2__RequestMessage::clientApplicationUser = NULL;
	this->ns2__RequestMessage::routingCode = NULL;
	this->ns2__RequestMessage::comments = NULL;
	this->ns2__RequestMessage::returnURL = NULL;
	this->ns2__RequestMessage::invoiceHeader = NULL;
	this->ns2__RequestMessage::aggregatorMerchantIdentifier = NULL;
	this->ns2__RequestMessage::customerID = NULL;
	this->ns2__RequestMessage::customerFirstName = NULL;
	this->ns2__RequestMessage::customerLastName = NULL;
	this->ns2__RequestMessage::billTo = NULL;
	this->ns2__RequestMessage::shipTo = NULL;
	this->ns2__RequestMessage::personalId = NULL;
	this->ns2__RequestMessage::shipFrom = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__Item(soap, &this->ns2__RequestMessage::item);
	this->ns2__RequestMessage::purchaseTotals = NULL;
	this->ns2__RequestMessage::fundingTotals = NULL;
	this->ns2__RequestMessage::dcc = NULL;
	this->ns2__RequestMessage::pos = NULL;
	this->ns2__RequestMessage::encryptedPayment = NULL;
	this->ns2__RequestMessage::installment = NULL;
	this->ns2__RequestMessage::card = NULL;
	this->ns2__RequestMessage::check = NULL;
	this->ns2__RequestMessage::bml = NULL;
	this->ns2__RequestMessage::gecc = NULL;
	this->ns2__RequestMessage::ucaf = NULL;
	this->ns2__RequestMessage::fundTransfer = NULL;
	this->ns2__RequestMessage::bankInfo = NULL;
	this->ns2__RequestMessage::subscription = NULL;
	this->ns2__RequestMessage::recurringSubscriptionInfo = NULL;
	this->ns2__RequestMessage::decisionManager = NULL;
	this->ns2__RequestMessage::otherTax = NULL;
	this->ns2__RequestMessage::paypal = NULL;
	this->ns2__RequestMessage::merchantDefinedData = NULL;
	this->ns2__RequestMessage::merchantSecureData = NULL;
	this->ns2__RequestMessage::jpo = NULL;
	this->ns2__RequestMessage::orderRequestToken = NULL;
	this->ns2__RequestMessage::linkToRequest = NULL;
	this->ns2__RequestMessage::serviceFee = NULL;
	this->ns2__RequestMessage::ccAuthService = NULL;
	this->ns2__RequestMessage::octService = NULL;
	this->ns2__RequestMessage::verificationService = NULL;
	this->ns2__RequestMessage::ccSaleService = NULL;
	this->ns2__RequestMessage::ccSaleCreditService = NULL;
	this->ns2__RequestMessage::ccSaleReversalService = NULL;
	this->ns2__RequestMessage::ccIncrementalAuthService = NULL;
	this->ns2__RequestMessage::ccCaptureService = NULL;
	this->ns2__RequestMessage::ccCreditService = NULL;
	this->ns2__RequestMessage::ccAuthReversalService = NULL;
	this->ns2__RequestMessage::ccAutoAuthReversalService = NULL;
	this->ns2__RequestMessage::ccDCCService = NULL;
	this->ns2__RequestMessage::serviceFeeCalculateService = NULL;
	this->ns2__RequestMessage::ecDebitService = NULL;
	this->ns2__RequestMessage::ecCreditService = NULL;
	this->ns2__RequestMessage::ecAuthenticateService = NULL;
	this->ns2__RequestMessage::payerAuthEnrollService = NULL;
	this->ns2__RequestMessage::payerAuthValidateService = NULL;
	this->ns2__RequestMessage::taxService = NULL;
	this->ns2__RequestMessage::dmeService = NULL;
	this->ns2__RequestMessage::afsService = NULL;
	this->ns2__RequestMessage::davService = NULL;
	this->ns2__RequestMessage::exportService = NULL;
	this->ns2__RequestMessage::fxRatesService = NULL;
	this->ns2__RequestMessage::bankTransferService = NULL;
	this->ns2__RequestMessage::bankTransferRefundService = NULL;
	this->ns2__RequestMessage::bankTransferRealTimeService = NULL;
	this->ns2__RequestMessage::directDebitMandateService = NULL;
	this->ns2__RequestMessage::directDebitService = NULL;
	this->ns2__RequestMessage::directDebitRefundService = NULL;
	this->ns2__RequestMessage::directDebitValidateService = NULL;
	this->ns2__RequestMessage::paySubscriptionCreateService = NULL;
	this->ns2__RequestMessage::paySubscriptionUpdateService = NULL;
	this->ns2__RequestMessage::paySubscriptionEventUpdateService = NULL;
	this->ns2__RequestMessage::paySubscriptionRetrieveService = NULL;
	this->ns2__RequestMessage::paySubscriptionDeleteService = NULL;
	this->ns2__RequestMessage::payPalPaymentService = NULL;
	this->ns2__RequestMessage::payPalCreditService = NULL;
	this->ns2__RequestMessage::voidService = NULL;
	this->ns2__RequestMessage::businessRules = NULL;
	this->ns2__RequestMessage::pinlessDebitService = NULL;
	this->ns2__RequestMessage::pinlessDebitValidateService = NULL;
	this->ns2__RequestMessage::pinlessDebitReversalService = NULL;
	this->ns2__RequestMessage::batch = NULL;
	this->ns2__RequestMessage::airlineData = NULL;
	this->ns2__RequestMessage::ancillaryData = NULL;
	this->ns2__RequestMessage::lodgingData = NULL;
	this->ns2__RequestMessage::payPalButtonCreateService = NULL;
	this->ns2__RequestMessage::payPalPreapprovedPaymentService = NULL;
	this->ns2__RequestMessage::payPalPreapprovedUpdateService = NULL;
	this->ns2__RequestMessage::riskUpdateService = NULL;
	this->ns2__RequestMessage::fraudUpdateService = NULL;
	this->ns2__RequestMessage::caseManagementActionService = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__RequestReserved(soap, &this->ns2__RequestMessage::reserved);
	this->ns2__RequestMessage::deviceFingerprintID = NULL;
	this->ns2__RequestMessage::deviceFingerprintRaw = NULL;
	this->ns2__RequestMessage::deviceFingerprintHash = NULL;
	this->ns2__RequestMessage::payPalRefundService = NULL;
	this->ns2__RequestMessage::payPalAuthReversalService = NULL;
	this->ns2__RequestMessage::payPalDoCaptureService = NULL;
	this->ns2__RequestMessage::payPalEcDoPaymentService = NULL;
	this->ns2__RequestMessage::payPalEcGetDetailsService = NULL;
	this->ns2__RequestMessage::payPalEcSetService = NULL;
	this->ns2__RequestMessage::payPalEcOrderSetupService = NULL;
	this->ns2__RequestMessage::payPalAuthorizationService = NULL;
	this->ns2__RequestMessage::payPalUpdateAgreementService = NULL;
	this->ns2__RequestMessage::payPalCreateAgreementService = NULL;
	this->ns2__RequestMessage::payPalDoRefTransactionService = NULL;
	this->ns2__RequestMessage::chinaPaymentService = NULL;
	this->ns2__RequestMessage::chinaRefundService = NULL;
	this->ns2__RequestMessage::boletoPaymentService = NULL;
	this->ns2__RequestMessage::apPaymentType = NULL;
	this->ns2__RequestMessage::apInitiateService = NULL;
	this->ns2__RequestMessage::apCheckStatusService = NULL;
	this->ns2__RequestMessage::ignoreCardExpiration = NULL;
	this->ns2__RequestMessage::reportGroup = NULL;
	this->ns2__RequestMessage::processorID = NULL;
	this->ns2__RequestMessage::thirdPartyCertificationNumber = NULL;
	this->ns2__RequestMessage::transactionLocalDateTime = NULL;
	this->ns2__RequestMessage::solutionProviderTransactionID = NULL;
	this->ns2__RequestMessage::surchargeAmount = NULL;
	this->ns2__RequestMessage::surchargeSign = NULL;
	this->ns2__RequestMessage::pinDataEncryptedPIN = NULL;
	this->ns2__RequestMessage::pinDataKeySerialNumber = NULL;
	this->ns2__RequestMessage::cashbackAmount = NULL;
	this->ns2__RequestMessage::pinDebitPurchaseService = NULL;
	this->ns2__RequestMessage::pinDebitCreditService = NULL;
	this->ns2__RequestMessage::pinDebitReversalService = NULL;
	this->ns2__RequestMessage::ap = NULL;
	this->ns2__RequestMessage::apAuthService = NULL;
	this->ns2__RequestMessage::apAuthReversalService = NULL;
	this->ns2__RequestMessage::apCaptureService = NULL;
	this->ns2__RequestMessage::apOptionsService = NULL;
	this->ns2__RequestMessage::apRefundService = NULL;
	this->ns2__RequestMessage::apSaleService = NULL;
	this->ns2__RequestMessage::apCheckoutDetailsService = NULL;
	this->ns2__RequestMessage::apTransactionDetailsService = NULL;
	this->ns2__RequestMessage::apConfirmPurchaseService = NULL;
	this->ns2__RequestMessage::payPalGetTxnDetailsService = NULL;
	this->ns2__RequestMessage::payPalTransactionSearchService = NULL;
	this->ns2__RequestMessage::ccDCCUpdateService = NULL;
	this->ns2__RequestMessage::emvRequest = NULL;
	this->ns2__RequestMessage::merchantTransactionIdentifier = NULL;
	this->ns2__RequestMessage::hostedDataCreateService = NULL;
	this->ns2__RequestMessage::hostedDataRetrieveService = NULL;
	this->ns2__RequestMessage::merchantCategoryCode = NULL;
	this->ns2__RequestMessage::salesSlipNumber = NULL;
	this->ns2__RequestMessage::merchandiseCode = NULL;
	this->ns2__RequestMessage::merchandiseDescription = NULL;
	this->ns2__RequestMessage::paymentInitiationChannel = NULL;
	this->ns2__RequestMessage::extendedCreditTotalCount = NULL;
	this->ns2__RequestMessage::authIndicator = NULL;
	this->ns2__RequestMessage::paymentNetworkToken = NULL;
	this->ns2__RequestMessage::recipient = NULL;
	this->ns2__RequestMessage::sender = NULL;
	this->ns2__RequestMessage::autoRentalData = NULL;
	this->ns2__RequestMessage::paymentSolution = NULL;
	this->ns2__RequestMessage::vc = NULL;
	this->ns2__RequestMessage::decryptVisaCheckoutDataService = NULL;
	this->ns2__RequestMessage::taxManagementIndicator = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__PromotionGroup(soap, &this->ns2__RequestMessage::promotionGroup);
	this->ns2__RequestMessage::wallet = NULL;
	this->ns2__RequestMessage::aft = NULL;
	this->ns2__RequestMessage::balanceInquiry = NULL;
	this->ns2__RequestMessage::prenoteTransaction = NULL;
	this->ns2__RequestMessage::encryptPaymentDataService = NULL;
	this->ns2__RequestMessage::nationalNetDomesticData = NULL;
	this->ns2__RequestMessage::subsequentAuth = NULL;
	this->ns2__RequestMessage::binLookupService = NULL;
	this->ns2__RequestMessage::verificationCode = NULL;
	this->ns2__RequestMessage::mobileNumber = NULL;
	this->ns2__RequestMessage::issuer = NULL;
	this->ns2__RequestMessage::partnerSolutionID = NULL;
	this->ns2__RequestMessage::developerID = NULL;
	/* transient soap skipped */
}

void ns2__RequestMessage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::merchantID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::merchantReferenceCode);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__RequestMessage::debtIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::clientLibrary);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::clientLibraryVersion);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::clientEnvironment);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::clientSecurityLibraryVersion);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::clientApplication);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::clientApplicationVersion);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::clientApplicationUser);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::routingCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::comments);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::returnURL);
	soap_serialize_PointerTons2__InvoiceHeader(soap, &this->ns2__RequestMessage::invoiceHeader);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::aggregatorMerchantIdentifier);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::customerID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::customerFirstName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::customerLastName);
	soap_serialize_PointerTons2__BillTo(soap, &this->ns2__RequestMessage::billTo);
	soap_serialize_PointerTons2__ShipTo(soap, &this->ns2__RequestMessage::shipTo);
	soap_serialize_PointerTons2__PersonalId(soap, &this->ns2__RequestMessage::personalId);
	soap_serialize_PointerTons2__ShipFrom(soap, &this->ns2__RequestMessage::shipFrom);
	soap_serialize_std__vectorTemplateOfPointerTons2__Item(soap, &this->ns2__RequestMessage::item);
	soap_serialize_PointerTons2__PurchaseTotals(soap, &this->ns2__RequestMessage::purchaseTotals);
	soap_serialize_PointerTons2__FundingTotals(soap, &this->ns2__RequestMessage::fundingTotals);
	soap_serialize_PointerTons2__DCC(soap, &this->ns2__RequestMessage::dcc);
	soap_serialize_PointerTons2__Pos(soap, &this->ns2__RequestMessage::pos);
	soap_serialize_PointerTons2__EncryptedPayment(soap, &this->ns2__RequestMessage::encryptedPayment);
	soap_serialize_PointerTons2__Installment(soap, &this->ns2__RequestMessage::installment);
	soap_serialize_PointerTons2__Card(soap, &this->ns2__RequestMessage::card);
	soap_serialize_PointerTons2__Check(soap, &this->ns2__RequestMessage::check);
	soap_serialize_PointerTons2__BML(soap, &this->ns2__RequestMessage::bml);
	soap_serialize_PointerTons2__GECC(soap, &this->ns2__RequestMessage::gecc);
	soap_serialize_PointerTons2__UCAF(soap, &this->ns2__RequestMessage::ucaf);
	soap_serialize_PointerTons2__FundTransfer(soap, &this->ns2__RequestMessage::fundTransfer);
	soap_serialize_PointerTons2__BankInfo(soap, &this->ns2__RequestMessage::bankInfo);
	soap_serialize_PointerTons2__Subscription(soap, &this->ns2__RequestMessage::subscription);
	soap_serialize_PointerTons2__RecurringSubscriptionInfo(soap, &this->ns2__RequestMessage::recurringSubscriptionInfo);
	soap_serialize_PointerTons2__DecisionManager(soap, &this->ns2__RequestMessage::decisionManager);
	soap_serialize_PointerTons2__OtherTax(soap, &this->ns2__RequestMessage::otherTax);
	soap_serialize_PointerTons2__PayPal(soap, &this->ns2__RequestMessage::paypal);
	soap_serialize_PointerTons2__MerchantDefinedData(soap, &this->ns2__RequestMessage::merchantDefinedData);
	soap_serialize_PointerTons2__MerchantSecureData(soap, &this->ns2__RequestMessage::merchantSecureData);
	soap_serialize_PointerTons2__JPO(soap, &this->ns2__RequestMessage::jpo);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::orderRequestToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::linkToRequest);
	soap_serialize_PointerTons2__ServiceFee(soap, &this->ns2__RequestMessage::serviceFee);
	soap_serialize_PointerTons2__CCAuthService(soap, &this->ns2__RequestMessage::ccAuthService);
	soap_serialize_PointerTons2__OCTService(soap, &this->ns2__RequestMessage::octService);
	soap_serialize_PointerTons2__VerificationService(soap, &this->ns2__RequestMessage::verificationService);
	soap_serialize_PointerTons2__CCSaleService(soap, &this->ns2__RequestMessage::ccSaleService);
	soap_serialize_PointerTons2__CCSaleCreditService(soap, &this->ns2__RequestMessage::ccSaleCreditService);
	soap_serialize_PointerTons2__CCSaleReversalService(soap, &this->ns2__RequestMessage::ccSaleReversalService);
	soap_serialize_PointerTons2__CCIncrementalAuthService(soap, &this->ns2__RequestMessage::ccIncrementalAuthService);
	soap_serialize_PointerTons2__CCCaptureService(soap, &this->ns2__RequestMessage::ccCaptureService);
	soap_serialize_PointerTons2__CCCreditService(soap, &this->ns2__RequestMessage::ccCreditService);
	soap_serialize_PointerTons2__CCAuthReversalService(soap, &this->ns2__RequestMessage::ccAuthReversalService);
	soap_serialize_PointerTons2__CCAutoAuthReversalService(soap, &this->ns2__RequestMessage::ccAutoAuthReversalService);
	soap_serialize_PointerTons2__CCDCCService(soap, &this->ns2__RequestMessage::ccDCCService);
	soap_serialize_PointerTons2__ServiceFeeCalculateService(soap, &this->ns2__RequestMessage::serviceFeeCalculateService);
	soap_serialize_PointerTons2__ECDebitService(soap, &this->ns2__RequestMessage::ecDebitService);
	soap_serialize_PointerTons2__ECCreditService(soap, &this->ns2__RequestMessage::ecCreditService);
	soap_serialize_PointerTons2__ECAuthenticateService(soap, &this->ns2__RequestMessage::ecAuthenticateService);
	soap_serialize_PointerTons2__PayerAuthEnrollService(soap, &this->ns2__RequestMessage::payerAuthEnrollService);
	soap_serialize_PointerTons2__PayerAuthValidateService(soap, &this->ns2__RequestMessage::payerAuthValidateService);
	soap_serialize_PointerTons2__TaxService(soap, &this->ns2__RequestMessage::taxService);
	soap_serialize_PointerTons2__DMEService(soap, &this->ns2__RequestMessage::dmeService);
	soap_serialize_PointerTons2__AFSService(soap, &this->ns2__RequestMessage::afsService);
	soap_serialize_PointerTons2__DAVService(soap, &this->ns2__RequestMessage::davService);
	soap_serialize_PointerTons2__ExportService(soap, &this->ns2__RequestMessage::exportService);
	soap_serialize_PointerTons2__FXRatesService(soap, &this->ns2__RequestMessage::fxRatesService);
	soap_serialize_PointerTons2__BankTransferService(soap, &this->ns2__RequestMessage::bankTransferService);
	soap_serialize_PointerTons2__BankTransferRefundService(soap, &this->ns2__RequestMessage::bankTransferRefundService);
	soap_serialize_PointerTons2__BankTransferRealTimeService(soap, &this->ns2__RequestMessage::bankTransferRealTimeService);
	soap_serialize_PointerTons2__DirectDebitMandateService(soap, &this->ns2__RequestMessage::directDebitMandateService);
	soap_serialize_PointerTons2__DirectDebitService(soap, &this->ns2__RequestMessage::directDebitService);
	soap_serialize_PointerTons2__DirectDebitRefundService(soap, &this->ns2__RequestMessage::directDebitRefundService);
	soap_serialize_PointerTons2__DirectDebitValidateService(soap, &this->ns2__RequestMessage::directDebitValidateService);
	soap_serialize_PointerTons2__PaySubscriptionCreateService(soap, &this->ns2__RequestMessage::paySubscriptionCreateService);
	soap_serialize_PointerTons2__PaySubscriptionUpdateService(soap, &this->ns2__RequestMessage::paySubscriptionUpdateService);
	soap_serialize_PointerTons2__PaySubscriptionEventUpdateService(soap, &this->ns2__RequestMessage::paySubscriptionEventUpdateService);
	soap_serialize_PointerTons2__PaySubscriptionRetrieveService(soap, &this->ns2__RequestMessage::paySubscriptionRetrieveService);
	soap_serialize_PointerTons2__PaySubscriptionDeleteService(soap, &this->ns2__RequestMessage::paySubscriptionDeleteService);
	soap_serialize_PointerTons2__PayPalPaymentService(soap, &this->ns2__RequestMessage::payPalPaymentService);
	soap_serialize_PointerTons2__PayPalCreditService(soap, &this->ns2__RequestMessage::payPalCreditService);
	soap_serialize_PointerTons2__VoidService(soap, &this->ns2__RequestMessage::voidService);
	soap_serialize_PointerTons2__BusinessRules(soap, &this->ns2__RequestMessage::businessRules);
	soap_serialize_PointerTons2__PinlessDebitService(soap, &this->ns2__RequestMessage::pinlessDebitService);
	soap_serialize_PointerTons2__PinlessDebitValidateService(soap, &this->ns2__RequestMessage::pinlessDebitValidateService);
	soap_serialize_PointerTons2__PinlessDebitReversalService(soap, &this->ns2__RequestMessage::pinlessDebitReversalService);
	soap_serialize_PointerTons2__Batch(soap, &this->ns2__RequestMessage::batch);
	soap_serialize_PointerTons2__AirlineData(soap, &this->ns2__RequestMessage::airlineData);
	soap_serialize_PointerTons2__AncillaryData(soap, &this->ns2__RequestMessage::ancillaryData);
	soap_serialize_PointerTons2__LodgingData(soap, &this->ns2__RequestMessage::lodgingData);
	soap_serialize_PointerTons2__PayPalButtonCreateService(soap, &this->ns2__RequestMessage::payPalButtonCreateService);
	soap_serialize_PointerTons2__PayPalPreapprovedPaymentService(soap, &this->ns2__RequestMessage::payPalPreapprovedPaymentService);
	soap_serialize_PointerTons2__PayPalPreapprovedUpdateService(soap, &this->ns2__RequestMessage::payPalPreapprovedUpdateService);
	soap_serialize_PointerTons2__RiskUpdateService(soap, &this->ns2__RequestMessage::riskUpdateService);
	soap_serialize_PointerTons2__FraudUpdateService(soap, &this->ns2__RequestMessage::fraudUpdateService);
	soap_serialize_PointerTons2__CaseManagementActionService(soap, &this->ns2__RequestMessage::caseManagementActionService);
	soap_serialize_std__vectorTemplateOfPointerTons2__RequestReserved(soap, &this->ns2__RequestMessage::reserved);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::deviceFingerprintID);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__RequestMessage::deviceFingerprintRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::deviceFingerprintHash);
	soap_serialize_PointerTons2__PayPalRefundService(soap, &this->ns2__RequestMessage::payPalRefundService);
	soap_serialize_PointerTons2__PayPalAuthReversalService(soap, &this->ns2__RequestMessage::payPalAuthReversalService);
	soap_serialize_PointerTons2__PayPalDoCaptureService(soap, &this->ns2__RequestMessage::payPalDoCaptureService);
	soap_serialize_PointerTons2__PayPalEcDoPaymentService(soap, &this->ns2__RequestMessage::payPalEcDoPaymentService);
	soap_serialize_PointerTons2__PayPalEcGetDetailsService(soap, &this->ns2__RequestMessage::payPalEcGetDetailsService);
	soap_serialize_PointerTons2__PayPalEcSetService(soap, &this->ns2__RequestMessage::payPalEcSetService);
	soap_serialize_PointerTons2__PayPalEcOrderSetupService(soap, &this->ns2__RequestMessage::payPalEcOrderSetupService);
	soap_serialize_PointerTons2__PayPalAuthorizationService(soap, &this->ns2__RequestMessage::payPalAuthorizationService);
	soap_serialize_PointerTons2__PayPalUpdateAgreementService(soap, &this->ns2__RequestMessage::payPalUpdateAgreementService);
	soap_serialize_PointerTons2__PayPalCreateAgreementService(soap, &this->ns2__RequestMessage::payPalCreateAgreementService);
	soap_serialize_PointerTons2__PayPalDoRefTransactionService(soap, &this->ns2__RequestMessage::payPalDoRefTransactionService);
	soap_serialize_PointerTons2__ChinaPaymentService(soap, &this->ns2__RequestMessage::chinaPaymentService);
	soap_serialize_PointerTons2__ChinaRefundService(soap, &this->ns2__RequestMessage::chinaRefundService);
	soap_serialize_PointerTons2__BoletoPaymentService(soap, &this->ns2__RequestMessage::boletoPaymentService);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::apPaymentType);
	soap_serialize_PointerTons2__APInitiateService(soap, &this->ns2__RequestMessage::apInitiateService);
	soap_serialize_PointerTons2__APCheckStatusService(soap, &this->ns2__RequestMessage::apCheckStatusService);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__RequestMessage::ignoreCardExpiration);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::reportGroup);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::processorID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::thirdPartyCertificationNumber);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__RequestMessage::transactionLocalDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::solutionProviderTransactionID);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__RequestMessage::surchargeAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::surchargeSign);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::pinDataEncryptedPIN);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::pinDataKeySerialNumber);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__RequestMessage::cashbackAmount);
	soap_serialize_PointerTons2__PinDebitPurchaseService(soap, &this->ns2__RequestMessage::pinDebitPurchaseService);
	soap_serialize_PointerTons2__PinDebitCreditService(soap, &this->ns2__RequestMessage::pinDebitCreditService);
	soap_serialize_PointerTons2__PinDebitReversalService(soap, &this->ns2__RequestMessage::pinDebitReversalService);
	soap_serialize_PointerTons2__AP(soap, &this->ns2__RequestMessage::ap);
	soap_serialize_PointerTons2__APAuthService(soap, &this->ns2__RequestMessage::apAuthService);
	soap_serialize_PointerTons2__APAuthReversalService(soap, &this->ns2__RequestMessage::apAuthReversalService);
	soap_serialize_PointerTons2__APCaptureService(soap, &this->ns2__RequestMessage::apCaptureService);
	soap_serialize_PointerTons2__APOptionsService(soap, &this->ns2__RequestMessage::apOptionsService);
	soap_serialize_PointerTons2__APRefundService(soap, &this->ns2__RequestMessage::apRefundService);
	soap_serialize_PointerTons2__APSaleService(soap, &this->ns2__RequestMessage::apSaleService);
	soap_serialize_PointerTons2__APCheckOutDetailsService(soap, &this->ns2__RequestMessage::apCheckoutDetailsService);
	soap_serialize_PointerTons2__APTransactionDetailsService(soap, &this->ns2__RequestMessage::apTransactionDetailsService);
	soap_serialize_PointerTons2__APConfirmPurchaseService(soap, &this->ns2__RequestMessage::apConfirmPurchaseService);
	soap_serialize_PointerTons2__PayPalGetTxnDetailsService(soap, &this->ns2__RequestMessage::payPalGetTxnDetailsService);
	soap_serialize_PointerTons2__PayPalTransactionSearchService(soap, &this->ns2__RequestMessage::payPalTransactionSearchService);
	soap_serialize_PointerTons2__CCDCCUpdateService(soap, &this->ns2__RequestMessage::ccDCCUpdateService);
	soap_serialize_PointerTons2__EmvRequest(soap, &this->ns2__RequestMessage::emvRequest);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::merchantTransactionIdentifier);
	soap_serialize_PointerTons2__HostedDataCreateService(soap, &this->ns2__RequestMessage::hostedDataCreateService);
	soap_serialize_PointerTons2__HostedDataRetrieveService(soap, &this->ns2__RequestMessage::hostedDataRetrieveService);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::merchantCategoryCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::salesSlipNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::merchandiseCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::merchandiseDescription);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::paymentInitiationChannel);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::extendedCreditTotalCount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::authIndicator);
	soap_serialize_PointerTons2__PaymentNetworkToken(soap, &this->ns2__RequestMessage::paymentNetworkToken);
	soap_serialize_PointerTons2__Recipient(soap, &this->ns2__RequestMessage::recipient);
	soap_serialize_PointerTons2__Sender(soap, &this->ns2__RequestMessage::sender);
	soap_serialize_PointerTons2__AutoRentalData(soap, &this->ns2__RequestMessage::autoRentalData);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::paymentSolution);
	soap_serialize_PointerTons2__VC(soap, &this->ns2__RequestMessage::vc);
	soap_serialize_PointerTons2__DecryptVisaCheckoutDataService(soap, &this->ns2__RequestMessage::decryptVisaCheckoutDataService);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::taxManagementIndicator);
	soap_serialize_std__vectorTemplateOfPointerTons2__PromotionGroup(soap, &this->ns2__RequestMessage::promotionGroup);
	soap_serialize_PointerTons2__Wallet(soap, &this->ns2__RequestMessage::wallet);
	soap_serialize_PointerTons2__Aft(soap, &this->ns2__RequestMessage::aft);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__RequestMessage::balanceInquiry);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__RequestMessage::prenoteTransaction);
	soap_serialize_PointerTons2__EncryptPaymentDataService(soap, &this->ns2__RequestMessage::encryptPaymentDataService);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::nationalNetDomesticData);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::subsequentAuth);
	soap_serialize_PointerTons2__BinLookupService(soap, &this->ns2__RequestMessage::binLookupService);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::verificationCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::mobileNumber);
	soap_serialize_PointerTons2__issuer(soap, &this->ns2__RequestMessage::issuer);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::partnerSolutionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RequestMessage::developerID);
#endif
}

int ns2__RequestMessage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RequestMessage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RequestMessage(struct soap *soap, const char *tag, int id, const ns2__RequestMessage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RequestMessage), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantID", -1, (wchar_t*const*)&a->ns2__RequestMessage::merchantID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantReferenceCode", -1, (wchar_t*const*)&a->ns2__RequestMessage::merchantReferenceCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:debtIndicator", -1, &a->ns2__RequestMessage::debtIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:clientLibrary", -1, (wchar_t*const*)&a->ns2__RequestMessage::clientLibrary, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:clientLibraryVersion", -1, (wchar_t*const*)&a->ns2__RequestMessage::clientLibraryVersion, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:clientEnvironment", -1, (wchar_t*const*)&a->ns2__RequestMessage::clientEnvironment, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:clientSecurityLibraryVersion", -1, (wchar_t*const*)&a->ns2__RequestMessage::clientSecurityLibraryVersion, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:clientApplication", -1, (wchar_t*const*)&a->ns2__RequestMessage::clientApplication, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:clientApplicationVersion", -1, (wchar_t*const*)&a->ns2__RequestMessage::clientApplicationVersion, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:clientApplicationUser", -1, (wchar_t*const*)&a->ns2__RequestMessage::clientApplicationUser, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:routingCode", -1, (wchar_t*const*)&a->ns2__RequestMessage::routingCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:comments", -1, (wchar_t*const*)&a->ns2__RequestMessage::comments, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:returnURL", -1, (wchar_t*const*)&a->ns2__RequestMessage::returnURL, ""))
		return soap->error;
	if (soap_out_PointerTons2__InvoiceHeader(soap, "ns2:invoiceHeader", -1, &a->ns2__RequestMessage::invoiceHeader, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:aggregatorMerchantIdentifier", -1, (wchar_t*const*)&a->ns2__RequestMessage::aggregatorMerchantIdentifier, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:customerID", -1, (wchar_t*const*)&a->ns2__RequestMessage::customerID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:customerFirstName", -1, (wchar_t*const*)&a->ns2__RequestMessage::customerFirstName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:customerLastName", -1, (wchar_t*const*)&a->ns2__RequestMessage::customerLastName, ""))
		return soap->error;
	if (soap_out_PointerTons2__BillTo(soap, "ns2:billTo", -1, &a->ns2__RequestMessage::billTo, ""))
		return soap->error;
	if (soap_out_PointerTons2__ShipTo(soap, "ns2:shipTo", -1, &a->ns2__RequestMessage::shipTo, ""))
		return soap->error;
	if (soap_out_PointerTons2__PersonalId(soap, "ns2:personalId", -1, &a->ns2__RequestMessage::personalId, ""))
		return soap->error;
	if (soap_out_PointerTons2__ShipFrom(soap, "ns2:shipFrom", -1, &a->ns2__RequestMessage::shipFrom, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__Item(soap, "ns2:item", -1, &a->ns2__RequestMessage::item, ""))
		return soap->error;
	if (soap_out_PointerTons2__PurchaseTotals(soap, "ns2:purchaseTotals", -1, &a->ns2__RequestMessage::purchaseTotals, ""))
		return soap->error;
	if (soap_out_PointerTons2__FundingTotals(soap, "ns2:fundingTotals", -1, &a->ns2__RequestMessage::fundingTotals, ""))
		return soap->error;
	if (soap_out_PointerTons2__DCC(soap, "ns2:dcc", -1, &a->ns2__RequestMessage::dcc, ""))
		return soap->error;
	if (soap_out_PointerTons2__Pos(soap, "ns2:pos", -1, &a->ns2__RequestMessage::pos, ""))
		return soap->error;
	if (soap_out_PointerTons2__EncryptedPayment(soap, "ns2:encryptedPayment", -1, &a->ns2__RequestMessage::encryptedPayment, ""))
		return soap->error;
	if (soap_out_PointerTons2__Installment(soap, "ns2:installment", -1, &a->ns2__RequestMessage::installment, ""))
		return soap->error;
	if (soap_out_PointerTons2__Card(soap, "ns2:card", -1, &a->ns2__RequestMessage::card, ""))
		return soap->error;
	if (soap_out_PointerTons2__Check(soap, "ns2:check", -1, &a->ns2__RequestMessage::check, ""))
		return soap->error;
	if (soap_out_PointerTons2__BML(soap, "ns2:bml", -1, &a->ns2__RequestMessage::bml, ""))
		return soap->error;
	if (soap_out_PointerTons2__GECC(soap, "ns2:gecc", -1, &a->ns2__RequestMessage::gecc, ""))
		return soap->error;
	if (soap_out_PointerTons2__UCAF(soap, "ns2:ucaf", -1, &a->ns2__RequestMessage::ucaf, ""))
		return soap->error;
	if (soap_out_PointerTons2__FundTransfer(soap, "ns2:fundTransfer", -1, &a->ns2__RequestMessage::fundTransfer, ""))
		return soap->error;
	if (soap_out_PointerTons2__BankInfo(soap, "ns2:bankInfo", -1, &a->ns2__RequestMessage::bankInfo, ""))
		return soap->error;
	if (soap_out_PointerTons2__Subscription(soap, "ns2:subscription", -1, &a->ns2__RequestMessage::subscription, ""))
		return soap->error;
	if (soap_out_PointerTons2__RecurringSubscriptionInfo(soap, "ns2:recurringSubscriptionInfo", -1, &a->ns2__RequestMessage::recurringSubscriptionInfo, ""))
		return soap->error;
	if (soap_out_PointerTons2__DecisionManager(soap, "ns2:decisionManager", -1, &a->ns2__RequestMessage::decisionManager, ""))
		return soap->error;
	if (soap_out_PointerTons2__OtherTax(soap, "ns2:otherTax", -1, &a->ns2__RequestMessage::otherTax, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPal(soap, "ns2:paypal", -1, &a->ns2__RequestMessage::paypal, ""))
		return soap->error;
	if (soap_out_PointerTons2__MerchantDefinedData(soap, "ns2:merchantDefinedData", -1, &a->ns2__RequestMessage::merchantDefinedData, ""))
		return soap->error;
	if (soap_out_PointerTons2__MerchantSecureData(soap, "ns2:merchantSecureData", -1, &a->ns2__RequestMessage::merchantSecureData, ""))
		return soap->error;
	if (soap_out_PointerTons2__JPO(soap, "ns2:jpo", -1, &a->ns2__RequestMessage::jpo, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderRequestToken", -1, (wchar_t*const*)&a->ns2__RequestMessage::orderRequestToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:linkToRequest", -1, (wchar_t*const*)&a->ns2__RequestMessage::linkToRequest, ""))
		return soap->error;
	if (soap_out_PointerTons2__ServiceFee(soap, "ns2:serviceFee", -1, &a->ns2__RequestMessage::serviceFee, ""))
		return soap->error;
	if (soap_out_PointerTons2__CCAuthService(soap, "ns2:ccAuthService", -1, &a->ns2__RequestMessage::ccAuthService, ""))
		return soap->error;
	if (soap_out_PointerTons2__OCTService(soap, "ns2:octService", -1, &a->ns2__RequestMessage::octService, ""))
		return soap->error;
	if (soap_out_PointerTons2__VerificationService(soap, "ns2:verificationService", -1, &a->ns2__RequestMessage::verificationService, ""))
		return soap->error;
	if (soap_out_PointerTons2__CCSaleService(soap, "ns2:ccSaleService", -1, &a->ns2__RequestMessage::ccSaleService, ""))
		return soap->error;
	if (soap_out_PointerTons2__CCSaleCreditService(soap, "ns2:ccSaleCreditService", -1, &a->ns2__RequestMessage::ccSaleCreditService, ""))
		return soap->error;
	if (soap_out_PointerTons2__CCSaleReversalService(soap, "ns2:ccSaleReversalService", -1, &a->ns2__RequestMessage::ccSaleReversalService, ""))
		return soap->error;
	if (soap_out_PointerTons2__CCIncrementalAuthService(soap, "ns2:ccIncrementalAuthService", -1, &a->ns2__RequestMessage::ccIncrementalAuthService, ""))
		return soap->error;
	if (soap_out_PointerTons2__CCCaptureService(soap, "ns2:ccCaptureService", -1, &a->ns2__RequestMessage::ccCaptureService, ""))
		return soap->error;
	if (soap_out_PointerTons2__CCCreditService(soap, "ns2:ccCreditService", -1, &a->ns2__RequestMessage::ccCreditService, ""))
		return soap->error;
	if (soap_out_PointerTons2__CCAuthReversalService(soap, "ns2:ccAuthReversalService", -1, &a->ns2__RequestMessage::ccAuthReversalService, ""))
		return soap->error;
	if (soap_out_PointerTons2__CCAutoAuthReversalService(soap, "ns2:ccAutoAuthReversalService", -1, &a->ns2__RequestMessage::ccAutoAuthReversalService, ""))
		return soap->error;
	if (soap_out_PointerTons2__CCDCCService(soap, "ns2:ccDCCService", -1, &a->ns2__RequestMessage::ccDCCService, ""))
		return soap->error;
	if (soap_out_PointerTons2__ServiceFeeCalculateService(soap, "ns2:serviceFeeCalculateService", -1, &a->ns2__RequestMessage::serviceFeeCalculateService, ""))
		return soap->error;
	if (soap_out_PointerTons2__ECDebitService(soap, "ns2:ecDebitService", -1, &a->ns2__RequestMessage::ecDebitService, ""))
		return soap->error;
	if (soap_out_PointerTons2__ECCreditService(soap, "ns2:ecCreditService", -1, &a->ns2__RequestMessage::ecCreditService, ""))
		return soap->error;
	if (soap_out_PointerTons2__ECAuthenticateService(soap, "ns2:ecAuthenticateService", -1, &a->ns2__RequestMessage::ecAuthenticateService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayerAuthEnrollService(soap, "ns2:payerAuthEnrollService", -1, &a->ns2__RequestMessage::payerAuthEnrollService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayerAuthValidateService(soap, "ns2:payerAuthValidateService", -1, &a->ns2__RequestMessage::payerAuthValidateService, ""))
		return soap->error;
	if (soap_out_PointerTons2__TaxService(soap, "ns2:taxService", -1, &a->ns2__RequestMessage::taxService, ""))
		return soap->error;
	if (soap_out_PointerTons2__DMEService(soap, "ns2:dmeService", -1, &a->ns2__RequestMessage::dmeService, ""))
		return soap->error;
	if (soap_out_PointerTons2__AFSService(soap, "ns2:afsService", -1, &a->ns2__RequestMessage::afsService, ""))
		return soap->error;
	if (soap_out_PointerTons2__DAVService(soap, "ns2:davService", -1, &a->ns2__RequestMessage::davService, ""))
		return soap->error;
	if (soap_out_PointerTons2__ExportService(soap, "ns2:exportService", -1, &a->ns2__RequestMessage::exportService, ""))
		return soap->error;
	if (soap_out_PointerTons2__FXRatesService(soap, "ns2:fxRatesService", -1, &a->ns2__RequestMessage::fxRatesService, ""))
		return soap->error;
	if (soap_out_PointerTons2__BankTransferService(soap, "ns2:bankTransferService", -1, &a->ns2__RequestMessage::bankTransferService, ""))
		return soap->error;
	if (soap_out_PointerTons2__BankTransferRefundService(soap, "ns2:bankTransferRefundService", -1, &a->ns2__RequestMessage::bankTransferRefundService, ""))
		return soap->error;
	if (soap_out_PointerTons2__BankTransferRealTimeService(soap, "ns2:bankTransferRealTimeService", -1, &a->ns2__RequestMessage::bankTransferRealTimeService, ""))
		return soap->error;
	if (soap_out_PointerTons2__DirectDebitMandateService(soap, "ns2:directDebitMandateService", -1, &a->ns2__RequestMessage::directDebitMandateService, ""))
		return soap->error;
	if (soap_out_PointerTons2__DirectDebitService(soap, "ns2:directDebitService", -1, &a->ns2__RequestMessage::directDebitService, ""))
		return soap->error;
	if (soap_out_PointerTons2__DirectDebitRefundService(soap, "ns2:directDebitRefundService", -1, &a->ns2__RequestMessage::directDebitRefundService, ""))
		return soap->error;
	if (soap_out_PointerTons2__DirectDebitValidateService(soap, "ns2:directDebitValidateService", -1, &a->ns2__RequestMessage::directDebitValidateService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PaySubscriptionCreateService(soap, "ns2:paySubscriptionCreateService", -1, &a->ns2__RequestMessage::paySubscriptionCreateService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PaySubscriptionUpdateService(soap, "ns2:paySubscriptionUpdateService", -1, &a->ns2__RequestMessage::paySubscriptionUpdateService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PaySubscriptionEventUpdateService(soap, "ns2:paySubscriptionEventUpdateService", -1, &a->ns2__RequestMessage::paySubscriptionEventUpdateService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PaySubscriptionRetrieveService(soap, "ns2:paySubscriptionRetrieveService", -1, &a->ns2__RequestMessage::paySubscriptionRetrieveService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PaySubscriptionDeleteService(soap, "ns2:paySubscriptionDeleteService", -1, &a->ns2__RequestMessage::paySubscriptionDeleteService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalPaymentService(soap, "ns2:payPalPaymentService", -1, &a->ns2__RequestMessage::payPalPaymentService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalCreditService(soap, "ns2:payPalCreditService", -1, &a->ns2__RequestMessage::payPalCreditService, ""))
		return soap->error;
	if (soap_out_PointerTons2__VoidService(soap, "ns2:voidService", -1, &a->ns2__RequestMessage::voidService, ""))
		return soap->error;
	if (soap_out_PointerTons2__BusinessRules(soap, "ns2:businessRules", -1, &a->ns2__RequestMessage::businessRules, ""))
		return soap->error;
	if (soap_out_PointerTons2__PinlessDebitService(soap, "ns2:pinlessDebitService", -1, &a->ns2__RequestMessage::pinlessDebitService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PinlessDebitValidateService(soap, "ns2:pinlessDebitValidateService", -1, &a->ns2__RequestMessage::pinlessDebitValidateService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PinlessDebitReversalService(soap, "ns2:pinlessDebitReversalService", -1, &a->ns2__RequestMessage::pinlessDebitReversalService, ""))
		return soap->error;
	if (soap_out_PointerTons2__Batch(soap, "ns2:batch", -1, &a->ns2__RequestMessage::batch, ""))
		return soap->error;
	if (soap_out_PointerTons2__AirlineData(soap, "ns2:airlineData", -1, &a->ns2__RequestMessage::airlineData, ""))
		return soap->error;
	if (soap_out_PointerTons2__AncillaryData(soap, "ns2:ancillaryData", -1, &a->ns2__RequestMessage::ancillaryData, ""))
		return soap->error;
	if (soap_out_PointerTons2__LodgingData(soap, "ns2:lodgingData", -1, &a->ns2__RequestMessage::lodgingData, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalButtonCreateService(soap, "ns2:payPalButtonCreateService", -1, &a->ns2__RequestMessage::payPalButtonCreateService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalPreapprovedPaymentService(soap, "ns2:payPalPreapprovedPaymentService", -1, &a->ns2__RequestMessage::payPalPreapprovedPaymentService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalPreapprovedUpdateService(soap, "ns2:payPalPreapprovedUpdateService", -1, &a->ns2__RequestMessage::payPalPreapprovedUpdateService, ""))
		return soap->error;
	if (soap_out_PointerTons2__RiskUpdateService(soap, "ns2:riskUpdateService", -1, &a->ns2__RequestMessage::riskUpdateService, ""))
		return soap->error;
	if (soap_out_PointerTons2__FraudUpdateService(soap, "ns2:fraudUpdateService", -1, &a->ns2__RequestMessage::fraudUpdateService, ""))
		return soap->error;
	if (soap_out_PointerTons2__CaseManagementActionService(soap, "ns2:caseManagementActionService", -1, &a->ns2__RequestMessage::caseManagementActionService, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__RequestReserved(soap, "ns2:reserved", -1, &a->ns2__RequestMessage::reserved, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:deviceFingerprintID", -1, (wchar_t*const*)&a->ns2__RequestMessage::deviceFingerprintID, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:deviceFingerprintRaw", -1, &a->ns2__RequestMessage::deviceFingerprintRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:deviceFingerprintHash", -1, (wchar_t*const*)&a->ns2__RequestMessage::deviceFingerprintHash, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalRefundService(soap, "ns2:payPalRefundService", -1, &a->ns2__RequestMessage::payPalRefundService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalAuthReversalService(soap, "ns2:payPalAuthReversalService", -1, &a->ns2__RequestMessage::payPalAuthReversalService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalDoCaptureService(soap, "ns2:payPalDoCaptureService", -1, &a->ns2__RequestMessage::payPalDoCaptureService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalEcDoPaymentService(soap, "ns2:payPalEcDoPaymentService", -1, &a->ns2__RequestMessage::payPalEcDoPaymentService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalEcGetDetailsService(soap, "ns2:payPalEcGetDetailsService", -1, &a->ns2__RequestMessage::payPalEcGetDetailsService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalEcSetService(soap, "ns2:payPalEcSetService", -1, &a->ns2__RequestMessage::payPalEcSetService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalEcOrderSetupService(soap, "ns2:payPalEcOrderSetupService", -1, &a->ns2__RequestMessage::payPalEcOrderSetupService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalAuthorizationService(soap, "ns2:payPalAuthorizationService", -1, &a->ns2__RequestMessage::payPalAuthorizationService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalUpdateAgreementService(soap, "ns2:payPalUpdateAgreementService", -1, &a->ns2__RequestMessage::payPalUpdateAgreementService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalCreateAgreementService(soap, "ns2:payPalCreateAgreementService", -1, &a->ns2__RequestMessage::payPalCreateAgreementService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalDoRefTransactionService(soap, "ns2:payPalDoRefTransactionService", -1, &a->ns2__RequestMessage::payPalDoRefTransactionService, ""))
		return soap->error;
	if (soap_out_PointerTons2__ChinaPaymentService(soap, "ns2:chinaPaymentService", -1, &a->ns2__RequestMessage::chinaPaymentService, ""))
		return soap->error;
	if (soap_out_PointerTons2__ChinaRefundService(soap, "ns2:chinaRefundService", -1, &a->ns2__RequestMessage::chinaRefundService, ""))
		return soap->error;
	if (soap_out_PointerTons2__BoletoPaymentService(soap, "ns2:boletoPaymentService", -1, &a->ns2__RequestMessage::boletoPaymentService, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:apPaymentType", -1, (wchar_t*const*)&a->ns2__RequestMessage::apPaymentType, ""))
		return soap->error;
	if (soap_out_PointerTons2__APInitiateService(soap, "ns2:apInitiateService", -1, &a->ns2__RequestMessage::apInitiateService, ""))
		return soap->error;
	if (soap_out_PointerTons2__APCheckStatusService(soap, "ns2:apCheckStatusService", -1, &a->ns2__RequestMessage::apCheckStatusService, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:ignoreCardExpiration", -1, &a->ns2__RequestMessage::ignoreCardExpiration, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reportGroup", -1, (wchar_t*const*)&a->ns2__RequestMessage::reportGroup, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:processorID", -1, (wchar_t*const*)&a->ns2__RequestMessage::processorID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:thirdPartyCertificationNumber", -1, (wchar_t*const*)&a->ns2__RequestMessage::thirdPartyCertificationNumber, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:transactionLocalDateTime", -1, &a->ns2__RequestMessage::transactionLocalDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:solutionProviderTransactionID", -1, (wchar_t*const*)&a->ns2__RequestMessage::solutionProviderTransactionID, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:surchargeAmount", -1, &a->ns2__RequestMessage::surchargeAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:surchargeSign", -1, (wchar_t*const*)&a->ns2__RequestMessage::surchargeSign, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pinDataEncryptedPIN", -1, (wchar_t*const*)&a->ns2__RequestMessage::pinDataEncryptedPIN, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pinDataKeySerialNumber", -1, (wchar_t*const*)&a->ns2__RequestMessage::pinDataKeySerialNumber, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:cashbackAmount", -1, &a->ns2__RequestMessage::cashbackAmount, ""))
		return soap->error;
	if (soap_out_PointerTons2__PinDebitPurchaseService(soap, "ns2:pinDebitPurchaseService", -1, &a->ns2__RequestMessage::pinDebitPurchaseService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PinDebitCreditService(soap, "ns2:pinDebitCreditService", -1, &a->ns2__RequestMessage::pinDebitCreditService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PinDebitReversalService(soap, "ns2:pinDebitReversalService", -1, &a->ns2__RequestMessage::pinDebitReversalService, ""))
		return soap->error;
	if (soap_out_PointerTons2__AP(soap, "ns2:ap", -1, &a->ns2__RequestMessage::ap, ""))
		return soap->error;
	if (soap_out_PointerTons2__APAuthService(soap, "ns2:apAuthService", -1, &a->ns2__RequestMessage::apAuthService, ""))
		return soap->error;
	if (soap_out_PointerTons2__APAuthReversalService(soap, "ns2:apAuthReversalService", -1, &a->ns2__RequestMessage::apAuthReversalService, ""))
		return soap->error;
	if (soap_out_PointerTons2__APCaptureService(soap, "ns2:apCaptureService", -1, &a->ns2__RequestMessage::apCaptureService, ""))
		return soap->error;
	if (soap_out_PointerTons2__APOptionsService(soap, "ns2:apOptionsService", -1, &a->ns2__RequestMessage::apOptionsService, ""))
		return soap->error;
	if (soap_out_PointerTons2__APRefundService(soap, "ns2:apRefundService", -1, &a->ns2__RequestMessage::apRefundService, ""))
		return soap->error;
	if (soap_out_PointerTons2__APSaleService(soap, "ns2:apSaleService", -1, &a->ns2__RequestMessage::apSaleService, ""))
		return soap->error;
	if (soap_out_PointerTons2__APCheckOutDetailsService(soap, "ns2:apCheckoutDetailsService", -1, &a->ns2__RequestMessage::apCheckoutDetailsService, ""))
		return soap->error;
	if (soap_out_PointerTons2__APTransactionDetailsService(soap, "ns2:apTransactionDetailsService", -1, &a->ns2__RequestMessage::apTransactionDetailsService, ""))
		return soap->error;
	if (soap_out_PointerTons2__APConfirmPurchaseService(soap, "ns2:apConfirmPurchaseService", -1, &a->ns2__RequestMessage::apConfirmPurchaseService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalGetTxnDetailsService(soap, "ns2:payPalGetTxnDetailsService", -1, &a->ns2__RequestMessage::payPalGetTxnDetailsService, ""))
		return soap->error;
	if (soap_out_PointerTons2__PayPalTransactionSearchService(soap, "ns2:payPalTransactionSearchService", -1, &a->ns2__RequestMessage::payPalTransactionSearchService, ""))
		return soap->error;
	if (soap_out_PointerTons2__CCDCCUpdateService(soap, "ns2:ccDCCUpdateService", -1, &a->ns2__RequestMessage::ccDCCUpdateService, ""))
		return soap->error;
	if (soap_out_PointerTons2__EmvRequest(soap, "ns2:emvRequest", -1, &a->ns2__RequestMessage::emvRequest, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantTransactionIdentifier", -1, (wchar_t*const*)&a->ns2__RequestMessage::merchantTransactionIdentifier, ""))
		return soap->error;
	if (soap_out_PointerTons2__HostedDataCreateService(soap, "ns2:hostedDataCreateService", -1, &a->ns2__RequestMessage::hostedDataCreateService, ""))
		return soap->error;
	if (soap_out_PointerTons2__HostedDataRetrieveService(soap, "ns2:hostedDataRetrieveService", -1, &a->ns2__RequestMessage::hostedDataRetrieveService, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantCategoryCode", -1, (wchar_t*const*)&a->ns2__RequestMessage::merchantCategoryCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:salesSlipNumber", -1, (wchar_t*const*)&a->ns2__RequestMessage::salesSlipNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchandiseCode", -1, (wchar_t*const*)&a->ns2__RequestMessage::merchandiseCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchandiseDescription", -1, (wchar_t*const*)&a->ns2__RequestMessage::merchandiseDescription, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentInitiationChannel", -1, (wchar_t*const*)&a->ns2__RequestMessage::paymentInitiationChannel, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:extendedCreditTotalCount", -1, (wchar_t*const*)&a->ns2__RequestMessage::extendedCreditTotalCount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authIndicator", -1, (wchar_t*const*)&a->ns2__RequestMessage::authIndicator, ""))
		return soap->error;
	if (soap_out_PointerTons2__PaymentNetworkToken(soap, "ns2:paymentNetworkToken", -1, &a->ns2__RequestMessage::paymentNetworkToken, ""))
		return soap->error;
	if (soap_out_PointerTons2__Recipient(soap, "ns2:recipient", -1, &a->ns2__RequestMessage::recipient, ""))
		return soap->error;
	if (soap_out_PointerTons2__Sender(soap, "ns2:sender", -1, &a->ns2__RequestMessage::sender, ""))
		return soap->error;
	if (soap_out_PointerTons2__AutoRentalData(soap, "ns2:autoRentalData", -1, &a->ns2__RequestMessage::autoRentalData, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentSolution", -1, (wchar_t*const*)&a->ns2__RequestMessage::paymentSolution, ""))
		return soap->error;
	if (soap_out_PointerTons2__VC(soap, "ns2:vc", -1, &a->ns2__RequestMessage::vc, ""))
		return soap->error;
	if (soap_out_PointerTons2__DecryptVisaCheckoutDataService(soap, "ns2:decryptVisaCheckoutDataService", -1, &a->ns2__RequestMessage::decryptVisaCheckoutDataService, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:taxManagementIndicator", -1, (wchar_t*const*)&a->ns2__RequestMessage::taxManagementIndicator, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__PromotionGroup(soap, "ns2:promotionGroup", -1, &a->ns2__RequestMessage::promotionGroup, ""))
		return soap->error;
	if (soap_out_PointerTons2__Wallet(soap, "ns2:wallet", -1, &a->ns2__RequestMessage::wallet, ""))
		return soap->error;
	if (soap_out_PointerTons2__Aft(soap, "ns2:aft", -1, &a->ns2__RequestMessage::aft, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:balanceInquiry", -1, &a->ns2__RequestMessage::balanceInquiry, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:prenoteTransaction", -1, &a->ns2__RequestMessage::prenoteTransaction, ""))
		return soap->error;
	if (soap_out_PointerTons2__EncryptPaymentDataService(soap, "ns2:encryptPaymentDataService", -1, &a->ns2__RequestMessage::encryptPaymentDataService, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:nationalNetDomesticData", -1, (wchar_t*const*)&a->ns2__RequestMessage::nationalNetDomesticData, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:subsequentAuth", -1, (wchar_t*const*)&a->ns2__RequestMessage::subsequentAuth, ""))
		return soap->error;
	if (soap_out_PointerTons2__BinLookupService(soap, "ns2:binLookupService", -1, &a->ns2__RequestMessage::binLookupService, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:verificationCode", -1, (wchar_t*const*)&a->ns2__RequestMessage::verificationCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:mobileNumber", -1, (wchar_t*const*)&a->ns2__RequestMessage::mobileNumber, ""))
		return soap->error;
	if (soap_out_PointerTons2__issuer(soap, "ns2:issuer", -1, &a->ns2__RequestMessage::issuer, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:partnerSolutionID", -1, (wchar_t*const*)&a->ns2__RequestMessage::partnerSolutionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:developerID", -1, (wchar_t*const*)&a->ns2__RequestMessage::developerID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__RequestMessage::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RequestMessage(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RequestMessage * SOAP_FMAC4 soap_in_ns2__RequestMessage(struct soap *soap, const char *tag, ns2__RequestMessage *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RequestMessage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RequestMessage, sizeof(ns2__RequestMessage), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__RequestMessage)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__RequestMessage *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_merchantID1 = 1;
	size_t soap_flag_merchantReferenceCode1 = 1;
	size_t soap_flag_debtIndicator1 = 1;
	size_t soap_flag_clientLibrary1 = 1;
	size_t soap_flag_clientLibraryVersion1 = 1;
	size_t soap_flag_clientEnvironment1 = 1;
	size_t soap_flag_clientSecurityLibraryVersion1 = 1;
	size_t soap_flag_clientApplication1 = 1;
	size_t soap_flag_clientApplicationVersion1 = 1;
	size_t soap_flag_clientApplicationUser1 = 1;
	size_t soap_flag_routingCode1 = 1;
	size_t soap_flag_comments1 = 1;
	size_t soap_flag_returnURL1 = 1;
	size_t soap_flag_invoiceHeader1 = 1;
	size_t soap_flag_aggregatorMerchantIdentifier1 = 1;
	size_t soap_flag_customerID1 = 1;
	size_t soap_flag_customerFirstName1 = 1;
	size_t soap_flag_customerLastName1 = 1;
	size_t soap_flag_billTo1 = 1;
	size_t soap_flag_shipTo1 = 1;
	size_t soap_flag_personalId1 = 1;
	size_t soap_flag_shipFrom1 = 1;
	size_t soap_flag_purchaseTotals1 = 1;
	size_t soap_flag_fundingTotals1 = 1;
	size_t soap_flag_dcc1 = 1;
	size_t soap_flag_pos1 = 1;
	size_t soap_flag_encryptedPayment1 = 1;
	size_t soap_flag_installment1 = 1;
	size_t soap_flag_card1 = 1;
	size_t soap_flag_check1 = 1;
	size_t soap_flag_bml1 = 1;
	size_t soap_flag_gecc1 = 1;
	size_t soap_flag_ucaf1 = 1;
	size_t soap_flag_fundTransfer1 = 1;
	size_t soap_flag_bankInfo1 = 1;
	size_t soap_flag_subscription1 = 1;
	size_t soap_flag_recurringSubscriptionInfo1 = 1;
	size_t soap_flag_decisionManager1 = 1;
	size_t soap_flag_otherTax1 = 1;
	size_t soap_flag_paypal1 = 1;
	size_t soap_flag_merchantDefinedData1 = 1;
	size_t soap_flag_merchantSecureData1 = 1;
	size_t soap_flag_jpo1 = 1;
	size_t soap_flag_orderRequestToken1 = 1;
	size_t soap_flag_linkToRequest1 = 1;
	size_t soap_flag_serviceFee1 = 1;
	size_t soap_flag_ccAuthService1 = 1;
	size_t soap_flag_octService1 = 1;
	size_t soap_flag_verificationService1 = 1;
	size_t soap_flag_ccSaleService1 = 1;
	size_t soap_flag_ccSaleCreditService1 = 1;
	size_t soap_flag_ccSaleReversalService1 = 1;
	size_t soap_flag_ccIncrementalAuthService1 = 1;
	size_t soap_flag_ccCaptureService1 = 1;
	size_t soap_flag_ccCreditService1 = 1;
	size_t soap_flag_ccAuthReversalService1 = 1;
	size_t soap_flag_ccAutoAuthReversalService1 = 1;
	size_t soap_flag_ccDCCService1 = 1;
	size_t soap_flag_serviceFeeCalculateService1 = 1;
	size_t soap_flag_ecDebitService1 = 1;
	size_t soap_flag_ecCreditService1 = 1;
	size_t soap_flag_ecAuthenticateService1 = 1;
	size_t soap_flag_payerAuthEnrollService1 = 1;
	size_t soap_flag_payerAuthValidateService1 = 1;
	size_t soap_flag_taxService1 = 1;
	size_t soap_flag_dmeService1 = 1;
	size_t soap_flag_afsService1 = 1;
	size_t soap_flag_davService1 = 1;
	size_t soap_flag_exportService1 = 1;
	size_t soap_flag_fxRatesService1 = 1;
	size_t soap_flag_bankTransferService1 = 1;
	size_t soap_flag_bankTransferRefundService1 = 1;
	size_t soap_flag_bankTransferRealTimeService1 = 1;
	size_t soap_flag_directDebitMandateService1 = 1;
	size_t soap_flag_directDebitService1 = 1;
	size_t soap_flag_directDebitRefundService1 = 1;
	size_t soap_flag_directDebitValidateService1 = 1;
	size_t soap_flag_paySubscriptionCreateService1 = 1;
	size_t soap_flag_paySubscriptionUpdateService1 = 1;
	size_t soap_flag_paySubscriptionEventUpdateService1 = 1;
	size_t soap_flag_paySubscriptionRetrieveService1 = 1;
	size_t soap_flag_paySubscriptionDeleteService1 = 1;
	size_t soap_flag_payPalPaymentService1 = 1;
	size_t soap_flag_payPalCreditService1 = 1;
	size_t soap_flag_voidService1 = 1;
	size_t soap_flag_businessRules1 = 1;
	size_t soap_flag_pinlessDebitService1 = 1;
	size_t soap_flag_pinlessDebitValidateService1 = 1;
	size_t soap_flag_pinlessDebitReversalService1 = 1;
	size_t soap_flag_batch1 = 1;
	size_t soap_flag_airlineData1 = 1;
	size_t soap_flag_ancillaryData1 = 1;
	size_t soap_flag_lodgingData1 = 1;
	size_t soap_flag_payPalButtonCreateService1 = 1;
	size_t soap_flag_payPalPreapprovedPaymentService1 = 1;
	size_t soap_flag_payPalPreapprovedUpdateService1 = 1;
	size_t soap_flag_riskUpdateService1 = 1;
	size_t soap_flag_fraudUpdateService1 = 1;
	size_t soap_flag_caseManagementActionService1 = 1;
	size_t soap_flag_deviceFingerprintID1 = 1;
	size_t soap_flag_deviceFingerprintRaw1 = 1;
	size_t soap_flag_deviceFingerprintHash1 = 1;
	size_t soap_flag_payPalRefundService1 = 1;
	size_t soap_flag_payPalAuthReversalService1 = 1;
	size_t soap_flag_payPalDoCaptureService1 = 1;
	size_t soap_flag_payPalEcDoPaymentService1 = 1;
	size_t soap_flag_payPalEcGetDetailsService1 = 1;
	size_t soap_flag_payPalEcSetService1 = 1;
	size_t soap_flag_payPalEcOrderSetupService1 = 1;
	size_t soap_flag_payPalAuthorizationService1 = 1;
	size_t soap_flag_payPalUpdateAgreementService1 = 1;
	size_t soap_flag_payPalCreateAgreementService1 = 1;
	size_t soap_flag_payPalDoRefTransactionService1 = 1;
	size_t soap_flag_chinaPaymentService1 = 1;
	size_t soap_flag_chinaRefundService1 = 1;
	size_t soap_flag_boletoPaymentService1 = 1;
	size_t soap_flag_apPaymentType1 = 1;
	size_t soap_flag_apInitiateService1 = 1;
	size_t soap_flag_apCheckStatusService1 = 1;
	size_t soap_flag_ignoreCardExpiration1 = 1;
	size_t soap_flag_reportGroup1 = 1;
	size_t soap_flag_processorID1 = 1;
	size_t soap_flag_thirdPartyCertificationNumber1 = 1;
	size_t soap_flag_transactionLocalDateTime1 = 1;
	size_t soap_flag_solutionProviderTransactionID1 = 1;
	size_t soap_flag_surchargeAmount1 = 1;
	size_t soap_flag_surchargeSign1 = 1;
	size_t soap_flag_pinDataEncryptedPIN1 = 1;
	size_t soap_flag_pinDataKeySerialNumber1 = 1;
	size_t soap_flag_cashbackAmount1 = 1;
	size_t soap_flag_pinDebitPurchaseService1 = 1;
	size_t soap_flag_pinDebitCreditService1 = 1;
	size_t soap_flag_pinDebitReversalService1 = 1;
	size_t soap_flag_ap1 = 1;
	size_t soap_flag_apAuthService1 = 1;
	size_t soap_flag_apAuthReversalService1 = 1;
	size_t soap_flag_apCaptureService1 = 1;
	size_t soap_flag_apOptionsService1 = 1;
	size_t soap_flag_apRefundService1 = 1;
	size_t soap_flag_apSaleService1 = 1;
	size_t soap_flag_apCheckoutDetailsService1 = 1;
	size_t soap_flag_apTransactionDetailsService1 = 1;
	size_t soap_flag_apConfirmPurchaseService1 = 1;
	size_t soap_flag_payPalGetTxnDetailsService1 = 1;
	size_t soap_flag_payPalTransactionSearchService1 = 1;
	size_t soap_flag_ccDCCUpdateService1 = 1;
	size_t soap_flag_emvRequest1 = 1;
	size_t soap_flag_merchantTransactionIdentifier1 = 1;
	size_t soap_flag_hostedDataCreateService1 = 1;
	size_t soap_flag_hostedDataRetrieveService1 = 1;
	size_t soap_flag_merchantCategoryCode1 = 1;
	size_t soap_flag_salesSlipNumber1 = 1;
	size_t soap_flag_merchandiseCode1 = 1;
	size_t soap_flag_merchandiseDescription1 = 1;
	size_t soap_flag_paymentInitiationChannel1 = 1;
	size_t soap_flag_extendedCreditTotalCount1 = 1;
	size_t soap_flag_authIndicator1 = 1;
	size_t soap_flag_paymentNetworkToken1 = 1;
	size_t soap_flag_recipient1 = 1;
	size_t soap_flag_sender1 = 1;
	size_t soap_flag_autoRentalData1 = 1;
	size_t soap_flag_paymentSolution1 = 1;
	size_t soap_flag_vc1 = 1;
	size_t soap_flag_decryptVisaCheckoutDataService1 = 1;
	size_t soap_flag_taxManagementIndicator1 = 1;
	size_t soap_flag_wallet1 = 1;
	size_t soap_flag_aft1 = 1;
	size_t soap_flag_balanceInquiry1 = 1;
	size_t soap_flag_prenoteTransaction1 = 1;
	size_t soap_flag_encryptPaymentDataService1 = 1;
	size_t soap_flag_nationalNetDomesticData1 = 1;
	size_t soap_flag_subsequentAuth1 = 1;
	size_t soap_flag_binLookupService1 = 1;
	size_t soap_flag_verificationCode1 = 1;
	size_t soap_flag_mobileNumber1 = 1;
	size_t soap_flag_issuer1 = 1;
	size_t soap_flag_partnerSolutionID1 = 1;
	size_t soap_flag_developerID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_merchantID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantID", (wchar_t**)&a->ns2__RequestMessage::merchantID, "xsd:string"))
				{	soap_flag_merchantID1--;
					continue;
				}
			if (soap_flag_merchantReferenceCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantReferenceCode", (wchar_t**)&a->ns2__RequestMessage::merchantReferenceCode, "xsd:string"))
				{	soap_flag_merchantReferenceCode1--;
					continue;
				}
			if (soap_flag_debtIndicator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:debtIndicator", &a->ns2__RequestMessage::debtIndicator, "ns2:boolean"))
				{	soap_flag_debtIndicator1--;
					continue;
				}
			if (soap_flag_clientLibrary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:clientLibrary", (wchar_t**)&a->ns2__RequestMessage::clientLibrary, "xsd:string"))
				{	soap_flag_clientLibrary1--;
					continue;
				}
			if (soap_flag_clientLibraryVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:clientLibraryVersion", (wchar_t**)&a->ns2__RequestMessage::clientLibraryVersion, "xsd:string"))
				{	soap_flag_clientLibraryVersion1--;
					continue;
				}
			if (soap_flag_clientEnvironment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:clientEnvironment", (wchar_t**)&a->ns2__RequestMessage::clientEnvironment, "xsd:string"))
				{	soap_flag_clientEnvironment1--;
					continue;
				}
			if (soap_flag_clientSecurityLibraryVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:clientSecurityLibraryVersion", (wchar_t**)&a->ns2__RequestMessage::clientSecurityLibraryVersion, "xsd:string"))
				{	soap_flag_clientSecurityLibraryVersion1--;
					continue;
				}
			if (soap_flag_clientApplication1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:clientApplication", (wchar_t**)&a->ns2__RequestMessage::clientApplication, "xsd:string"))
				{	soap_flag_clientApplication1--;
					continue;
				}
			if (soap_flag_clientApplicationVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:clientApplicationVersion", (wchar_t**)&a->ns2__RequestMessage::clientApplicationVersion, "xsd:string"))
				{	soap_flag_clientApplicationVersion1--;
					continue;
				}
			if (soap_flag_clientApplicationUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:clientApplicationUser", (wchar_t**)&a->ns2__RequestMessage::clientApplicationUser, "xsd:string"))
				{	soap_flag_clientApplicationUser1--;
					continue;
				}
			if (soap_flag_routingCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:routingCode", (wchar_t**)&a->ns2__RequestMessage::routingCode, "xsd:string"))
				{	soap_flag_routingCode1--;
					continue;
				}
			if (soap_flag_comments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:comments", (wchar_t**)&a->ns2__RequestMessage::comments, "xsd:string"))
				{	soap_flag_comments1--;
					continue;
				}
			if (soap_flag_returnURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:returnURL", (wchar_t**)&a->ns2__RequestMessage::returnURL, "xsd:string"))
				{	soap_flag_returnURL1--;
					continue;
				}
			if (soap_flag_invoiceHeader1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__InvoiceHeader(soap, "ns2:invoiceHeader", &a->ns2__RequestMessage::invoiceHeader, "ns2:InvoiceHeader"))
				{	soap_flag_invoiceHeader1--;
					continue;
				}
			if (soap_flag_aggregatorMerchantIdentifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:aggregatorMerchantIdentifier", (wchar_t**)&a->ns2__RequestMessage::aggregatorMerchantIdentifier, "xsd:string"))
				{	soap_flag_aggregatorMerchantIdentifier1--;
					continue;
				}
			if (soap_flag_customerID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:customerID", (wchar_t**)&a->ns2__RequestMessage::customerID, "xsd:string"))
				{	soap_flag_customerID1--;
					continue;
				}
			if (soap_flag_customerFirstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:customerFirstName", (wchar_t**)&a->ns2__RequestMessage::customerFirstName, "xsd:string"))
				{	soap_flag_customerFirstName1--;
					continue;
				}
			if (soap_flag_customerLastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:customerLastName", (wchar_t**)&a->ns2__RequestMessage::customerLastName, "xsd:string"))
				{	soap_flag_customerLastName1--;
					continue;
				}
			if (soap_flag_billTo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BillTo(soap, "ns2:billTo", &a->ns2__RequestMessage::billTo, "ns2:BillTo"))
				{	soap_flag_billTo1--;
					continue;
				}
			if (soap_flag_shipTo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ShipTo(soap, "ns2:shipTo", &a->ns2__RequestMessage::shipTo, "ns2:ShipTo"))
				{	soap_flag_shipTo1--;
					continue;
				}
			if (soap_flag_personalId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PersonalId(soap, "ns2:personalId", &a->ns2__RequestMessage::personalId, "ns2:PersonalId"))
				{	soap_flag_personalId1--;
					continue;
				}
			if (soap_flag_shipFrom1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ShipFrom(soap, "ns2:shipFrom", &a->ns2__RequestMessage::shipFrom, "ns2:ShipFrom"))
				{	soap_flag_shipFrom1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__Item(soap, "ns2:item", &a->ns2__RequestMessage::item, "ns2:Item"))
					continue;
			if (soap_flag_purchaseTotals1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PurchaseTotals(soap, "ns2:purchaseTotals", &a->ns2__RequestMessage::purchaseTotals, "ns2:PurchaseTotals"))
				{	soap_flag_purchaseTotals1--;
					continue;
				}
			if (soap_flag_fundingTotals1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FundingTotals(soap, "ns2:fundingTotals", &a->ns2__RequestMessage::fundingTotals, "ns2:FundingTotals"))
				{	soap_flag_fundingTotals1--;
					continue;
				}
			if (soap_flag_dcc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DCC(soap, "ns2:dcc", &a->ns2__RequestMessage::dcc, "ns2:DCC"))
				{	soap_flag_dcc1--;
					continue;
				}
			if (soap_flag_pos1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Pos(soap, "ns2:pos", &a->ns2__RequestMessage::pos, "ns2:Pos"))
				{	soap_flag_pos1--;
					continue;
				}
			if (soap_flag_encryptedPayment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EncryptedPayment(soap, "ns2:encryptedPayment", &a->ns2__RequestMessage::encryptedPayment, "ns2:EncryptedPayment"))
				{	soap_flag_encryptedPayment1--;
					continue;
				}
			if (soap_flag_installment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Installment(soap, "ns2:installment", &a->ns2__RequestMessage::installment, "ns2:Installment"))
				{	soap_flag_installment1--;
					continue;
				}
			if (soap_flag_card1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Card(soap, "ns2:card", &a->ns2__RequestMessage::card, "ns2:Card"))
				{	soap_flag_card1--;
					continue;
				}
			if (soap_flag_check1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Check(soap, "ns2:check", &a->ns2__RequestMessage::check, "ns2:Check"))
				{	soap_flag_check1--;
					continue;
				}
			if (soap_flag_bml1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BML(soap, "ns2:bml", &a->ns2__RequestMessage::bml, "ns2:BML"))
				{	soap_flag_bml1--;
					continue;
				}
			if (soap_flag_gecc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__GECC(soap, "ns2:gecc", &a->ns2__RequestMessage::gecc, "ns2:GECC"))
				{	soap_flag_gecc1--;
					continue;
				}
			if (soap_flag_ucaf1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UCAF(soap, "ns2:ucaf", &a->ns2__RequestMessage::ucaf, "ns2:UCAF"))
				{	soap_flag_ucaf1--;
					continue;
				}
			if (soap_flag_fundTransfer1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FundTransfer(soap, "ns2:fundTransfer", &a->ns2__RequestMessage::fundTransfer, "ns2:FundTransfer"))
				{	soap_flag_fundTransfer1--;
					continue;
				}
			if (soap_flag_bankInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BankInfo(soap, "ns2:bankInfo", &a->ns2__RequestMessage::bankInfo, "ns2:BankInfo"))
				{	soap_flag_bankInfo1--;
					continue;
				}
			if (soap_flag_subscription1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Subscription(soap, "ns2:subscription", &a->ns2__RequestMessage::subscription, "ns2:Subscription"))
				{	soap_flag_subscription1--;
					continue;
				}
			if (soap_flag_recurringSubscriptionInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RecurringSubscriptionInfo(soap, "ns2:recurringSubscriptionInfo", &a->ns2__RequestMessage::recurringSubscriptionInfo, "ns2:RecurringSubscriptionInfo"))
				{	soap_flag_recurringSubscriptionInfo1--;
					continue;
				}
			if (soap_flag_decisionManager1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DecisionManager(soap, "ns2:decisionManager", &a->ns2__RequestMessage::decisionManager, "ns2:DecisionManager"))
				{	soap_flag_decisionManager1--;
					continue;
				}
			if (soap_flag_otherTax1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__OtherTax(soap, "ns2:otherTax", &a->ns2__RequestMessage::otherTax, "ns2:OtherTax"))
				{	soap_flag_otherTax1--;
					continue;
				}
			if (soap_flag_paypal1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPal(soap, "ns2:paypal", &a->ns2__RequestMessage::paypal, "ns2:PayPal"))
				{	soap_flag_paypal1--;
					continue;
				}
			if (soap_flag_merchantDefinedData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MerchantDefinedData(soap, "ns2:merchantDefinedData", &a->ns2__RequestMessage::merchantDefinedData, "ns2:MerchantDefinedData"))
				{	soap_flag_merchantDefinedData1--;
					continue;
				}
			if (soap_flag_merchantSecureData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MerchantSecureData(soap, "ns2:merchantSecureData", &a->ns2__RequestMessage::merchantSecureData, "ns2:MerchantSecureData"))
				{	soap_flag_merchantSecureData1--;
					continue;
				}
			if (soap_flag_jpo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__JPO(soap, "ns2:jpo", &a->ns2__RequestMessage::jpo, "ns2:JPO"))
				{	soap_flag_jpo1--;
					continue;
				}
			if (soap_flag_orderRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderRequestToken", (wchar_t**)&a->ns2__RequestMessage::orderRequestToken, "xsd:string"))
				{	soap_flag_orderRequestToken1--;
					continue;
				}
			if (soap_flag_linkToRequest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:linkToRequest", (wchar_t**)&a->ns2__RequestMessage::linkToRequest, "xsd:string"))
				{	soap_flag_linkToRequest1--;
					continue;
				}
			if (soap_flag_serviceFee1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ServiceFee(soap, "ns2:serviceFee", &a->ns2__RequestMessage::serviceFee, "ns2:ServiceFee"))
				{	soap_flag_serviceFee1--;
					continue;
				}
			if (soap_flag_ccAuthService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CCAuthService(soap, "ns2:ccAuthService", &a->ns2__RequestMessage::ccAuthService, "ns2:CCAuthService"))
				{	soap_flag_ccAuthService1--;
					continue;
				}
			if (soap_flag_octService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__OCTService(soap, "ns2:octService", &a->ns2__RequestMessage::octService, "ns2:OCTService"))
				{	soap_flag_octService1--;
					continue;
				}
			if (soap_flag_verificationService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VerificationService(soap, "ns2:verificationService", &a->ns2__RequestMessage::verificationService, "ns2:VerificationService"))
				{	soap_flag_verificationService1--;
					continue;
				}
			if (soap_flag_ccSaleService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CCSaleService(soap, "ns2:ccSaleService", &a->ns2__RequestMessage::ccSaleService, "ns2:CCSaleService"))
				{	soap_flag_ccSaleService1--;
					continue;
				}
			if (soap_flag_ccSaleCreditService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CCSaleCreditService(soap, "ns2:ccSaleCreditService", &a->ns2__RequestMessage::ccSaleCreditService, "ns2:CCSaleCreditService"))
				{	soap_flag_ccSaleCreditService1--;
					continue;
				}
			if (soap_flag_ccSaleReversalService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CCSaleReversalService(soap, "ns2:ccSaleReversalService", &a->ns2__RequestMessage::ccSaleReversalService, "ns2:CCSaleReversalService"))
				{	soap_flag_ccSaleReversalService1--;
					continue;
				}
			if (soap_flag_ccIncrementalAuthService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CCIncrementalAuthService(soap, "ns2:ccIncrementalAuthService", &a->ns2__RequestMessage::ccIncrementalAuthService, "ns2:CCIncrementalAuthService"))
				{	soap_flag_ccIncrementalAuthService1--;
					continue;
				}
			if (soap_flag_ccCaptureService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CCCaptureService(soap, "ns2:ccCaptureService", &a->ns2__RequestMessage::ccCaptureService, "ns2:CCCaptureService"))
				{	soap_flag_ccCaptureService1--;
					continue;
				}
			if (soap_flag_ccCreditService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CCCreditService(soap, "ns2:ccCreditService", &a->ns2__RequestMessage::ccCreditService, "ns2:CCCreditService"))
				{	soap_flag_ccCreditService1--;
					continue;
				}
			if (soap_flag_ccAuthReversalService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CCAuthReversalService(soap, "ns2:ccAuthReversalService", &a->ns2__RequestMessage::ccAuthReversalService, "ns2:CCAuthReversalService"))
				{	soap_flag_ccAuthReversalService1--;
					continue;
				}
			if (soap_flag_ccAutoAuthReversalService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CCAutoAuthReversalService(soap, "ns2:ccAutoAuthReversalService", &a->ns2__RequestMessage::ccAutoAuthReversalService, "ns2:CCAutoAuthReversalService"))
				{	soap_flag_ccAutoAuthReversalService1--;
					continue;
				}
			if (soap_flag_ccDCCService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CCDCCService(soap, "ns2:ccDCCService", &a->ns2__RequestMessage::ccDCCService, "ns2:CCDCCService"))
				{	soap_flag_ccDCCService1--;
					continue;
				}
			if (soap_flag_serviceFeeCalculateService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ServiceFeeCalculateService(soap, "ns2:serviceFeeCalculateService", &a->ns2__RequestMessage::serviceFeeCalculateService, "ns2:ServiceFeeCalculateService"))
				{	soap_flag_serviceFeeCalculateService1--;
					continue;
				}
			if (soap_flag_ecDebitService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ECDebitService(soap, "ns2:ecDebitService", &a->ns2__RequestMessage::ecDebitService, "ns2:ECDebitService"))
				{	soap_flag_ecDebitService1--;
					continue;
				}
			if (soap_flag_ecCreditService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ECCreditService(soap, "ns2:ecCreditService", &a->ns2__RequestMessage::ecCreditService, "ns2:ECCreditService"))
				{	soap_flag_ecCreditService1--;
					continue;
				}
			if (soap_flag_ecAuthenticateService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ECAuthenticateService(soap, "ns2:ecAuthenticateService", &a->ns2__RequestMessage::ecAuthenticateService, "ns2:ECAuthenticateService"))
				{	soap_flag_ecAuthenticateService1--;
					continue;
				}
			if (soap_flag_payerAuthEnrollService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayerAuthEnrollService(soap, "ns2:payerAuthEnrollService", &a->ns2__RequestMessage::payerAuthEnrollService, "ns2:PayerAuthEnrollService"))
				{	soap_flag_payerAuthEnrollService1--;
					continue;
				}
			if (soap_flag_payerAuthValidateService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayerAuthValidateService(soap, "ns2:payerAuthValidateService", &a->ns2__RequestMessage::payerAuthValidateService, "ns2:PayerAuthValidateService"))
				{	soap_flag_payerAuthValidateService1--;
					continue;
				}
			if (soap_flag_taxService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__TaxService(soap, "ns2:taxService", &a->ns2__RequestMessage::taxService, "ns2:TaxService"))
				{	soap_flag_taxService1--;
					continue;
				}
			if (soap_flag_dmeService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DMEService(soap, "ns2:dmeService", &a->ns2__RequestMessage::dmeService, "ns2:DMEService"))
				{	soap_flag_dmeService1--;
					continue;
				}
			if (soap_flag_afsService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AFSService(soap, "ns2:afsService", &a->ns2__RequestMessage::afsService, "ns2:AFSService"))
				{	soap_flag_afsService1--;
					continue;
				}
			if (soap_flag_davService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DAVService(soap, "ns2:davService", &a->ns2__RequestMessage::davService, "ns2:DAVService"))
				{	soap_flag_davService1--;
					continue;
				}
			if (soap_flag_exportService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ExportService(soap, "ns2:exportService", &a->ns2__RequestMessage::exportService, "ns2:ExportService"))
				{	soap_flag_exportService1--;
					continue;
				}
			if (soap_flag_fxRatesService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FXRatesService(soap, "ns2:fxRatesService", &a->ns2__RequestMessage::fxRatesService, "ns2:FXRatesService"))
				{	soap_flag_fxRatesService1--;
					continue;
				}
			if (soap_flag_bankTransferService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BankTransferService(soap, "ns2:bankTransferService", &a->ns2__RequestMessage::bankTransferService, "ns2:BankTransferService"))
				{	soap_flag_bankTransferService1--;
					continue;
				}
			if (soap_flag_bankTransferRefundService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BankTransferRefundService(soap, "ns2:bankTransferRefundService", &a->ns2__RequestMessage::bankTransferRefundService, "ns2:BankTransferRefundService"))
				{	soap_flag_bankTransferRefundService1--;
					continue;
				}
			if (soap_flag_bankTransferRealTimeService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BankTransferRealTimeService(soap, "ns2:bankTransferRealTimeService", &a->ns2__RequestMessage::bankTransferRealTimeService, "ns2:BankTransferRealTimeService"))
				{	soap_flag_bankTransferRealTimeService1--;
					continue;
				}
			if (soap_flag_directDebitMandateService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DirectDebitMandateService(soap, "ns2:directDebitMandateService", &a->ns2__RequestMessage::directDebitMandateService, "ns2:DirectDebitMandateService"))
				{	soap_flag_directDebitMandateService1--;
					continue;
				}
			if (soap_flag_directDebitService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DirectDebitService(soap, "ns2:directDebitService", &a->ns2__RequestMessage::directDebitService, "ns2:DirectDebitService"))
				{	soap_flag_directDebitService1--;
					continue;
				}
			if (soap_flag_directDebitRefundService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DirectDebitRefundService(soap, "ns2:directDebitRefundService", &a->ns2__RequestMessage::directDebitRefundService, "ns2:DirectDebitRefundService"))
				{	soap_flag_directDebitRefundService1--;
					continue;
				}
			if (soap_flag_directDebitValidateService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DirectDebitValidateService(soap, "ns2:directDebitValidateService", &a->ns2__RequestMessage::directDebitValidateService, "ns2:DirectDebitValidateService"))
				{	soap_flag_directDebitValidateService1--;
					continue;
				}
			if (soap_flag_paySubscriptionCreateService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PaySubscriptionCreateService(soap, "ns2:paySubscriptionCreateService", &a->ns2__RequestMessage::paySubscriptionCreateService, "ns2:PaySubscriptionCreateService"))
				{	soap_flag_paySubscriptionCreateService1--;
					continue;
				}
			if (soap_flag_paySubscriptionUpdateService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PaySubscriptionUpdateService(soap, "ns2:paySubscriptionUpdateService", &a->ns2__RequestMessage::paySubscriptionUpdateService, "ns2:PaySubscriptionUpdateService"))
				{	soap_flag_paySubscriptionUpdateService1--;
					continue;
				}
			if (soap_flag_paySubscriptionEventUpdateService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PaySubscriptionEventUpdateService(soap, "ns2:paySubscriptionEventUpdateService", &a->ns2__RequestMessage::paySubscriptionEventUpdateService, "ns2:PaySubscriptionEventUpdateService"))
				{	soap_flag_paySubscriptionEventUpdateService1--;
					continue;
				}
			if (soap_flag_paySubscriptionRetrieveService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PaySubscriptionRetrieveService(soap, "ns2:paySubscriptionRetrieveService", &a->ns2__RequestMessage::paySubscriptionRetrieveService, "ns2:PaySubscriptionRetrieveService"))
				{	soap_flag_paySubscriptionRetrieveService1--;
					continue;
				}
			if (soap_flag_paySubscriptionDeleteService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PaySubscriptionDeleteService(soap, "ns2:paySubscriptionDeleteService", &a->ns2__RequestMessage::paySubscriptionDeleteService, "ns2:PaySubscriptionDeleteService"))
				{	soap_flag_paySubscriptionDeleteService1--;
					continue;
				}
			if (soap_flag_payPalPaymentService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalPaymentService(soap, "ns2:payPalPaymentService", &a->ns2__RequestMessage::payPalPaymentService, "ns2:PayPalPaymentService"))
				{	soap_flag_payPalPaymentService1--;
					continue;
				}
			if (soap_flag_payPalCreditService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalCreditService(soap, "ns2:payPalCreditService", &a->ns2__RequestMessage::payPalCreditService, "ns2:PayPalCreditService"))
				{	soap_flag_payPalCreditService1--;
					continue;
				}
			if (soap_flag_voidService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VoidService(soap, "ns2:voidService", &a->ns2__RequestMessage::voidService, "ns2:VoidService"))
				{	soap_flag_voidService1--;
					continue;
				}
			if (soap_flag_businessRules1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BusinessRules(soap, "ns2:businessRules", &a->ns2__RequestMessage::businessRules, "ns2:BusinessRules"))
				{	soap_flag_businessRules1--;
					continue;
				}
			if (soap_flag_pinlessDebitService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PinlessDebitService(soap, "ns2:pinlessDebitService", &a->ns2__RequestMessage::pinlessDebitService, "ns2:PinlessDebitService"))
				{	soap_flag_pinlessDebitService1--;
					continue;
				}
			if (soap_flag_pinlessDebitValidateService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PinlessDebitValidateService(soap, "ns2:pinlessDebitValidateService", &a->ns2__RequestMessage::pinlessDebitValidateService, "ns2:PinlessDebitValidateService"))
				{	soap_flag_pinlessDebitValidateService1--;
					continue;
				}
			if (soap_flag_pinlessDebitReversalService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PinlessDebitReversalService(soap, "ns2:pinlessDebitReversalService", &a->ns2__RequestMessage::pinlessDebitReversalService, "ns2:PinlessDebitReversalService"))
				{	soap_flag_pinlessDebitReversalService1--;
					continue;
				}
			if (soap_flag_batch1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Batch(soap, "ns2:batch", &a->ns2__RequestMessage::batch, "ns2:Batch"))
				{	soap_flag_batch1--;
					continue;
				}
			if (soap_flag_airlineData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AirlineData(soap, "ns2:airlineData", &a->ns2__RequestMessage::airlineData, "ns2:AirlineData"))
				{	soap_flag_airlineData1--;
					continue;
				}
			if (soap_flag_ancillaryData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AncillaryData(soap, "ns2:ancillaryData", &a->ns2__RequestMessage::ancillaryData, "ns2:AncillaryData"))
				{	soap_flag_ancillaryData1--;
					continue;
				}
			if (soap_flag_lodgingData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__LodgingData(soap, "ns2:lodgingData", &a->ns2__RequestMessage::lodgingData, "ns2:LodgingData"))
				{	soap_flag_lodgingData1--;
					continue;
				}
			if (soap_flag_payPalButtonCreateService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalButtonCreateService(soap, "ns2:payPalButtonCreateService", &a->ns2__RequestMessage::payPalButtonCreateService, "ns2:PayPalButtonCreateService"))
				{	soap_flag_payPalButtonCreateService1--;
					continue;
				}
			if (soap_flag_payPalPreapprovedPaymentService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalPreapprovedPaymentService(soap, "ns2:payPalPreapprovedPaymentService", &a->ns2__RequestMessage::payPalPreapprovedPaymentService, "ns2:PayPalPreapprovedPaymentService"))
				{	soap_flag_payPalPreapprovedPaymentService1--;
					continue;
				}
			if (soap_flag_payPalPreapprovedUpdateService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalPreapprovedUpdateService(soap, "ns2:payPalPreapprovedUpdateService", &a->ns2__RequestMessage::payPalPreapprovedUpdateService, "ns2:PayPalPreapprovedUpdateService"))
				{	soap_flag_payPalPreapprovedUpdateService1--;
					continue;
				}
			if (soap_flag_riskUpdateService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RiskUpdateService(soap, "ns2:riskUpdateService", &a->ns2__RequestMessage::riskUpdateService, "ns2:RiskUpdateService"))
				{	soap_flag_riskUpdateService1--;
					continue;
				}
			if (soap_flag_fraudUpdateService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FraudUpdateService(soap, "ns2:fraudUpdateService", &a->ns2__RequestMessage::fraudUpdateService, "ns2:FraudUpdateService"))
				{	soap_flag_fraudUpdateService1--;
					continue;
				}
			if (soap_flag_caseManagementActionService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CaseManagementActionService(soap, "ns2:caseManagementActionService", &a->ns2__RequestMessage::caseManagementActionService, "ns2:CaseManagementActionService"))
				{	soap_flag_caseManagementActionService1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__RequestReserved(soap, "ns2:reserved", &a->ns2__RequestMessage::reserved, "ns2:RequestReserved"))
					continue;
			if (soap_flag_deviceFingerprintID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:deviceFingerprintID", (wchar_t**)&a->ns2__RequestMessage::deviceFingerprintID, "xsd:string"))
				{	soap_flag_deviceFingerprintID1--;
					continue;
				}
			if (soap_flag_deviceFingerprintRaw1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:deviceFingerprintRaw", &a->ns2__RequestMessage::deviceFingerprintRaw, "ns2:boolean"))
				{	soap_flag_deviceFingerprintRaw1--;
					continue;
				}
			if (soap_flag_deviceFingerprintHash1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:deviceFingerprintHash", (wchar_t**)&a->ns2__RequestMessage::deviceFingerprintHash, "xsd:string"))
				{	soap_flag_deviceFingerprintHash1--;
					continue;
				}
			if (soap_flag_payPalRefundService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalRefundService(soap, "ns2:payPalRefundService", &a->ns2__RequestMessage::payPalRefundService, "ns2:PayPalRefundService"))
				{	soap_flag_payPalRefundService1--;
					continue;
				}
			if (soap_flag_payPalAuthReversalService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalAuthReversalService(soap, "ns2:payPalAuthReversalService", &a->ns2__RequestMessage::payPalAuthReversalService, "ns2:PayPalAuthReversalService"))
				{	soap_flag_payPalAuthReversalService1--;
					continue;
				}
			if (soap_flag_payPalDoCaptureService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalDoCaptureService(soap, "ns2:payPalDoCaptureService", &a->ns2__RequestMessage::payPalDoCaptureService, "ns2:PayPalDoCaptureService"))
				{	soap_flag_payPalDoCaptureService1--;
					continue;
				}
			if (soap_flag_payPalEcDoPaymentService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalEcDoPaymentService(soap, "ns2:payPalEcDoPaymentService", &a->ns2__RequestMessage::payPalEcDoPaymentService, "ns2:PayPalEcDoPaymentService"))
				{	soap_flag_payPalEcDoPaymentService1--;
					continue;
				}
			if (soap_flag_payPalEcGetDetailsService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalEcGetDetailsService(soap, "ns2:payPalEcGetDetailsService", &a->ns2__RequestMessage::payPalEcGetDetailsService, "ns2:PayPalEcGetDetailsService"))
				{	soap_flag_payPalEcGetDetailsService1--;
					continue;
				}
			if (soap_flag_payPalEcSetService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalEcSetService(soap, "ns2:payPalEcSetService", &a->ns2__RequestMessage::payPalEcSetService, "ns2:PayPalEcSetService"))
				{	soap_flag_payPalEcSetService1--;
					continue;
				}
			if (soap_flag_payPalEcOrderSetupService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalEcOrderSetupService(soap, "ns2:payPalEcOrderSetupService", &a->ns2__RequestMessage::payPalEcOrderSetupService, "ns2:PayPalEcOrderSetupService"))
				{	soap_flag_payPalEcOrderSetupService1--;
					continue;
				}
			if (soap_flag_payPalAuthorizationService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalAuthorizationService(soap, "ns2:payPalAuthorizationService", &a->ns2__RequestMessage::payPalAuthorizationService, "ns2:PayPalAuthorizationService"))
				{	soap_flag_payPalAuthorizationService1--;
					continue;
				}
			if (soap_flag_payPalUpdateAgreementService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalUpdateAgreementService(soap, "ns2:payPalUpdateAgreementService", &a->ns2__RequestMessage::payPalUpdateAgreementService, "ns2:PayPalUpdateAgreementService"))
				{	soap_flag_payPalUpdateAgreementService1--;
					continue;
				}
			if (soap_flag_payPalCreateAgreementService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalCreateAgreementService(soap, "ns2:payPalCreateAgreementService", &a->ns2__RequestMessage::payPalCreateAgreementService, "ns2:PayPalCreateAgreementService"))
				{	soap_flag_payPalCreateAgreementService1--;
					continue;
				}
			if (soap_flag_payPalDoRefTransactionService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalDoRefTransactionService(soap, "ns2:payPalDoRefTransactionService", &a->ns2__RequestMessage::payPalDoRefTransactionService, "ns2:PayPalDoRefTransactionService"))
				{	soap_flag_payPalDoRefTransactionService1--;
					continue;
				}
			if (soap_flag_chinaPaymentService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ChinaPaymentService(soap, "ns2:chinaPaymentService", &a->ns2__RequestMessage::chinaPaymentService, "ns2:ChinaPaymentService"))
				{	soap_flag_chinaPaymentService1--;
					continue;
				}
			if (soap_flag_chinaRefundService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ChinaRefundService(soap, "ns2:chinaRefundService", &a->ns2__RequestMessage::chinaRefundService, "ns2:ChinaRefundService"))
				{	soap_flag_chinaRefundService1--;
					continue;
				}
			if (soap_flag_boletoPaymentService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BoletoPaymentService(soap, "ns2:boletoPaymentService", &a->ns2__RequestMessage::boletoPaymentService, "ns2:BoletoPaymentService"))
				{	soap_flag_boletoPaymentService1--;
					continue;
				}
			if (soap_flag_apPaymentType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:apPaymentType", (wchar_t**)&a->ns2__RequestMessage::apPaymentType, "xsd:string"))
				{	soap_flag_apPaymentType1--;
					continue;
				}
			if (soap_flag_apInitiateService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APInitiateService(soap, "ns2:apInitiateService", &a->ns2__RequestMessage::apInitiateService, "ns2:APInitiateService"))
				{	soap_flag_apInitiateService1--;
					continue;
				}
			if (soap_flag_apCheckStatusService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APCheckStatusService(soap, "ns2:apCheckStatusService", &a->ns2__RequestMessage::apCheckStatusService, "ns2:APCheckStatusService"))
				{	soap_flag_apCheckStatusService1--;
					continue;
				}
			if (soap_flag_ignoreCardExpiration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:ignoreCardExpiration", &a->ns2__RequestMessage::ignoreCardExpiration, "ns2:boolean"))
				{	soap_flag_ignoreCardExpiration1--;
					continue;
				}
			if (soap_flag_reportGroup1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reportGroup", (wchar_t**)&a->ns2__RequestMessage::reportGroup, "xsd:string"))
				{	soap_flag_reportGroup1--;
					continue;
				}
			if (soap_flag_processorID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:processorID", (wchar_t**)&a->ns2__RequestMessage::processorID, "xsd:string"))
				{	soap_flag_processorID1--;
					continue;
				}
			if (soap_flag_thirdPartyCertificationNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:thirdPartyCertificationNumber", (wchar_t**)&a->ns2__RequestMessage::thirdPartyCertificationNumber, "xsd:string"))
				{	soap_flag_thirdPartyCertificationNumber1--;
					continue;
				}
			if (soap_flag_transactionLocalDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:transactionLocalDateTime", &a->ns2__RequestMessage::transactionLocalDateTime, "ns2:dateTime"))
				{	soap_flag_transactionLocalDateTime1--;
					continue;
				}
			if (soap_flag_solutionProviderTransactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:solutionProviderTransactionID", (wchar_t**)&a->ns2__RequestMessage::solutionProviderTransactionID, "xsd:string"))
				{	soap_flag_solutionProviderTransactionID1--;
					continue;
				}
			if (soap_flag_surchargeAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:surchargeAmount", &a->ns2__RequestMessage::surchargeAmount, "ns2:amount"))
				{	soap_flag_surchargeAmount1--;
					continue;
				}
			if (soap_flag_surchargeSign1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:surchargeSign", (wchar_t**)&a->ns2__RequestMessage::surchargeSign, "xsd:string"))
				{	soap_flag_surchargeSign1--;
					continue;
				}
			if (soap_flag_pinDataEncryptedPIN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pinDataEncryptedPIN", (wchar_t**)&a->ns2__RequestMessage::pinDataEncryptedPIN, "xsd:string"))
				{	soap_flag_pinDataEncryptedPIN1--;
					continue;
				}
			if (soap_flag_pinDataKeySerialNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pinDataKeySerialNumber", (wchar_t**)&a->ns2__RequestMessage::pinDataKeySerialNumber, "xsd:string"))
				{	soap_flag_pinDataKeySerialNumber1--;
					continue;
				}
			if (soap_flag_cashbackAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:cashbackAmount", &a->ns2__RequestMessage::cashbackAmount, "ns2:amount"))
				{	soap_flag_cashbackAmount1--;
					continue;
				}
			if (soap_flag_pinDebitPurchaseService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PinDebitPurchaseService(soap, "ns2:pinDebitPurchaseService", &a->ns2__RequestMessage::pinDebitPurchaseService, "ns2:PinDebitPurchaseService"))
				{	soap_flag_pinDebitPurchaseService1--;
					continue;
				}
			if (soap_flag_pinDebitCreditService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PinDebitCreditService(soap, "ns2:pinDebitCreditService", &a->ns2__RequestMessage::pinDebitCreditService, "ns2:PinDebitCreditService"))
				{	soap_flag_pinDebitCreditService1--;
					continue;
				}
			if (soap_flag_pinDebitReversalService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PinDebitReversalService(soap, "ns2:pinDebitReversalService", &a->ns2__RequestMessage::pinDebitReversalService, "ns2:PinDebitReversalService"))
				{	soap_flag_pinDebitReversalService1--;
					continue;
				}
			if (soap_flag_ap1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AP(soap, "ns2:ap", &a->ns2__RequestMessage::ap, "ns2:AP"))
				{	soap_flag_ap1--;
					continue;
				}
			if (soap_flag_apAuthService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APAuthService(soap, "ns2:apAuthService", &a->ns2__RequestMessage::apAuthService, "ns2:APAuthService"))
				{	soap_flag_apAuthService1--;
					continue;
				}
			if (soap_flag_apAuthReversalService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APAuthReversalService(soap, "ns2:apAuthReversalService", &a->ns2__RequestMessage::apAuthReversalService, "ns2:APAuthReversalService"))
				{	soap_flag_apAuthReversalService1--;
					continue;
				}
			if (soap_flag_apCaptureService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APCaptureService(soap, "ns2:apCaptureService", &a->ns2__RequestMessage::apCaptureService, "ns2:APCaptureService"))
				{	soap_flag_apCaptureService1--;
					continue;
				}
			if (soap_flag_apOptionsService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APOptionsService(soap, "ns2:apOptionsService", &a->ns2__RequestMessage::apOptionsService, "ns2:APOptionsService"))
				{	soap_flag_apOptionsService1--;
					continue;
				}
			if (soap_flag_apRefundService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APRefundService(soap, "ns2:apRefundService", &a->ns2__RequestMessage::apRefundService, "ns2:APRefundService"))
				{	soap_flag_apRefundService1--;
					continue;
				}
			if (soap_flag_apSaleService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APSaleService(soap, "ns2:apSaleService", &a->ns2__RequestMessage::apSaleService, "ns2:APSaleService"))
				{	soap_flag_apSaleService1--;
					continue;
				}
			if (soap_flag_apCheckoutDetailsService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APCheckOutDetailsService(soap, "ns2:apCheckoutDetailsService", &a->ns2__RequestMessage::apCheckoutDetailsService, "ns2:APCheckOutDetailsService"))
				{	soap_flag_apCheckoutDetailsService1--;
					continue;
				}
			if (soap_flag_apTransactionDetailsService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APTransactionDetailsService(soap, "ns2:apTransactionDetailsService", &a->ns2__RequestMessage::apTransactionDetailsService, "ns2:APTransactionDetailsService"))
				{	soap_flag_apTransactionDetailsService1--;
					continue;
				}
			if (soap_flag_apConfirmPurchaseService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APConfirmPurchaseService(soap, "ns2:apConfirmPurchaseService", &a->ns2__RequestMessage::apConfirmPurchaseService, "ns2:APConfirmPurchaseService"))
				{	soap_flag_apConfirmPurchaseService1--;
					continue;
				}
			if (soap_flag_payPalGetTxnDetailsService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalGetTxnDetailsService(soap, "ns2:payPalGetTxnDetailsService", &a->ns2__RequestMessage::payPalGetTxnDetailsService, "ns2:PayPalGetTxnDetailsService"))
				{	soap_flag_payPalGetTxnDetailsService1--;
					continue;
				}
			if (soap_flag_payPalTransactionSearchService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayPalTransactionSearchService(soap, "ns2:payPalTransactionSearchService", &a->ns2__RequestMessage::payPalTransactionSearchService, "ns2:PayPalTransactionSearchService"))
				{	soap_flag_payPalTransactionSearchService1--;
					continue;
				}
			if (soap_flag_ccDCCUpdateService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CCDCCUpdateService(soap, "ns2:ccDCCUpdateService", &a->ns2__RequestMessage::ccDCCUpdateService, "ns2:CCDCCUpdateService"))
				{	soap_flag_ccDCCUpdateService1--;
					continue;
				}
			if (soap_flag_emvRequest1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EmvRequest(soap, "ns2:emvRequest", &a->ns2__RequestMessage::emvRequest, "ns2:EmvRequest"))
				{	soap_flag_emvRequest1--;
					continue;
				}
			if (soap_flag_merchantTransactionIdentifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantTransactionIdentifier", (wchar_t**)&a->ns2__RequestMessage::merchantTransactionIdentifier, "xsd:string"))
				{	soap_flag_merchantTransactionIdentifier1--;
					continue;
				}
			if (soap_flag_hostedDataCreateService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__HostedDataCreateService(soap, "ns2:hostedDataCreateService", &a->ns2__RequestMessage::hostedDataCreateService, "ns2:HostedDataCreateService"))
				{	soap_flag_hostedDataCreateService1--;
					continue;
				}
			if (soap_flag_hostedDataRetrieveService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__HostedDataRetrieveService(soap, "ns2:hostedDataRetrieveService", &a->ns2__RequestMessage::hostedDataRetrieveService, "ns2:HostedDataRetrieveService"))
				{	soap_flag_hostedDataRetrieveService1--;
					continue;
				}
			if (soap_flag_merchantCategoryCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantCategoryCode", (wchar_t**)&a->ns2__RequestMessage::merchantCategoryCode, "xsd:string"))
				{	soap_flag_merchantCategoryCode1--;
					continue;
				}
			if (soap_flag_salesSlipNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:salesSlipNumber", (wchar_t**)&a->ns2__RequestMessage::salesSlipNumber, "xsd:string"))
				{	soap_flag_salesSlipNumber1--;
					continue;
				}
			if (soap_flag_merchandiseCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchandiseCode", (wchar_t**)&a->ns2__RequestMessage::merchandiseCode, "xsd:string"))
				{	soap_flag_merchandiseCode1--;
					continue;
				}
			if (soap_flag_merchandiseDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchandiseDescription", (wchar_t**)&a->ns2__RequestMessage::merchandiseDescription, "xsd:string"))
				{	soap_flag_merchandiseDescription1--;
					continue;
				}
			if (soap_flag_paymentInitiationChannel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentInitiationChannel", (wchar_t**)&a->ns2__RequestMessage::paymentInitiationChannel, "xsd:string"))
				{	soap_flag_paymentInitiationChannel1--;
					continue;
				}
			if (soap_flag_extendedCreditTotalCount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:extendedCreditTotalCount", (wchar_t**)&a->ns2__RequestMessage::extendedCreditTotalCount, "xsd:string"))
				{	soap_flag_extendedCreditTotalCount1--;
					continue;
				}
			if (soap_flag_authIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authIndicator", (wchar_t**)&a->ns2__RequestMessage::authIndicator, "xsd:string"))
				{	soap_flag_authIndicator1--;
					continue;
				}
			if (soap_flag_paymentNetworkToken1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PaymentNetworkToken(soap, "ns2:paymentNetworkToken", &a->ns2__RequestMessage::paymentNetworkToken, "ns2:PaymentNetworkToken"))
				{	soap_flag_paymentNetworkToken1--;
					continue;
				}
			if (soap_flag_recipient1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Recipient(soap, "ns2:recipient", &a->ns2__RequestMessage::recipient, "ns2:Recipient"))
				{	soap_flag_recipient1--;
					continue;
				}
			if (soap_flag_sender1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Sender(soap, "ns2:sender", &a->ns2__RequestMessage::sender, "ns2:Sender"))
				{	soap_flag_sender1--;
					continue;
				}
			if (soap_flag_autoRentalData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AutoRentalData(soap, "ns2:autoRentalData", &a->ns2__RequestMessage::autoRentalData, "ns2:AutoRentalData"))
				{	soap_flag_autoRentalData1--;
					continue;
				}
			if (soap_flag_paymentSolution1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentSolution", (wchar_t**)&a->ns2__RequestMessage::paymentSolution, "xsd:string"))
				{	soap_flag_paymentSolution1--;
					continue;
				}
			if (soap_flag_vc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__VC(soap, "ns2:vc", &a->ns2__RequestMessage::vc, "ns2:VC"))
				{	soap_flag_vc1--;
					continue;
				}
			if (soap_flag_decryptVisaCheckoutDataService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DecryptVisaCheckoutDataService(soap, "ns2:decryptVisaCheckoutDataService", &a->ns2__RequestMessage::decryptVisaCheckoutDataService, "ns2:DecryptVisaCheckoutDataService"))
				{	soap_flag_decryptVisaCheckoutDataService1--;
					continue;
				}
			if (soap_flag_taxManagementIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:taxManagementIndicator", (wchar_t**)&a->ns2__RequestMessage::taxManagementIndicator, "xsd:string"))
				{	soap_flag_taxManagementIndicator1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__PromotionGroup(soap, "ns2:promotionGroup", &a->ns2__RequestMessage::promotionGroup, "ns2:PromotionGroup"))
					continue;
			if (soap_flag_wallet1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Wallet(soap, "ns2:wallet", &a->ns2__RequestMessage::wallet, "ns2:Wallet"))
				{	soap_flag_wallet1--;
					continue;
				}
			if (soap_flag_aft1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Aft(soap, "ns2:aft", &a->ns2__RequestMessage::aft, "ns2:Aft"))
				{	soap_flag_aft1--;
					continue;
				}
			if (soap_flag_balanceInquiry1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:balanceInquiry", &a->ns2__RequestMessage::balanceInquiry, "ns2:boolean"))
				{	soap_flag_balanceInquiry1--;
					continue;
				}
			if (soap_flag_prenoteTransaction1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:prenoteTransaction", &a->ns2__RequestMessage::prenoteTransaction, "ns2:boolean"))
				{	soap_flag_prenoteTransaction1--;
					continue;
				}
			if (soap_flag_encryptPaymentDataService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EncryptPaymentDataService(soap, "ns2:encryptPaymentDataService", &a->ns2__RequestMessage::encryptPaymentDataService, "ns2:EncryptPaymentDataService"))
				{	soap_flag_encryptPaymentDataService1--;
					continue;
				}
			if (soap_flag_nationalNetDomesticData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:nationalNetDomesticData", (wchar_t**)&a->ns2__RequestMessage::nationalNetDomesticData, "xsd:string"))
				{	soap_flag_nationalNetDomesticData1--;
					continue;
				}
			if (soap_flag_subsequentAuth1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:subsequentAuth", (wchar_t**)&a->ns2__RequestMessage::subsequentAuth, "xsd:string"))
				{	soap_flag_subsequentAuth1--;
					continue;
				}
			if (soap_flag_binLookupService1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__BinLookupService(soap, "ns2:binLookupService", &a->ns2__RequestMessage::binLookupService, "ns2:BinLookupService"))
				{	soap_flag_binLookupService1--;
					continue;
				}
			if (soap_flag_verificationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:verificationCode", (wchar_t**)&a->ns2__RequestMessage::verificationCode, "xsd:string"))
				{	soap_flag_verificationCode1--;
					continue;
				}
			if (soap_flag_mobileNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:mobileNumber", (wchar_t**)&a->ns2__RequestMessage::mobileNumber, "xsd:string"))
				{	soap_flag_mobileNumber1--;
					continue;
				}
			if (soap_flag_issuer1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__issuer(soap, "ns2:issuer", &a->ns2__RequestMessage::issuer, "ns2:issuer"))
				{	soap_flag_issuer1--;
					continue;
				}
			if (soap_flag_partnerSolutionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:partnerSolutionID", (wchar_t**)&a->ns2__RequestMessage::partnerSolutionID, "xsd:string"))
				{	soap_flag_partnerSolutionID1--;
					continue;
				}
			if (soap_flag_developerID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:developerID", (wchar_t**)&a->ns2__RequestMessage::developerID, "xsd:string"))
				{	soap_flag_developerID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__RequestMessage::item.size() > 1000 || a->ns2__RequestMessage::reserved.size() > 999 || a->ns2__RequestMessage::promotionGroup.size() > 100))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns2__RequestMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RequestMessage, SOAP_TYPE_ns2__RequestMessage, sizeof(ns2__RequestMessage), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__RequestMessage * SOAP_FMAC2 soap_instantiate_ns2__RequestMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RequestMessage(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__RequestMessage *p;
	size_t k = sizeof(ns2__RequestMessage);
	if (n < 0)
	{	p = SOAP_NEW(ns2__RequestMessage);
		if (p)
			((ns2__RequestMessage*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__RequestMessage, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__RequestMessage*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__RequestMessage location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__RequestMessage, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__RequestMessage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:RequestMessage", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RequestMessage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RequestMessage(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RequestMessage * SOAP_FMAC4 soap_get_ns2__RequestMessage(struct soap *soap, ns2__RequestMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RequestMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Sender::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Sender::referenceNumber = NULL;
	this->ns2__Sender::sourceOfFunds = NULL;
	this->ns2__Sender::name = NULL;
	this->ns2__Sender::address = NULL;
	this->ns2__Sender::city = NULL;
	this->ns2__Sender::state = NULL;
	this->ns2__Sender::postalCode = NULL;
	this->ns2__Sender::country = NULL;
	this->ns2__Sender::accountNumber = NULL;
	/* transient soap skipped */
}

void ns2__Sender::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Sender::referenceNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Sender::sourceOfFunds);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Sender::name);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Sender::address);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Sender::city);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Sender::state);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Sender::postalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Sender::country);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Sender::accountNumber);
#endif
}

int ns2__Sender::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Sender(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Sender(struct soap *soap, const char *tag, int id, const ns2__Sender *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Sender), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:referenceNumber", -1, (wchar_t*const*)&a->ns2__Sender::referenceNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sourceOfFunds", -1, (wchar_t*const*)&a->ns2__Sender::sourceOfFunds, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:name", -1, (wchar_t*const*)&a->ns2__Sender::name, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:address", -1, (wchar_t*const*)&a->ns2__Sender::address, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:city", -1, (wchar_t*const*)&a->ns2__Sender::city, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:state", -1, (wchar_t*const*)&a->ns2__Sender::state, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:postalCode", -1, (wchar_t*const*)&a->ns2__Sender::postalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:country", -1, (wchar_t*const*)&a->ns2__Sender::country, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:accountNumber", -1, (wchar_t*const*)&a->ns2__Sender::accountNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Sender::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Sender(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Sender * SOAP_FMAC4 soap_in_ns2__Sender(struct soap *soap, const char *tag, ns2__Sender *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Sender *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Sender, sizeof(ns2__Sender), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Sender)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Sender *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_referenceNumber1 = 1;
	size_t soap_flag_sourceOfFunds1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_address1 = 1;
	size_t soap_flag_city1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_postalCode1 = 1;
	size_t soap_flag_country1 = 1;
	size_t soap_flag_accountNumber1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_referenceNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:referenceNumber", (wchar_t**)&a->ns2__Sender::referenceNumber, "xsd:string"))
				{	soap_flag_referenceNumber1--;
					continue;
				}
			if (soap_flag_sourceOfFunds1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sourceOfFunds", (wchar_t**)&a->ns2__Sender::sourceOfFunds, "xsd:string"))
				{	soap_flag_sourceOfFunds1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:name", (wchar_t**)&a->ns2__Sender::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:address", (wchar_t**)&a->ns2__Sender::address, "xsd:string"))
				{	soap_flag_address1--;
					continue;
				}
			if (soap_flag_city1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:city", (wchar_t**)&a->ns2__Sender::city, "xsd:string"))
				{	soap_flag_city1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:state", (wchar_t**)&a->ns2__Sender::state, "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_postalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:postalCode", (wchar_t**)&a->ns2__Sender::postalCode, "xsd:string"))
				{	soap_flag_postalCode1--;
					continue;
				}
			if (soap_flag_country1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:country", (wchar_t**)&a->ns2__Sender::country, "xsd:string"))
				{	soap_flag_country1--;
					continue;
				}
			if (soap_flag_accountNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:accountNumber", (wchar_t**)&a->ns2__Sender::accountNumber, "xsd:string"))
				{	soap_flag_accountNumber1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Sender *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Sender, SOAP_TYPE_ns2__Sender, sizeof(ns2__Sender), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Sender * SOAP_FMAC2 soap_instantiate_ns2__Sender(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Sender(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Sender *p;
	size_t k = sizeof(ns2__Sender);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Sender);
		if (p)
			((ns2__Sender*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Sender, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Sender*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Sender location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Sender, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Sender::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:Sender", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Sender::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Sender(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Sender * SOAP_FMAC4 soap_get_ns2__Sender(struct soap *soap, ns2__Sender *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Sender(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Recipient::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Recipient::dateOfBirth = NULL;
	this->ns2__Recipient::postalCode = NULL;
	this->ns2__Recipient::accountID = NULL;
	this->ns2__Recipient::lastName = NULL;
	this->ns2__Recipient::name = NULL;
	this->ns2__Recipient::billingAmount = NULL;
	this->ns2__Recipient::billingCurrency = NULL;
	/* transient soap skipped */
}

void ns2__Recipient::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Recipient::dateOfBirth);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Recipient::postalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Recipient::accountID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Recipient::lastName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Recipient::name);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Recipient::billingAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Recipient::billingCurrency);
#endif
}

int ns2__Recipient::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Recipient(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Recipient(struct soap *soap, const char *tag, int id, const ns2__Recipient *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Recipient), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:dateOfBirth", -1, (wchar_t*const*)&a->ns2__Recipient::dateOfBirth, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:postalCode", -1, (wchar_t*const*)&a->ns2__Recipient::postalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:accountID", -1, (wchar_t*const*)&a->ns2__Recipient::accountID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:lastName", -1, (wchar_t*const*)&a->ns2__Recipient::lastName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:name", -1, (wchar_t*const*)&a->ns2__Recipient::name, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:billingAmount", -1, &a->ns2__Recipient::billingAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:billingCurrency", -1, (wchar_t*const*)&a->ns2__Recipient::billingCurrency, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Recipient::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Recipient(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Recipient * SOAP_FMAC4 soap_in_ns2__Recipient(struct soap *soap, const char *tag, ns2__Recipient *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Recipient *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Recipient, sizeof(ns2__Recipient), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Recipient)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Recipient *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_dateOfBirth1 = 1;
	size_t soap_flag_postalCode1 = 1;
	size_t soap_flag_accountID1 = 1;
	size_t soap_flag_lastName1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_billingAmount1 = 1;
	size_t soap_flag_billingCurrency1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dateOfBirth1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:dateOfBirth", (wchar_t**)&a->ns2__Recipient::dateOfBirth, "xsd:string"))
				{	soap_flag_dateOfBirth1--;
					continue;
				}
			if (soap_flag_postalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:postalCode", (wchar_t**)&a->ns2__Recipient::postalCode, "xsd:string"))
				{	soap_flag_postalCode1--;
					continue;
				}
			if (soap_flag_accountID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:accountID", (wchar_t**)&a->ns2__Recipient::accountID, "xsd:string"))
				{	soap_flag_accountID1--;
					continue;
				}
			if (soap_flag_lastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:lastName", (wchar_t**)&a->ns2__Recipient::lastName, "xsd:string"))
				{	soap_flag_lastName1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:name", (wchar_t**)&a->ns2__Recipient::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_billingAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:billingAmount", &a->ns2__Recipient::billingAmount, "ns2:amount"))
				{	soap_flag_billingAmount1--;
					continue;
				}
			if (soap_flag_billingCurrency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:billingCurrency", (wchar_t**)&a->ns2__Recipient::billingCurrency, "xsd:string"))
				{	soap_flag_billingCurrency1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Recipient *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Recipient, SOAP_TYPE_ns2__Recipient, sizeof(ns2__Recipient), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Recipient * SOAP_FMAC2 soap_instantiate_ns2__Recipient(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Recipient(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Recipient *p;
	size_t k = sizeof(ns2__Recipient);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Recipient);
		if (p)
			((ns2__Recipient*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Recipient, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Recipient*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Recipient location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Recipient, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Recipient::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:Recipient", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Recipient::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Recipient(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Recipient * SOAP_FMAC4 soap_get_ns2__Recipient(struct soap *soap, ns2__Recipient *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Recipient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalTransactionSearchService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalTransactionSearchService::startDate = NULL;
	this->ns2__PayPalTransactionSearchService::endDate = NULL;
	this->ns2__PayPalTransactionSearchService::paypalCustomerEmail = NULL;
	this->ns2__PayPalTransactionSearchService::paypalReceiptId = NULL;
	this->ns2__PayPalTransactionSearchService::transactionID = NULL;
	this->ns2__PayPalTransactionSearchService::invoiceNumber = NULL;
	this->ns2__PayPalTransactionSearchService::grandTotalAmount = NULL;
	this->ns2__PayPalTransactionSearchService::currency = NULL;
	this->ns2__PayPalTransactionSearchService::paymentStatus = NULL;
	this->ns2__PayPalTransactionSearchService::payerSalutation = NULL;
	this->ns2__PayPalTransactionSearchService::payerFirstname = NULL;
	this->ns2__PayPalTransactionSearchService::payerMiddlename = NULL;
	this->ns2__PayPalTransactionSearchService::payerLastname = NULL;
	this->ns2__PayPalTransactionSearchService::payerSuffix = NULL;
	this->ns2__PayPalTransactionSearchService::run = NULL;
	/* transient soap skipped */
}

void ns2__PayPalTransactionSearchService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalTransactionSearchService::startDate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalTransactionSearchService::endDate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalTransactionSearchService::paypalCustomerEmail);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalTransactionSearchService::paypalReceiptId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalTransactionSearchService::transactionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalTransactionSearchService::invoiceNumber);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__PayPalTransactionSearchService::grandTotalAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalTransactionSearchService::currency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalTransactionSearchService::paymentStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalTransactionSearchService::payerSalutation);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalTransactionSearchService::payerFirstname);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalTransactionSearchService::payerMiddlename);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalTransactionSearchService::payerLastname);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalTransactionSearchService::payerSuffix);
#endif
}

int ns2__PayPalTransactionSearchService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalTransactionSearchService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalTransactionSearchService(struct soap *soap, const char *tag, int id, const ns2__PayPalTransactionSearchService *a, const char *type)
{
	if (((ns2__PayPalTransactionSearchService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PayPalTransactionSearchService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalTransactionSearchService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:startDate", -1, (wchar_t*const*)&a->ns2__PayPalTransactionSearchService::startDate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:endDate", -1, (wchar_t*const*)&a->ns2__PayPalTransactionSearchService::endDate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalCustomerEmail", -1, (wchar_t*const*)&a->ns2__PayPalTransactionSearchService::paypalCustomerEmail, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalReceiptId", -1, (wchar_t*const*)&a->ns2__PayPalTransactionSearchService::paypalReceiptId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionID", -1, (wchar_t*const*)&a->ns2__PayPalTransactionSearchService::transactionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:invoiceNumber", -1, (wchar_t*const*)&a->ns2__PayPalTransactionSearchService::invoiceNumber, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:grandTotalAmount", -1, &a->ns2__PayPalTransactionSearchService::grandTotalAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:currency", -1, (wchar_t*const*)&a->ns2__PayPalTransactionSearchService::currency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentStatus", -1, (wchar_t*const*)&a->ns2__PayPalTransactionSearchService::paymentStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerSalutation", -1, (wchar_t*const*)&a->ns2__PayPalTransactionSearchService::payerSalutation, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerFirstname", -1, (wchar_t*const*)&a->ns2__PayPalTransactionSearchService::payerFirstname, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerMiddlename", -1, (wchar_t*const*)&a->ns2__PayPalTransactionSearchService::payerMiddlename, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerLastname", -1, (wchar_t*const*)&a->ns2__PayPalTransactionSearchService::payerLastname, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payerSuffix", -1, (wchar_t*const*)&a->ns2__PayPalTransactionSearchService::payerSuffix, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalTransactionSearchService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalTransactionSearchService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalTransactionSearchService * SOAP_FMAC4 soap_in_ns2__PayPalTransactionSearchService(struct soap *soap, const char *tag, ns2__PayPalTransactionSearchService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalTransactionSearchService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalTransactionSearchService, sizeof(ns2__PayPalTransactionSearchService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalTransactionSearchService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalTransactionSearchService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PayPalTransactionSearchService*)a)->run))
		return NULL;
	size_t soap_flag_startDate1 = 1;
	size_t soap_flag_endDate1 = 1;
	size_t soap_flag_paypalCustomerEmail1 = 1;
	size_t soap_flag_paypalReceiptId1 = 1;
	size_t soap_flag_transactionID1 = 1;
	size_t soap_flag_invoiceNumber1 = 1;
	size_t soap_flag_grandTotalAmount1 = 1;
	size_t soap_flag_currency1 = 1;
	size_t soap_flag_paymentStatus1 = 1;
	size_t soap_flag_payerSalutation1 = 1;
	size_t soap_flag_payerFirstname1 = 1;
	size_t soap_flag_payerMiddlename1 = 1;
	size_t soap_flag_payerLastname1 = 1;
	size_t soap_flag_payerSuffix1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_startDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:startDate", (wchar_t**)&a->ns2__PayPalTransactionSearchService::startDate, "xsd:string"))
				{	soap_flag_startDate1--;
					continue;
				}
			if (soap_flag_endDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:endDate", (wchar_t**)&a->ns2__PayPalTransactionSearchService::endDate, "xsd:string"))
				{	soap_flag_endDate1--;
					continue;
				}
			if (soap_flag_paypalCustomerEmail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalCustomerEmail", (wchar_t**)&a->ns2__PayPalTransactionSearchService::paypalCustomerEmail, "xsd:string"))
				{	soap_flag_paypalCustomerEmail1--;
					continue;
				}
			if (soap_flag_paypalReceiptId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalReceiptId", (wchar_t**)&a->ns2__PayPalTransactionSearchService::paypalReceiptId, "xsd:string"))
				{	soap_flag_paypalReceiptId1--;
					continue;
				}
			if (soap_flag_transactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionID", (wchar_t**)&a->ns2__PayPalTransactionSearchService::transactionID, "xsd:string"))
				{	soap_flag_transactionID1--;
					continue;
				}
			if (soap_flag_invoiceNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:invoiceNumber", (wchar_t**)&a->ns2__PayPalTransactionSearchService::invoiceNumber, "xsd:string"))
				{	soap_flag_invoiceNumber1--;
					continue;
				}
			if (soap_flag_grandTotalAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:grandTotalAmount", &a->ns2__PayPalTransactionSearchService::grandTotalAmount, "ns2:amount"))
				{	soap_flag_grandTotalAmount1--;
					continue;
				}
			if (soap_flag_currency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:currency", (wchar_t**)&a->ns2__PayPalTransactionSearchService::currency, "xsd:string"))
				{	soap_flag_currency1--;
					continue;
				}
			if (soap_flag_paymentStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentStatus", (wchar_t**)&a->ns2__PayPalTransactionSearchService::paymentStatus, "xsd:string"))
				{	soap_flag_paymentStatus1--;
					continue;
				}
			if (soap_flag_payerSalutation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerSalutation", (wchar_t**)&a->ns2__PayPalTransactionSearchService::payerSalutation, "xsd:string"))
				{	soap_flag_payerSalutation1--;
					continue;
				}
			if (soap_flag_payerFirstname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerFirstname", (wchar_t**)&a->ns2__PayPalTransactionSearchService::payerFirstname, "xsd:string"))
				{	soap_flag_payerFirstname1--;
					continue;
				}
			if (soap_flag_payerMiddlename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerMiddlename", (wchar_t**)&a->ns2__PayPalTransactionSearchService::payerMiddlename, "xsd:string"))
				{	soap_flag_payerMiddlename1--;
					continue;
				}
			if (soap_flag_payerLastname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerLastname", (wchar_t**)&a->ns2__PayPalTransactionSearchService::payerLastname, "xsd:string"))
				{	soap_flag_payerLastname1--;
					continue;
				}
			if (soap_flag_payerSuffix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payerSuffix", (wchar_t**)&a->ns2__PayPalTransactionSearchService::payerSuffix, "xsd:string"))
				{	soap_flag_payerSuffix1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayPalTransactionSearchService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalTransactionSearchService, SOAP_TYPE_ns2__PayPalTransactionSearchService, sizeof(ns2__PayPalTransactionSearchService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalTransactionSearchService * SOAP_FMAC2 soap_instantiate_ns2__PayPalTransactionSearchService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalTransactionSearchService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalTransactionSearchService *p;
	size_t k = sizeof(ns2__PayPalTransactionSearchService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalTransactionSearchService);
		if (p)
			((ns2__PayPalTransactionSearchService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalTransactionSearchService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalTransactionSearchService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalTransactionSearchService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalTransactionSearchService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalTransactionSearchService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalTransactionSearchService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalTransactionSearchService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalTransactionSearchService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalTransactionSearchService * SOAP_FMAC4 soap_get_ns2__PayPalTransactionSearchService(struct soap *soap, ns2__PayPalTransactionSearchService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalTransactionSearchService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalGetTxnDetailsService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalGetTxnDetailsService::transactionID = NULL;
	this->ns2__PayPalGetTxnDetailsService::run = NULL;
	/* transient soap skipped */
}

void ns2__PayPalGetTxnDetailsService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalGetTxnDetailsService::transactionID);
#endif
}

int ns2__PayPalGetTxnDetailsService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalGetTxnDetailsService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalGetTxnDetailsService(struct soap *soap, const char *tag, int id, const ns2__PayPalGetTxnDetailsService *a, const char *type)
{
	if (((ns2__PayPalGetTxnDetailsService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PayPalGetTxnDetailsService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalGetTxnDetailsService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionID", -1, (wchar_t*const*)&a->ns2__PayPalGetTxnDetailsService::transactionID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalGetTxnDetailsService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalGetTxnDetailsService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalGetTxnDetailsService * SOAP_FMAC4 soap_in_ns2__PayPalGetTxnDetailsService(struct soap *soap, const char *tag, ns2__PayPalGetTxnDetailsService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalGetTxnDetailsService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalGetTxnDetailsService, sizeof(ns2__PayPalGetTxnDetailsService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalGetTxnDetailsService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalGetTxnDetailsService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PayPalGetTxnDetailsService*)a)->run))
		return NULL;
	size_t soap_flag_transactionID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_transactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionID", (wchar_t**)&a->ns2__PayPalGetTxnDetailsService::transactionID, "xsd:string"))
				{	soap_flag_transactionID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayPalGetTxnDetailsService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalGetTxnDetailsService, SOAP_TYPE_ns2__PayPalGetTxnDetailsService, sizeof(ns2__PayPalGetTxnDetailsService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalGetTxnDetailsService * SOAP_FMAC2 soap_instantiate_ns2__PayPalGetTxnDetailsService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalGetTxnDetailsService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalGetTxnDetailsService *p;
	size_t k = sizeof(ns2__PayPalGetTxnDetailsService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalGetTxnDetailsService);
		if (p)
			((ns2__PayPalGetTxnDetailsService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalGetTxnDetailsService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalGetTxnDetailsService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalGetTxnDetailsService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalGetTxnDetailsService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalGetTxnDetailsService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalGetTxnDetailsService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalGetTxnDetailsService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalGetTxnDetailsService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalGetTxnDetailsService * SOAP_FMAC4 soap_get_ns2__PayPalGetTxnDetailsService(struct soap *soap, ns2__PayPalGetTxnDetailsService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalGetTxnDetailsService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APConfirmPurchaseService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APConfirmPurchaseService::run = NULL;
	/* transient soap skipped */
}

void ns2__APConfirmPurchaseService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__APConfirmPurchaseService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APConfirmPurchaseService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APConfirmPurchaseService(struct soap *soap, const char *tag, int id, const ns2__APConfirmPurchaseService *a, const char *type)
{
	if (((ns2__APConfirmPurchaseService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__APConfirmPurchaseService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APConfirmPurchaseService), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APConfirmPurchaseService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APConfirmPurchaseService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APConfirmPurchaseService * SOAP_FMAC4 soap_in_ns2__APConfirmPurchaseService(struct soap *soap, const char *tag, ns2__APConfirmPurchaseService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APConfirmPurchaseService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APConfirmPurchaseService, sizeof(ns2__APConfirmPurchaseService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APConfirmPurchaseService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APConfirmPurchaseService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__APConfirmPurchaseService*)a)->run))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__APConfirmPurchaseService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APConfirmPurchaseService, SOAP_TYPE_ns2__APConfirmPurchaseService, sizeof(ns2__APConfirmPurchaseService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APConfirmPurchaseService * SOAP_FMAC2 soap_instantiate_ns2__APConfirmPurchaseService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APConfirmPurchaseService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APConfirmPurchaseService *p;
	size_t k = sizeof(ns2__APConfirmPurchaseService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APConfirmPurchaseService);
		if (p)
			((ns2__APConfirmPurchaseService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APConfirmPurchaseService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APConfirmPurchaseService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APConfirmPurchaseService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APConfirmPurchaseService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APConfirmPurchaseService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APConfirmPurchaseService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APConfirmPurchaseService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APConfirmPurchaseService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APConfirmPurchaseService * SOAP_FMAC4 soap_get_ns2__APConfirmPurchaseService(struct soap *soap, ns2__APConfirmPurchaseService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APConfirmPurchaseService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APTransactionDetailsService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APTransactionDetailsService::transactionDetailsRequestID = NULL;
	this->ns2__APTransactionDetailsService::run = NULL;
	/* transient soap skipped */
}

void ns2__APTransactionDetailsService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APTransactionDetailsService::transactionDetailsRequestID);
#endif
}

int ns2__APTransactionDetailsService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APTransactionDetailsService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APTransactionDetailsService(struct soap *soap, const char *tag, int id, const ns2__APTransactionDetailsService *a, const char *type)
{
	if (((ns2__APTransactionDetailsService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__APTransactionDetailsService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APTransactionDetailsService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionDetailsRequestID", -1, (wchar_t*const*)&a->ns2__APTransactionDetailsService::transactionDetailsRequestID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APTransactionDetailsService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APTransactionDetailsService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APTransactionDetailsService * SOAP_FMAC4 soap_in_ns2__APTransactionDetailsService(struct soap *soap, const char *tag, ns2__APTransactionDetailsService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APTransactionDetailsService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APTransactionDetailsService, sizeof(ns2__APTransactionDetailsService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APTransactionDetailsService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APTransactionDetailsService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__APTransactionDetailsService*)a)->run))
		return NULL;
	size_t soap_flag_transactionDetailsRequestID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_transactionDetailsRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionDetailsRequestID", (wchar_t**)&a->ns2__APTransactionDetailsService::transactionDetailsRequestID, "xsd:string"))
				{	soap_flag_transactionDetailsRequestID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__APTransactionDetailsService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APTransactionDetailsService, SOAP_TYPE_ns2__APTransactionDetailsService, sizeof(ns2__APTransactionDetailsService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APTransactionDetailsService * SOAP_FMAC2 soap_instantiate_ns2__APTransactionDetailsService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APTransactionDetailsService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APTransactionDetailsService *p;
	size_t k = sizeof(ns2__APTransactionDetailsService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APTransactionDetailsService);
		if (p)
			((ns2__APTransactionDetailsService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APTransactionDetailsService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APTransactionDetailsService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APTransactionDetailsService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APTransactionDetailsService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APTransactionDetailsService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APTransactionDetailsService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APTransactionDetailsService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APTransactionDetailsService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APTransactionDetailsService * SOAP_FMAC4 soap_get_ns2__APTransactionDetailsService(struct soap *soap, ns2__APTransactionDetailsService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APTransactionDetailsService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APCheckOutDetailsService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APCheckOutDetailsService::run = NULL;
	/* transient soap skipped */
}

void ns2__APCheckOutDetailsService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__APCheckOutDetailsService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APCheckOutDetailsService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APCheckOutDetailsService(struct soap *soap, const char *tag, int id, const ns2__APCheckOutDetailsService *a, const char *type)
{
	if (((ns2__APCheckOutDetailsService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__APCheckOutDetailsService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APCheckOutDetailsService), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APCheckOutDetailsService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APCheckOutDetailsService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APCheckOutDetailsService * SOAP_FMAC4 soap_in_ns2__APCheckOutDetailsService(struct soap *soap, const char *tag, ns2__APCheckOutDetailsService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APCheckOutDetailsService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APCheckOutDetailsService, sizeof(ns2__APCheckOutDetailsService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APCheckOutDetailsService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APCheckOutDetailsService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__APCheckOutDetailsService*)a)->run))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__APCheckOutDetailsService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APCheckOutDetailsService, SOAP_TYPE_ns2__APCheckOutDetailsService, sizeof(ns2__APCheckOutDetailsService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APCheckOutDetailsService * SOAP_FMAC2 soap_instantiate_ns2__APCheckOutDetailsService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APCheckOutDetailsService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APCheckOutDetailsService *p;
	size_t k = sizeof(ns2__APCheckOutDetailsService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APCheckOutDetailsService);
		if (p)
			((ns2__APCheckOutDetailsService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APCheckOutDetailsService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APCheckOutDetailsService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APCheckOutDetailsService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APCheckOutDetailsService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APCheckOutDetailsService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APCheckOutDetailsService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APCheckOutDetailsService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APCheckOutDetailsService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APCheckOutDetailsService * SOAP_FMAC4 soap_get_ns2__APCheckOutDetailsService(struct soap *soap, ns2__APCheckOutDetailsService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APCheckOutDetailsService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APSaleService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APSaleService::cancelURL = NULL;
	this->ns2__APSaleService::successURL = NULL;
	this->ns2__APSaleService::failureURL = NULL;
	this->ns2__APSaleService::reconciliationID = NULL;
	this->ns2__APSaleService::overridePaymentMethod = NULL;
	this->ns2__APSaleService::paymentOptionID = NULL;
	this->ns2__APSaleService::transactionTimeout = NULL;
	this->ns2__APSaleService::run = NULL;
	/* transient soap skipped */
}

void ns2__APSaleService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APSaleService::cancelURL);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APSaleService::successURL);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APSaleService::failureURL);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APSaleService::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APSaleService::overridePaymentMethod);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APSaleService::paymentOptionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APSaleService::transactionTimeout);
#endif
}

int ns2__APSaleService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APSaleService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APSaleService(struct soap *soap, const char *tag, int id, const ns2__APSaleService *a, const char *type)
{
	if (((ns2__APSaleService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__APSaleService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APSaleService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cancelURL", -1, (wchar_t*const*)&a->ns2__APSaleService::cancelURL, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:successURL", -1, (wchar_t*const*)&a->ns2__APSaleService::successURL, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:failureURL", -1, (wchar_t*const*)&a->ns2__APSaleService::failureURL, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__APSaleService::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:overridePaymentMethod", -1, (wchar_t*const*)&a->ns2__APSaleService::overridePaymentMethod, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentOptionID", -1, (wchar_t*const*)&a->ns2__APSaleService::paymentOptionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionTimeout", -1, (wchar_t*const*)&a->ns2__APSaleService::transactionTimeout, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APSaleService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APSaleService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APSaleService * SOAP_FMAC4 soap_in_ns2__APSaleService(struct soap *soap, const char *tag, ns2__APSaleService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APSaleService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APSaleService, sizeof(ns2__APSaleService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APSaleService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APSaleService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__APSaleService*)a)->run))
		return NULL;
	size_t soap_flag_cancelURL1 = 1;
	size_t soap_flag_successURL1 = 1;
	size_t soap_flag_failureURL1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_overridePaymentMethod1 = 1;
	size_t soap_flag_paymentOptionID1 = 1;
	size_t soap_flag_transactionTimeout1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cancelURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cancelURL", (wchar_t**)&a->ns2__APSaleService::cancelURL, "xsd:string"))
				{	soap_flag_cancelURL1--;
					continue;
				}
			if (soap_flag_successURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:successURL", (wchar_t**)&a->ns2__APSaleService::successURL, "xsd:string"))
				{	soap_flag_successURL1--;
					continue;
				}
			if (soap_flag_failureURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:failureURL", (wchar_t**)&a->ns2__APSaleService::failureURL, "xsd:string"))
				{	soap_flag_failureURL1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__APSaleService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_overridePaymentMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:overridePaymentMethod", (wchar_t**)&a->ns2__APSaleService::overridePaymentMethod, "xsd:string"))
				{	soap_flag_overridePaymentMethod1--;
					continue;
				}
			if (soap_flag_paymentOptionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentOptionID", (wchar_t**)&a->ns2__APSaleService::paymentOptionID, "xsd:string"))
				{	soap_flag_paymentOptionID1--;
					continue;
				}
			if (soap_flag_transactionTimeout1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionTimeout", (wchar_t**)&a->ns2__APSaleService::transactionTimeout, "xsd:string"))
				{	soap_flag_transactionTimeout1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__APSaleService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APSaleService, SOAP_TYPE_ns2__APSaleService, sizeof(ns2__APSaleService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APSaleService * SOAP_FMAC2 soap_instantiate_ns2__APSaleService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APSaleService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APSaleService *p;
	size_t k = sizeof(ns2__APSaleService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APSaleService);
		if (p)
			((ns2__APSaleService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APSaleService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APSaleService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APSaleService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APSaleService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APSaleService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APSaleService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APSaleService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APSaleService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APSaleService * SOAP_FMAC4 soap_get_ns2__APSaleService(struct soap *soap, ns2__APSaleService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APSaleService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APRefundService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APRefundService::captureRequestID = NULL;
	this->ns2__APRefundService::refundRequestID = NULL;
	this->ns2__APRefundService::reason = NULL;
	this->ns2__APRefundService::note = NULL;
	this->ns2__APRefundService::apInitiateRequestID = NULL;
	this->ns2__APRefundService::returnRef = NULL;
	this->ns2__APRefundService::reconciliationID = NULL;
	this->ns2__APRefundService::run = NULL;
	/* transient soap skipped */
}

void ns2__APRefundService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APRefundService::captureRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APRefundService::refundRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APRefundService::reason);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APRefundService::note);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APRefundService::apInitiateRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APRefundService::returnRef);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APRefundService::reconciliationID);
#endif
}

int ns2__APRefundService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APRefundService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APRefundService(struct soap *soap, const char *tag, int id, const ns2__APRefundService *a, const char *type)
{
	if (((ns2__APRefundService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__APRefundService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APRefundService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:captureRequestID", -1, (wchar_t*const*)&a->ns2__APRefundService::captureRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:refundRequestID", -1, (wchar_t*const*)&a->ns2__APRefundService::refundRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reason", -1, (wchar_t*const*)&a->ns2__APRefundService::reason, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:note", -1, (wchar_t*const*)&a->ns2__APRefundService::note, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:apInitiateRequestID", -1, (wchar_t*const*)&a->ns2__APRefundService::apInitiateRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:returnRef", -1, (wchar_t*const*)&a->ns2__APRefundService::returnRef, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__APRefundService::reconciliationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APRefundService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APRefundService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APRefundService * SOAP_FMAC4 soap_in_ns2__APRefundService(struct soap *soap, const char *tag, ns2__APRefundService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APRefundService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APRefundService, sizeof(ns2__APRefundService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APRefundService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APRefundService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__APRefundService*)a)->run))
		return NULL;
	size_t soap_flag_captureRequestID1 = 1;
	size_t soap_flag_refundRequestID1 = 1;
	size_t soap_flag_reason1 = 1;
	size_t soap_flag_note1 = 1;
	size_t soap_flag_apInitiateRequestID1 = 1;
	size_t soap_flag_returnRef1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_captureRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:captureRequestID", (wchar_t**)&a->ns2__APRefundService::captureRequestID, "xsd:string"))
				{	soap_flag_captureRequestID1--;
					continue;
				}
			if (soap_flag_refundRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:refundRequestID", (wchar_t**)&a->ns2__APRefundService::refundRequestID, "xsd:string"))
				{	soap_flag_refundRequestID1--;
					continue;
				}
			if (soap_flag_reason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reason", (wchar_t**)&a->ns2__APRefundService::reason, "xsd:string"))
				{	soap_flag_reason1--;
					continue;
				}
			if (soap_flag_note1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:note", (wchar_t**)&a->ns2__APRefundService::note, "xsd:string"))
				{	soap_flag_note1--;
					continue;
				}
			if (soap_flag_apInitiateRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:apInitiateRequestID", (wchar_t**)&a->ns2__APRefundService::apInitiateRequestID, "xsd:string"))
				{	soap_flag_apInitiateRequestID1--;
					continue;
				}
			if (soap_flag_returnRef1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:returnRef", (wchar_t**)&a->ns2__APRefundService::returnRef, "xsd:string"))
				{	soap_flag_returnRef1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__APRefundService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__APRefundService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APRefundService, SOAP_TYPE_ns2__APRefundService, sizeof(ns2__APRefundService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APRefundService * SOAP_FMAC2 soap_instantiate_ns2__APRefundService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APRefundService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APRefundService *p;
	size_t k = sizeof(ns2__APRefundService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APRefundService);
		if (p)
			((ns2__APRefundService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APRefundService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APRefundService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APRefundService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APRefundService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APRefundService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APRefundService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APRefundService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APRefundService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APRefundService * SOAP_FMAC4 soap_get_ns2__APRefundService(struct soap *soap, ns2__APRefundService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APRefundService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APOptionsService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APOptionsService::limit = NULL;
	this->ns2__APOptionsService::offset = NULL;
	this->ns2__APOptionsService::run = NULL;
	/* transient soap skipped */
}

void ns2__APOptionsService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APOptionsService::limit);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APOptionsService::offset);
#endif
}

int ns2__APOptionsService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APOptionsService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APOptionsService(struct soap *soap, const char *tag, int id, const ns2__APOptionsService *a, const char *type)
{
	if (((ns2__APOptionsService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__APOptionsService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APOptionsService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:limit", -1, (wchar_t*const*)&a->ns2__APOptionsService::limit, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:offset", -1, (wchar_t*const*)&a->ns2__APOptionsService::offset, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APOptionsService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APOptionsService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APOptionsService * SOAP_FMAC4 soap_in_ns2__APOptionsService(struct soap *soap, const char *tag, ns2__APOptionsService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APOptionsService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APOptionsService, sizeof(ns2__APOptionsService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APOptionsService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APOptionsService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__APOptionsService*)a)->run))
		return NULL;
	size_t soap_flag_limit1 = 1;
	size_t soap_flag_offset1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_limit1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:limit", (wchar_t**)&a->ns2__APOptionsService::limit, "xsd:string"))
				{	soap_flag_limit1--;
					continue;
				}
			if (soap_flag_offset1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:offset", (wchar_t**)&a->ns2__APOptionsService::offset, "xsd:string"))
				{	soap_flag_offset1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__APOptionsService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APOptionsService, SOAP_TYPE_ns2__APOptionsService, sizeof(ns2__APOptionsService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APOptionsService * SOAP_FMAC2 soap_instantiate_ns2__APOptionsService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APOptionsService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APOptionsService *p;
	size_t k = sizeof(ns2__APOptionsService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APOptionsService);
		if (p)
			((ns2__APOptionsService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APOptionsService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APOptionsService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APOptionsService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APOptionsService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APOptionsService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APOptionsService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APOptionsService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APOptionsService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APOptionsService * SOAP_FMAC4 soap_get_ns2__APOptionsService(struct soap *soap, ns2__APOptionsService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APOptionsService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APCaptureService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APCaptureService::authRequestID = NULL;
	this->ns2__APCaptureService::reconciliationID = NULL;
	this->ns2__APCaptureService::run = NULL;
	/* transient soap skipped */
}

void ns2__APCaptureService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APCaptureService::authRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APCaptureService::reconciliationID);
#endif
}

int ns2__APCaptureService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APCaptureService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APCaptureService(struct soap *soap, const char *tag, int id, const ns2__APCaptureService *a, const char *type)
{
	if (((ns2__APCaptureService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__APCaptureService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APCaptureService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authRequestID", -1, (wchar_t*const*)&a->ns2__APCaptureService::authRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__APCaptureService::reconciliationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APCaptureService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APCaptureService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APCaptureService * SOAP_FMAC4 soap_in_ns2__APCaptureService(struct soap *soap, const char *tag, ns2__APCaptureService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APCaptureService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APCaptureService, sizeof(ns2__APCaptureService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APCaptureService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APCaptureService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__APCaptureService*)a)->run))
		return NULL;
	size_t soap_flag_authRequestID1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authRequestID", (wchar_t**)&a->ns2__APCaptureService::authRequestID, "xsd:string"))
				{	soap_flag_authRequestID1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__APCaptureService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__APCaptureService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APCaptureService, SOAP_TYPE_ns2__APCaptureService, sizeof(ns2__APCaptureService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APCaptureService * SOAP_FMAC2 soap_instantiate_ns2__APCaptureService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APCaptureService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APCaptureService *p;
	size_t k = sizeof(ns2__APCaptureService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APCaptureService);
		if (p)
			((ns2__APCaptureService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APCaptureService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APCaptureService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APCaptureService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APCaptureService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APCaptureService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APCaptureService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APCaptureService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APCaptureService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APCaptureService * SOAP_FMAC4 soap_get_ns2__APCaptureService(struct soap *soap, ns2__APCaptureService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APCaptureService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APAuthReversalService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APAuthReversalService::authRequestID = NULL;
	this->ns2__APAuthReversalService::reconciliationID = NULL;
	this->ns2__APAuthReversalService::run = NULL;
	/* transient soap skipped */
}

void ns2__APAuthReversalService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthReversalService::authRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthReversalService::reconciliationID);
#endif
}

int ns2__APAuthReversalService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APAuthReversalService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APAuthReversalService(struct soap *soap, const char *tag, int id, const ns2__APAuthReversalService *a, const char *type)
{
	if (((ns2__APAuthReversalService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__APAuthReversalService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APAuthReversalService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authRequestID", -1, (wchar_t*const*)&a->ns2__APAuthReversalService::authRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__APAuthReversalService::reconciliationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APAuthReversalService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APAuthReversalService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APAuthReversalService * SOAP_FMAC4 soap_in_ns2__APAuthReversalService(struct soap *soap, const char *tag, ns2__APAuthReversalService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APAuthReversalService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APAuthReversalService, sizeof(ns2__APAuthReversalService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APAuthReversalService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APAuthReversalService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__APAuthReversalService*)a)->run))
		return NULL;
	size_t soap_flag_authRequestID1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authRequestID", (wchar_t**)&a->ns2__APAuthReversalService::authRequestID, "xsd:string"))
				{	soap_flag_authRequestID1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__APAuthReversalService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__APAuthReversalService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APAuthReversalService, SOAP_TYPE_ns2__APAuthReversalService, sizeof(ns2__APAuthReversalService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APAuthReversalService * SOAP_FMAC2 soap_instantiate_ns2__APAuthReversalService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APAuthReversalService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APAuthReversalService *p;
	size_t k = sizeof(ns2__APAuthReversalService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APAuthReversalService);
		if (p)
			((ns2__APAuthReversalService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APAuthReversalService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APAuthReversalService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APAuthReversalService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APAuthReversalService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APAuthReversalService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APAuthReversalService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APAuthReversalService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APAuthReversalService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APAuthReversalService * SOAP_FMAC4 soap_get_ns2__APAuthReversalService(struct soap *soap, ns2__APAuthReversalService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APAuthReversalService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APAuthService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APAuthService::cancelURL = NULL;
	this->ns2__APAuthService::successURL = NULL;
	this->ns2__APAuthService::failureURL = NULL;
	this->ns2__APAuthService::overridePaymentMethod = NULL;
	this->ns2__APAuthService::reconciliationID = NULL;
	this->ns2__APAuthService::preapprovalToken = NULL;
	this->ns2__APAuthService::run = NULL;
	/* transient soap skipped */
}

void ns2__APAuthService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthService::cancelURL);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthService::successURL);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthService::failureURL);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthService::overridePaymentMethod);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthService::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APAuthService::preapprovalToken);
#endif
}

int ns2__APAuthService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APAuthService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APAuthService(struct soap *soap, const char *tag, int id, const ns2__APAuthService *a, const char *type)
{
	if (((ns2__APAuthService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__APAuthService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APAuthService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cancelURL", -1, (wchar_t*const*)&a->ns2__APAuthService::cancelURL, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:successURL", -1, (wchar_t*const*)&a->ns2__APAuthService::successURL, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:failureURL", -1, (wchar_t*const*)&a->ns2__APAuthService::failureURL, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:overridePaymentMethod", -1, (wchar_t*const*)&a->ns2__APAuthService::overridePaymentMethod, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__APAuthService::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:preapprovalToken", -1, (wchar_t*const*)&a->ns2__APAuthService::preapprovalToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APAuthService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APAuthService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APAuthService * SOAP_FMAC4 soap_in_ns2__APAuthService(struct soap *soap, const char *tag, ns2__APAuthService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APAuthService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APAuthService, sizeof(ns2__APAuthService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APAuthService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APAuthService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__APAuthService*)a)->run))
		return NULL;
	size_t soap_flag_cancelURL1 = 1;
	size_t soap_flag_successURL1 = 1;
	size_t soap_flag_failureURL1 = 1;
	size_t soap_flag_overridePaymentMethod1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_preapprovalToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cancelURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cancelURL", (wchar_t**)&a->ns2__APAuthService::cancelURL, "xsd:string"))
				{	soap_flag_cancelURL1--;
					continue;
				}
			if (soap_flag_successURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:successURL", (wchar_t**)&a->ns2__APAuthService::successURL, "xsd:string"))
				{	soap_flag_successURL1--;
					continue;
				}
			if (soap_flag_failureURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:failureURL", (wchar_t**)&a->ns2__APAuthService::failureURL, "xsd:string"))
				{	soap_flag_failureURL1--;
					continue;
				}
			if (soap_flag_overridePaymentMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:overridePaymentMethod", (wchar_t**)&a->ns2__APAuthService::overridePaymentMethod, "xsd:string"))
				{	soap_flag_overridePaymentMethod1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__APAuthService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_preapprovalToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:preapprovalToken", (wchar_t**)&a->ns2__APAuthService::preapprovalToken, "xsd:string"))
				{	soap_flag_preapprovalToken1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__APAuthService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APAuthService, SOAP_TYPE_ns2__APAuthService, sizeof(ns2__APAuthService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APAuthService * SOAP_FMAC2 soap_instantiate_ns2__APAuthService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APAuthService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APAuthService *p;
	size_t k = sizeof(ns2__APAuthService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APAuthService);
		if (p)
			((ns2__APAuthService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APAuthService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APAuthService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APAuthService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APAuthService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APAuthService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APAuthService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APAuthService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APAuthService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APAuthService * SOAP_FMAC4 soap_get_ns2__APAuthService(struct soap *soap, ns2__APAuthService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APAuthService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APDevice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APDevice::id = NULL;
	this->ns2__APDevice::type = NULL;
	this->ns2__APDevice::userAgent = NULL;
	/* transient soap skipped */
}

void ns2__APDevice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APDevice::id);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APDevice::type);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APDevice::userAgent);
#endif
}

int ns2__APDevice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APDevice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APDevice(struct soap *soap, const char *tag, int id, const ns2__APDevice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APDevice), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:id", -1, (wchar_t*const*)&a->ns2__APDevice::id, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:type", -1, (wchar_t*const*)&a->ns2__APDevice::type, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:userAgent", -1, (wchar_t*const*)&a->ns2__APDevice::userAgent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APDevice::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APDevice(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APDevice * SOAP_FMAC4 soap_in_ns2__APDevice(struct soap *soap, const char *tag, ns2__APDevice *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APDevice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APDevice, sizeof(ns2__APDevice), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APDevice)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APDevice *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_id1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_userAgent1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:id", (wchar_t**)&a->ns2__APDevice::id, "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:type", (wchar_t**)&a->ns2__APDevice::type, "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_userAgent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:userAgent", (wchar_t**)&a->ns2__APDevice::userAgent, "xsd:string"))
				{	soap_flag_userAgent1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__APDevice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APDevice, SOAP_TYPE_ns2__APDevice, sizeof(ns2__APDevice), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APDevice * SOAP_FMAC2 soap_instantiate_ns2__APDevice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APDevice(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APDevice *p;
	size_t k = sizeof(ns2__APDevice);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APDevice);
		if (p)
			((ns2__APDevice*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APDevice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APDevice*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APDevice location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APDevice, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APDevice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APDevice", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APDevice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APDevice(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APDevice * SOAP_FMAC4 soap_get_ns2__APDevice(struct soap *soap, ns2__APDevice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__AP::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__AP::orderID = NULL;
	this->ns2__AP::customerRepresentativeID = NULL;
	this->ns2__AP::productDescription = NULL;
	this->ns2__AP::settlementCurrency = NULL;
	this->ns2__AP::subtotalAmount = NULL;
	this->ns2__AP::shippingAmount = NULL;
	this->ns2__AP::handlingAmount = NULL;
	this->ns2__AP::shippingHandlingAmount = NULL;
	this->ns2__AP::additionalAmount = NULL;
	this->ns2__AP::taxAmount = NULL;
	this->ns2__AP::giftWrapAmount = NULL;
	this->ns2__AP::discountAmount = NULL;
	this->ns2__AP::purchaseID = NULL;
	this->ns2__AP::productID = NULL;
	this->ns2__AP::device = NULL;
	/* transient soap skipped */
}

void ns2__AP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AP::orderID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AP::customerRepresentativeID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AP::productDescription);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AP::settlementCurrency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AP::subtotalAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AP::shippingAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AP::handlingAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AP::shippingHandlingAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AP::additionalAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AP::taxAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AP::giftWrapAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AP::discountAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AP::purchaseID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AP::productID);
	soap_serialize_PointerTons2__APDevice(soap, &this->ns2__AP::device);
#endif
}

int ns2__AP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AP(struct soap *soap, const char *tag, int id, const ns2__AP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AP), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderID", -1, (wchar_t*const*)&a->ns2__AP::orderID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:customerRepresentativeID", -1, (wchar_t*const*)&a->ns2__AP::customerRepresentativeID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:productDescription", -1, (wchar_t*const*)&a->ns2__AP::productDescription, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:settlementCurrency", -1, (wchar_t*const*)&a->ns2__AP::settlementCurrency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:subtotalAmount", -1, (wchar_t*const*)&a->ns2__AP::subtotalAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shippingAmount", -1, (wchar_t*const*)&a->ns2__AP::shippingAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:handlingAmount", -1, (wchar_t*const*)&a->ns2__AP::handlingAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shippingHandlingAmount", -1, (wchar_t*const*)&a->ns2__AP::shippingHandlingAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:additionalAmount", -1, (wchar_t*const*)&a->ns2__AP::additionalAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:taxAmount", -1, (wchar_t*const*)&a->ns2__AP::taxAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:giftWrapAmount", -1, (wchar_t*const*)&a->ns2__AP::giftWrapAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:discountAmount", -1, (wchar_t*const*)&a->ns2__AP::discountAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:purchaseID", -1, (wchar_t*const*)&a->ns2__AP::purchaseID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:productID", -1, (wchar_t*const*)&a->ns2__AP::productID, ""))
		return soap->error;
	if (soap_out_PointerTons2__APDevice(soap, "ns2:device", -1, &a->ns2__AP::device, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__AP::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AP(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AP * SOAP_FMAC4 soap_in_ns2__AP(struct soap *soap, const char *tag, ns2__AP *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AP, sizeof(ns2__AP), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__AP)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__AP *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_orderID1 = 1;
	size_t soap_flag_customerRepresentativeID1 = 1;
	size_t soap_flag_productDescription1 = 1;
	size_t soap_flag_settlementCurrency1 = 1;
	size_t soap_flag_subtotalAmount1 = 1;
	size_t soap_flag_shippingAmount1 = 1;
	size_t soap_flag_handlingAmount1 = 1;
	size_t soap_flag_shippingHandlingAmount1 = 1;
	size_t soap_flag_additionalAmount1 = 1;
	size_t soap_flag_taxAmount1 = 1;
	size_t soap_flag_giftWrapAmount1 = 1;
	size_t soap_flag_discountAmount1 = 1;
	size_t soap_flag_purchaseID1 = 1;
	size_t soap_flag_productID1 = 1;
	size_t soap_flag_device1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_orderID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderID", (wchar_t**)&a->ns2__AP::orderID, "xsd:string"))
				{	soap_flag_orderID1--;
					continue;
				}
			if (soap_flag_customerRepresentativeID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:customerRepresentativeID", (wchar_t**)&a->ns2__AP::customerRepresentativeID, "xsd:string"))
				{	soap_flag_customerRepresentativeID1--;
					continue;
				}
			if (soap_flag_productDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:productDescription", (wchar_t**)&a->ns2__AP::productDescription, "xsd:string"))
				{	soap_flag_productDescription1--;
					continue;
				}
			if (soap_flag_settlementCurrency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:settlementCurrency", (wchar_t**)&a->ns2__AP::settlementCurrency, "xsd:string"))
				{	soap_flag_settlementCurrency1--;
					continue;
				}
			if (soap_flag_subtotalAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:subtotalAmount", (wchar_t**)&a->ns2__AP::subtotalAmount, "xsd:string"))
				{	soap_flag_subtotalAmount1--;
					continue;
				}
			if (soap_flag_shippingAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shippingAmount", (wchar_t**)&a->ns2__AP::shippingAmount, "xsd:string"))
				{	soap_flag_shippingAmount1--;
					continue;
				}
			if (soap_flag_handlingAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:handlingAmount", (wchar_t**)&a->ns2__AP::handlingAmount, "xsd:string"))
				{	soap_flag_handlingAmount1--;
					continue;
				}
			if (soap_flag_shippingHandlingAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shippingHandlingAmount", (wchar_t**)&a->ns2__AP::shippingHandlingAmount, "xsd:string"))
				{	soap_flag_shippingHandlingAmount1--;
					continue;
				}
			if (soap_flag_additionalAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:additionalAmount", (wchar_t**)&a->ns2__AP::additionalAmount, "xsd:string"))
				{	soap_flag_additionalAmount1--;
					continue;
				}
			if (soap_flag_taxAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:taxAmount", (wchar_t**)&a->ns2__AP::taxAmount, "xsd:string"))
				{	soap_flag_taxAmount1--;
					continue;
				}
			if (soap_flag_giftWrapAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:giftWrapAmount", (wchar_t**)&a->ns2__AP::giftWrapAmount, "xsd:string"))
				{	soap_flag_giftWrapAmount1--;
					continue;
				}
			if (soap_flag_discountAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:discountAmount", (wchar_t**)&a->ns2__AP::discountAmount, "xsd:string"))
				{	soap_flag_discountAmount1--;
					continue;
				}
			if (soap_flag_purchaseID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:purchaseID", (wchar_t**)&a->ns2__AP::purchaseID, "xsd:string"))
				{	soap_flag_purchaseID1--;
					continue;
				}
			if (soap_flag_productID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:productID", (wchar_t**)&a->ns2__AP::productID, "xsd:string"))
				{	soap_flag_productID1--;
					continue;
				}
			if (soap_flag_device1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__APDevice(soap, "ns2:device", &a->ns2__AP::device, "ns2:APDevice"))
				{	soap_flag_device1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AP, SOAP_TYPE_ns2__AP, sizeof(ns2__AP), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__AP * SOAP_FMAC2 soap_instantiate_ns2__AP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AP(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__AP *p;
	size_t k = sizeof(ns2__AP);
	if (n < 0)
	{	p = SOAP_NEW(ns2__AP);
		if (p)
			((ns2__AP*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__AP, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__AP*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__AP location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__AP, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__AP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:AP", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AP(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AP * SOAP_FMAC4 soap_get_ns2__AP(struct soap *soap, ns2__AP *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Token::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Token::prefix = NULL;
	this->ns2__Token::suffix = NULL;
	this->ns2__Token::expirationMonth = NULL;
	this->ns2__Token::expirationYear = NULL;
	/* transient soap skipped */
}

void ns2__Token::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Token::prefix);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Token::suffix);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Token::expirationMonth);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Token::expirationYear);
#endif
}

int ns2__Token::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Token(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Token(struct soap *soap, const char *tag, int id, const ns2__Token *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Token), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:prefix", -1, (wchar_t*const*)&a->ns2__Token::prefix, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:suffix", -1, (wchar_t*const*)&a->ns2__Token::suffix, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:expirationMonth", -1, (wchar_t*const*)&a->ns2__Token::expirationMonth, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:expirationYear", -1, (wchar_t*const*)&a->ns2__Token::expirationYear, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Token::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Token(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Token * SOAP_FMAC4 soap_in_ns2__Token(struct soap *soap, const char *tag, ns2__Token *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Token *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Token, sizeof(ns2__Token), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Token)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Token *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_prefix1 = 1;
	size_t soap_flag_suffix1 = 1;
	size_t soap_flag_expirationMonth1 = 1;
	size_t soap_flag_expirationYear1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_prefix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:prefix", (wchar_t**)&a->ns2__Token::prefix, "xsd:string"))
				{	soap_flag_prefix1--;
					continue;
				}
			if (soap_flag_suffix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:suffix", (wchar_t**)&a->ns2__Token::suffix, "xsd:string"))
				{	soap_flag_suffix1--;
					continue;
				}
			if (soap_flag_expirationMonth1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:expirationMonth", (wchar_t**)&a->ns2__Token::expirationMonth, "xsd:string"))
				{	soap_flag_expirationMonth1--;
					continue;
				}
			if (soap_flag_expirationYear1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:expirationYear", (wchar_t**)&a->ns2__Token::expirationYear, "xsd:string"))
				{	soap_flag_expirationYear1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Token *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Token, SOAP_TYPE_ns2__Token, sizeof(ns2__Token), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Token * SOAP_FMAC2 soap_instantiate_ns2__Token(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Token(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Token *p;
	size_t k = sizeof(ns2__Token);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Token);
		if (p)
			((ns2__Token*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Token, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Token*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Token location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Token, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Token::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:Token", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Token::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Token(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Token * SOAP_FMAC4 soap_get_ns2__Token(struct soap *soap, ns2__Token *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__JPO::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__JPO::paymentMethod = NULL;
	this->ns2__JPO::bonusAmount = NULL;
	this->ns2__JPO::bonuses = NULL;
	this->ns2__JPO::installments = NULL;
	this->ns2__JPO::firstBillingMonth = NULL;
	this->ns2__JPO::jccaTerminalID = NULL;
	this->ns2__JPO::issuerMessage = NULL;
	/* transient soap skipped */
}

void ns2__JPO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__JPO::paymentMethod);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__JPO::bonusAmount);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__JPO::bonuses);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__JPO::installments);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__JPO::firstBillingMonth);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__JPO::jccaTerminalID);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__JPO::issuerMessage);
#endif
}

int ns2__JPO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__JPO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__JPO(struct soap *soap, const char *tag, int id, const ns2__JPO *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__JPO), type))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:paymentMethod", -1, &a->ns2__JPO::paymentMethod, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:bonusAmount", -1, &a->ns2__JPO::bonusAmount, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:bonuses", -1, &a->ns2__JPO::bonuses, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:installments", -1, &a->ns2__JPO::installments, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:firstBillingMonth", -1, &a->ns2__JPO::firstBillingMonth, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:jccaTerminalID", -1, &a->ns2__JPO::jccaTerminalID, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:issuerMessage", -1, &a->ns2__JPO::issuerMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__JPO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__JPO(soap, tag, this, type);
}

SOAP_FMAC3 ns2__JPO * SOAP_FMAC4 soap_in_ns2__JPO(struct soap *soap, const char *tag, ns2__JPO *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__JPO *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__JPO, sizeof(ns2__JPO), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__JPO)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__JPO *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_paymentMethod1 = 1;
	size_t soap_flag_bonusAmount1 = 1;
	size_t soap_flag_bonuses1 = 1;
	size_t soap_flag_installments1 = 1;
	size_t soap_flag_firstBillingMonth1 = 1;
	size_t soap_flag_jccaTerminalID1 = 1;
	size_t soap_flag_issuerMessage1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_paymentMethod1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:paymentMethod", &a->ns2__JPO::paymentMethod, "xsd:integer"))
				{	soap_flag_paymentMethod1--;
					continue;
				}
			if (soap_flag_bonusAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:bonusAmount", &a->ns2__JPO::bonusAmount, "ns2:amount"))
				{	soap_flag_bonusAmount1--;
					continue;
				}
			if (soap_flag_bonuses1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:bonuses", &a->ns2__JPO::bonuses, "xsd:integer"))
				{	soap_flag_bonuses1--;
					continue;
				}
			if (soap_flag_installments1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:installments", &a->ns2__JPO::installments, "xsd:integer"))
				{	soap_flag_installments1--;
					continue;
				}
			if (soap_flag_firstBillingMonth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:firstBillingMonth", &a->ns2__JPO::firstBillingMonth, "xsd:integer"))
				{	soap_flag_firstBillingMonth1--;
					continue;
				}
			if (soap_flag_jccaTerminalID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:jccaTerminalID", &a->ns2__JPO::jccaTerminalID, "xsd:integer"))
				{	soap_flag_jccaTerminalID1--;
					continue;
				}
			if (soap_flag_issuerMessage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:issuerMessage", &a->ns2__JPO::issuerMessage, "xsd:integer"))
				{	soap_flag_issuerMessage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__JPO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__JPO, SOAP_TYPE_ns2__JPO, sizeof(ns2__JPO), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__JPO * SOAP_FMAC2 soap_instantiate_ns2__JPO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__JPO(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__JPO *p;
	size_t k = sizeof(ns2__JPO);
	if (n < 0)
	{	p = SOAP_NEW(ns2__JPO);
		if (p)
			((ns2__JPO*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__JPO, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__JPO*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__JPO location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__JPO, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__JPO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:JPO", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__JPO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__JPO(soap, this, tag, type);
}

SOAP_FMAC3 ns2__JPO * SOAP_FMAC4 soap_get_ns2__JPO(struct soap *soap, ns2__JPO *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__JPO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPal::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->ns2__PayPal::__any);
	/* transient soap skipped */
}

void ns2__PayPal::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->ns2__PayPal::__any);
#endif
}

int ns2__PayPal::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPal(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPal(struct soap *soap, const char *tag, int id, const ns2__PayPal *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPal), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &a->ns2__PayPal::__any, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPal::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPal(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPal * SOAP_FMAC4 soap_in_ns2__PayPal(struct soap *soap, const char *tag, ns2__PayPal *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPal *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPal, sizeof(ns2__PayPal), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPal)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPal *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &a->ns2__PayPal::__any, ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayPal *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPal, SOAP_TYPE_ns2__PayPal, sizeof(ns2__PayPal), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPal * SOAP_FMAC2 soap_instantiate_ns2__PayPal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPal(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPal *p;
	size_t k = sizeof(ns2__PayPal);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPal);
		if (p)
			((ns2__PayPal*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPal, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPal*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPal location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPal, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPal::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPal", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPal::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPal(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPal * SOAP_FMAC4 soap_get_ns2__PayPal(struct soap *soap, ns2__PayPal *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Batch::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Batch::batchID = NULL;
	this->ns2__Batch::recordID = NULL;
	/* transient soap skipped */
}

void ns2__Batch::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Batch::batchID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Batch::recordID);
#endif
}

int ns2__Batch::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Batch(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Batch(struct soap *soap, const char *tag, int id, const ns2__Batch *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Batch), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:batchID", -1, (wchar_t*const*)&a->ns2__Batch::batchID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:recordID", -1, (wchar_t*const*)&a->ns2__Batch::recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Batch::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Batch(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Batch * SOAP_FMAC4 soap_in_ns2__Batch(struct soap *soap, const char *tag, ns2__Batch *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Batch *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Batch, sizeof(ns2__Batch), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Batch)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Batch *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_batchID1 = 1;
	size_t soap_flag_recordID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_batchID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:batchID", (wchar_t**)&a->ns2__Batch::batchID, "xsd:string"))
				{	soap_flag_batchID1--;
					continue;
				}
			if (soap_flag_recordID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:recordID", (wchar_t**)&a->ns2__Batch::recordID, "xsd:string"))
				{	soap_flag_recordID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Batch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Batch, SOAP_TYPE_ns2__Batch, sizeof(ns2__Batch), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Batch * SOAP_FMAC2 soap_instantiate_ns2__Batch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Batch(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Batch *p;
	size_t k = sizeof(ns2__Batch);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Batch);
		if (p)
			((ns2__Batch*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Batch, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Batch*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Batch location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Batch, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Batch::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:Batch", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Batch::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Batch(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Batch * SOAP_FMAC4 soap_get_ns2__Batch(struct soap *soap, ns2__Batch *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Batch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DecisionManagerTravelLeg::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DecisionManagerTravelLeg::origin = NULL;
	this->ns2__DecisionManagerTravelLeg::destination = NULL;
	this->ns2__DecisionManagerTravelLeg::id = NULL;
	/* transient soap skipped */
}

void ns2__DecisionManagerTravelLeg::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DecisionManagerTravelLeg::origin);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DecisionManagerTravelLeg::destination);
#endif
}

int ns2__DecisionManagerTravelLeg::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DecisionManagerTravelLeg(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DecisionManagerTravelLeg(struct soap *soap, const char *tag, int id, const ns2__DecisionManagerTravelLeg *a, const char *type)
{
	if (((ns2__DecisionManagerTravelLeg*)a)->id)
		if (*((ns2__DecisionManagerTravelLeg*)a)->id)
			soap_set_attr(soap, "id", soap_xsd__integer2s(soap, *((ns2__DecisionManagerTravelLeg*)a)->id), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DecisionManagerTravelLeg), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:origin", -1, (wchar_t*const*)&a->ns2__DecisionManagerTravelLeg::origin, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:destination", -1, (wchar_t*const*)&a->ns2__DecisionManagerTravelLeg::destination, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DecisionManagerTravelLeg::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DecisionManagerTravelLeg(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DecisionManagerTravelLeg * SOAP_FMAC4 soap_in_ns2__DecisionManagerTravelLeg(struct soap *soap, const char *tag, ns2__DecisionManagerTravelLeg *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DecisionManagerTravelLeg *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DecisionManagerTravelLeg, sizeof(ns2__DecisionManagerTravelLeg), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DecisionManagerTravelLeg)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DecisionManagerTravelLeg *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "id", 0);
		if (t)
		{
			if (!(((ns2__DecisionManagerTravelLeg*)a)->id = (wchar_t **)soap_malloc(soap, sizeof(wchar_t *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__integer(soap, t, ((ns2__DecisionManagerTravelLeg*)a)->id))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_origin1 = 1;
	size_t soap_flag_destination1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_origin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:origin", (wchar_t**)&a->ns2__DecisionManagerTravelLeg::origin, "xsd:string"))
				{	soap_flag_origin1--;
					continue;
				}
			if (soap_flag_destination1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:destination", (wchar_t**)&a->ns2__DecisionManagerTravelLeg::destination, "xsd:string"))
				{	soap_flag_destination1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DecisionManagerTravelLeg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DecisionManagerTravelLeg, SOAP_TYPE_ns2__DecisionManagerTravelLeg, sizeof(ns2__DecisionManagerTravelLeg), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DecisionManagerTravelLeg * SOAP_FMAC2 soap_instantiate_ns2__DecisionManagerTravelLeg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DecisionManagerTravelLeg(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DecisionManagerTravelLeg *p;
	size_t k = sizeof(ns2__DecisionManagerTravelLeg);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DecisionManagerTravelLeg);
		if (p)
			((ns2__DecisionManagerTravelLeg*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DecisionManagerTravelLeg, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DecisionManagerTravelLeg*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DecisionManagerTravelLeg location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DecisionManagerTravelLeg, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DecisionManagerTravelLeg::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:DecisionManagerTravelLeg", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DecisionManagerTravelLeg::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DecisionManagerTravelLeg(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DecisionManagerTravelLeg * SOAP_FMAC4 soap_get_ns2__DecisionManagerTravelLeg(struct soap *soap, ns2__DecisionManagerTravelLeg *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DecisionManagerTravelLeg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DecisionManagerTravelData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons2__DecisionManagerTravelLeg(soap, &this->ns2__DecisionManagerTravelData::leg);
	this->ns2__DecisionManagerTravelData::departureDateTime = NULL;
	this->ns2__DecisionManagerTravelData::completeRoute = NULL;
	this->ns2__DecisionManagerTravelData::journeyType = NULL;
	/* transient soap skipped */
}

void ns2__DecisionManagerTravelData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons2__DecisionManagerTravelLeg(soap, &this->ns2__DecisionManagerTravelData::leg);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__DecisionManagerTravelData::departureDateTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DecisionManagerTravelData::completeRoute);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DecisionManagerTravelData::journeyType);
#endif
}

int ns2__DecisionManagerTravelData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DecisionManagerTravelData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DecisionManagerTravelData(struct soap *soap, const char *tag, int id, const ns2__DecisionManagerTravelData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DecisionManagerTravelData), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__DecisionManagerTravelLeg(soap, "ns2:leg", -1, &a->ns2__DecisionManagerTravelData::leg, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:departureDateTime", -1, &a->ns2__DecisionManagerTravelData::departureDateTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:completeRoute", -1, (wchar_t*const*)&a->ns2__DecisionManagerTravelData::completeRoute, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:journeyType", -1, (wchar_t*const*)&a->ns2__DecisionManagerTravelData::journeyType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DecisionManagerTravelData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DecisionManagerTravelData(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DecisionManagerTravelData * SOAP_FMAC4 soap_in_ns2__DecisionManagerTravelData(struct soap *soap, const char *tag, ns2__DecisionManagerTravelData *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DecisionManagerTravelData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DecisionManagerTravelData, sizeof(ns2__DecisionManagerTravelData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DecisionManagerTravelData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DecisionManagerTravelData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_departureDateTime1 = 1;
	size_t soap_flag_completeRoute1 = 1;
	size_t soap_flag_journeyType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__DecisionManagerTravelLeg(soap, "ns2:leg", &a->ns2__DecisionManagerTravelData::leg, "ns2:DecisionManagerTravelLeg"))
					continue;
			if (soap_flag_departureDateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:departureDateTime", &a->ns2__DecisionManagerTravelData::departureDateTime, "ns2:dateTime"))
				{	soap_flag_departureDateTime1--;
					continue;
				}
			if (soap_flag_completeRoute1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:completeRoute", (wchar_t**)&a->ns2__DecisionManagerTravelData::completeRoute, "xsd:string"))
				{	soap_flag_completeRoute1--;
					continue;
				}
			if (soap_flag_journeyType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:journeyType", (wchar_t**)&a->ns2__DecisionManagerTravelData::journeyType, "xsd:string"))
				{	soap_flag_journeyType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__DecisionManagerTravelData::leg.size() > 100))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns2__DecisionManagerTravelData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DecisionManagerTravelData, SOAP_TYPE_ns2__DecisionManagerTravelData, sizeof(ns2__DecisionManagerTravelData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DecisionManagerTravelData * SOAP_FMAC2 soap_instantiate_ns2__DecisionManagerTravelData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DecisionManagerTravelData(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DecisionManagerTravelData *p;
	size_t k = sizeof(ns2__DecisionManagerTravelData);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DecisionManagerTravelData);
		if (p)
			((ns2__DecisionManagerTravelData*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DecisionManagerTravelData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DecisionManagerTravelData*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DecisionManagerTravelData location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DecisionManagerTravelData, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DecisionManagerTravelData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:DecisionManagerTravelData", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DecisionManagerTravelData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DecisionManagerTravelData(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DecisionManagerTravelData * SOAP_FMAC4 soap_get_ns2__DecisionManagerTravelData(struct soap *soap, ns2__DecisionManagerTravelData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DecisionManagerTravelData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DecisionManager::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DecisionManager::enabled = NULL;
	this->ns2__DecisionManager::profile = NULL;
	this->ns2__DecisionManager::travelData = NULL;
	/* transient soap skipped */
}

void ns2__DecisionManager::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__DecisionManager::enabled);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DecisionManager::profile);
	soap_serialize_PointerTons2__DecisionManagerTravelData(soap, &this->ns2__DecisionManager::travelData);
#endif
}

int ns2__DecisionManager::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DecisionManager(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DecisionManager(struct soap *soap, const char *tag, int id, const ns2__DecisionManager *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DecisionManager), type))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:enabled", -1, &a->ns2__DecisionManager::enabled, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:profile", -1, (wchar_t*const*)&a->ns2__DecisionManager::profile, ""))
		return soap->error;
	if (soap_out_PointerTons2__DecisionManagerTravelData(soap, "ns2:travelData", -1, &a->ns2__DecisionManager::travelData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DecisionManager::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DecisionManager(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DecisionManager * SOAP_FMAC4 soap_in_ns2__DecisionManager(struct soap *soap, const char *tag, ns2__DecisionManager *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DecisionManager *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DecisionManager, sizeof(ns2__DecisionManager), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DecisionManager)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DecisionManager *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_enabled1 = 1;
	size_t soap_flag_profile1 = 1;
	size_t soap_flag_travelData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:enabled", &a->ns2__DecisionManager::enabled, "ns2:boolean"))
				{	soap_flag_enabled1--;
					continue;
				}
			if (soap_flag_profile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:profile", (wchar_t**)&a->ns2__DecisionManager::profile, "xsd:string"))
				{	soap_flag_profile1--;
					continue;
				}
			if (soap_flag_travelData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DecisionManagerTravelData(soap, "ns2:travelData", &a->ns2__DecisionManager::travelData, "ns2:DecisionManagerTravelData"))
				{	soap_flag_travelData1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DecisionManager *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DecisionManager, SOAP_TYPE_ns2__DecisionManager, sizeof(ns2__DecisionManager), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DecisionManager * SOAP_FMAC2 soap_instantiate_ns2__DecisionManager(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DecisionManager(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DecisionManager *p;
	size_t k = sizeof(ns2__DecisionManager);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DecisionManager);
		if (p)
			((ns2__DecisionManager*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DecisionManager, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DecisionManager*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DecisionManager location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DecisionManager, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DecisionManager::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:DecisionManager", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DecisionManager::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DecisionManager(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DecisionManager * SOAP_FMAC4 soap_get_ns2__DecisionManager(struct soap *soap, ns2__DecisionManager *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DecisionManager(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PaymentNetworkToken::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PaymentNetworkToken::requestorID = NULL;
	this->ns2__PaymentNetworkToken::transactionType = NULL;
	this->ns2__PaymentNetworkToken::assuranceLevel = NULL;
	this->ns2__PaymentNetworkToken::accountStatus = NULL;
	this->ns2__PaymentNetworkToken::originalCardCategory = NULL;
	this->ns2__PaymentNetworkToken::deviceTechType = NULL;
	/* transient soap skipped */
}

void ns2__PaymentNetworkToken::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaymentNetworkToken::requestorID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaymentNetworkToken::transactionType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaymentNetworkToken::assuranceLevel);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaymentNetworkToken::accountStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaymentNetworkToken::originalCardCategory);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaymentNetworkToken::deviceTechType);
#endif
}

int ns2__PaymentNetworkToken::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PaymentNetworkToken(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PaymentNetworkToken(struct soap *soap, const char *tag, int id, const ns2__PaymentNetworkToken *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PaymentNetworkToken), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:requestorID", -1, (wchar_t*const*)&a->ns2__PaymentNetworkToken::requestorID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionType", -1, (wchar_t*const*)&a->ns2__PaymentNetworkToken::transactionType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:assuranceLevel", -1, (wchar_t*const*)&a->ns2__PaymentNetworkToken::assuranceLevel, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:accountStatus", -1, (wchar_t*const*)&a->ns2__PaymentNetworkToken::accountStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:originalCardCategory", -1, (wchar_t*const*)&a->ns2__PaymentNetworkToken::originalCardCategory, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:deviceTechType", -1, (wchar_t*const*)&a->ns2__PaymentNetworkToken::deviceTechType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PaymentNetworkToken::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PaymentNetworkToken(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PaymentNetworkToken * SOAP_FMAC4 soap_in_ns2__PaymentNetworkToken(struct soap *soap, const char *tag, ns2__PaymentNetworkToken *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PaymentNetworkToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PaymentNetworkToken, sizeof(ns2__PaymentNetworkToken), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PaymentNetworkToken)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PaymentNetworkToken *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_requestorID1 = 1;
	size_t soap_flag_transactionType1 = 1;
	size_t soap_flag_assuranceLevel1 = 1;
	size_t soap_flag_accountStatus1 = 1;
	size_t soap_flag_originalCardCategory1 = 1;
	size_t soap_flag_deviceTechType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestorID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:requestorID", (wchar_t**)&a->ns2__PaymentNetworkToken::requestorID, "xsd:string"))
				{	soap_flag_requestorID1--;
					continue;
				}
			if (soap_flag_transactionType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionType", (wchar_t**)&a->ns2__PaymentNetworkToken::transactionType, "xsd:string"))
				{	soap_flag_transactionType1--;
					continue;
				}
			if (soap_flag_assuranceLevel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:assuranceLevel", (wchar_t**)&a->ns2__PaymentNetworkToken::assuranceLevel, "xsd:string"))
				{	soap_flag_assuranceLevel1--;
					continue;
				}
			if (soap_flag_accountStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:accountStatus", (wchar_t**)&a->ns2__PaymentNetworkToken::accountStatus, "xsd:string"))
				{	soap_flag_accountStatus1--;
					continue;
				}
			if (soap_flag_originalCardCategory1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:originalCardCategory", (wchar_t**)&a->ns2__PaymentNetworkToken::originalCardCategory, "xsd:string"))
				{	soap_flag_originalCardCategory1--;
					continue;
				}
			if (soap_flag_deviceTechType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:deviceTechType", (wchar_t**)&a->ns2__PaymentNetworkToken::deviceTechType, "xsd:string"))
				{	soap_flag_deviceTechType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PaymentNetworkToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PaymentNetworkToken, SOAP_TYPE_ns2__PaymentNetworkToken, sizeof(ns2__PaymentNetworkToken), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PaymentNetworkToken * SOAP_FMAC2 soap_instantiate_ns2__PaymentNetworkToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PaymentNetworkToken(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PaymentNetworkToken *p;
	size_t k = sizeof(ns2__PaymentNetworkToken);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PaymentNetworkToken);
		if (p)
			((ns2__PaymentNetworkToken*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PaymentNetworkToken, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PaymentNetworkToken*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PaymentNetworkToken location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PaymentNetworkToken, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PaymentNetworkToken::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PaymentNetworkToken", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PaymentNetworkToken::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PaymentNetworkToken(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PaymentNetworkToken * SOAP_FMAC4 soap_get_ns2__PaymentNetworkToken(struct soap *soap, ns2__PaymentNetworkToken *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PaymentNetworkToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Subscription::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Subscription::title = NULL;
	this->ns2__Subscription::paymentMethod = NULL;
	/* transient soap skipped */
}

void ns2__Subscription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Subscription::title);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Subscription::paymentMethod);
#endif
}

int ns2__Subscription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Subscription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Subscription(struct soap *soap, const char *tag, int id, const ns2__Subscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Subscription), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:title", -1, (wchar_t*const*)&a->ns2__Subscription::title, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentMethod", -1, (wchar_t*const*)&a->ns2__Subscription::paymentMethod, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Subscription::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Subscription(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Subscription * SOAP_FMAC4 soap_in_ns2__Subscription(struct soap *soap, const char *tag, ns2__Subscription *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Subscription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Subscription, sizeof(ns2__Subscription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Subscription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Subscription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_title1 = 1;
	size_t soap_flag_paymentMethod1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:title", (wchar_t**)&a->ns2__Subscription::title, "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			if (soap_flag_paymentMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentMethod", (wchar_t**)&a->ns2__Subscription::paymentMethod, "xsd:string"))
				{	soap_flag_paymentMethod1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Subscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Subscription, SOAP_TYPE_ns2__Subscription, sizeof(ns2__Subscription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Subscription * SOAP_FMAC2 soap_instantiate_ns2__Subscription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Subscription(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Subscription *p;
	size_t k = sizeof(ns2__Subscription);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Subscription);
		if (p)
			((ns2__Subscription*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Subscription, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Subscription*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Subscription location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Subscription, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Subscription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:Subscription", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Subscription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Subscription(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Subscription * SOAP_FMAC4 soap_get_ns2__Subscription(struct soap *soap, ns2__Subscription *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Subscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PaySubscriptionEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PaySubscriptionEvent::amount = NULL;
	this->ns2__PaySubscriptionEvent::approvedBy = NULL;
	this->ns2__PaySubscriptionEvent::number = NULL;
	/* transient soap skipped */
}

void ns2__PaySubscriptionEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__amount(soap, &this->ns2__PaySubscriptionEvent::amount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionEvent::approvedBy);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__PaySubscriptionEvent::number);
#endif
}

int ns2__PaySubscriptionEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PaySubscriptionEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PaySubscriptionEvent(struct soap *soap, const char *tag, int id, const ns2__PaySubscriptionEvent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PaySubscriptionEvent), type))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__PaySubscriptionEvent::amount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:approvedBy", -1, (wchar_t*const*)&a->ns2__PaySubscriptionEvent::approvedBy, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:number", -1, &a->ns2__PaySubscriptionEvent::number, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PaySubscriptionEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PaySubscriptionEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PaySubscriptionEvent * SOAP_FMAC4 soap_in_ns2__PaySubscriptionEvent(struct soap *soap, const char *tag, ns2__PaySubscriptionEvent *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PaySubscriptionEvent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PaySubscriptionEvent, sizeof(ns2__PaySubscriptionEvent), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PaySubscriptionEvent)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PaySubscriptionEvent *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_approvedBy1 = 1;
	size_t soap_flag_number1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__PaySubscriptionEvent::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_approvedBy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:approvedBy", (wchar_t**)&a->ns2__PaySubscriptionEvent::approvedBy, "xsd:string"))
				{	soap_flag_approvedBy1--;
					continue;
				}
			if (soap_flag_number1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:number", &a->ns2__PaySubscriptionEvent::number, "xsd:integer"))
				{	soap_flag_number1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PaySubscriptionEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PaySubscriptionEvent, SOAP_TYPE_ns2__PaySubscriptionEvent, sizeof(ns2__PaySubscriptionEvent), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PaySubscriptionEvent * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PaySubscriptionEvent(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PaySubscriptionEvent *p;
	size_t k = sizeof(ns2__PaySubscriptionEvent);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PaySubscriptionEvent);
		if (p)
			((ns2__PaySubscriptionEvent*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PaySubscriptionEvent, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PaySubscriptionEvent*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PaySubscriptionEvent location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PaySubscriptionEvent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PaySubscriptionEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PaySubscriptionEvent", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PaySubscriptionEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PaySubscriptionEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PaySubscriptionEvent * SOAP_FMAC4 soap_get_ns2__PaySubscriptionEvent(struct soap *soap, ns2__PaySubscriptionEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PaySubscriptionEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__RecurringSubscriptionInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RecurringSubscriptionInfo::subscriptionID = NULL;
	this->ns2__RecurringSubscriptionInfo::status = NULL;
	this->ns2__RecurringSubscriptionInfo::amount = NULL;
	this->ns2__RecurringSubscriptionInfo::numberOfPayments = NULL;
	this->ns2__RecurringSubscriptionInfo::numberOfPaymentsToAdd = NULL;
	this->ns2__RecurringSubscriptionInfo::automaticRenew = NULL;
	this->ns2__RecurringSubscriptionInfo::frequency = NULL;
	this->ns2__RecurringSubscriptionInfo::startDate = NULL;
	this->ns2__RecurringSubscriptionInfo::endDate = NULL;
	this->ns2__RecurringSubscriptionInfo::approvalRequired = NULL;
	this->ns2__RecurringSubscriptionInfo::event = NULL;
	this->ns2__RecurringSubscriptionInfo::billPayment = NULL;
	/* transient soap skipped */
}

void ns2__RecurringSubscriptionInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RecurringSubscriptionInfo::subscriptionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RecurringSubscriptionInfo::status);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__RecurringSubscriptionInfo::amount);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__RecurringSubscriptionInfo::numberOfPayments);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__RecurringSubscriptionInfo::numberOfPaymentsToAdd);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__RecurringSubscriptionInfo::automaticRenew);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RecurringSubscriptionInfo::frequency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RecurringSubscriptionInfo::startDate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RecurringSubscriptionInfo::endDate);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__RecurringSubscriptionInfo::approvalRequired);
	soap_serialize_PointerTons2__PaySubscriptionEvent(soap, &this->ns2__RecurringSubscriptionInfo::event);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__RecurringSubscriptionInfo::billPayment);
#endif
}

int ns2__RecurringSubscriptionInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RecurringSubscriptionInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RecurringSubscriptionInfo(struct soap *soap, const char *tag, int id, const ns2__RecurringSubscriptionInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RecurringSubscriptionInfo), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:subscriptionID", -1, (wchar_t*const*)&a->ns2__RecurringSubscriptionInfo::subscriptionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:status", -1, (wchar_t*const*)&a->ns2__RecurringSubscriptionInfo::status, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:amount", -1, &a->ns2__RecurringSubscriptionInfo::amount, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:numberOfPayments", -1, &a->ns2__RecurringSubscriptionInfo::numberOfPayments, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:numberOfPaymentsToAdd", -1, &a->ns2__RecurringSubscriptionInfo::numberOfPaymentsToAdd, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:automaticRenew", -1, &a->ns2__RecurringSubscriptionInfo::automaticRenew, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:frequency", -1, (wchar_t*const*)&a->ns2__RecurringSubscriptionInfo::frequency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:startDate", -1, (wchar_t*const*)&a->ns2__RecurringSubscriptionInfo::startDate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:endDate", -1, (wchar_t*const*)&a->ns2__RecurringSubscriptionInfo::endDate, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:approvalRequired", -1, &a->ns2__RecurringSubscriptionInfo::approvalRequired, ""))
		return soap->error;
	if (soap_out_PointerTons2__PaySubscriptionEvent(soap, "ns2:event", -1, &a->ns2__RecurringSubscriptionInfo::event, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:billPayment", -1, &a->ns2__RecurringSubscriptionInfo::billPayment, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__RecurringSubscriptionInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RecurringSubscriptionInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RecurringSubscriptionInfo * SOAP_FMAC4 soap_in_ns2__RecurringSubscriptionInfo(struct soap *soap, const char *tag, ns2__RecurringSubscriptionInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RecurringSubscriptionInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RecurringSubscriptionInfo, sizeof(ns2__RecurringSubscriptionInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__RecurringSubscriptionInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__RecurringSubscriptionInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_subscriptionID1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_numberOfPayments1 = 1;
	size_t soap_flag_numberOfPaymentsToAdd1 = 1;
	size_t soap_flag_automaticRenew1 = 1;
	size_t soap_flag_frequency1 = 1;
	size_t soap_flag_startDate1 = 1;
	size_t soap_flag_endDate1 = 1;
	size_t soap_flag_approvalRequired1 = 1;
	size_t soap_flag_event1 = 1;
	size_t soap_flag_billPayment1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_subscriptionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:subscriptionID", (wchar_t**)&a->ns2__RecurringSubscriptionInfo::subscriptionID, "xsd:string"))
				{	soap_flag_subscriptionID1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:status", (wchar_t**)&a->ns2__RecurringSubscriptionInfo::status, "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:amount", &a->ns2__RecurringSubscriptionInfo::amount, "ns2:amount"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_numberOfPayments1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:numberOfPayments", &a->ns2__RecurringSubscriptionInfo::numberOfPayments, "xsd:integer"))
				{	soap_flag_numberOfPayments1--;
					continue;
				}
			if (soap_flag_numberOfPaymentsToAdd1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:numberOfPaymentsToAdd", &a->ns2__RecurringSubscriptionInfo::numberOfPaymentsToAdd, "xsd:integer"))
				{	soap_flag_numberOfPaymentsToAdd1--;
					continue;
				}
			if (soap_flag_automaticRenew1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:automaticRenew", &a->ns2__RecurringSubscriptionInfo::automaticRenew, "ns2:boolean"))
				{	soap_flag_automaticRenew1--;
					continue;
				}
			if (soap_flag_frequency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:frequency", (wchar_t**)&a->ns2__RecurringSubscriptionInfo::frequency, "xsd:string"))
				{	soap_flag_frequency1--;
					continue;
				}
			if (soap_flag_startDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:startDate", (wchar_t**)&a->ns2__RecurringSubscriptionInfo::startDate, "xsd:string"))
				{	soap_flag_startDate1--;
					continue;
				}
			if (soap_flag_endDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:endDate", (wchar_t**)&a->ns2__RecurringSubscriptionInfo::endDate, "xsd:string"))
				{	soap_flag_endDate1--;
					continue;
				}
			if (soap_flag_approvalRequired1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:approvalRequired", &a->ns2__RecurringSubscriptionInfo::approvalRequired, "ns2:boolean"))
				{	soap_flag_approvalRequired1--;
					continue;
				}
			if (soap_flag_event1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PaySubscriptionEvent(soap, "ns2:event", &a->ns2__RecurringSubscriptionInfo::event, "ns2:PaySubscriptionEvent"))
				{	soap_flag_event1--;
					continue;
				}
			if (soap_flag_billPayment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:billPayment", &a->ns2__RecurringSubscriptionInfo::billPayment, "ns2:boolean"))
				{	soap_flag_billPayment1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RecurringSubscriptionInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RecurringSubscriptionInfo, SOAP_TYPE_ns2__RecurringSubscriptionInfo, sizeof(ns2__RecurringSubscriptionInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__RecurringSubscriptionInfo * SOAP_FMAC2 soap_instantiate_ns2__RecurringSubscriptionInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RecurringSubscriptionInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__RecurringSubscriptionInfo *p;
	size_t k = sizeof(ns2__RecurringSubscriptionInfo);
	if (n < 0)
	{	p = SOAP_NEW(ns2__RecurringSubscriptionInfo);
		if (p)
			((ns2__RecurringSubscriptionInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__RecurringSubscriptionInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__RecurringSubscriptionInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__RecurringSubscriptionInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__RecurringSubscriptionInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__RecurringSubscriptionInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:RecurringSubscriptionInfo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RecurringSubscriptionInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RecurringSubscriptionInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RecurringSubscriptionInfo * SOAP_FMAC4 soap_get_ns2__RecurringSubscriptionInfo(struct soap *soap, ns2__RecurringSubscriptionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RecurringSubscriptionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__BankInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__BankInfo::bankCode = NULL;
	this->ns2__BankInfo::name = NULL;
	this->ns2__BankInfo::address = NULL;
	this->ns2__BankInfo::city = NULL;
	this->ns2__BankInfo::country = NULL;
	this->ns2__BankInfo::branchCode = NULL;
	this->ns2__BankInfo::swiftCode = NULL;
	this->ns2__BankInfo::sortCode = NULL;
	this->ns2__BankInfo::issuerID = NULL;
	/* transient soap skipped */
}

void ns2__BankInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankInfo::bankCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankInfo::name);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankInfo::address);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankInfo::city);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankInfo::country);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankInfo::branchCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankInfo::swiftCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankInfo::sortCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankInfo::issuerID);
#endif
}

int ns2__BankInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__BankInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BankInfo(struct soap *soap, const char *tag, int id, const ns2__BankInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BankInfo), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:bankCode", -1, (wchar_t*const*)&a->ns2__BankInfo::bankCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:name", -1, (wchar_t*const*)&a->ns2__BankInfo::name, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:address", -1, (wchar_t*const*)&a->ns2__BankInfo::address, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:city", -1, (wchar_t*const*)&a->ns2__BankInfo::city, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:country", -1, (wchar_t*const*)&a->ns2__BankInfo::country, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:branchCode", -1, (wchar_t*const*)&a->ns2__BankInfo::branchCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:swiftCode", -1, (wchar_t*const*)&a->ns2__BankInfo::swiftCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sortCode", -1, (wchar_t*const*)&a->ns2__BankInfo::sortCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:issuerID", -1, (wchar_t*const*)&a->ns2__BankInfo::issuerID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__BankInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__BankInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__BankInfo * SOAP_FMAC4 soap_in_ns2__BankInfo(struct soap *soap, const char *tag, ns2__BankInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__BankInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BankInfo, sizeof(ns2__BankInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__BankInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__BankInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_bankCode1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_address1 = 1;
	size_t soap_flag_city1 = 1;
	size_t soap_flag_country1 = 1;
	size_t soap_flag_branchCode1 = 1;
	size_t soap_flag_swiftCode1 = 1;
	size_t soap_flag_sortCode1 = 1;
	size_t soap_flag_issuerID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bankCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:bankCode", (wchar_t**)&a->ns2__BankInfo::bankCode, "xsd:string"))
				{	soap_flag_bankCode1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:name", (wchar_t**)&a->ns2__BankInfo::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:address", (wchar_t**)&a->ns2__BankInfo::address, "xsd:string"))
				{	soap_flag_address1--;
					continue;
				}
			if (soap_flag_city1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:city", (wchar_t**)&a->ns2__BankInfo::city, "xsd:string"))
				{	soap_flag_city1--;
					continue;
				}
			if (soap_flag_country1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:country", (wchar_t**)&a->ns2__BankInfo::country, "xsd:string"))
				{	soap_flag_country1--;
					continue;
				}
			if (soap_flag_branchCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:branchCode", (wchar_t**)&a->ns2__BankInfo::branchCode, "xsd:string"))
				{	soap_flag_branchCode1--;
					continue;
				}
			if (soap_flag_swiftCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:swiftCode", (wchar_t**)&a->ns2__BankInfo::swiftCode, "xsd:string"))
				{	soap_flag_swiftCode1--;
					continue;
				}
			if (soap_flag_sortCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sortCode", (wchar_t**)&a->ns2__BankInfo::sortCode, "xsd:string"))
				{	soap_flag_sortCode1--;
					continue;
				}
			if (soap_flag_issuerID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:issuerID", (wchar_t**)&a->ns2__BankInfo::issuerID, "xsd:string"))
				{	soap_flag_issuerID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__BankInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BankInfo, SOAP_TYPE_ns2__BankInfo, sizeof(ns2__BankInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__BankInfo * SOAP_FMAC2 soap_instantiate_ns2__BankInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__BankInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__BankInfo *p;
	size_t k = sizeof(ns2__BankInfo);
	if (n < 0)
	{	p = SOAP_NEW(ns2__BankInfo);
		if (p)
			((ns2__BankInfo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__BankInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__BankInfo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__BankInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__BankInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__BankInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:BankInfo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__BankInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__BankInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__BankInfo * SOAP_FMAC4 soap_get_ns2__BankInfo(struct soap *soap, ns2__BankInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BankInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__FundTransfer::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__FundTransfer::accountNumber = NULL;
	this->ns2__FundTransfer::accountName = NULL;
	this->ns2__FundTransfer::bankCheckDigit = NULL;
	this->ns2__FundTransfer::iban = NULL;
	/* transient soap skipped */
}

void ns2__FundTransfer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__FundTransfer::accountNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__FundTransfer::accountName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__FundTransfer::bankCheckDigit);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__FundTransfer::iban);
#endif
}

int ns2__FundTransfer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FundTransfer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FundTransfer(struct soap *soap, const char *tag, int id, const ns2__FundTransfer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FundTransfer), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:accountNumber", -1, (wchar_t*const*)&a->ns2__FundTransfer::accountNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:accountName", -1, (wchar_t*const*)&a->ns2__FundTransfer::accountName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:bankCheckDigit", -1, (wchar_t*const*)&a->ns2__FundTransfer::bankCheckDigit, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:iban", -1, (wchar_t*const*)&a->ns2__FundTransfer::iban, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__FundTransfer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FundTransfer(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FundTransfer * SOAP_FMAC4 soap_in_ns2__FundTransfer(struct soap *soap, const char *tag, ns2__FundTransfer *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FundTransfer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FundTransfer, sizeof(ns2__FundTransfer), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__FundTransfer)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__FundTransfer *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_accountNumber1 = 1;
	size_t soap_flag_accountName1 = 1;
	size_t soap_flag_bankCheckDigit1 = 1;
	size_t soap_flag_iban1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accountNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:accountNumber", (wchar_t**)&a->ns2__FundTransfer::accountNumber, "xsd:string"))
				{	soap_flag_accountNumber1--;
					continue;
				}
			if (soap_flag_accountName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:accountName", (wchar_t**)&a->ns2__FundTransfer::accountName, "xsd:string"))
				{	soap_flag_accountName1--;
					continue;
				}
			if (soap_flag_bankCheckDigit1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:bankCheckDigit", (wchar_t**)&a->ns2__FundTransfer::bankCheckDigit, "xsd:string"))
				{	soap_flag_bankCheckDigit1--;
					continue;
				}
			if (soap_flag_iban1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:iban", (wchar_t**)&a->ns2__FundTransfer::iban, "xsd:string"))
				{	soap_flag_iban1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__FundTransfer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FundTransfer, SOAP_TYPE_ns2__FundTransfer, sizeof(ns2__FundTransfer), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__FundTransfer * SOAP_FMAC2 soap_instantiate_ns2__FundTransfer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FundTransfer(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__FundTransfer *p;
	size_t k = sizeof(ns2__FundTransfer);
	if (n < 0)
	{	p = SOAP_NEW(ns2__FundTransfer);
		if (p)
			((ns2__FundTransfer*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__FundTransfer, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__FundTransfer*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__FundTransfer location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__FundTransfer, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__FundTransfer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:FundTransfer", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FundTransfer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FundTransfer(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FundTransfer * SOAP_FMAC4 soap_get_ns2__FundTransfer(struct soap *soap, ns2__FundTransfer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FundTransfer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__UCAF::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__UCAF::authenticationData = NULL;
	this->ns2__UCAF::collectionIndicator = NULL;
	/* transient soap skipped */
}

void ns2__UCAF::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__UCAF::authenticationData);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__UCAF::collectionIndicator);
#endif
}

int ns2__UCAF::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__UCAF(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UCAF(struct soap *soap, const char *tag, int id, const ns2__UCAF *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__UCAF), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authenticationData", -1, (wchar_t*const*)&a->ns2__UCAF::authenticationData, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:collectionIndicator", -1, (wchar_t*const*)&a->ns2__UCAF::collectionIndicator, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__UCAF::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__UCAF(soap, tag, this, type);
}

SOAP_FMAC3 ns2__UCAF * SOAP_FMAC4 soap_in_ns2__UCAF(struct soap *soap, const char *tag, ns2__UCAF *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__UCAF *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__UCAF, sizeof(ns2__UCAF), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__UCAF)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__UCAF *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_authenticationData1 = 1;
	size_t soap_flag_collectionIndicator1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authenticationData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authenticationData", (wchar_t**)&a->ns2__UCAF::authenticationData, "xsd:string"))
				{	soap_flag_authenticationData1--;
					continue;
				}
			if (soap_flag_collectionIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:collectionIndicator", (wchar_t**)&a->ns2__UCAF::collectionIndicator, "xsd:string"))
				{	soap_flag_collectionIndicator1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__UCAF *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__UCAF, SOAP_TYPE_ns2__UCAF, sizeof(ns2__UCAF), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__UCAF * SOAP_FMAC2 soap_instantiate_ns2__UCAF(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__UCAF(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__UCAF *p;
	size_t k = sizeof(ns2__UCAF);
	if (n < 0)
	{	p = SOAP_NEW(ns2__UCAF);
		if (p)
			((ns2__UCAF*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__UCAF, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__UCAF*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__UCAF location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__UCAF, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__UCAF::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:UCAF", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__UCAF::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__UCAF(soap, this, tag, type);
}

SOAP_FMAC3 ns2__UCAF * SOAP_FMAC4 soap_get_ns2__UCAF(struct soap *soap, ns2__UCAF *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UCAF(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__GECC::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__GECC::saleType = NULL;
	this->ns2__GECC::planNumber = NULL;
	this->ns2__GECC::sequenceNumber = NULL;
	this->ns2__GECC::promotionEndDate = NULL;
	this->ns2__GECC::promotionPlan = NULL;
	soap_default_std__vectorTemplateOfwstring(soap, &this->ns2__GECC::line);
	/* transient soap skipped */
}

void ns2__GECC::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__GECC::saleType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__GECC::planNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__GECC::sequenceNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__GECC::promotionEndDate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__GECC::promotionPlan);
	soap_serialize_std__vectorTemplateOfwstring(soap, &this->ns2__GECC::line);
#endif
}

int ns2__GECC::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__GECC(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__GECC(struct soap *soap, const char *tag, int id, const ns2__GECC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__GECC), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:saleType", -1, (wchar_t*const*)&a->ns2__GECC::saleType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:planNumber", -1, (wchar_t*const*)&a->ns2__GECC::planNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sequenceNumber", -1, (wchar_t*const*)&a->ns2__GECC::sequenceNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:promotionEndDate", -1, (wchar_t*const*)&a->ns2__GECC::promotionEndDate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:promotionPlan", -1, (wchar_t*const*)&a->ns2__GECC::promotionPlan, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfwstring(soap, "ns2:line", -1, &a->ns2__GECC::line, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__GECC::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__GECC(soap, tag, this, type);
}

SOAP_FMAC3 ns2__GECC * SOAP_FMAC4 soap_in_ns2__GECC(struct soap *soap, const char *tag, ns2__GECC *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__GECC *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__GECC, sizeof(ns2__GECC), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__GECC)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__GECC *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_saleType1 = 1;
	size_t soap_flag_planNumber1 = 1;
	size_t soap_flag_sequenceNumber1 = 1;
	size_t soap_flag_promotionEndDate1 = 1;
	size_t soap_flag_promotionPlan1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saleType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:saleType", (wchar_t**)&a->ns2__GECC::saleType, "xsd:string"))
				{	soap_flag_saleType1--;
					continue;
				}
			if (soap_flag_planNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:planNumber", (wchar_t**)&a->ns2__GECC::planNumber, "xsd:string"))
				{	soap_flag_planNumber1--;
					continue;
				}
			if (soap_flag_sequenceNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sequenceNumber", (wchar_t**)&a->ns2__GECC::sequenceNumber, "xsd:string"))
				{	soap_flag_sequenceNumber1--;
					continue;
				}
			if (soap_flag_promotionEndDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:promotionEndDate", (wchar_t**)&a->ns2__GECC::promotionEndDate, "xsd:string"))
				{	soap_flag_promotionEndDate1--;
					continue;
				}
			if (soap_flag_promotionPlan1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:promotionPlan", (wchar_t**)&a->ns2__GECC::promotionPlan, "xsd:string"))
				{	soap_flag_promotionPlan1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfwstring(soap, "ns2:line", &a->ns2__GECC::line, "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->ns2__GECC::line.size() > 7))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else
	{	a = (ns2__GECC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__GECC, SOAP_TYPE_ns2__GECC, sizeof(ns2__GECC), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__GECC * SOAP_FMAC2 soap_instantiate_ns2__GECC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__GECC(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__GECC *p;
	size_t k = sizeof(ns2__GECC);
	if (n < 0)
	{	p = SOAP_NEW(ns2__GECC);
		if (p)
			((ns2__GECC*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__GECC, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__GECC*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__GECC location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__GECC, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__GECC::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:GECC", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__GECC::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__GECC(soap, this, tag, type);
}

SOAP_FMAC3 ns2__GECC * SOAP_FMAC4 soap_get_ns2__GECC(struct soap *soap, ns2__GECC *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__GECC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__FundingTotals::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__FundingTotals::currency = NULL;
	this->ns2__FundingTotals::grandTotalAmount = NULL;
	/* transient soap skipped */
}

void ns2__FundingTotals::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__FundingTotals::currency);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__FundingTotals::grandTotalAmount);
#endif
}

int ns2__FundingTotals::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FundingTotals(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FundingTotals(struct soap *soap, const char *tag, int id, const ns2__FundingTotals *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FundingTotals), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:currency", -1, (wchar_t*const*)&a->ns2__FundingTotals::currency, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:grandTotalAmount", -1, &a->ns2__FundingTotals::grandTotalAmount, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__FundingTotals::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FundingTotals(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FundingTotals * SOAP_FMAC4 soap_in_ns2__FundingTotals(struct soap *soap, const char *tag, ns2__FundingTotals *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FundingTotals *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FundingTotals, sizeof(ns2__FundingTotals), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__FundingTotals)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__FundingTotals *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_currency1 = 1;
	size_t soap_flag_grandTotalAmount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_currency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:currency", (wchar_t**)&a->ns2__FundingTotals::currency, "xsd:string"))
				{	soap_flag_currency1--;
					continue;
				}
			if (soap_flag_grandTotalAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:grandTotalAmount", &a->ns2__FundingTotals::grandTotalAmount, "ns2:amount"))
				{	soap_flag_grandTotalAmount1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__FundingTotals *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FundingTotals, SOAP_TYPE_ns2__FundingTotals, sizeof(ns2__FundingTotals), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__FundingTotals * SOAP_FMAC2 soap_instantiate_ns2__FundingTotals(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FundingTotals(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__FundingTotals *p;
	size_t k = sizeof(ns2__FundingTotals);
	if (n < 0)
	{	p = SOAP_NEW(ns2__FundingTotals);
		if (p)
			((ns2__FundingTotals*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__FundingTotals, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__FundingTotals*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__FundingTotals location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__FundingTotals, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__FundingTotals::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:FundingTotals", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FundingTotals::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FundingTotals(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FundingTotals * SOAP_FMAC4 soap_get_ns2__FundingTotals(struct soap *soap, ns2__FundingTotals *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FundingTotals(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PurchaseTotals::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PurchaseTotals::currency = NULL;
	this->ns2__PurchaseTotals::discountAmount = NULL;
	this->ns2__PurchaseTotals::discountAmountSign = NULL;
	this->ns2__PurchaseTotals::discountManagementIndicator = NULL;
	this->ns2__PurchaseTotals::taxAmount = NULL;
	this->ns2__PurchaseTotals::dutyAmount = NULL;
	this->ns2__PurchaseTotals::dutyAmountSign = NULL;
	this->ns2__PurchaseTotals::grandTotalAmount = NULL;
	this->ns2__PurchaseTotals::freightAmount = NULL;
	this->ns2__PurchaseTotals::freightAmountSign = NULL;
	this->ns2__PurchaseTotals::foreignAmount = NULL;
	this->ns2__PurchaseTotals::foreignCurrency = NULL;
	this->ns2__PurchaseTotals::originalAmount = NULL;
	this->ns2__PurchaseTotals::originalCurrency = NULL;
	this->ns2__PurchaseTotals::exchangeRate = NULL;
	this->ns2__PurchaseTotals::exchangeRateTimeStamp = NULL;
	this->ns2__PurchaseTotals::additionalAmountType0 = NULL;
	this->ns2__PurchaseTotals::additionalAmount0 = NULL;
	this->ns2__PurchaseTotals::additionalAmountType1 = NULL;
	this->ns2__PurchaseTotals::additionalAmount1 = NULL;
	this->ns2__PurchaseTotals::additionalAmountType2 = NULL;
	this->ns2__PurchaseTotals::additionalAmount2 = NULL;
	this->ns2__PurchaseTotals::additionalAmountType3 = NULL;
	this->ns2__PurchaseTotals::additionalAmount3 = NULL;
	this->ns2__PurchaseTotals::additionalAmountType4 = NULL;
	this->ns2__PurchaseTotals::additionalAmount4 = NULL;
	this->ns2__PurchaseTotals::serviceFeeAmount = NULL;
	/* transient soap skipped */
}

void ns2__PurchaseTotals::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PurchaseTotals::currency);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__PurchaseTotals::discountAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PurchaseTotals::discountAmountSign);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PurchaseTotals::discountManagementIndicator);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__PurchaseTotals::taxAmount);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__PurchaseTotals::dutyAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PurchaseTotals::dutyAmountSign);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__PurchaseTotals::grandTotalAmount);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__PurchaseTotals::freightAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PurchaseTotals::freightAmountSign);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__PurchaseTotals::foreignAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PurchaseTotals::foreignCurrency);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__PurchaseTotals::originalAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PurchaseTotals::originalCurrency);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__PurchaseTotals::exchangeRate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PurchaseTotals::exchangeRateTimeStamp);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PurchaseTotals::additionalAmountType0);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PurchaseTotals::additionalAmount0);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PurchaseTotals::additionalAmountType1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PurchaseTotals::additionalAmount1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PurchaseTotals::additionalAmountType2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PurchaseTotals::additionalAmount2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PurchaseTotals::additionalAmountType3);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PurchaseTotals::additionalAmount3);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PurchaseTotals::additionalAmountType4);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PurchaseTotals::additionalAmount4);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__PurchaseTotals::serviceFeeAmount);
#endif
}

int ns2__PurchaseTotals::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PurchaseTotals(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PurchaseTotals(struct soap *soap, const char *tag, int id, const ns2__PurchaseTotals *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PurchaseTotals), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:currency", -1, (wchar_t*const*)&a->ns2__PurchaseTotals::currency, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:discountAmount", -1, &a->ns2__PurchaseTotals::discountAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:discountAmountSign", -1, (wchar_t*const*)&a->ns2__PurchaseTotals::discountAmountSign, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:discountManagementIndicator", -1, (wchar_t*const*)&a->ns2__PurchaseTotals::discountManagementIndicator, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:taxAmount", -1, &a->ns2__PurchaseTotals::taxAmount, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:dutyAmount", -1, &a->ns2__PurchaseTotals::dutyAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:dutyAmountSign", -1, (wchar_t*const*)&a->ns2__PurchaseTotals::dutyAmountSign, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:grandTotalAmount", -1, &a->ns2__PurchaseTotals::grandTotalAmount, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:freightAmount", -1, &a->ns2__PurchaseTotals::freightAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:freightAmountSign", -1, (wchar_t*const*)&a->ns2__PurchaseTotals::freightAmountSign, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:foreignAmount", -1, &a->ns2__PurchaseTotals::foreignAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:foreignCurrency", -1, (wchar_t*const*)&a->ns2__PurchaseTotals::foreignCurrency, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:originalAmount", -1, &a->ns2__PurchaseTotals::originalAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:originalCurrency", -1, (wchar_t*const*)&a->ns2__PurchaseTotals::originalCurrency, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:exchangeRate", -1, &a->ns2__PurchaseTotals::exchangeRate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:exchangeRateTimeStamp", -1, (wchar_t*const*)&a->ns2__PurchaseTotals::exchangeRateTimeStamp, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:additionalAmountType0", -1, (wchar_t*const*)&a->ns2__PurchaseTotals::additionalAmountType0, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:additionalAmount0", -1, (wchar_t*const*)&a->ns2__PurchaseTotals::additionalAmount0, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:additionalAmountType1", -1, (wchar_t*const*)&a->ns2__PurchaseTotals::additionalAmountType1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:additionalAmount1", -1, (wchar_t*const*)&a->ns2__PurchaseTotals::additionalAmount1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:additionalAmountType2", -1, (wchar_t*const*)&a->ns2__PurchaseTotals::additionalAmountType2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:additionalAmount2", -1, (wchar_t*const*)&a->ns2__PurchaseTotals::additionalAmount2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:additionalAmountType3", -1, (wchar_t*const*)&a->ns2__PurchaseTotals::additionalAmountType3, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:additionalAmount3", -1, (wchar_t*const*)&a->ns2__PurchaseTotals::additionalAmount3, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:additionalAmountType4", -1, (wchar_t*const*)&a->ns2__PurchaseTotals::additionalAmountType4, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:additionalAmount4", -1, (wchar_t*const*)&a->ns2__PurchaseTotals::additionalAmount4, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:serviceFeeAmount", -1, &a->ns2__PurchaseTotals::serviceFeeAmount, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PurchaseTotals::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PurchaseTotals(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PurchaseTotals * SOAP_FMAC4 soap_in_ns2__PurchaseTotals(struct soap *soap, const char *tag, ns2__PurchaseTotals *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PurchaseTotals *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PurchaseTotals, sizeof(ns2__PurchaseTotals), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PurchaseTotals)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PurchaseTotals *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_currency1 = 1;
	size_t soap_flag_discountAmount1 = 1;
	size_t soap_flag_discountAmountSign1 = 1;
	size_t soap_flag_discountManagementIndicator1 = 1;
	size_t soap_flag_taxAmount1 = 1;
	size_t soap_flag_dutyAmount1 = 1;
	size_t soap_flag_dutyAmountSign1 = 1;
	size_t soap_flag_grandTotalAmount1 = 1;
	size_t soap_flag_freightAmount1 = 1;
	size_t soap_flag_freightAmountSign1 = 1;
	size_t soap_flag_foreignAmount1 = 1;
	size_t soap_flag_foreignCurrency1 = 1;
	size_t soap_flag_originalAmount1 = 1;
	size_t soap_flag_originalCurrency1 = 1;
	size_t soap_flag_exchangeRate1 = 1;
	size_t soap_flag_exchangeRateTimeStamp1 = 1;
	size_t soap_flag_additionalAmountType01 = 1;
	size_t soap_flag_additionalAmount01 = 1;
	size_t soap_flag_additionalAmountType11 = 1;
	size_t soap_flag_additionalAmount11 = 1;
	size_t soap_flag_additionalAmountType21 = 1;
	size_t soap_flag_additionalAmount21 = 1;
	size_t soap_flag_additionalAmountType31 = 1;
	size_t soap_flag_additionalAmount31 = 1;
	size_t soap_flag_additionalAmountType41 = 1;
	size_t soap_flag_additionalAmount41 = 1;
	size_t soap_flag_serviceFeeAmount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_currency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:currency", (wchar_t**)&a->ns2__PurchaseTotals::currency, "xsd:string"))
				{	soap_flag_currency1--;
					continue;
				}
			if (soap_flag_discountAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:discountAmount", &a->ns2__PurchaseTotals::discountAmount, "ns2:amount"))
				{	soap_flag_discountAmount1--;
					continue;
				}
			if (soap_flag_discountAmountSign1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:discountAmountSign", (wchar_t**)&a->ns2__PurchaseTotals::discountAmountSign, "xsd:string"))
				{	soap_flag_discountAmountSign1--;
					continue;
				}
			if (soap_flag_discountManagementIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:discountManagementIndicator", (wchar_t**)&a->ns2__PurchaseTotals::discountManagementIndicator, "xsd:string"))
				{	soap_flag_discountManagementIndicator1--;
					continue;
				}
			if (soap_flag_taxAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:taxAmount", &a->ns2__PurchaseTotals::taxAmount, "ns2:amount"))
				{	soap_flag_taxAmount1--;
					continue;
				}
			if (soap_flag_dutyAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:dutyAmount", &a->ns2__PurchaseTotals::dutyAmount, "ns2:amount"))
				{	soap_flag_dutyAmount1--;
					continue;
				}
			if (soap_flag_dutyAmountSign1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:dutyAmountSign", (wchar_t**)&a->ns2__PurchaseTotals::dutyAmountSign, "xsd:string"))
				{	soap_flag_dutyAmountSign1--;
					continue;
				}
			if (soap_flag_grandTotalAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:grandTotalAmount", &a->ns2__PurchaseTotals::grandTotalAmount, "ns2:amount"))
				{	soap_flag_grandTotalAmount1--;
					continue;
				}
			if (soap_flag_freightAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:freightAmount", &a->ns2__PurchaseTotals::freightAmount, "ns2:amount"))
				{	soap_flag_freightAmount1--;
					continue;
				}
			if (soap_flag_freightAmountSign1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:freightAmountSign", (wchar_t**)&a->ns2__PurchaseTotals::freightAmountSign, "xsd:string"))
				{	soap_flag_freightAmountSign1--;
					continue;
				}
			if (soap_flag_foreignAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:foreignAmount", &a->ns2__PurchaseTotals::foreignAmount, "ns2:amount"))
				{	soap_flag_foreignAmount1--;
					continue;
				}
			if (soap_flag_foreignCurrency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:foreignCurrency", (wchar_t**)&a->ns2__PurchaseTotals::foreignCurrency, "xsd:string"))
				{	soap_flag_foreignCurrency1--;
					continue;
				}
			if (soap_flag_originalAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:originalAmount", &a->ns2__PurchaseTotals::originalAmount, "ns2:amount"))
				{	soap_flag_originalAmount1--;
					continue;
				}
			if (soap_flag_originalCurrency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:originalCurrency", (wchar_t**)&a->ns2__PurchaseTotals::originalCurrency, "xsd:string"))
				{	soap_flag_originalCurrency1--;
					continue;
				}
			if (soap_flag_exchangeRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:exchangeRate", &a->ns2__PurchaseTotals::exchangeRate, "ns2:amount"))
				{	soap_flag_exchangeRate1--;
					continue;
				}
			if (soap_flag_exchangeRateTimeStamp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:exchangeRateTimeStamp", (wchar_t**)&a->ns2__PurchaseTotals::exchangeRateTimeStamp, "xsd:string"))
				{	soap_flag_exchangeRateTimeStamp1--;
					continue;
				}
			if (soap_flag_additionalAmountType01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:additionalAmountType0", (wchar_t**)&a->ns2__PurchaseTotals::additionalAmountType0, "xsd:string"))
				{	soap_flag_additionalAmountType01--;
					continue;
				}
			if (soap_flag_additionalAmount01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:additionalAmount0", (wchar_t**)&a->ns2__PurchaseTotals::additionalAmount0, "xsd:string"))
				{	soap_flag_additionalAmount01--;
					continue;
				}
			if (soap_flag_additionalAmountType11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:additionalAmountType1", (wchar_t**)&a->ns2__PurchaseTotals::additionalAmountType1, "xsd:string"))
				{	soap_flag_additionalAmountType11--;
					continue;
				}
			if (soap_flag_additionalAmount11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:additionalAmount1", (wchar_t**)&a->ns2__PurchaseTotals::additionalAmount1, "xsd:string"))
				{	soap_flag_additionalAmount11--;
					continue;
				}
			if (soap_flag_additionalAmountType21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:additionalAmountType2", (wchar_t**)&a->ns2__PurchaseTotals::additionalAmountType2, "xsd:string"))
				{	soap_flag_additionalAmountType21--;
					continue;
				}
			if (soap_flag_additionalAmount21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:additionalAmount2", (wchar_t**)&a->ns2__PurchaseTotals::additionalAmount2, "xsd:string"))
				{	soap_flag_additionalAmount21--;
					continue;
				}
			if (soap_flag_additionalAmountType31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:additionalAmountType3", (wchar_t**)&a->ns2__PurchaseTotals::additionalAmountType3, "xsd:string"))
				{	soap_flag_additionalAmountType31--;
					continue;
				}
			if (soap_flag_additionalAmount31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:additionalAmount3", (wchar_t**)&a->ns2__PurchaseTotals::additionalAmount3, "xsd:string"))
				{	soap_flag_additionalAmount31--;
					continue;
				}
			if (soap_flag_additionalAmountType41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:additionalAmountType4", (wchar_t**)&a->ns2__PurchaseTotals::additionalAmountType4, "xsd:string"))
				{	soap_flag_additionalAmountType41--;
					continue;
				}
			if (soap_flag_additionalAmount41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:additionalAmount4", (wchar_t**)&a->ns2__PurchaseTotals::additionalAmount4, "xsd:string"))
				{	soap_flag_additionalAmount41--;
					continue;
				}
			if (soap_flag_serviceFeeAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:serviceFeeAmount", &a->ns2__PurchaseTotals::serviceFeeAmount, "ns2:amount"))
				{	soap_flag_serviceFeeAmount1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PurchaseTotals *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PurchaseTotals, SOAP_TYPE_ns2__PurchaseTotals, sizeof(ns2__PurchaseTotals), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PurchaseTotals * SOAP_FMAC2 soap_instantiate_ns2__PurchaseTotals(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PurchaseTotals(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PurchaseTotals *p;
	size_t k = sizeof(ns2__PurchaseTotals);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PurchaseTotals);
		if (p)
			((ns2__PurchaseTotals*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PurchaseTotals, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PurchaseTotals*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PurchaseTotals location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PurchaseTotals, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PurchaseTotals::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PurchaseTotals", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PurchaseTotals::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PurchaseTotals(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PurchaseTotals * SOAP_FMAC4 soap_get_ns2__PurchaseTotals(struct soap *soap, ns2__PurchaseTotals *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PurchaseTotals(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Wallet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Wallet::type = NULL;
	/* transient soap skipped */
}

void ns2__Wallet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Wallet::type);
#endif
}

int ns2__Wallet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Wallet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Wallet(struct soap *soap, const char *tag, int id, const ns2__Wallet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Wallet), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:type", -1, (wchar_t*const*)&a->ns2__Wallet::type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Wallet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Wallet(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Wallet * SOAP_FMAC4 soap_in_ns2__Wallet(struct soap *soap, const char *tag, ns2__Wallet *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Wallet *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Wallet, sizeof(ns2__Wallet), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Wallet)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Wallet *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:type", (wchar_t**)&a->ns2__Wallet::type, "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Wallet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Wallet, SOAP_TYPE_ns2__Wallet, sizeof(ns2__Wallet), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Wallet * SOAP_FMAC2 soap_instantiate_ns2__Wallet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Wallet(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Wallet *p;
	size_t k = sizeof(ns2__Wallet);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Wallet);
		if (p)
			((ns2__Wallet*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Wallet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Wallet*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Wallet location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Wallet, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Wallet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:Wallet", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Wallet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Wallet(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Wallet * SOAP_FMAC4 soap_get_ns2__Wallet(struct soap *soap, ns2__Wallet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Wallet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Aft::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Aft::indicator = NULL;
	this->ns2__Aft::serviceFee = NULL;
	this->ns2__Aft::foreignExchangeFee = NULL;
	/* transient soap skipped */
}

void ns2__Aft::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Aft::indicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Aft::serviceFee);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Aft::foreignExchangeFee);
#endif
}

int ns2__Aft::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Aft(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Aft(struct soap *soap, const char *tag, int id, const ns2__Aft *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Aft), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:indicator", -1, (wchar_t*const*)&a->ns2__Aft::indicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:serviceFee", -1, (wchar_t*const*)&a->ns2__Aft::serviceFee, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:foreignExchangeFee", -1, (wchar_t*const*)&a->ns2__Aft::foreignExchangeFee, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Aft::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Aft(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Aft * SOAP_FMAC4 soap_in_ns2__Aft(struct soap *soap, const char *tag, ns2__Aft *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Aft *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Aft, sizeof(ns2__Aft), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Aft)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Aft *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_indicator1 = 1;
	size_t soap_flag_serviceFee1 = 1;
	size_t soap_flag_foreignExchangeFee1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_indicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:indicator", (wchar_t**)&a->ns2__Aft::indicator, "xsd:string"))
				{	soap_flag_indicator1--;
					continue;
				}
			if (soap_flag_serviceFee1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:serviceFee", (wchar_t**)&a->ns2__Aft::serviceFee, "xsd:string"))
				{	soap_flag_serviceFee1--;
					continue;
				}
			if (soap_flag_foreignExchangeFee1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:foreignExchangeFee", (wchar_t**)&a->ns2__Aft::foreignExchangeFee, "xsd:string"))
				{	soap_flag_foreignExchangeFee1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Aft *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Aft, SOAP_TYPE_ns2__Aft, sizeof(ns2__Aft), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Aft * SOAP_FMAC2 soap_instantiate_ns2__Aft(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Aft(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Aft *p;
	size_t k = sizeof(ns2__Aft);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Aft);
		if (p)
			((ns2__Aft*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Aft, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Aft*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Aft location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Aft, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Aft::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:Aft", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Aft::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Aft(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Aft * SOAP_FMAC4 soap_get_ns2__Aft(struct soap *soap, ns2__Aft *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Aft(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__OtherTax::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__OtherTax::vatTaxAmount = NULL;
	this->ns2__OtherTax::vatTaxRate = NULL;
	this->ns2__OtherTax::vatTaxAmountSign = NULL;
	this->ns2__OtherTax::alternateTaxAmount = NULL;
	this->ns2__OtherTax::alternateTaxIndicator = NULL;
	this->ns2__OtherTax::alternateTaxID = NULL;
	this->ns2__OtherTax::localTaxAmount = NULL;
	this->ns2__OtherTax::localTaxIndicator = NULL;
	this->ns2__OtherTax::nationalTaxAmount = NULL;
	this->ns2__OtherTax::nationalTaxIndicator = NULL;
	/* transient soap skipped */
}

void ns2__OtherTax::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__amount(soap, &this->ns2__OtherTax::vatTaxAmount);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__OtherTax::vatTaxRate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__OtherTax::vatTaxAmountSign);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__OtherTax::alternateTaxAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__OtherTax::alternateTaxIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__OtherTax::alternateTaxID);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__OtherTax::localTaxAmount);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__OtherTax::localTaxIndicator);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__OtherTax::nationalTaxAmount);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__OtherTax::nationalTaxIndicator);
#endif
}

int ns2__OtherTax::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__OtherTax(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OtherTax(struct soap *soap, const char *tag, int id, const ns2__OtherTax *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OtherTax), type))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:vatTaxAmount", -1, &a->ns2__OtherTax::vatTaxAmount, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:vatTaxRate", -1, &a->ns2__OtherTax::vatTaxRate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:vatTaxAmountSign", -1, (wchar_t*const*)&a->ns2__OtherTax::vatTaxAmountSign, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:alternateTaxAmount", -1, &a->ns2__OtherTax::alternateTaxAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:alternateTaxIndicator", -1, (wchar_t*const*)&a->ns2__OtherTax::alternateTaxIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:alternateTaxID", -1, (wchar_t*const*)&a->ns2__OtherTax::alternateTaxID, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:localTaxAmount", -1, &a->ns2__OtherTax::localTaxAmount, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:localTaxIndicator", -1, &a->ns2__OtherTax::localTaxIndicator, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:nationalTaxAmount", -1, &a->ns2__OtherTax::nationalTaxAmount, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:nationalTaxIndicator", -1, &a->ns2__OtherTax::nationalTaxIndicator, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__OtherTax::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__OtherTax(soap, tag, this, type);
}

SOAP_FMAC3 ns2__OtherTax * SOAP_FMAC4 soap_in_ns2__OtherTax(struct soap *soap, const char *tag, ns2__OtherTax *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__OtherTax *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OtherTax, sizeof(ns2__OtherTax), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__OtherTax)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__OtherTax *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_vatTaxAmount1 = 1;
	size_t soap_flag_vatTaxRate1 = 1;
	size_t soap_flag_vatTaxAmountSign1 = 1;
	size_t soap_flag_alternateTaxAmount1 = 1;
	size_t soap_flag_alternateTaxIndicator1 = 1;
	size_t soap_flag_alternateTaxID1 = 1;
	size_t soap_flag_localTaxAmount1 = 1;
	size_t soap_flag_localTaxIndicator1 = 1;
	size_t soap_flag_nationalTaxAmount1 = 1;
	size_t soap_flag_nationalTaxIndicator1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_vatTaxAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:vatTaxAmount", &a->ns2__OtherTax::vatTaxAmount, "ns2:amount"))
				{	soap_flag_vatTaxAmount1--;
					continue;
				}
			if (soap_flag_vatTaxRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:vatTaxRate", &a->ns2__OtherTax::vatTaxRate, "ns2:amount"))
				{	soap_flag_vatTaxRate1--;
					continue;
				}
			if (soap_flag_vatTaxAmountSign1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:vatTaxAmountSign", (wchar_t**)&a->ns2__OtherTax::vatTaxAmountSign, "xsd:string"))
				{	soap_flag_vatTaxAmountSign1--;
					continue;
				}
			if (soap_flag_alternateTaxAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:alternateTaxAmount", &a->ns2__OtherTax::alternateTaxAmount, "ns2:amount"))
				{	soap_flag_alternateTaxAmount1--;
					continue;
				}
			if (soap_flag_alternateTaxIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:alternateTaxIndicator", (wchar_t**)&a->ns2__OtherTax::alternateTaxIndicator, "xsd:string"))
				{	soap_flag_alternateTaxIndicator1--;
					continue;
				}
			if (soap_flag_alternateTaxID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:alternateTaxID", (wchar_t**)&a->ns2__OtherTax::alternateTaxID, "xsd:string"))
				{	soap_flag_alternateTaxID1--;
					continue;
				}
			if (soap_flag_localTaxAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:localTaxAmount", &a->ns2__OtherTax::localTaxAmount, "ns2:amount"))
				{	soap_flag_localTaxAmount1--;
					continue;
				}
			if (soap_flag_localTaxIndicator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:localTaxIndicator", &a->ns2__OtherTax::localTaxIndicator, "xsd:integer"))
				{	soap_flag_localTaxIndicator1--;
					continue;
				}
			if (soap_flag_nationalTaxAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:nationalTaxAmount", &a->ns2__OtherTax::nationalTaxAmount, "ns2:amount"))
				{	soap_flag_nationalTaxAmount1--;
					continue;
				}
			if (soap_flag_nationalTaxIndicator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:nationalTaxIndicator", &a->ns2__OtherTax::nationalTaxIndicator, "xsd:integer"))
				{	soap_flag_nationalTaxIndicator1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__OtherTax *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OtherTax, SOAP_TYPE_ns2__OtherTax, sizeof(ns2__OtherTax), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__OtherTax * SOAP_FMAC2 soap_instantiate_ns2__OtherTax(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__OtherTax(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__OtherTax *p;
	size_t k = sizeof(ns2__OtherTax);
	if (n < 0)
	{	p = SOAP_NEW(ns2__OtherTax);
		if (p)
			((ns2__OtherTax*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__OtherTax, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__OtherTax*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__OtherTax location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__OtherTax, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__OtherTax::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:OtherTax", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__OtherTax::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__OtherTax(soap, this, tag, type);
}

SOAP_FMAC3 ns2__OtherTax * SOAP_FMAC4 soap_get_ns2__OtherTax(struct soap *soap, ns2__OtherTax *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OtherTax(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__BML::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__BML::customerBillingAddressChange = NULL;
	this->ns2__BML::customerEmailChange = NULL;
	this->ns2__BML::customerHasCheckingAccount = NULL;
	this->ns2__BML::customerHasSavingsAccount = NULL;
	this->ns2__BML::customerPasswordChange = NULL;
	this->ns2__BML::customerPhoneChange = NULL;
	this->ns2__BML::customerRegistrationDate = NULL;
	this->ns2__BML::customerTypeFlag = NULL;
	this->ns2__BML::grossHouseholdIncome = NULL;
	this->ns2__BML::householdIncomeCurrency = NULL;
	this->ns2__BML::itemCategory = NULL;
	this->ns2__BML::merchantPromotionCode = NULL;
	this->ns2__BML::preapprovalNumber = NULL;
	this->ns2__BML::productDeliveryTypeIndicator = NULL;
	this->ns2__BML::residenceStatus = NULL;
	this->ns2__BML::tcVersion = NULL;
	this->ns2__BML::yearsAtCurrentResidence = NULL;
	this->ns2__BML::yearsWithCurrentEmployer = NULL;
	this->ns2__BML::employerStreet1 = NULL;
	this->ns2__BML::employerStreet2 = NULL;
	this->ns2__BML::employerCity = NULL;
	this->ns2__BML::employerCompanyName = NULL;
	this->ns2__BML::employerCountry = NULL;
	this->ns2__BML::employerPhoneNumber = NULL;
	this->ns2__BML::employerPhoneType = NULL;
	this->ns2__BML::employerState = NULL;
	this->ns2__BML::employerPostalCode = NULL;
	this->ns2__BML::shipToPhoneType = NULL;
	this->ns2__BML::billToPhoneType = NULL;
	this->ns2__BML::methodOfPayment = NULL;
	this->ns2__BML::productType = NULL;
	this->ns2__BML::customerAuthenticatedByMerchant = NULL;
	this->ns2__BML::backOfficeIndicator = NULL;
	this->ns2__BML::shipToEqualsBillToNameIndicator = NULL;
	this->ns2__BML::shipToEqualsBillToAddressIndicator = NULL;
	this->ns2__BML::alternateIPAddress = NULL;
	this->ns2__BML::businessLegalName = NULL;
	this->ns2__BML::dbaName = NULL;
	this->ns2__BML::businessAddress1 = NULL;
	this->ns2__BML::businessAddress2 = NULL;
	this->ns2__BML::businessCity = NULL;
	this->ns2__BML::businessState = NULL;
	this->ns2__BML::businessPostalCode = NULL;
	this->ns2__BML::businessCountry = NULL;
	this->ns2__BML::businessMainPhone = NULL;
	this->ns2__BML::userID = NULL;
	this->ns2__BML::pin = NULL;
	this->ns2__BML::adminLastName = NULL;
	this->ns2__BML::adminFirstName = NULL;
	this->ns2__BML::adminPhone = NULL;
	this->ns2__BML::adminFax = NULL;
	this->ns2__BML::adminEmailAddress = NULL;
	this->ns2__BML::adminTitle = NULL;
	this->ns2__BML::supervisorLastName = NULL;
	this->ns2__BML::supervisorFirstName = NULL;
	this->ns2__BML::supervisorEmailAddress = NULL;
	this->ns2__BML::businessDAndBNumber = NULL;
	this->ns2__BML::businessTaxID = NULL;
	this->ns2__BML::businessNAICSCode = NULL;
	this->ns2__BML::businessType = NULL;
	this->ns2__BML::businessYearsInBusiness = NULL;
	this->ns2__BML::businessNumberOfEmployees = NULL;
	this->ns2__BML::businessPONumber = NULL;
	this->ns2__BML::businessLoanType = NULL;
	this->ns2__BML::businessApplicationID = NULL;
	this->ns2__BML::businessProductCode = NULL;
	this->ns2__BML::pgLastName = NULL;
	this->ns2__BML::pgFirstName = NULL;
	this->ns2__BML::pgSSN = NULL;
	this->ns2__BML::pgDateOfBirth = NULL;
	this->ns2__BML::pgAnnualIncome = NULL;
	this->ns2__BML::pgIncomeCurrencyType = NULL;
	this->ns2__BML::pgResidenceStatus = NULL;
	this->ns2__BML::pgCheckingAccountIndicator = NULL;
	this->ns2__BML::pgSavingsAccountIndicator = NULL;
	this->ns2__BML::pgYearsAtEmployer = NULL;
	this->ns2__BML::pgYearsAtResidence = NULL;
	this->ns2__BML::pgHomeAddress1 = NULL;
	this->ns2__BML::pgHomeAddress2 = NULL;
	this->ns2__BML::pgHomeCity = NULL;
	this->ns2__BML::pgHomeState = NULL;
	this->ns2__BML::pgHomePostalCode = NULL;
	this->ns2__BML::pgHomeCountry = NULL;
	this->ns2__BML::pgEmailAddress = NULL;
	this->ns2__BML::pgHomePhone = NULL;
	this->ns2__BML::pgTitle = NULL;
	/* transient soap skipped */
}

void ns2__BML::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__BML::customerBillingAddressChange);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__BML::customerEmailChange);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__BML::customerHasCheckingAccount);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__BML::customerHasSavingsAccount);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__BML::customerPasswordChange);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__BML::customerPhoneChange);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::customerRegistrationDate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::customerTypeFlag);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__BML::grossHouseholdIncome);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::householdIncomeCurrency);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::itemCategory);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::merchantPromotionCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::preapprovalNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::productDeliveryTypeIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::residenceStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::tcVersion);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__BML::yearsAtCurrentResidence);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__BML::yearsWithCurrentEmployer);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::employerStreet1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::employerStreet2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::employerCity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::employerCompanyName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::employerCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::employerPhoneNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::employerPhoneType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::employerState);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::employerPostalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::shipToPhoneType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::billToPhoneType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::methodOfPayment);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::productType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::customerAuthenticatedByMerchant);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::backOfficeIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::shipToEqualsBillToNameIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::shipToEqualsBillToAddressIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::alternateIPAddress);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::businessLegalName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::dbaName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::businessAddress1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::businessAddress2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::businessCity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::businessState);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::businessPostalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::businessCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::businessMainPhone);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::userID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::pin);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::adminLastName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::adminFirstName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::adminPhone);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::adminFax);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::adminEmailAddress);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::adminTitle);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::supervisorLastName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::supervisorFirstName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::supervisorEmailAddress);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::businessDAndBNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::businessTaxID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::businessNAICSCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::businessType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::businessYearsInBusiness);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::businessNumberOfEmployees);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::businessPONumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::businessLoanType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::businessApplicationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::businessProductCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::pgLastName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::pgFirstName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::pgSSN);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::pgDateOfBirth);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::pgAnnualIncome);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::pgIncomeCurrencyType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::pgResidenceStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::pgCheckingAccountIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::pgSavingsAccountIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::pgYearsAtEmployer);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::pgYearsAtResidence);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::pgHomeAddress1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::pgHomeAddress2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::pgHomeCity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::pgHomeState);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::pgHomePostalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::pgHomeCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::pgEmailAddress);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::pgHomePhone);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BML::pgTitle);
#endif
}

int ns2__BML::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__BML(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BML(struct soap *soap, const char *tag, int id, const ns2__BML *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BML), type))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:customerBillingAddressChange", -1, &a->ns2__BML::customerBillingAddressChange, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:customerEmailChange", -1, &a->ns2__BML::customerEmailChange, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:customerHasCheckingAccount", -1, &a->ns2__BML::customerHasCheckingAccount, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:customerHasSavingsAccount", -1, &a->ns2__BML::customerHasSavingsAccount, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:customerPasswordChange", -1, &a->ns2__BML::customerPasswordChange, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:customerPhoneChange", -1, &a->ns2__BML::customerPhoneChange, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:customerRegistrationDate", -1, (wchar_t*const*)&a->ns2__BML::customerRegistrationDate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:customerTypeFlag", -1, (wchar_t*const*)&a->ns2__BML::customerTypeFlag, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:grossHouseholdIncome", -1, &a->ns2__BML::grossHouseholdIncome, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:householdIncomeCurrency", -1, (wchar_t*const*)&a->ns2__BML::householdIncomeCurrency, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:itemCategory", -1, (wchar_t*const*)&a->ns2__BML::itemCategory, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantPromotionCode", -1, (wchar_t*const*)&a->ns2__BML::merchantPromotionCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:preapprovalNumber", -1, (wchar_t*const*)&a->ns2__BML::preapprovalNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:productDeliveryTypeIndicator", -1, (wchar_t*const*)&a->ns2__BML::productDeliveryTypeIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:residenceStatus", -1, (wchar_t*const*)&a->ns2__BML::residenceStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:tcVersion", -1, (wchar_t*const*)&a->ns2__BML::tcVersion, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:yearsAtCurrentResidence", -1, &a->ns2__BML::yearsAtCurrentResidence, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:yearsWithCurrentEmployer", -1, &a->ns2__BML::yearsWithCurrentEmployer, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:employerStreet1", -1, (wchar_t*const*)&a->ns2__BML::employerStreet1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:employerStreet2", -1, (wchar_t*const*)&a->ns2__BML::employerStreet2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:employerCity", -1, (wchar_t*const*)&a->ns2__BML::employerCity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:employerCompanyName", -1, (wchar_t*const*)&a->ns2__BML::employerCompanyName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:employerCountry", -1, (wchar_t*const*)&a->ns2__BML::employerCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:employerPhoneNumber", -1, (wchar_t*const*)&a->ns2__BML::employerPhoneNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:employerPhoneType", -1, (wchar_t*const*)&a->ns2__BML::employerPhoneType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:employerState", -1, (wchar_t*const*)&a->ns2__BML::employerState, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:employerPostalCode", -1, (wchar_t*const*)&a->ns2__BML::employerPostalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToPhoneType", -1, (wchar_t*const*)&a->ns2__BML::shipToPhoneType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:billToPhoneType", -1, (wchar_t*const*)&a->ns2__BML::billToPhoneType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:methodOfPayment", -1, (wchar_t*const*)&a->ns2__BML::methodOfPayment, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:productType", -1, (wchar_t*const*)&a->ns2__BML::productType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:customerAuthenticatedByMerchant", -1, (wchar_t*const*)&a->ns2__BML::customerAuthenticatedByMerchant, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:backOfficeIndicator", -1, (wchar_t*const*)&a->ns2__BML::backOfficeIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToEqualsBillToNameIndicator", -1, (wchar_t*const*)&a->ns2__BML::shipToEqualsBillToNameIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipToEqualsBillToAddressIndicator", -1, (wchar_t*const*)&a->ns2__BML::shipToEqualsBillToAddressIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:alternateIPAddress", -1, (wchar_t*const*)&a->ns2__BML::alternateIPAddress, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:businessLegalName", -1, (wchar_t*const*)&a->ns2__BML::businessLegalName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:dbaName", -1, (wchar_t*const*)&a->ns2__BML::dbaName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:businessAddress1", -1, (wchar_t*const*)&a->ns2__BML::businessAddress1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:businessAddress2", -1, (wchar_t*const*)&a->ns2__BML::businessAddress2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:businessCity", -1, (wchar_t*const*)&a->ns2__BML::businessCity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:businessState", -1, (wchar_t*const*)&a->ns2__BML::businessState, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:businessPostalCode", -1, (wchar_t*const*)&a->ns2__BML::businessPostalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:businessCountry", -1, (wchar_t*const*)&a->ns2__BML::businessCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:businessMainPhone", -1, (wchar_t*const*)&a->ns2__BML::businessMainPhone, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:userID", -1, (wchar_t*const*)&a->ns2__BML::userID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pin", -1, (wchar_t*const*)&a->ns2__BML::pin, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:adminLastName", -1, (wchar_t*const*)&a->ns2__BML::adminLastName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:adminFirstName", -1, (wchar_t*const*)&a->ns2__BML::adminFirstName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:adminPhone", -1, (wchar_t*const*)&a->ns2__BML::adminPhone, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:adminFax", -1, (wchar_t*const*)&a->ns2__BML::adminFax, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:adminEmailAddress", -1, (wchar_t*const*)&a->ns2__BML::adminEmailAddress, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:adminTitle", -1, (wchar_t*const*)&a->ns2__BML::adminTitle, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:supervisorLastName", -1, (wchar_t*const*)&a->ns2__BML::supervisorLastName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:supervisorFirstName", -1, (wchar_t*const*)&a->ns2__BML::supervisorFirstName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:supervisorEmailAddress", -1, (wchar_t*const*)&a->ns2__BML::supervisorEmailAddress, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:businessDAndBNumber", -1, (wchar_t*const*)&a->ns2__BML::businessDAndBNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:businessTaxID", -1, (wchar_t*const*)&a->ns2__BML::businessTaxID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:businessNAICSCode", -1, (wchar_t*const*)&a->ns2__BML::businessNAICSCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:businessType", -1, (wchar_t*const*)&a->ns2__BML::businessType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:businessYearsInBusiness", -1, (wchar_t*const*)&a->ns2__BML::businessYearsInBusiness, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:businessNumberOfEmployees", -1, (wchar_t*const*)&a->ns2__BML::businessNumberOfEmployees, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:businessPONumber", -1, (wchar_t*const*)&a->ns2__BML::businessPONumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:businessLoanType", -1, (wchar_t*const*)&a->ns2__BML::businessLoanType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:businessApplicationID", -1, (wchar_t*const*)&a->ns2__BML::businessApplicationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:businessProductCode", -1, (wchar_t*const*)&a->ns2__BML::businessProductCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pgLastName", -1, (wchar_t*const*)&a->ns2__BML::pgLastName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pgFirstName", -1, (wchar_t*const*)&a->ns2__BML::pgFirstName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pgSSN", -1, (wchar_t*const*)&a->ns2__BML::pgSSN, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pgDateOfBirth", -1, (wchar_t*const*)&a->ns2__BML::pgDateOfBirth, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pgAnnualIncome", -1, (wchar_t*const*)&a->ns2__BML::pgAnnualIncome, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pgIncomeCurrencyType", -1, (wchar_t*const*)&a->ns2__BML::pgIncomeCurrencyType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pgResidenceStatus", -1, (wchar_t*const*)&a->ns2__BML::pgResidenceStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pgCheckingAccountIndicator", -1, (wchar_t*const*)&a->ns2__BML::pgCheckingAccountIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pgSavingsAccountIndicator", -1, (wchar_t*const*)&a->ns2__BML::pgSavingsAccountIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pgYearsAtEmployer", -1, (wchar_t*const*)&a->ns2__BML::pgYearsAtEmployer, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pgYearsAtResidence", -1, (wchar_t*const*)&a->ns2__BML::pgYearsAtResidence, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pgHomeAddress1", -1, (wchar_t*const*)&a->ns2__BML::pgHomeAddress1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pgHomeAddress2", -1, (wchar_t*const*)&a->ns2__BML::pgHomeAddress2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pgHomeCity", -1, (wchar_t*const*)&a->ns2__BML::pgHomeCity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pgHomeState", -1, (wchar_t*const*)&a->ns2__BML::pgHomeState, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pgHomePostalCode", -1, (wchar_t*const*)&a->ns2__BML::pgHomePostalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pgHomeCountry", -1, (wchar_t*const*)&a->ns2__BML::pgHomeCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pgEmailAddress", -1, (wchar_t*const*)&a->ns2__BML::pgEmailAddress, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pgHomePhone", -1, (wchar_t*const*)&a->ns2__BML::pgHomePhone, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pgTitle", -1, (wchar_t*const*)&a->ns2__BML::pgTitle, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__BML::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__BML(soap, tag, this, type);
}

SOAP_FMAC3 ns2__BML * SOAP_FMAC4 soap_in_ns2__BML(struct soap *soap, const char *tag, ns2__BML *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__BML *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BML, sizeof(ns2__BML), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__BML)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__BML *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_customerBillingAddressChange1 = 1;
	size_t soap_flag_customerEmailChange1 = 1;
	size_t soap_flag_customerHasCheckingAccount1 = 1;
	size_t soap_flag_customerHasSavingsAccount1 = 1;
	size_t soap_flag_customerPasswordChange1 = 1;
	size_t soap_flag_customerPhoneChange1 = 1;
	size_t soap_flag_customerRegistrationDate1 = 1;
	size_t soap_flag_customerTypeFlag1 = 1;
	size_t soap_flag_grossHouseholdIncome1 = 1;
	size_t soap_flag_householdIncomeCurrency1 = 1;
	size_t soap_flag_itemCategory1 = 1;
	size_t soap_flag_merchantPromotionCode1 = 1;
	size_t soap_flag_preapprovalNumber1 = 1;
	size_t soap_flag_productDeliveryTypeIndicator1 = 1;
	size_t soap_flag_residenceStatus1 = 1;
	size_t soap_flag_tcVersion1 = 1;
	size_t soap_flag_yearsAtCurrentResidence1 = 1;
	size_t soap_flag_yearsWithCurrentEmployer1 = 1;
	size_t soap_flag_employerStreet11 = 1;
	size_t soap_flag_employerStreet21 = 1;
	size_t soap_flag_employerCity1 = 1;
	size_t soap_flag_employerCompanyName1 = 1;
	size_t soap_flag_employerCountry1 = 1;
	size_t soap_flag_employerPhoneNumber1 = 1;
	size_t soap_flag_employerPhoneType1 = 1;
	size_t soap_flag_employerState1 = 1;
	size_t soap_flag_employerPostalCode1 = 1;
	size_t soap_flag_shipToPhoneType1 = 1;
	size_t soap_flag_billToPhoneType1 = 1;
	size_t soap_flag_methodOfPayment1 = 1;
	size_t soap_flag_productType1 = 1;
	size_t soap_flag_customerAuthenticatedByMerchant1 = 1;
	size_t soap_flag_backOfficeIndicator1 = 1;
	size_t soap_flag_shipToEqualsBillToNameIndicator1 = 1;
	size_t soap_flag_shipToEqualsBillToAddressIndicator1 = 1;
	size_t soap_flag_alternateIPAddress1 = 1;
	size_t soap_flag_businessLegalName1 = 1;
	size_t soap_flag_dbaName1 = 1;
	size_t soap_flag_businessAddress11 = 1;
	size_t soap_flag_businessAddress21 = 1;
	size_t soap_flag_businessCity1 = 1;
	size_t soap_flag_businessState1 = 1;
	size_t soap_flag_businessPostalCode1 = 1;
	size_t soap_flag_businessCountry1 = 1;
	size_t soap_flag_businessMainPhone1 = 1;
	size_t soap_flag_userID1 = 1;
	size_t soap_flag_pin1 = 1;
	size_t soap_flag_adminLastName1 = 1;
	size_t soap_flag_adminFirstName1 = 1;
	size_t soap_flag_adminPhone1 = 1;
	size_t soap_flag_adminFax1 = 1;
	size_t soap_flag_adminEmailAddress1 = 1;
	size_t soap_flag_adminTitle1 = 1;
	size_t soap_flag_supervisorLastName1 = 1;
	size_t soap_flag_supervisorFirstName1 = 1;
	size_t soap_flag_supervisorEmailAddress1 = 1;
	size_t soap_flag_businessDAndBNumber1 = 1;
	size_t soap_flag_businessTaxID1 = 1;
	size_t soap_flag_businessNAICSCode1 = 1;
	size_t soap_flag_businessType1 = 1;
	size_t soap_flag_businessYearsInBusiness1 = 1;
	size_t soap_flag_businessNumberOfEmployees1 = 1;
	size_t soap_flag_businessPONumber1 = 1;
	size_t soap_flag_businessLoanType1 = 1;
	size_t soap_flag_businessApplicationID1 = 1;
	size_t soap_flag_businessProductCode1 = 1;
	size_t soap_flag_pgLastName1 = 1;
	size_t soap_flag_pgFirstName1 = 1;
	size_t soap_flag_pgSSN1 = 1;
	size_t soap_flag_pgDateOfBirth1 = 1;
	size_t soap_flag_pgAnnualIncome1 = 1;
	size_t soap_flag_pgIncomeCurrencyType1 = 1;
	size_t soap_flag_pgResidenceStatus1 = 1;
	size_t soap_flag_pgCheckingAccountIndicator1 = 1;
	size_t soap_flag_pgSavingsAccountIndicator1 = 1;
	size_t soap_flag_pgYearsAtEmployer1 = 1;
	size_t soap_flag_pgYearsAtResidence1 = 1;
	size_t soap_flag_pgHomeAddress11 = 1;
	size_t soap_flag_pgHomeAddress21 = 1;
	size_t soap_flag_pgHomeCity1 = 1;
	size_t soap_flag_pgHomeState1 = 1;
	size_t soap_flag_pgHomePostalCode1 = 1;
	size_t soap_flag_pgHomeCountry1 = 1;
	size_t soap_flag_pgEmailAddress1 = 1;
	size_t soap_flag_pgHomePhone1 = 1;
	size_t soap_flag_pgTitle1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_customerBillingAddressChange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:customerBillingAddressChange", &a->ns2__BML::customerBillingAddressChange, "ns2:boolean"))
				{	soap_flag_customerBillingAddressChange1--;
					continue;
				}
			if (soap_flag_customerEmailChange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:customerEmailChange", &a->ns2__BML::customerEmailChange, "ns2:boolean"))
				{	soap_flag_customerEmailChange1--;
					continue;
				}
			if (soap_flag_customerHasCheckingAccount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:customerHasCheckingAccount", &a->ns2__BML::customerHasCheckingAccount, "ns2:boolean"))
				{	soap_flag_customerHasCheckingAccount1--;
					continue;
				}
			if (soap_flag_customerHasSavingsAccount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:customerHasSavingsAccount", &a->ns2__BML::customerHasSavingsAccount, "ns2:boolean"))
				{	soap_flag_customerHasSavingsAccount1--;
					continue;
				}
			if (soap_flag_customerPasswordChange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:customerPasswordChange", &a->ns2__BML::customerPasswordChange, "ns2:boolean"))
				{	soap_flag_customerPasswordChange1--;
					continue;
				}
			if (soap_flag_customerPhoneChange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:customerPhoneChange", &a->ns2__BML::customerPhoneChange, "ns2:boolean"))
				{	soap_flag_customerPhoneChange1--;
					continue;
				}
			if (soap_flag_customerRegistrationDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:customerRegistrationDate", (wchar_t**)&a->ns2__BML::customerRegistrationDate, "xsd:string"))
				{	soap_flag_customerRegistrationDate1--;
					continue;
				}
			if (soap_flag_customerTypeFlag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:customerTypeFlag", (wchar_t**)&a->ns2__BML::customerTypeFlag, "xsd:string"))
				{	soap_flag_customerTypeFlag1--;
					continue;
				}
			if (soap_flag_grossHouseholdIncome1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:grossHouseholdIncome", &a->ns2__BML::grossHouseholdIncome, "ns2:amount"))
				{	soap_flag_grossHouseholdIncome1--;
					continue;
				}
			if (soap_flag_householdIncomeCurrency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:householdIncomeCurrency", (wchar_t**)&a->ns2__BML::householdIncomeCurrency, "xsd:string"))
				{	soap_flag_householdIncomeCurrency1--;
					continue;
				}
			if (soap_flag_itemCategory1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:itemCategory", (wchar_t**)&a->ns2__BML::itemCategory, "xsd:string"))
				{	soap_flag_itemCategory1--;
					continue;
				}
			if (soap_flag_merchantPromotionCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantPromotionCode", (wchar_t**)&a->ns2__BML::merchantPromotionCode, "xsd:string"))
				{	soap_flag_merchantPromotionCode1--;
					continue;
				}
			if (soap_flag_preapprovalNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:preapprovalNumber", (wchar_t**)&a->ns2__BML::preapprovalNumber, "xsd:string"))
				{	soap_flag_preapprovalNumber1--;
					continue;
				}
			if (soap_flag_productDeliveryTypeIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:productDeliveryTypeIndicator", (wchar_t**)&a->ns2__BML::productDeliveryTypeIndicator, "xsd:string"))
				{	soap_flag_productDeliveryTypeIndicator1--;
					continue;
				}
			if (soap_flag_residenceStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:residenceStatus", (wchar_t**)&a->ns2__BML::residenceStatus, "xsd:string"))
				{	soap_flag_residenceStatus1--;
					continue;
				}
			if (soap_flag_tcVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:tcVersion", (wchar_t**)&a->ns2__BML::tcVersion, "xsd:string"))
				{	soap_flag_tcVersion1--;
					continue;
				}
			if (soap_flag_yearsAtCurrentResidence1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:yearsAtCurrentResidence", &a->ns2__BML::yearsAtCurrentResidence, "xsd:integer"))
				{	soap_flag_yearsAtCurrentResidence1--;
					continue;
				}
			if (soap_flag_yearsWithCurrentEmployer1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:yearsWithCurrentEmployer", &a->ns2__BML::yearsWithCurrentEmployer, "xsd:integer"))
				{	soap_flag_yearsWithCurrentEmployer1--;
					continue;
				}
			if (soap_flag_employerStreet11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:employerStreet1", (wchar_t**)&a->ns2__BML::employerStreet1, "xsd:string"))
				{	soap_flag_employerStreet11--;
					continue;
				}
			if (soap_flag_employerStreet21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:employerStreet2", (wchar_t**)&a->ns2__BML::employerStreet2, "xsd:string"))
				{	soap_flag_employerStreet21--;
					continue;
				}
			if (soap_flag_employerCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:employerCity", (wchar_t**)&a->ns2__BML::employerCity, "xsd:string"))
				{	soap_flag_employerCity1--;
					continue;
				}
			if (soap_flag_employerCompanyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:employerCompanyName", (wchar_t**)&a->ns2__BML::employerCompanyName, "xsd:string"))
				{	soap_flag_employerCompanyName1--;
					continue;
				}
			if (soap_flag_employerCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:employerCountry", (wchar_t**)&a->ns2__BML::employerCountry, "xsd:string"))
				{	soap_flag_employerCountry1--;
					continue;
				}
			if (soap_flag_employerPhoneNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:employerPhoneNumber", (wchar_t**)&a->ns2__BML::employerPhoneNumber, "xsd:string"))
				{	soap_flag_employerPhoneNumber1--;
					continue;
				}
			if (soap_flag_employerPhoneType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:employerPhoneType", (wchar_t**)&a->ns2__BML::employerPhoneType, "xsd:string"))
				{	soap_flag_employerPhoneType1--;
					continue;
				}
			if (soap_flag_employerState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:employerState", (wchar_t**)&a->ns2__BML::employerState, "xsd:string"))
				{	soap_flag_employerState1--;
					continue;
				}
			if (soap_flag_employerPostalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:employerPostalCode", (wchar_t**)&a->ns2__BML::employerPostalCode, "xsd:string"))
				{	soap_flag_employerPostalCode1--;
					continue;
				}
			if (soap_flag_shipToPhoneType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToPhoneType", (wchar_t**)&a->ns2__BML::shipToPhoneType, "xsd:string"))
				{	soap_flag_shipToPhoneType1--;
					continue;
				}
			if (soap_flag_billToPhoneType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:billToPhoneType", (wchar_t**)&a->ns2__BML::billToPhoneType, "xsd:string"))
				{	soap_flag_billToPhoneType1--;
					continue;
				}
			if (soap_flag_methodOfPayment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:methodOfPayment", (wchar_t**)&a->ns2__BML::methodOfPayment, "xsd:string"))
				{	soap_flag_methodOfPayment1--;
					continue;
				}
			if (soap_flag_productType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:productType", (wchar_t**)&a->ns2__BML::productType, "xsd:string"))
				{	soap_flag_productType1--;
					continue;
				}
			if (soap_flag_customerAuthenticatedByMerchant1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:customerAuthenticatedByMerchant", (wchar_t**)&a->ns2__BML::customerAuthenticatedByMerchant, "xsd:string"))
				{	soap_flag_customerAuthenticatedByMerchant1--;
					continue;
				}
			if (soap_flag_backOfficeIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:backOfficeIndicator", (wchar_t**)&a->ns2__BML::backOfficeIndicator, "xsd:string"))
				{	soap_flag_backOfficeIndicator1--;
					continue;
				}
			if (soap_flag_shipToEqualsBillToNameIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToEqualsBillToNameIndicator", (wchar_t**)&a->ns2__BML::shipToEqualsBillToNameIndicator, "xsd:string"))
				{	soap_flag_shipToEqualsBillToNameIndicator1--;
					continue;
				}
			if (soap_flag_shipToEqualsBillToAddressIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipToEqualsBillToAddressIndicator", (wchar_t**)&a->ns2__BML::shipToEqualsBillToAddressIndicator, "xsd:string"))
				{	soap_flag_shipToEqualsBillToAddressIndicator1--;
					continue;
				}
			if (soap_flag_alternateIPAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:alternateIPAddress", (wchar_t**)&a->ns2__BML::alternateIPAddress, "xsd:string"))
				{	soap_flag_alternateIPAddress1--;
					continue;
				}
			if (soap_flag_businessLegalName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:businessLegalName", (wchar_t**)&a->ns2__BML::businessLegalName, "xsd:string"))
				{	soap_flag_businessLegalName1--;
					continue;
				}
			if (soap_flag_dbaName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:dbaName", (wchar_t**)&a->ns2__BML::dbaName, "xsd:string"))
				{	soap_flag_dbaName1--;
					continue;
				}
			if (soap_flag_businessAddress11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:businessAddress1", (wchar_t**)&a->ns2__BML::businessAddress1, "xsd:string"))
				{	soap_flag_businessAddress11--;
					continue;
				}
			if (soap_flag_businessAddress21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:businessAddress2", (wchar_t**)&a->ns2__BML::businessAddress2, "xsd:string"))
				{	soap_flag_businessAddress21--;
					continue;
				}
			if (soap_flag_businessCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:businessCity", (wchar_t**)&a->ns2__BML::businessCity, "xsd:string"))
				{	soap_flag_businessCity1--;
					continue;
				}
			if (soap_flag_businessState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:businessState", (wchar_t**)&a->ns2__BML::businessState, "xsd:string"))
				{	soap_flag_businessState1--;
					continue;
				}
			if (soap_flag_businessPostalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:businessPostalCode", (wchar_t**)&a->ns2__BML::businessPostalCode, "xsd:string"))
				{	soap_flag_businessPostalCode1--;
					continue;
				}
			if (soap_flag_businessCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:businessCountry", (wchar_t**)&a->ns2__BML::businessCountry, "xsd:string"))
				{	soap_flag_businessCountry1--;
					continue;
				}
			if (soap_flag_businessMainPhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:businessMainPhone", (wchar_t**)&a->ns2__BML::businessMainPhone, "xsd:string"))
				{	soap_flag_businessMainPhone1--;
					continue;
				}
			if (soap_flag_userID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:userID", (wchar_t**)&a->ns2__BML::userID, "xsd:string"))
				{	soap_flag_userID1--;
					continue;
				}
			if (soap_flag_pin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pin", (wchar_t**)&a->ns2__BML::pin, "xsd:string"))
				{	soap_flag_pin1--;
					continue;
				}
			if (soap_flag_adminLastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:adminLastName", (wchar_t**)&a->ns2__BML::adminLastName, "xsd:string"))
				{	soap_flag_adminLastName1--;
					continue;
				}
			if (soap_flag_adminFirstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:adminFirstName", (wchar_t**)&a->ns2__BML::adminFirstName, "xsd:string"))
				{	soap_flag_adminFirstName1--;
					continue;
				}
			if (soap_flag_adminPhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:adminPhone", (wchar_t**)&a->ns2__BML::adminPhone, "xsd:string"))
				{	soap_flag_adminPhone1--;
					continue;
				}
			if (soap_flag_adminFax1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:adminFax", (wchar_t**)&a->ns2__BML::adminFax, "xsd:string"))
				{	soap_flag_adminFax1--;
					continue;
				}
			if (soap_flag_adminEmailAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:adminEmailAddress", (wchar_t**)&a->ns2__BML::adminEmailAddress, "xsd:string"))
				{	soap_flag_adminEmailAddress1--;
					continue;
				}
			if (soap_flag_adminTitle1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:adminTitle", (wchar_t**)&a->ns2__BML::adminTitle, "xsd:string"))
				{	soap_flag_adminTitle1--;
					continue;
				}
			if (soap_flag_supervisorLastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:supervisorLastName", (wchar_t**)&a->ns2__BML::supervisorLastName, "xsd:string"))
				{	soap_flag_supervisorLastName1--;
					continue;
				}
			if (soap_flag_supervisorFirstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:supervisorFirstName", (wchar_t**)&a->ns2__BML::supervisorFirstName, "xsd:string"))
				{	soap_flag_supervisorFirstName1--;
					continue;
				}
			if (soap_flag_supervisorEmailAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:supervisorEmailAddress", (wchar_t**)&a->ns2__BML::supervisorEmailAddress, "xsd:string"))
				{	soap_flag_supervisorEmailAddress1--;
					continue;
				}
			if (soap_flag_businessDAndBNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:businessDAndBNumber", (wchar_t**)&a->ns2__BML::businessDAndBNumber, "xsd:string"))
				{	soap_flag_businessDAndBNumber1--;
					continue;
				}
			if (soap_flag_businessTaxID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:businessTaxID", (wchar_t**)&a->ns2__BML::businessTaxID, "xsd:string"))
				{	soap_flag_businessTaxID1--;
					continue;
				}
			if (soap_flag_businessNAICSCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:businessNAICSCode", (wchar_t**)&a->ns2__BML::businessNAICSCode, "xsd:string"))
				{	soap_flag_businessNAICSCode1--;
					continue;
				}
			if (soap_flag_businessType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:businessType", (wchar_t**)&a->ns2__BML::businessType, "xsd:string"))
				{	soap_flag_businessType1--;
					continue;
				}
			if (soap_flag_businessYearsInBusiness1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:businessYearsInBusiness", (wchar_t**)&a->ns2__BML::businessYearsInBusiness, "xsd:string"))
				{	soap_flag_businessYearsInBusiness1--;
					continue;
				}
			if (soap_flag_businessNumberOfEmployees1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:businessNumberOfEmployees", (wchar_t**)&a->ns2__BML::businessNumberOfEmployees, "xsd:string"))
				{	soap_flag_businessNumberOfEmployees1--;
					continue;
				}
			if (soap_flag_businessPONumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:businessPONumber", (wchar_t**)&a->ns2__BML::businessPONumber, "xsd:string"))
				{	soap_flag_businessPONumber1--;
					continue;
				}
			if (soap_flag_businessLoanType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:businessLoanType", (wchar_t**)&a->ns2__BML::businessLoanType, "xsd:string"))
				{	soap_flag_businessLoanType1--;
					continue;
				}
			if (soap_flag_businessApplicationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:businessApplicationID", (wchar_t**)&a->ns2__BML::businessApplicationID, "xsd:string"))
				{	soap_flag_businessApplicationID1--;
					continue;
				}
			if (soap_flag_businessProductCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:businessProductCode", (wchar_t**)&a->ns2__BML::businessProductCode, "xsd:string"))
				{	soap_flag_businessProductCode1--;
					continue;
				}
			if (soap_flag_pgLastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pgLastName", (wchar_t**)&a->ns2__BML::pgLastName, "xsd:string"))
				{	soap_flag_pgLastName1--;
					continue;
				}
			if (soap_flag_pgFirstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pgFirstName", (wchar_t**)&a->ns2__BML::pgFirstName, "xsd:string"))
				{	soap_flag_pgFirstName1--;
					continue;
				}
			if (soap_flag_pgSSN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pgSSN", (wchar_t**)&a->ns2__BML::pgSSN, "xsd:string"))
				{	soap_flag_pgSSN1--;
					continue;
				}
			if (soap_flag_pgDateOfBirth1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pgDateOfBirth", (wchar_t**)&a->ns2__BML::pgDateOfBirth, "xsd:string"))
				{	soap_flag_pgDateOfBirth1--;
					continue;
				}
			if (soap_flag_pgAnnualIncome1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pgAnnualIncome", (wchar_t**)&a->ns2__BML::pgAnnualIncome, "xsd:string"))
				{	soap_flag_pgAnnualIncome1--;
					continue;
				}
			if (soap_flag_pgIncomeCurrencyType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pgIncomeCurrencyType", (wchar_t**)&a->ns2__BML::pgIncomeCurrencyType, "xsd:string"))
				{	soap_flag_pgIncomeCurrencyType1--;
					continue;
				}
			if (soap_flag_pgResidenceStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pgResidenceStatus", (wchar_t**)&a->ns2__BML::pgResidenceStatus, "xsd:string"))
				{	soap_flag_pgResidenceStatus1--;
					continue;
				}
			if (soap_flag_pgCheckingAccountIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pgCheckingAccountIndicator", (wchar_t**)&a->ns2__BML::pgCheckingAccountIndicator, "xsd:string"))
				{	soap_flag_pgCheckingAccountIndicator1--;
					continue;
				}
			if (soap_flag_pgSavingsAccountIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pgSavingsAccountIndicator", (wchar_t**)&a->ns2__BML::pgSavingsAccountIndicator, "xsd:string"))
				{	soap_flag_pgSavingsAccountIndicator1--;
					continue;
				}
			if (soap_flag_pgYearsAtEmployer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pgYearsAtEmployer", (wchar_t**)&a->ns2__BML::pgYearsAtEmployer, "xsd:string"))
				{	soap_flag_pgYearsAtEmployer1--;
					continue;
				}
			if (soap_flag_pgYearsAtResidence1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pgYearsAtResidence", (wchar_t**)&a->ns2__BML::pgYearsAtResidence, "xsd:string"))
				{	soap_flag_pgYearsAtResidence1--;
					continue;
				}
			if (soap_flag_pgHomeAddress11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pgHomeAddress1", (wchar_t**)&a->ns2__BML::pgHomeAddress1, "xsd:string"))
				{	soap_flag_pgHomeAddress11--;
					continue;
				}
			if (soap_flag_pgHomeAddress21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pgHomeAddress2", (wchar_t**)&a->ns2__BML::pgHomeAddress2, "xsd:string"))
				{	soap_flag_pgHomeAddress21--;
					continue;
				}
			if (soap_flag_pgHomeCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pgHomeCity", (wchar_t**)&a->ns2__BML::pgHomeCity, "xsd:string"))
				{	soap_flag_pgHomeCity1--;
					continue;
				}
			if (soap_flag_pgHomeState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pgHomeState", (wchar_t**)&a->ns2__BML::pgHomeState, "xsd:string"))
				{	soap_flag_pgHomeState1--;
					continue;
				}
			if (soap_flag_pgHomePostalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pgHomePostalCode", (wchar_t**)&a->ns2__BML::pgHomePostalCode, "xsd:string"))
				{	soap_flag_pgHomePostalCode1--;
					continue;
				}
			if (soap_flag_pgHomeCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pgHomeCountry", (wchar_t**)&a->ns2__BML::pgHomeCountry, "xsd:string"))
				{	soap_flag_pgHomeCountry1--;
					continue;
				}
			if (soap_flag_pgEmailAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pgEmailAddress", (wchar_t**)&a->ns2__BML::pgEmailAddress, "xsd:string"))
				{	soap_flag_pgEmailAddress1--;
					continue;
				}
			if (soap_flag_pgHomePhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pgHomePhone", (wchar_t**)&a->ns2__BML::pgHomePhone, "xsd:string"))
				{	soap_flag_pgHomePhone1--;
					continue;
				}
			if (soap_flag_pgTitle1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pgTitle", (wchar_t**)&a->ns2__BML::pgTitle, "xsd:string"))
				{	soap_flag_pgTitle1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__BML *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BML, SOAP_TYPE_ns2__BML, sizeof(ns2__BML), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__BML * SOAP_FMAC2 soap_instantiate_ns2__BML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__BML(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__BML *p;
	size_t k = sizeof(ns2__BML);
	if (n < 0)
	{	p = SOAP_NEW(ns2__BML);
		if (p)
			((ns2__BML*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__BML, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__BML*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__BML location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__BML, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__BML::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:BML", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__BML::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__BML(soap, this, tag, type);
}

SOAP_FMAC3 ns2__BML * SOAP_FMAC4 soap_get_ns2__BML(struct soap *soap, ns2__BML *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BML(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Check::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Check::fullName = NULL;
	this->ns2__Check::accountNumber = NULL;
	this->ns2__Check::accountType = NULL;
	this->ns2__Check::bankTransitNumber = NULL;
	this->ns2__Check::checkNumber = NULL;
	this->ns2__Check::secCode = NULL;
	this->ns2__Check::accountEncoderID = NULL;
	this->ns2__Check::authenticateID = NULL;
	this->ns2__Check::paymentInfo = NULL;
	this->ns2__Check::imageReferenceNumber = NULL;
	this->ns2__Check::terminalCity = NULL;
	this->ns2__Check::terminalState = NULL;
	/* transient soap skipped */
}

void ns2__Check::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Check::fullName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Check::accountNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Check::accountType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Check::bankTransitNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Check::checkNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Check::secCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Check::accountEncoderID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Check::authenticateID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Check::paymentInfo);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Check::imageReferenceNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Check::terminalCity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Check::terminalState);
#endif
}

int ns2__Check::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Check(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Check(struct soap *soap, const char *tag, int id, const ns2__Check *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Check), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:fullName", -1, (wchar_t*const*)&a->ns2__Check::fullName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:accountNumber", -1, (wchar_t*const*)&a->ns2__Check::accountNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:accountType", -1, (wchar_t*const*)&a->ns2__Check::accountType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:bankTransitNumber", -1, (wchar_t*const*)&a->ns2__Check::bankTransitNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:checkNumber", -1, (wchar_t*const*)&a->ns2__Check::checkNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:secCode", -1, (wchar_t*const*)&a->ns2__Check::secCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:accountEncoderID", -1, (wchar_t*const*)&a->ns2__Check::accountEncoderID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authenticateID", -1, (wchar_t*const*)&a->ns2__Check::authenticateID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentInfo", -1, (wchar_t*const*)&a->ns2__Check::paymentInfo, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:imageReferenceNumber", -1, (wchar_t*const*)&a->ns2__Check::imageReferenceNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:terminalCity", -1, (wchar_t*const*)&a->ns2__Check::terminalCity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:terminalState", -1, (wchar_t*const*)&a->ns2__Check::terminalState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Check::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Check(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Check * SOAP_FMAC4 soap_in_ns2__Check(struct soap *soap, const char *tag, ns2__Check *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Check *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Check, sizeof(ns2__Check), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Check)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Check *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_fullName1 = 1;
	size_t soap_flag_accountNumber1 = 1;
	size_t soap_flag_accountType1 = 1;
	size_t soap_flag_bankTransitNumber1 = 1;
	size_t soap_flag_checkNumber1 = 1;
	size_t soap_flag_secCode1 = 1;
	size_t soap_flag_accountEncoderID1 = 1;
	size_t soap_flag_authenticateID1 = 1;
	size_t soap_flag_paymentInfo1 = 1;
	size_t soap_flag_imageReferenceNumber1 = 1;
	size_t soap_flag_terminalCity1 = 1;
	size_t soap_flag_terminalState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:fullName", (wchar_t**)&a->ns2__Check::fullName, "xsd:string"))
				{	soap_flag_fullName1--;
					continue;
				}
			if (soap_flag_accountNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:accountNumber", (wchar_t**)&a->ns2__Check::accountNumber, "xsd:string"))
				{	soap_flag_accountNumber1--;
					continue;
				}
			if (soap_flag_accountType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:accountType", (wchar_t**)&a->ns2__Check::accountType, "xsd:string"))
				{	soap_flag_accountType1--;
					continue;
				}
			if (soap_flag_bankTransitNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:bankTransitNumber", (wchar_t**)&a->ns2__Check::bankTransitNumber, "xsd:string"))
				{	soap_flag_bankTransitNumber1--;
					continue;
				}
			if (soap_flag_checkNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:checkNumber", (wchar_t**)&a->ns2__Check::checkNumber, "xsd:string"))
				{	soap_flag_checkNumber1--;
					continue;
				}
			if (soap_flag_secCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:secCode", (wchar_t**)&a->ns2__Check::secCode, "xsd:string"))
				{	soap_flag_secCode1--;
					continue;
				}
			if (soap_flag_accountEncoderID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:accountEncoderID", (wchar_t**)&a->ns2__Check::accountEncoderID, "xsd:string"))
				{	soap_flag_accountEncoderID1--;
					continue;
				}
			if (soap_flag_authenticateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authenticateID", (wchar_t**)&a->ns2__Check::authenticateID, "xsd:string"))
				{	soap_flag_authenticateID1--;
					continue;
				}
			if (soap_flag_paymentInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentInfo", (wchar_t**)&a->ns2__Check::paymentInfo, "xsd:string"))
				{	soap_flag_paymentInfo1--;
					continue;
				}
			if (soap_flag_imageReferenceNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:imageReferenceNumber", (wchar_t**)&a->ns2__Check::imageReferenceNumber, "xsd:string"))
				{	soap_flag_imageReferenceNumber1--;
					continue;
				}
			if (soap_flag_terminalCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:terminalCity", (wchar_t**)&a->ns2__Check::terminalCity, "xsd:string"))
				{	soap_flag_terminalCity1--;
					continue;
				}
			if (soap_flag_terminalState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:terminalState", (wchar_t**)&a->ns2__Check::terminalState, "xsd:string"))
				{	soap_flag_terminalState1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Check *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Check, SOAP_TYPE_ns2__Check, sizeof(ns2__Check), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Check * SOAP_FMAC2 soap_instantiate_ns2__Check(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Check(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Check *p;
	size_t k = sizeof(ns2__Check);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Check);
		if (p)
			((ns2__Check*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Check, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Check*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Check location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Check, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Check::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:Check", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Check::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Check(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Check * SOAP_FMAC4 soap_get_ns2__Check(struct soap *soap, ns2__Check *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Check(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Card::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Card::fullName = NULL;
	this->ns2__Card::accountNumber = NULL;
	this->ns2__Card::expirationMonth = NULL;
	this->ns2__Card::expirationYear = NULL;
	this->ns2__Card::cvIndicator = NULL;
	this->ns2__Card::cvNumber = NULL;
	this->ns2__Card::cardType = NULL;
	this->ns2__Card::issueNumber = NULL;
	this->ns2__Card::startMonth = NULL;
	this->ns2__Card::startYear = NULL;
	this->ns2__Card::pin = NULL;
	this->ns2__Card::accountEncoderID = NULL;
	this->ns2__Card::bin = NULL;
	this->ns2__Card::encryptedData = NULL;
	this->ns2__Card::suffix = NULL;
	this->ns2__Card::prefix = NULL;
	/* transient soap skipped */
}

void ns2__Card::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Card::fullName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Card::accountNumber);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__Card::expirationMonth);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__Card::expirationYear);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Card::cvIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Card::cvNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Card::cardType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Card::issueNumber);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__Card::startMonth);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__Card::startYear);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Card::pin);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Card::accountEncoderID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Card::bin);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Card::encryptedData);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Card::suffix);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Card::prefix);
#endif
}

int ns2__Card::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Card(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Card(struct soap *soap, const char *tag, int id, const ns2__Card *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Card), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:fullName", -1, (wchar_t*const*)&a->ns2__Card::fullName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:accountNumber", -1, (wchar_t*const*)&a->ns2__Card::accountNumber, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:expirationMonth", -1, &a->ns2__Card::expirationMonth, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:expirationYear", -1, &a->ns2__Card::expirationYear, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cvIndicator", -1, (wchar_t*const*)&a->ns2__Card::cvIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cvNumber", -1, (wchar_t*const*)&a->ns2__Card::cvNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardType", -1, (wchar_t*const*)&a->ns2__Card::cardType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:issueNumber", -1, (wchar_t*const*)&a->ns2__Card::issueNumber, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:startMonth", -1, &a->ns2__Card::startMonth, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:startYear", -1, &a->ns2__Card::startYear, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pin", -1, (wchar_t*const*)&a->ns2__Card::pin, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:accountEncoderID", -1, (wchar_t*const*)&a->ns2__Card::accountEncoderID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:bin", -1, (wchar_t*const*)&a->ns2__Card::bin, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:encryptedData", -1, (wchar_t*const*)&a->ns2__Card::encryptedData, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:suffix", -1, (wchar_t*const*)&a->ns2__Card::suffix, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:prefix", -1, (wchar_t*const*)&a->ns2__Card::prefix, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Card::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Card(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Card * SOAP_FMAC4 soap_in_ns2__Card(struct soap *soap, const char *tag, ns2__Card *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Card *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Card, sizeof(ns2__Card), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Card)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Card *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_fullName1 = 1;
	size_t soap_flag_accountNumber1 = 1;
	size_t soap_flag_expirationMonth1 = 1;
	size_t soap_flag_expirationYear1 = 1;
	size_t soap_flag_cvIndicator1 = 1;
	size_t soap_flag_cvNumber1 = 1;
	size_t soap_flag_cardType1 = 1;
	size_t soap_flag_issueNumber1 = 1;
	size_t soap_flag_startMonth1 = 1;
	size_t soap_flag_startYear1 = 1;
	size_t soap_flag_pin1 = 1;
	size_t soap_flag_accountEncoderID1 = 1;
	size_t soap_flag_bin1 = 1;
	size_t soap_flag_encryptedData1 = 1;
	size_t soap_flag_suffix1 = 1;
	size_t soap_flag_prefix1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:fullName", (wchar_t**)&a->ns2__Card::fullName, "xsd:string"))
				{	soap_flag_fullName1--;
					continue;
				}
			if (soap_flag_accountNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:accountNumber", (wchar_t**)&a->ns2__Card::accountNumber, "xsd:string"))
				{	soap_flag_accountNumber1--;
					continue;
				}
			if (soap_flag_expirationMonth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:expirationMonth", &a->ns2__Card::expirationMonth, "xsd:integer"))
				{	soap_flag_expirationMonth1--;
					continue;
				}
			if (soap_flag_expirationYear1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:expirationYear", &a->ns2__Card::expirationYear, "xsd:integer"))
				{	soap_flag_expirationYear1--;
					continue;
				}
			if (soap_flag_cvIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cvIndicator", (wchar_t**)&a->ns2__Card::cvIndicator, "xsd:string"))
				{	soap_flag_cvIndicator1--;
					continue;
				}
			if (soap_flag_cvNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cvNumber", (wchar_t**)&a->ns2__Card::cvNumber, "xsd:string"))
				{	soap_flag_cvNumber1--;
					continue;
				}
			if (soap_flag_cardType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardType", (wchar_t**)&a->ns2__Card::cardType, "xsd:string"))
				{	soap_flag_cardType1--;
					continue;
				}
			if (soap_flag_issueNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:issueNumber", (wchar_t**)&a->ns2__Card::issueNumber, "xsd:string"))
				{	soap_flag_issueNumber1--;
					continue;
				}
			if (soap_flag_startMonth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:startMonth", &a->ns2__Card::startMonth, "xsd:integer"))
				{	soap_flag_startMonth1--;
					continue;
				}
			if (soap_flag_startYear1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:startYear", &a->ns2__Card::startYear, "xsd:integer"))
				{	soap_flag_startYear1--;
					continue;
				}
			if (soap_flag_pin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pin", (wchar_t**)&a->ns2__Card::pin, "xsd:string"))
				{	soap_flag_pin1--;
					continue;
				}
			if (soap_flag_accountEncoderID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:accountEncoderID", (wchar_t**)&a->ns2__Card::accountEncoderID, "xsd:string"))
				{	soap_flag_accountEncoderID1--;
					continue;
				}
			if (soap_flag_bin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:bin", (wchar_t**)&a->ns2__Card::bin, "xsd:string"))
				{	soap_flag_bin1--;
					continue;
				}
			if (soap_flag_encryptedData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:encryptedData", (wchar_t**)&a->ns2__Card::encryptedData, "xsd:string"))
				{	soap_flag_encryptedData1--;
					continue;
				}
			if (soap_flag_suffix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:suffix", (wchar_t**)&a->ns2__Card::suffix, "xsd:string"))
				{	soap_flag_suffix1--;
					continue;
				}
			if (soap_flag_prefix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:prefix", (wchar_t**)&a->ns2__Card::prefix, "xsd:string"))
				{	soap_flag_prefix1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Card *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Card, SOAP_TYPE_ns2__Card, sizeof(ns2__Card), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Card * SOAP_FMAC2 soap_instantiate_ns2__Card(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Card(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Card *p;
	size_t k = sizeof(ns2__Card);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Card);
		if (p)
			((ns2__Card*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Card, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Card*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Card location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Card, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Card::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:Card", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Card::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Card(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Card * SOAP_FMAC4 soap_get_ns2__Card(struct soap *soap, ns2__Card *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Card(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ShipFrom::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ShipFrom::title = NULL;
	this->ns2__ShipFrom::firstName = NULL;
	this->ns2__ShipFrom::middleName = NULL;
	this->ns2__ShipFrom::lastName = NULL;
	this->ns2__ShipFrom::suffix = NULL;
	this->ns2__ShipFrom::street1 = NULL;
	this->ns2__ShipFrom::street2 = NULL;
	this->ns2__ShipFrom::street3 = NULL;
	this->ns2__ShipFrom::street4 = NULL;
	this->ns2__ShipFrom::city = NULL;
	this->ns2__ShipFrom::county = NULL;
	this->ns2__ShipFrom::state = NULL;
	this->ns2__ShipFrom::postalCode = NULL;
	this->ns2__ShipFrom::country = NULL;
	this->ns2__ShipFrom::company = NULL;
	this->ns2__ShipFrom::phoneNumber = NULL;
	this->ns2__ShipFrom::email = NULL;
	/* transient soap skipped */
}

void ns2__ShipFrom::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipFrom::title);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipFrom::firstName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipFrom::middleName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipFrom::lastName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipFrom::suffix);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipFrom::street1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipFrom::street2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipFrom::street3);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipFrom::street4);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipFrom::city);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipFrom::county);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipFrom::state);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipFrom::postalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipFrom::country);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipFrom::company);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipFrom::phoneNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipFrom::email);
#endif
}

int ns2__ShipFrom::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ShipFrom(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ShipFrom(struct soap *soap, const char *tag, int id, const ns2__ShipFrom *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ShipFrom), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:title", -1, (wchar_t*const*)&a->ns2__ShipFrom::title, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:firstName", -1, (wchar_t*const*)&a->ns2__ShipFrom::firstName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:middleName", -1, (wchar_t*const*)&a->ns2__ShipFrom::middleName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:lastName", -1, (wchar_t*const*)&a->ns2__ShipFrom::lastName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:suffix", -1, (wchar_t*const*)&a->ns2__ShipFrom::suffix, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:street1", -1, (wchar_t*const*)&a->ns2__ShipFrom::street1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:street2", -1, (wchar_t*const*)&a->ns2__ShipFrom::street2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:street3", -1, (wchar_t*const*)&a->ns2__ShipFrom::street3, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:street4", -1, (wchar_t*const*)&a->ns2__ShipFrom::street4, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:city", -1, (wchar_t*const*)&a->ns2__ShipFrom::city, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:county", -1, (wchar_t*const*)&a->ns2__ShipFrom::county, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:state", -1, (wchar_t*const*)&a->ns2__ShipFrom::state, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:postalCode", -1, (wchar_t*const*)&a->ns2__ShipFrom::postalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:country", -1, (wchar_t*const*)&a->ns2__ShipFrom::country, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:company", -1, (wchar_t*const*)&a->ns2__ShipFrom::company, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:phoneNumber", -1, (wchar_t*const*)&a->ns2__ShipFrom::phoneNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:email", -1, (wchar_t*const*)&a->ns2__ShipFrom::email, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ShipFrom::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ShipFrom(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ShipFrom * SOAP_FMAC4 soap_in_ns2__ShipFrom(struct soap *soap, const char *tag, ns2__ShipFrom *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ShipFrom *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ShipFrom, sizeof(ns2__ShipFrom), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ShipFrom)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ShipFrom *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_title1 = 1;
	size_t soap_flag_firstName1 = 1;
	size_t soap_flag_middleName1 = 1;
	size_t soap_flag_lastName1 = 1;
	size_t soap_flag_suffix1 = 1;
	size_t soap_flag_street11 = 1;
	size_t soap_flag_street21 = 1;
	size_t soap_flag_street31 = 1;
	size_t soap_flag_street41 = 1;
	size_t soap_flag_city1 = 1;
	size_t soap_flag_county1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_postalCode1 = 1;
	size_t soap_flag_country1 = 1;
	size_t soap_flag_company1 = 1;
	size_t soap_flag_phoneNumber1 = 1;
	size_t soap_flag_email1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:title", (wchar_t**)&a->ns2__ShipFrom::title, "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			if (soap_flag_firstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:firstName", (wchar_t**)&a->ns2__ShipFrom::firstName, "xsd:string"))
				{	soap_flag_firstName1--;
					continue;
				}
			if (soap_flag_middleName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:middleName", (wchar_t**)&a->ns2__ShipFrom::middleName, "xsd:string"))
				{	soap_flag_middleName1--;
					continue;
				}
			if (soap_flag_lastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:lastName", (wchar_t**)&a->ns2__ShipFrom::lastName, "xsd:string"))
				{	soap_flag_lastName1--;
					continue;
				}
			if (soap_flag_suffix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:suffix", (wchar_t**)&a->ns2__ShipFrom::suffix, "xsd:string"))
				{	soap_flag_suffix1--;
					continue;
				}
			if (soap_flag_street11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:street1", (wchar_t**)&a->ns2__ShipFrom::street1, "xsd:string"))
				{	soap_flag_street11--;
					continue;
				}
			if (soap_flag_street21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:street2", (wchar_t**)&a->ns2__ShipFrom::street2, "xsd:string"))
				{	soap_flag_street21--;
					continue;
				}
			if (soap_flag_street31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:street3", (wchar_t**)&a->ns2__ShipFrom::street3, "xsd:string"))
				{	soap_flag_street31--;
					continue;
				}
			if (soap_flag_street41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:street4", (wchar_t**)&a->ns2__ShipFrom::street4, "xsd:string"))
				{	soap_flag_street41--;
					continue;
				}
			if (soap_flag_city1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:city", (wchar_t**)&a->ns2__ShipFrom::city, "xsd:string"))
				{	soap_flag_city1--;
					continue;
				}
			if (soap_flag_county1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:county", (wchar_t**)&a->ns2__ShipFrom::county, "xsd:string"))
				{	soap_flag_county1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:state", (wchar_t**)&a->ns2__ShipFrom::state, "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_postalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:postalCode", (wchar_t**)&a->ns2__ShipFrom::postalCode, "xsd:string"))
				{	soap_flag_postalCode1--;
					continue;
				}
			if (soap_flag_country1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:country", (wchar_t**)&a->ns2__ShipFrom::country, "xsd:string"))
				{	soap_flag_country1--;
					continue;
				}
			if (soap_flag_company1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:company", (wchar_t**)&a->ns2__ShipFrom::company, "xsd:string"))
				{	soap_flag_company1--;
					continue;
				}
			if (soap_flag_phoneNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:phoneNumber", (wchar_t**)&a->ns2__ShipFrom::phoneNumber, "xsd:string"))
				{	soap_flag_phoneNumber1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:email", (wchar_t**)&a->ns2__ShipFrom::email, "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ShipFrom *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ShipFrom, SOAP_TYPE_ns2__ShipFrom, sizeof(ns2__ShipFrom), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ShipFrom * SOAP_FMAC2 soap_instantiate_ns2__ShipFrom(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ShipFrom(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ShipFrom *p;
	size_t k = sizeof(ns2__ShipFrom);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ShipFrom);
		if (p)
			((ns2__ShipFrom*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ShipFrom, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ShipFrom*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ShipFrom location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ShipFrom, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ShipFrom::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:ShipFrom", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ShipFrom::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ShipFrom(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ShipFrom * SOAP_FMAC4 soap_get_ns2__ShipFrom(struct soap *soap, ns2__ShipFrom *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ShipFrom(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ShipTo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ShipTo::title = NULL;
	this->ns2__ShipTo::firstName = NULL;
	this->ns2__ShipTo::middleName = NULL;
	this->ns2__ShipTo::lastName = NULL;
	this->ns2__ShipTo::suffix = NULL;
	this->ns2__ShipTo::street1 = NULL;
	this->ns2__ShipTo::street2 = NULL;
	this->ns2__ShipTo::street3 = NULL;
	this->ns2__ShipTo::street4 = NULL;
	this->ns2__ShipTo::city = NULL;
	this->ns2__ShipTo::county = NULL;
	this->ns2__ShipTo::state = NULL;
	this->ns2__ShipTo::buildingNumber = NULL;
	this->ns2__ShipTo::district = NULL;
	this->ns2__ShipTo::postalCode = NULL;
	this->ns2__ShipTo::country = NULL;
	this->ns2__ShipTo::company = NULL;
	this->ns2__ShipTo::phoneNumber = NULL;
	this->ns2__ShipTo::email = NULL;
	this->ns2__ShipTo::shippingMethod = NULL;
	this->ns2__ShipTo::name = NULL;
	this->ns2__ShipTo::id = NULL;
	this->ns2__ShipTo::addressVerificationStatus = NULL;
	/* transient soap skipped */
}

void ns2__ShipTo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::title);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::firstName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::middleName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::lastName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::suffix);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::street1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::street2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::street3);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::street4);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::city);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::county);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::state);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::buildingNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::district);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::postalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::country);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::company);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::phoneNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::email);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::shippingMethod);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::name);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::id);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ShipTo::addressVerificationStatus);
#endif
}

int ns2__ShipTo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ShipTo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ShipTo(struct soap *soap, const char *tag, int id, const ns2__ShipTo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ShipTo), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:title", -1, (wchar_t*const*)&a->ns2__ShipTo::title, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:firstName", -1, (wchar_t*const*)&a->ns2__ShipTo::firstName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:middleName", -1, (wchar_t*const*)&a->ns2__ShipTo::middleName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:lastName", -1, (wchar_t*const*)&a->ns2__ShipTo::lastName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:suffix", -1, (wchar_t*const*)&a->ns2__ShipTo::suffix, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:street1", -1, (wchar_t*const*)&a->ns2__ShipTo::street1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:street2", -1, (wchar_t*const*)&a->ns2__ShipTo::street2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:street3", -1, (wchar_t*const*)&a->ns2__ShipTo::street3, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:street4", -1, (wchar_t*const*)&a->ns2__ShipTo::street4, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:city", -1, (wchar_t*const*)&a->ns2__ShipTo::city, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:county", -1, (wchar_t*const*)&a->ns2__ShipTo::county, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:state", -1, (wchar_t*const*)&a->ns2__ShipTo::state, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:buildingNumber", -1, (wchar_t*const*)&a->ns2__ShipTo::buildingNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:district", -1, (wchar_t*const*)&a->ns2__ShipTo::district, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:postalCode", -1, (wchar_t*const*)&a->ns2__ShipTo::postalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:country", -1, (wchar_t*const*)&a->ns2__ShipTo::country, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:company", -1, (wchar_t*const*)&a->ns2__ShipTo::company, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:phoneNumber", -1, (wchar_t*const*)&a->ns2__ShipTo::phoneNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:email", -1, (wchar_t*const*)&a->ns2__ShipTo::email, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shippingMethod", -1, (wchar_t*const*)&a->ns2__ShipTo::shippingMethod, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:name", -1, (wchar_t*const*)&a->ns2__ShipTo::name, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:id", -1, (wchar_t*const*)&a->ns2__ShipTo::id, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:addressVerificationStatus", -1, (wchar_t*const*)&a->ns2__ShipTo::addressVerificationStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ShipTo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ShipTo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ShipTo * SOAP_FMAC4 soap_in_ns2__ShipTo(struct soap *soap, const char *tag, ns2__ShipTo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ShipTo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ShipTo, sizeof(ns2__ShipTo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ShipTo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ShipTo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_title1 = 1;
	size_t soap_flag_firstName1 = 1;
	size_t soap_flag_middleName1 = 1;
	size_t soap_flag_lastName1 = 1;
	size_t soap_flag_suffix1 = 1;
	size_t soap_flag_street11 = 1;
	size_t soap_flag_street21 = 1;
	size_t soap_flag_street31 = 1;
	size_t soap_flag_street41 = 1;
	size_t soap_flag_city1 = 1;
	size_t soap_flag_county1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_buildingNumber1 = 1;
	size_t soap_flag_district1 = 1;
	size_t soap_flag_postalCode1 = 1;
	size_t soap_flag_country1 = 1;
	size_t soap_flag_company1 = 1;
	size_t soap_flag_phoneNumber1 = 1;
	size_t soap_flag_email1 = 1;
	size_t soap_flag_shippingMethod1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_addressVerificationStatus1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:title", (wchar_t**)&a->ns2__ShipTo::title, "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			if (soap_flag_firstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:firstName", (wchar_t**)&a->ns2__ShipTo::firstName, "xsd:string"))
				{	soap_flag_firstName1--;
					continue;
				}
			if (soap_flag_middleName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:middleName", (wchar_t**)&a->ns2__ShipTo::middleName, "xsd:string"))
				{	soap_flag_middleName1--;
					continue;
				}
			if (soap_flag_lastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:lastName", (wchar_t**)&a->ns2__ShipTo::lastName, "xsd:string"))
				{	soap_flag_lastName1--;
					continue;
				}
			if (soap_flag_suffix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:suffix", (wchar_t**)&a->ns2__ShipTo::suffix, "xsd:string"))
				{	soap_flag_suffix1--;
					continue;
				}
			if (soap_flag_street11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:street1", (wchar_t**)&a->ns2__ShipTo::street1, "xsd:string"))
				{	soap_flag_street11--;
					continue;
				}
			if (soap_flag_street21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:street2", (wchar_t**)&a->ns2__ShipTo::street2, "xsd:string"))
				{	soap_flag_street21--;
					continue;
				}
			if (soap_flag_street31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:street3", (wchar_t**)&a->ns2__ShipTo::street3, "xsd:string"))
				{	soap_flag_street31--;
					continue;
				}
			if (soap_flag_street41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:street4", (wchar_t**)&a->ns2__ShipTo::street4, "xsd:string"))
				{	soap_flag_street41--;
					continue;
				}
			if (soap_flag_city1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:city", (wchar_t**)&a->ns2__ShipTo::city, "xsd:string"))
				{	soap_flag_city1--;
					continue;
				}
			if (soap_flag_county1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:county", (wchar_t**)&a->ns2__ShipTo::county, "xsd:string"))
				{	soap_flag_county1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:state", (wchar_t**)&a->ns2__ShipTo::state, "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_buildingNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:buildingNumber", (wchar_t**)&a->ns2__ShipTo::buildingNumber, "xsd:string"))
				{	soap_flag_buildingNumber1--;
					continue;
				}
			if (soap_flag_district1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:district", (wchar_t**)&a->ns2__ShipTo::district, "xsd:string"))
				{	soap_flag_district1--;
					continue;
				}
			if (soap_flag_postalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:postalCode", (wchar_t**)&a->ns2__ShipTo::postalCode, "xsd:string"))
				{	soap_flag_postalCode1--;
					continue;
				}
			if (soap_flag_country1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:country", (wchar_t**)&a->ns2__ShipTo::country, "xsd:string"))
				{	soap_flag_country1--;
					continue;
				}
			if (soap_flag_company1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:company", (wchar_t**)&a->ns2__ShipTo::company, "xsd:string"))
				{	soap_flag_company1--;
					continue;
				}
			if (soap_flag_phoneNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:phoneNumber", (wchar_t**)&a->ns2__ShipTo::phoneNumber, "xsd:string"))
				{	soap_flag_phoneNumber1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:email", (wchar_t**)&a->ns2__ShipTo::email, "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			if (soap_flag_shippingMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shippingMethod", (wchar_t**)&a->ns2__ShipTo::shippingMethod, "xsd:string"))
				{	soap_flag_shippingMethod1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:name", (wchar_t**)&a->ns2__ShipTo::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:id", (wchar_t**)&a->ns2__ShipTo::id, "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_addressVerificationStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:addressVerificationStatus", (wchar_t**)&a->ns2__ShipTo::addressVerificationStatus, "xsd:string"))
				{	soap_flag_addressVerificationStatus1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ShipTo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ShipTo, SOAP_TYPE_ns2__ShipTo, sizeof(ns2__ShipTo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ShipTo * SOAP_FMAC2 soap_instantiate_ns2__ShipTo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ShipTo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ShipTo *p;
	size_t k = sizeof(ns2__ShipTo);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ShipTo);
		if (p)
			((ns2__ShipTo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ShipTo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ShipTo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ShipTo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ShipTo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ShipTo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:ShipTo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ShipTo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ShipTo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ShipTo * SOAP_FMAC4 soap_get_ns2__ShipTo(struct soap *soap, ns2__ShipTo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ShipTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__BillTo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__BillTo::title = NULL;
	this->ns2__BillTo::firstName = NULL;
	this->ns2__BillTo::middleName = NULL;
	this->ns2__BillTo::lastName = NULL;
	this->ns2__BillTo::suffix = NULL;
	this->ns2__BillTo::buildingNumber = NULL;
	this->ns2__BillTo::street1 = NULL;
	this->ns2__BillTo::street2 = NULL;
	this->ns2__BillTo::street3 = NULL;
	this->ns2__BillTo::street4 = NULL;
	this->ns2__BillTo::city = NULL;
	this->ns2__BillTo::district = NULL;
	this->ns2__BillTo::county = NULL;
	this->ns2__BillTo::state = NULL;
	this->ns2__BillTo::postalCode = NULL;
	this->ns2__BillTo::country = NULL;
	this->ns2__BillTo::company = NULL;
	this->ns2__BillTo::companyTaxID = NULL;
	this->ns2__BillTo::phoneNumber = NULL;
	this->ns2__BillTo::email = NULL;
	this->ns2__BillTo::ipAddress = NULL;
	this->ns2__BillTo::customerUserName = NULL;
	this->ns2__BillTo::customerPassword = NULL;
	this->ns2__BillTo::ipNetworkAddress = NULL;
	this->ns2__BillTo::hostname = NULL;
	this->ns2__BillTo::domainName = NULL;
	this->ns2__BillTo::dateOfBirth = NULL;
	this->ns2__BillTo::driversLicenseNumber = NULL;
	this->ns2__BillTo::driversLicenseState = NULL;
	this->ns2__BillTo::ssn = NULL;
	this->ns2__BillTo::customerID = NULL;
	this->ns2__BillTo::httpBrowserType = NULL;
	this->ns2__BillTo::httpBrowserEmail = NULL;
	this->ns2__BillTo::httpBrowserCookiesAccepted = NULL;
	this->ns2__BillTo::nif = NULL;
	this->ns2__BillTo::personalID = NULL;
	this->ns2__BillTo::language = NULL;
	this->ns2__BillTo::name = NULL;
	this->ns2__BillTo::gender = NULL;
	/* transient soap skipped */
}

void ns2__BillTo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::title);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::firstName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::middleName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::lastName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::suffix);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::buildingNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::street1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::street2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::street3);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::street4);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::city);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::district);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::county);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::state);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::postalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::country);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::company);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::companyTaxID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::phoneNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::email);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::ipAddress);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::customerUserName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::customerPassword);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::ipNetworkAddress);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::hostname);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::domainName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::dateOfBirth);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::driversLicenseNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::driversLicenseState);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::ssn);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::customerID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::httpBrowserType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::httpBrowserEmail);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__BillTo::httpBrowserCookiesAccepted);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::nif);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::personalID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::language);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::name);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BillTo::gender);
#endif
}

int ns2__BillTo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__BillTo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BillTo(struct soap *soap, const char *tag, int id, const ns2__BillTo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BillTo), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:title", -1, (wchar_t*const*)&a->ns2__BillTo::title, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:firstName", -1, (wchar_t*const*)&a->ns2__BillTo::firstName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:middleName", -1, (wchar_t*const*)&a->ns2__BillTo::middleName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:lastName", -1, (wchar_t*const*)&a->ns2__BillTo::lastName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:suffix", -1, (wchar_t*const*)&a->ns2__BillTo::suffix, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:buildingNumber", -1, (wchar_t*const*)&a->ns2__BillTo::buildingNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:street1", -1, (wchar_t*const*)&a->ns2__BillTo::street1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:street2", -1, (wchar_t*const*)&a->ns2__BillTo::street2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:street3", -1, (wchar_t*const*)&a->ns2__BillTo::street3, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:street4", -1, (wchar_t*const*)&a->ns2__BillTo::street4, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:city", -1, (wchar_t*const*)&a->ns2__BillTo::city, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:district", -1, (wchar_t*const*)&a->ns2__BillTo::district, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:county", -1, (wchar_t*const*)&a->ns2__BillTo::county, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:state", -1, (wchar_t*const*)&a->ns2__BillTo::state, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:postalCode", -1, (wchar_t*const*)&a->ns2__BillTo::postalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:country", -1, (wchar_t*const*)&a->ns2__BillTo::country, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:company", -1, (wchar_t*const*)&a->ns2__BillTo::company, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:companyTaxID", -1, (wchar_t*const*)&a->ns2__BillTo::companyTaxID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:phoneNumber", -1, (wchar_t*const*)&a->ns2__BillTo::phoneNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:email", -1, (wchar_t*const*)&a->ns2__BillTo::email, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ipAddress", -1, (wchar_t*const*)&a->ns2__BillTo::ipAddress, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:customerUserName", -1, (wchar_t*const*)&a->ns2__BillTo::customerUserName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:customerPassword", -1, (wchar_t*const*)&a->ns2__BillTo::customerPassword, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ipNetworkAddress", -1, (wchar_t*const*)&a->ns2__BillTo::ipNetworkAddress, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:hostname", -1, (wchar_t*const*)&a->ns2__BillTo::hostname, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:domainName", -1, (wchar_t*const*)&a->ns2__BillTo::domainName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:dateOfBirth", -1, (wchar_t*const*)&a->ns2__BillTo::dateOfBirth, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:driversLicenseNumber", -1, (wchar_t*const*)&a->ns2__BillTo::driversLicenseNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:driversLicenseState", -1, (wchar_t*const*)&a->ns2__BillTo::driversLicenseState, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ssn", -1, (wchar_t*const*)&a->ns2__BillTo::ssn, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:customerID", -1, (wchar_t*const*)&a->ns2__BillTo::customerID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:httpBrowserType", -1, (wchar_t*const*)&a->ns2__BillTo::httpBrowserType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:httpBrowserEmail", -1, (wchar_t*const*)&a->ns2__BillTo::httpBrowserEmail, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:httpBrowserCookiesAccepted", -1, &a->ns2__BillTo::httpBrowserCookiesAccepted, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:nif", -1, (wchar_t*const*)&a->ns2__BillTo::nif, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:personalID", -1, (wchar_t*const*)&a->ns2__BillTo::personalID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:language", -1, (wchar_t*const*)&a->ns2__BillTo::language, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:name", -1, (wchar_t*const*)&a->ns2__BillTo::name, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:gender", -1, (wchar_t*const*)&a->ns2__BillTo::gender, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__BillTo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__BillTo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__BillTo * SOAP_FMAC4 soap_in_ns2__BillTo(struct soap *soap, const char *tag, ns2__BillTo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__BillTo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BillTo, sizeof(ns2__BillTo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__BillTo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__BillTo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_title1 = 1;
	size_t soap_flag_firstName1 = 1;
	size_t soap_flag_middleName1 = 1;
	size_t soap_flag_lastName1 = 1;
	size_t soap_flag_suffix1 = 1;
	size_t soap_flag_buildingNumber1 = 1;
	size_t soap_flag_street11 = 1;
	size_t soap_flag_street21 = 1;
	size_t soap_flag_street31 = 1;
	size_t soap_flag_street41 = 1;
	size_t soap_flag_city1 = 1;
	size_t soap_flag_district1 = 1;
	size_t soap_flag_county1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_postalCode1 = 1;
	size_t soap_flag_country1 = 1;
	size_t soap_flag_company1 = 1;
	size_t soap_flag_companyTaxID1 = 1;
	size_t soap_flag_phoneNumber1 = 1;
	size_t soap_flag_email1 = 1;
	size_t soap_flag_ipAddress1 = 1;
	size_t soap_flag_customerUserName1 = 1;
	size_t soap_flag_customerPassword1 = 1;
	size_t soap_flag_ipNetworkAddress1 = 1;
	size_t soap_flag_hostname1 = 1;
	size_t soap_flag_domainName1 = 1;
	size_t soap_flag_dateOfBirth1 = 1;
	size_t soap_flag_driversLicenseNumber1 = 1;
	size_t soap_flag_driversLicenseState1 = 1;
	size_t soap_flag_ssn1 = 1;
	size_t soap_flag_customerID1 = 1;
	size_t soap_flag_httpBrowserType1 = 1;
	size_t soap_flag_httpBrowserEmail1 = 1;
	size_t soap_flag_httpBrowserCookiesAccepted1 = 1;
	size_t soap_flag_nif1 = 1;
	size_t soap_flag_personalID1 = 1;
	size_t soap_flag_language1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_gender1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:title", (wchar_t**)&a->ns2__BillTo::title, "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			if (soap_flag_firstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:firstName", (wchar_t**)&a->ns2__BillTo::firstName, "xsd:string"))
				{	soap_flag_firstName1--;
					continue;
				}
			if (soap_flag_middleName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:middleName", (wchar_t**)&a->ns2__BillTo::middleName, "xsd:string"))
				{	soap_flag_middleName1--;
					continue;
				}
			if (soap_flag_lastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:lastName", (wchar_t**)&a->ns2__BillTo::lastName, "xsd:string"))
				{	soap_flag_lastName1--;
					continue;
				}
			if (soap_flag_suffix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:suffix", (wchar_t**)&a->ns2__BillTo::suffix, "xsd:string"))
				{	soap_flag_suffix1--;
					continue;
				}
			if (soap_flag_buildingNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:buildingNumber", (wchar_t**)&a->ns2__BillTo::buildingNumber, "xsd:string"))
				{	soap_flag_buildingNumber1--;
					continue;
				}
			if (soap_flag_street11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:street1", (wchar_t**)&a->ns2__BillTo::street1, "xsd:string"))
				{	soap_flag_street11--;
					continue;
				}
			if (soap_flag_street21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:street2", (wchar_t**)&a->ns2__BillTo::street2, "xsd:string"))
				{	soap_flag_street21--;
					continue;
				}
			if (soap_flag_street31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:street3", (wchar_t**)&a->ns2__BillTo::street3, "xsd:string"))
				{	soap_flag_street31--;
					continue;
				}
			if (soap_flag_street41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:street4", (wchar_t**)&a->ns2__BillTo::street4, "xsd:string"))
				{	soap_flag_street41--;
					continue;
				}
			if (soap_flag_city1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:city", (wchar_t**)&a->ns2__BillTo::city, "xsd:string"))
				{	soap_flag_city1--;
					continue;
				}
			if (soap_flag_district1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:district", (wchar_t**)&a->ns2__BillTo::district, "xsd:string"))
				{	soap_flag_district1--;
					continue;
				}
			if (soap_flag_county1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:county", (wchar_t**)&a->ns2__BillTo::county, "xsd:string"))
				{	soap_flag_county1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:state", (wchar_t**)&a->ns2__BillTo::state, "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_postalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:postalCode", (wchar_t**)&a->ns2__BillTo::postalCode, "xsd:string"))
				{	soap_flag_postalCode1--;
					continue;
				}
			if (soap_flag_country1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:country", (wchar_t**)&a->ns2__BillTo::country, "xsd:string"))
				{	soap_flag_country1--;
					continue;
				}
			if (soap_flag_company1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:company", (wchar_t**)&a->ns2__BillTo::company, "xsd:string"))
				{	soap_flag_company1--;
					continue;
				}
			if (soap_flag_companyTaxID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:companyTaxID", (wchar_t**)&a->ns2__BillTo::companyTaxID, "xsd:string"))
				{	soap_flag_companyTaxID1--;
					continue;
				}
			if (soap_flag_phoneNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:phoneNumber", (wchar_t**)&a->ns2__BillTo::phoneNumber, "xsd:string"))
				{	soap_flag_phoneNumber1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:email", (wchar_t**)&a->ns2__BillTo::email, "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			if (soap_flag_ipAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ipAddress", (wchar_t**)&a->ns2__BillTo::ipAddress, "xsd:string"))
				{	soap_flag_ipAddress1--;
					continue;
				}
			if (soap_flag_customerUserName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:customerUserName", (wchar_t**)&a->ns2__BillTo::customerUserName, "xsd:string"))
				{	soap_flag_customerUserName1--;
					continue;
				}
			if (soap_flag_customerPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:customerPassword", (wchar_t**)&a->ns2__BillTo::customerPassword, "xsd:string"))
				{	soap_flag_customerPassword1--;
					continue;
				}
			if (soap_flag_ipNetworkAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ipNetworkAddress", (wchar_t**)&a->ns2__BillTo::ipNetworkAddress, "xsd:string"))
				{	soap_flag_ipNetworkAddress1--;
					continue;
				}
			if (soap_flag_hostname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:hostname", (wchar_t**)&a->ns2__BillTo::hostname, "xsd:string"))
				{	soap_flag_hostname1--;
					continue;
				}
			if (soap_flag_domainName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:domainName", (wchar_t**)&a->ns2__BillTo::domainName, "xsd:string"))
				{	soap_flag_domainName1--;
					continue;
				}
			if (soap_flag_dateOfBirth1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:dateOfBirth", (wchar_t**)&a->ns2__BillTo::dateOfBirth, "xsd:string"))
				{	soap_flag_dateOfBirth1--;
					continue;
				}
			if (soap_flag_driversLicenseNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:driversLicenseNumber", (wchar_t**)&a->ns2__BillTo::driversLicenseNumber, "xsd:string"))
				{	soap_flag_driversLicenseNumber1--;
					continue;
				}
			if (soap_flag_driversLicenseState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:driversLicenseState", (wchar_t**)&a->ns2__BillTo::driversLicenseState, "xsd:string"))
				{	soap_flag_driversLicenseState1--;
					continue;
				}
			if (soap_flag_ssn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ssn", (wchar_t**)&a->ns2__BillTo::ssn, "xsd:string"))
				{	soap_flag_ssn1--;
					continue;
				}
			if (soap_flag_customerID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:customerID", (wchar_t**)&a->ns2__BillTo::customerID, "xsd:string"))
				{	soap_flag_customerID1--;
					continue;
				}
			if (soap_flag_httpBrowserType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:httpBrowserType", (wchar_t**)&a->ns2__BillTo::httpBrowserType, "xsd:string"))
				{	soap_flag_httpBrowserType1--;
					continue;
				}
			if (soap_flag_httpBrowserEmail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:httpBrowserEmail", (wchar_t**)&a->ns2__BillTo::httpBrowserEmail, "xsd:string"))
				{	soap_flag_httpBrowserEmail1--;
					continue;
				}
			if (soap_flag_httpBrowserCookiesAccepted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:httpBrowserCookiesAccepted", &a->ns2__BillTo::httpBrowserCookiesAccepted, "ns2:boolean"))
				{	soap_flag_httpBrowserCookiesAccepted1--;
					continue;
				}
			if (soap_flag_nif1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:nif", (wchar_t**)&a->ns2__BillTo::nif, "xsd:string"))
				{	soap_flag_nif1--;
					continue;
				}
			if (soap_flag_personalID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:personalID", (wchar_t**)&a->ns2__BillTo::personalID, "xsd:string"))
				{	soap_flag_personalID1--;
					continue;
				}
			if (soap_flag_language1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:language", (wchar_t**)&a->ns2__BillTo::language, "xsd:string"))
				{	soap_flag_language1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:name", (wchar_t**)&a->ns2__BillTo::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_gender1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:gender", (wchar_t**)&a->ns2__BillTo::gender, "xsd:string"))
				{	soap_flag_gender1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__BillTo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BillTo, SOAP_TYPE_ns2__BillTo, sizeof(ns2__BillTo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__BillTo * SOAP_FMAC2 soap_instantiate_ns2__BillTo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__BillTo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__BillTo *p;
	size_t k = sizeof(ns2__BillTo);
	if (n < 0)
	{	p = SOAP_NEW(ns2__BillTo);
		if (p)
			((ns2__BillTo*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__BillTo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__BillTo*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__BillTo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__BillTo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__BillTo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:BillTo", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__BillTo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__BillTo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__BillTo * SOAP_FMAC4 soap_get_ns2__BillTo(struct soap *soap, ns2__BillTo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BillTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__BusinessRules::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__BusinessRules::ignoreAVSResult = NULL;
	this->ns2__BusinessRules::ignoreCVResult = NULL;
	this->ns2__BusinessRules::ignoreDAVResult = NULL;
	this->ns2__BusinessRules::ignoreExportResult = NULL;
	this->ns2__BusinessRules::ignoreValidateResult = NULL;
	this->ns2__BusinessRules::declineAVSFlags = NULL;
	this->ns2__BusinessRules::scoreThreshold = NULL;
	/* transient soap skipped */
}

void ns2__BusinessRules::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__BusinessRules::ignoreAVSResult);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__BusinessRules::ignoreCVResult);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__BusinessRules::ignoreDAVResult);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__BusinessRules::ignoreExportResult);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__BusinessRules::ignoreValidateResult);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BusinessRules::declineAVSFlags);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__BusinessRules::scoreThreshold);
#endif
}

int ns2__BusinessRules::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__BusinessRules(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BusinessRules(struct soap *soap, const char *tag, int id, const ns2__BusinessRules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BusinessRules), type))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:ignoreAVSResult", -1, &a->ns2__BusinessRules::ignoreAVSResult, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:ignoreCVResult", -1, &a->ns2__BusinessRules::ignoreCVResult, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:ignoreDAVResult", -1, &a->ns2__BusinessRules::ignoreDAVResult, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:ignoreExportResult", -1, &a->ns2__BusinessRules::ignoreExportResult, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:ignoreValidateResult", -1, &a->ns2__BusinessRules::ignoreValidateResult, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:declineAVSFlags", -1, (wchar_t*const*)&a->ns2__BusinessRules::declineAVSFlags, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:scoreThreshold", -1, &a->ns2__BusinessRules::scoreThreshold, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__BusinessRules::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__BusinessRules(soap, tag, this, type);
}

SOAP_FMAC3 ns2__BusinessRules * SOAP_FMAC4 soap_in_ns2__BusinessRules(struct soap *soap, const char *tag, ns2__BusinessRules *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__BusinessRules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BusinessRules, sizeof(ns2__BusinessRules), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__BusinessRules)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__BusinessRules *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ignoreAVSResult1 = 1;
	size_t soap_flag_ignoreCVResult1 = 1;
	size_t soap_flag_ignoreDAVResult1 = 1;
	size_t soap_flag_ignoreExportResult1 = 1;
	size_t soap_flag_ignoreValidateResult1 = 1;
	size_t soap_flag_declineAVSFlags1 = 1;
	size_t soap_flag_scoreThreshold1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ignoreAVSResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:ignoreAVSResult", &a->ns2__BusinessRules::ignoreAVSResult, "ns2:boolean"))
				{	soap_flag_ignoreAVSResult1--;
					continue;
				}
			if (soap_flag_ignoreCVResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:ignoreCVResult", &a->ns2__BusinessRules::ignoreCVResult, "ns2:boolean"))
				{	soap_flag_ignoreCVResult1--;
					continue;
				}
			if (soap_flag_ignoreDAVResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:ignoreDAVResult", &a->ns2__BusinessRules::ignoreDAVResult, "ns2:boolean"))
				{	soap_flag_ignoreDAVResult1--;
					continue;
				}
			if (soap_flag_ignoreExportResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:ignoreExportResult", &a->ns2__BusinessRules::ignoreExportResult, "ns2:boolean"))
				{	soap_flag_ignoreExportResult1--;
					continue;
				}
			if (soap_flag_ignoreValidateResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:ignoreValidateResult", &a->ns2__BusinessRules::ignoreValidateResult, "ns2:boolean"))
				{	soap_flag_ignoreValidateResult1--;
					continue;
				}
			if (soap_flag_declineAVSFlags1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:declineAVSFlags", (wchar_t**)&a->ns2__BusinessRules::declineAVSFlags, "xsd:string"))
				{	soap_flag_declineAVSFlags1--;
					continue;
				}
			if (soap_flag_scoreThreshold1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:scoreThreshold", &a->ns2__BusinessRules::scoreThreshold, "xsd:integer"))
				{	soap_flag_scoreThreshold1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__BusinessRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BusinessRules, SOAP_TYPE_ns2__BusinessRules, sizeof(ns2__BusinessRules), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__BusinessRules * SOAP_FMAC2 soap_instantiate_ns2__BusinessRules(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__BusinessRules(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__BusinessRules *p;
	size_t k = sizeof(ns2__BusinessRules);
	if (n < 0)
	{	p = SOAP_NEW(ns2__BusinessRules);
		if (p)
			((ns2__BusinessRules*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__BusinessRules, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__BusinessRules*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__BusinessRules location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__BusinessRules, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__BusinessRules::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:BusinessRules", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__BusinessRules::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__BusinessRules(soap, this, tag, type);
}

SOAP_FMAC3 ns2__BusinessRules * SOAP_FMAC4 soap_get_ns2__BusinessRules(struct soap *soap, ns2__BusinessRules *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BusinessRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__InvoiceHeader::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__InvoiceHeader::merchantDescriptor = NULL;
	this->ns2__InvoiceHeader::merchantDescriptorContact = NULL;
	this->ns2__InvoiceHeader::merchantDescriptorAlternate = NULL;
	this->ns2__InvoiceHeader::merchantDescriptorStreet = NULL;
	this->ns2__InvoiceHeader::merchantDescriptorCity = NULL;
	this->ns2__InvoiceHeader::merchantDescriptorState = NULL;
	this->ns2__InvoiceHeader::merchantDescriptorPostalCode = NULL;
	this->ns2__InvoiceHeader::merchantDescriptorCountry = NULL;
	this->ns2__InvoiceHeader::isGift = NULL;
	this->ns2__InvoiceHeader::returnsAccepted = NULL;
	this->ns2__InvoiceHeader::tenderType = NULL;
	this->ns2__InvoiceHeader::merchantVATRegistrationNumber = NULL;
	this->ns2__InvoiceHeader::purchaserOrderDate = NULL;
	this->ns2__InvoiceHeader::purchaserVATRegistrationNumber = NULL;
	this->ns2__InvoiceHeader::vatInvoiceReferenceNumber = NULL;
	this->ns2__InvoiceHeader::summaryCommodityCode = NULL;
	this->ns2__InvoiceHeader::supplierOrderReference = NULL;
	this->ns2__InvoiceHeader::userPO = NULL;
	this->ns2__InvoiceHeader::costCenter = NULL;
	this->ns2__InvoiceHeader::purchaserCode = NULL;
	this->ns2__InvoiceHeader::taxable = NULL;
	this->ns2__InvoiceHeader::amexDataTAA1 = NULL;
	this->ns2__InvoiceHeader::amexDataTAA2 = NULL;
	this->ns2__InvoiceHeader::amexDataTAA3 = NULL;
	this->ns2__InvoiceHeader::amexDataTAA4 = NULL;
	this->ns2__InvoiceHeader::invoiceDate = NULL;
	this->ns2__InvoiceHeader::totalTaxTypeCode = NULL;
	this->ns2__InvoiceHeader::cardAcceptorRefNumber = NULL;
	this->ns2__InvoiceHeader::authorizedContactName = NULL;
	this->ns2__InvoiceHeader::businessApplicationID = NULL;
	this->ns2__InvoiceHeader::salesOrganizationID = NULL;
	this->ns2__InvoiceHeader::submerchantID = NULL;
	this->ns2__InvoiceHeader::submerchantName = NULL;
	this->ns2__InvoiceHeader::submerchantStreet = NULL;
	this->ns2__InvoiceHeader::submerchantCity = NULL;
	this->ns2__InvoiceHeader::submerchantPostalCode = NULL;
	this->ns2__InvoiceHeader::submerchantState = NULL;
	this->ns2__InvoiceHeader::submerchantCountry = NULL;
	this->ns2__InvoiceHeader::submerchantEmail = NULL;
	this->ns2__InvoiceHeader::submerchantTelephoneNumber = NULL;
	this->ns2__InvoiceHeader::submerchantRegion = NULL;
	this->ns2__InvoiceHeader::submerchantMerchantID = NULL;
	/* transient soap skipped */
}

void ns2__InvoiceHeader::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::merchantDescriptor);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::merchantDescriptorContact);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::merchantDescriptorAlternate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::merchantDescriptorStreet);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::merchantDescriptorCity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::merchantDescriptorState);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::merchantDescriptorPostalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::merchantDescriptorCountry);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__InvoiceHeader::isGift);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__InvoiceHeader::returnsAccepted);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::tenderType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::merchantVATRegistrationNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::purchaserOrderDate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::purchaserVATRegistrationNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::vatInvoiceReferenceNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::summaryCommodityCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::supplierOrderReference);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::userPO);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::costCenter);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::purchaserCode);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__InvoiceHeader::taxable);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::amexDataTAA1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::amexDataTAA2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::amexDataTAA3);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::amexDataTAA4);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::invoiceDate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::totalTaxTypeCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::cardAcceptorRefNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::authorizedContactName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::businessApplicationID);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__InvoiceHeader::salesOrganizationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::submerchantID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::submerchantName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::submerchantStreet);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::submerchantCity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::submerchantPostalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::submerchantState);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::submerchantCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::submerchantEmail);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::submerchantTelephoneNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::submerchantRegion);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__InvoiceHeader::submerchantMerchantID);
#endif
}

int ns2__InvoiceHeader::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__InvoiceHeader(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__InvoiceHeader(struct soap *soap, const char *tag, int id, const ns2__InvoiceHeader *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__InvoiceHeader), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantDescriptor", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::merchantDescriptor, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantDescriptorContact", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::merchantDescriptorContact, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantDescriptorAlternate", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::merchantDescriptorAlternate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantDescriptorStreet", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::merchantDescriptorStreet, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantDescriptorCity", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::merchantDescriptorCity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantDescriptorState", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::merchantDescriptorState, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantDescriptorPostalCode", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::merchantDescriptorPostalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantDescriptorCountry", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::merchantDescriptorCountry, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:isGift", -1, &a->ns2__InvoiceHeader::isGift, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:returnsAccepted", -1, &a->ns2__InvoiceHeader::returnsAccepted, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:tenderType", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::tenderType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantVATRegistrationNumber", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::merchantVATRegistrationNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:purchaserOrderDate", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::purchaserOrderDate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:purchaserVATRegistrationNumber", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::purchaserVATRegistrationNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:vatInvoiceReferenceNumber", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::vatInvoiceReferenceNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:summaryCommodityCode", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::summaryCommodityCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:supplierOrderReference", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::supplierOrderReference, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:userPO", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::userPO, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:costCenter", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::costCenter, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:purchaserCode", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::purchaserCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:taxable", -1, &a->ns2__InvoiceHeader::taxable, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:amexDataTAA1", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::amexDataTAA1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:amexDataTAA2", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::amexDataTAA2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:amexDataTAA3", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::amexDataTAA3, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:amexDataTAA4", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::amexDataTAA4, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:invoiceDate", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::invoiceDate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:totalTaxTypeCode", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::totalTaxTypeCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardAcceptorRefNumber", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::cardAcceptorRefNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authorizedContactName", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::authorizedContactName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:businessApplicationID", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::businessApplicationID, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:salesOrganizationID", -1, &a->ns2__InvoiceHeader::salesOrganizationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:submerchantID", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::submerchantID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:submerchantName", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::submerchantName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:submerchantStreet", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::submerchantStreet, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:submerchantCity", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::submerchantCity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:submerchantPostalCode", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::submerchantPostalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:submerchantState", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::submerchantState, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:submerchantCountry", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::submerchantCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:submerchantEmail", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::submerchantEmail, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:submerchantTelephoneNumber", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::submerchantTelephoneNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:submerchantRegion", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::submerchantRegion, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:submerchantMerchantID", -1, (wchar_t*const*)&a->ns2__InvoiceHeader::submerchantMerchantID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__InvoiceHeader::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__InvoiceHeader(soap, tag, this, type);
}

SOAP_FMAC3 ns2__InvoiceHeader * SOAP_FMAC4 soap_in_ns2__InvoiceHeader(struct soap *soap, const char *tag, ns2__InvoiceHeader *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__InvoiceHeader *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__InvoiceHeader, sizeof(ns2__InvoiceHeader), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__InvoiceHeader)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__InvoiceHeader *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_merchantDescriptor1 = 1;
	size_t soap_flag_merchantDescriptorContact1 = 1;
	size_t soap_flag_merchantDescriptorAlternate1 = 1;
	size_t soap_flag_merchantDescriptorStreet1 = 1;
	size_t soap_flag_merchantDescriptorCity1 = 1;
	size_t soap_flag_merchantDescriptorState1 = 1;
	size_t soap_flag_merchantDescriptorPostalCode1 = 1;
	size_t soap_flag_merchantDescriptorCountry1 = 1;
	size_t soap_flag_isGift1 = 1;
	size_t soap_flag_returnsAccepted1 = 1;
	size_t soap_flag_tenderType1 = 1;
	size_t soap_flag_merchantVATRegistrationNumber1 = 1;
	size_t soap_flag_purchaserOrderDate1 = 1;
	size_t soap_flag_purchaserVATRegistrationNumber1 = 1;
	size_t soap_flag_vatInvoiceReferenceNumber1 = 1;
	size_t soap_flag_summaryCommodityCode1 = 1;
	size_t soap_flag_supplierOrderReference1 = 1;
	size_t soap_flag_userPO1 = 1;
	size_t soap_flag_costCenter1 = 1;
	size_t soap_flag_purchaserCode1 = 1;
	size_t soap_flag_taxable1 = 1;
	size_t soap_flag_amexDataTAA11 = 1;
	size_t soap_flag_amexDataTAA21 = 1;
	size_t soap_flag_amexDataTAA31 = 1;
	size_t soap_flag_amexDataTAA41 = 1;
	size_t soap_flag_invoiceDate1 = 1;
	size_t soap_flag_totalTaxTypeCode1 = 1;
	size_t soap_flag_cardAcceptorRefNumber1 = 1;
	size_t soap_flag_authorizedContactName1 = 1;
	size_t soap_flag_businessApplicationID1 = 1;
	size_t soap_flag_salesOrganizationID1 = 1;
	size_t soap_flag_submerchantID1 = 1;
	size_t soap_flag_submerchantName1 = 1;
	size_t soap_flag_submerchantStreet1 = 1;
	size_t soap_flag_submerchantCity1 = 1;
	size_t soap_flag_submerchantPostalCode1 = 1;
	size_t soap_flag_submerchantState1 = 1;
	size_t soap_flag_submerchantCountry1 = 1;
	size_t soap_flag_submerchantEmail1 = 1;
	size_t soap_flag_submerchantTelephoneNumber1 = 1;
	size_t soap_flag_submerchantRegion1 = 1;
	size_t soap_flag_submerchantMerchantID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_merchantDescriptor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantDescriptor", (wchar_t**)&a->ns2__InvoiceHeader::merchantDescriptor, "xsd:string"))
				{	soap_flag_merchantDescriptor1--;
					continue;
				}
			if (soap_flag_merchantDescriptorContact1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantDescriptorContact", (wchar_t**)&a->ns2__InvoiceHeader::merchantDescriptorContact, "xsd:string"))
				{	soap_flag_merchantDescriptorContact1--;
					continue;
				}
			if (soap_flag_merchantDescriptorAlternate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantDescriptorAlternate", (wchar_t**)&a->ns2__InvoiceHeader::merchantDescriptorAlternate, "xsd:string"))
				{	soap_flag_merchantDescriptorAlternate1--;
					continue;
				}
			if (soap_flag_merchantDescriptorStreet1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantDescriptorStreet", (wchar_t**)&a->ns2__InvoiceHeader::merchantDescriptorStreet, "xsd:string"))
				{	soap_flag_merchantDescriptorStreet1--;
					continue;
				}
			if (soap_flag_merchantDescriptorCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantDescriptorCity", (wchar_t**)&a->ns2__InvoiceHeader::merchantDescriptorCity, "xsd:string"))
				{	soap_flag_merchantDescriptorCity1--;
					continue;
				}
			if (soap_flag_merchantDescriptorState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantDescriptorState", (wchar_t**)&a->ns2__InvoiceHeader::merchantDescriptorState, "xsd:string"))
				{	soap_flag_merchantDescriptorState1--;
					continue;
				}
			if (soap_flag_merchantDescriptorPostalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantDescriptorPostalCode", (wchar_t**)&a->ns2__InvoiceHeader::merchantDescriptorPostalCode, "xsd:string"))
				{	soap_flag_merchantDescriptorPostalCode1--;
					continue;
				}
			if (soap_flag_merchantDescriptorCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantDescriptorCountry", (wchar_t**)&a->ns2__InvoiceHeader::merchantDescriptorCountry, "xsd:string"))
				{	soap_flag_merchantDescriptorCountry1--;
					continue;
				}
			if (soap_flag_isGift1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:isGift", &a->ns2__InvoiceHeader::isGift, "ns2:boolean"))
				{	soap_flag_isGift1--;
					continue;
				}
			if (soap_flag_returnsAccepted1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:returnsAccepted", &a->ns2__InvoiceHeader::returnsAccepted, "ns2:boolean"))
				{	soap_flag_returnsAccepted1--;
					continue;
				}
			if (soap_flag_tenderType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:tenderType", (wchar_t**)&a->ns2__InvoiceHeader::tenderType, "xsd:string"))
				{	soap_flag_tenderType1--;
					continue;
				}
			if (soap_flag_merchantVATRegistrationNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantVATRegistrationNumber", (wchar_t**)&a->ns2__InvoiceHeader::merchantVATRegistrationNumber, "xsd:string"))
				{	soap_flag_merchantVATRegistrationNumber1--;
					continue;
				}
			if (soap_flag_purchaserOrderDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:purchaserOrderDate", (wchar_t**)&a->ns2__InvoiceHeader::purchaserOrderDate, "xsd:string"))
				{	soap_flag_purchaserOrderDate1--;
					continue;
				}
			if (soap_flag_purchaserVATRegistrationNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:purchaserVATRegistrationNumber", (wchar_t**)&a->ns2__InvoiceHeader::purchaserVATRegistrationNumber, "xsd:string"))
				{	soap_flag_purchaserVATRegistrationNumber1--;
					continue;
				}
			if (soap_flag_vatInvoiceReferenceNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:vatInvoiceReferenceNumber", (wchar_t**)&a->ns2__InvoiceHeader::vatInvoiceReferenceNumber, "xsd:string"))
				{	soap_flag_vatInvoiceReferenceNumber1--;
					continue;
				}
			if (soap_flag_summaryCommodityCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:summaryCommodityCode", (wchar_t**)&a->ns2__InvoiceHeader::summaryCommodityCode, "xsd:string"))
				{	soap_flag_summaryCommodityCode1--;
					continue;
				}
			if (soap_flag_supplierOrderReference1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:supplierOrderReference", (wchar_t**)&a->ns2__InvoiceHeader::supplierOrderReference, "xsd:string"))
				{	soap_flag_supplierOrderReference1--;
					continue;
				}
			if (soap_flag_userPO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:userPO", (wchar_t**)&a->ns2__InvoiceHeader::userPO, "xsd:string"))
				{	soap_flag_userPO1--;
					continue;
				}
			if (soap_flag_costCenter1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:costCenter", (wchar_t**)&a->ns2__InvoiceHeader::costCenter, "xsd:string"))
				{	soap_flag_costCenter1--;
					continue;
				}
			if (soap_flag_purchaserCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:purchaserCode", (wchar_t**)&a->ns2__InvoiceHeader::purchaserCode, "xsd:string"))
				{	soap_flag_purchaserCode1--;
					continue;
				}
			if (soap_flag_taxable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:taxable", &a->ns2__InvoiceHeader::taxable, "ns2:boolean"))
				{	soap_flag_taxable1--;
					continue;
				}
			if (soap_flag_amexDataTAA11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:amexDataTAA1", (wchar_t**)&a->ns2__InvoiceHeader::amexDataTAA1, "xsd:string"))
				{	soap_flag_amexDataTAA11--;
					continue;
				}
			if (soap_flag_amexDataTAA21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:amexDataTAA2", (wchar_t**)&a->ns2__InvoiceHeader::amexDataTAA2, "xsd:string"))
				{	soap_flag_amexDataTAA21--;
					continue;
				}
			if (soap_flag_amexDataTAA31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:amexDataTAA3", (wchar_t**)&a->ns2__InvoiceHeader::amexDataTAA3, "xsd:string"))
				{	soap_flag_amexDataTAA31--;
					continue;
				}
			if (soap_flag_amexDataTAA41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:amexDataTAA4", (wchar_t**)&a->ns2__InvoiceHeader::amexDataTAA4, "xsd:string"))
				{	soap_flag_amexDataTAA41--;
					continue;
				}
			if (soap_flag_invoiceDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:invoiceDate", (wchar_t**)&a->ns2__InvoiceHeader::invoiceDate, "xsd:string"))
				{	soap_flag_invoiceDate1--;
					continue;
				}
			if (soap_flag_totalTaxTypeCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:totalTaxTypeCode", (wchar_t**)&a->ns2__InvoiceHeader::totalTaxTypeCode, "xsd:string"))
				{	soap_flag_totalTaxTypeCode1--;
					continue;
				}
			if (soap_flag_cardAcceptorRefNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardAcceptorRefNumber", (wchar_t**)&a->ns2__InvoiceHeader::cardAcceptorRefNumber, "xsd:string"))
				{	soap_flag_cardAcceptorRefNumber1--;
					continue;
				}
			if (soap_flag_authorizedContactName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authorizedContactName", (wchar_t**)&a->ns2__InvoiceHeader::authorizedContactName, "xsd:string"))
				{	soap_flag_authorizedContactName1--;
					continue;
				}
			if (soap_flag_businessApplicationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:businessApplicationID", (wchar_t**)&a->ns2__InvoiceHeader::businessApplicationID, "xsd:string"))
				{	soap_flag_businessApplicationID1--;
					continue;
				}
			if (soap_flag_salesOrganizationID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:salesOrganizationID", &a->ns2__InvoiceHeader::salesOrganizationID, "xsd:integer"))
				{	soap_flag_salesOrganizationID1--;
					continue;
				}
			if (soap_flag_submerchantID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:submerchantID", (wchar_t**)&a->ns2__InvoiceHeader::submerchantID, "xsd:string"))
				{	soap_flag_submerchantID1--;
					continue;
				}
			if (soap_flag_submerchantName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:submerchantName", (wchar_t**)&a->ns2__InvoiceHeader::submerchantName, "xsd:string"))
				{	soap_flag_submerchantName1--;
					continue;
				}
			if (soap_flag_submerchantStreet1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:submerchantStreet", (wchar_t**)&a->ns2__InvoiceHeader::submerchantStreet, "xsd:string"))
				{	soap_flag_submerchantStreet1--;
					continue;
				}
			if (soap_flag_submerchantCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:submerchantCity", (wchar_t**)&a->ns2__InvoiceHeader::submerchantCity, "xsd:string"))
				{	soap_flag_submerchantCity1--;
					continue;
				}
			if (soap_flag_submerchantPostalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:submerchantPostalCode", (wchar_t**)&a->ns2__InvoiceHeader::submerchantPostalCode, "xsd:string"))
				{	soap_flag_submerchantPostalCode1--;
					continue;
				}
			if (soap_flag_submerchantState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:submerchantState", (wchar_t**)&a->ns2__InvoiceHeader::submerchantState, "xsd:string"))
				{	soap_flag_submerchantState1--;
					continue;
				}
			if (soap_flag_submerchantCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:submerchantCountry", (wchar_t**)&a->ns2__InvoiceHeader::submerchantCountry, "xsd:string"))
				{	soap_flag_submerchantCountry1--;
					continue;
				}
			if (soap_flag_submerchantEmail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:submerchantEmail", (wchar_t**)&a->ns2__InvoiceHeader::submerchantEmail, "xsd:string"))
				{	soap_flag_submerchantEmail1--;
					continue;
				}
			if (soap_flag_submerchantTelephoneNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:submerchantTelephoneNumber", (wchar_t**)&a->ns2__InvoiceHeader::submerchantTelephoneNumber, "xsd:string"))
				{	soap_flag_submerchantTelephoneNumber1--;
					continue;
				}
			if (soap_flag_submerchantRegion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:submerchantRegion", (wchar_t**)&a->ns2__InvoiceHeader::submerchantRegion, "xsd:string"))
				{	soap_flag_submerchantRegion1--;
					continue;
				}
			if (soap_flag_submerchantMerchantID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:submerchantMerchantID", (wchar_t**)&a->ns2__InvoiceHeader::submerchantMerchantID, "xsd:string"))
				{	soap_flag_submerchantMerchantID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__InvoiceHeader *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__InvoiceHeader, SOAP_TYPE_ns2__InvoiceHeader, sizeof(ns2__InvoiceHeader), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__InvoiceHeader * SOAP_FMAC2 soap_instantiate_ns2__InvoiceHeader(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__InvoiceHeader(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__InvoiceHeader *p;
	size_t k = sizeof(ns2__InvoiceHeader);
	if (n < 0)
	{	p = SOAP_NEW(ns2__InvoiceHeader);
		if (p)
			((ns2__InvoiceHeader*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__InvoiceHeader, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__InvoiceHeader*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__InvoiceHeader location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__InvoiceHeader, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__InvoiceHeader::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:InvoiceHeader", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__InvoiceHeader::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__InvoiceHeader(soap, this, tag, type);
}

SOAP_FMAC3 ns2__InvoiceHeader * SOAP_FMAC4 soap_get_ns2__InvoiceHeader(struct soap *soap, ns2__InvoiceHeader *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__InvoiceHeader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__EncryptPaymentDataService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__EncryptPaymentDataService::run = NULL;
	/* transient soap skipped */
}

void ns2__EncryptPaymentDataService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__EncryptPaymentDataService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__EncryptPaymentDataService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EncryptPaymentDataService(struct soap *soap, const char *tag, int id, const ns2__EncryptPaymentDataService *a, const char *type)
{
	if (((ns2__EncryptPaymentDataService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__EncryptPaymentDataService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EncryptPaymentDataService), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__EncryptPaymentDataService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__EncryptPaymentDataService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__EncryptPaymentDataService * SOAP_FMAC4 soap_in_ns2__EncryptPaymentDataService(struct soap *soap, const char *tag, ns2__EncryptPaymentDataService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__EncryptPaymentDataService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EncryptPaymentDataService, sizeof(ns2__EncryptPaymentDataService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__EncryptPaymentDataService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__EncryptPaymentDataService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__EncryptPaymentDataService*)a)->run))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__EncryptPaymentDataService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EncryptPaymentDataService, SOAP_TYPE_ns2__EncryptPaymentDataService, sizeof(ns2__EncryptPaymentDataService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__EncryptPaymentDataService * SOAP_FMAC2 soap_instantiate_ns2__EncryptPaymentDataService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__EncryptPaymentDataService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__EncryptPaymentDataService *p;
	size_t k = sizeof(ns2__EncryptPaymentDataService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__EncryptPaymentDataService);
		if (p)
			((ns2__EncryptPaymentDataService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__EncryptPaymentDataService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__EncryptPaymentDataService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__EncryptPaymentDataService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__EncryptPaymentDataService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__EncryptPaymentDataService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:EncryptPaymentDataService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__EncryptPaymentDataService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__EncryptPaymentDataService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__EncryptPaymentDataService * SOAP_FMAC4 soap_get_ns2__EncryptPaymentDataService(struct soap *soap, ns2__EncryptPaymentDataService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EncryptPaymentDataService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CaseManagementActionService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CaseManagementActionService::actionCode = NULL;
	this->ns2__CaseManagementActionService::requestID = NULL;
	this->ns2__CaseManagementActionService::comments = NULL;
	this->ns2__CaseManagementActionService::run = NULL;
	/* transient soap skipped */
}

void ns2__CaseManagementActionService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CaseManagementActionService::actionCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CaseManagementActionService::requestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CaseManagementActionService::comments);
#endif
}

int ns2__CaseManagementActionService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CaseManagementActionService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CaseManagementActionService(struct soap *soap, const char *tag, int id, const ns2__CaseManagementActionService *a, const char *type)
{
	if (((ns2__CaseManagementActionService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__CaseManagementActionService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CaseManagementActionService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:actionCode", -1, (wchar_t*const*)&a->ns2__CaseManagementActionService::actionCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:requestID", -1, (wchar_t*const*)&a->ns2__CaseManagementActionService::requestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:comments", -1, (wchar_t*const*)&a->ns2__CaseManagementActionService::comments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CaseManagementActionService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CaseManagementActionService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CaseManagementActionService * SOAP_FMAC4 soap_in_ns2__CaseManagementActionService(struct soap *soap, const char *tag, ns2__CaseManagementActionService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CaseManagementActionService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CaseManagementActionService, sizeof(ns2__CaseManagementActionService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CaseManagementActionService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CaseManagementActionService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__CaseManagementActionService*)a)->run))
		return NULL;
	size_t soap_flag_actionCode1 = 1;
	size_t soap_flag_requestID1 = 1;
	size_t soap_flag_comments1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_actionCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:actionCode", (wchar_t**)&a->ns2__CaseManagementActionService::actionCode, "xsd:string"))
				{	soap_flag_actionCode1--;
					continue;
				}
			if (soap_flag_requestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:requestID", (wchar_t**)&a->ns2__CaseManagementActionService::requestID, "xsd:string"))
				{	soap_flag_requestID1--;
					continue;
				}
			if (soap_flag_comments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:comments", (wchar_t**)&a->ns2__CaseManagementActionService::comments, "xsd:string"))
				{	soap_flag_comments1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CaseManagementActionService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CaseManagementActionService, SOAP_TYPE_ns2__CaseManagementActionService, sizeof(ns2__CaseManagementActionService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CaseManagementActionService * SOAP_FMAC2 soap_instantiate_ns2__CaseManagementActionService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CaseManagementActionService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CaseManagementActionService *p;
	size_t k = sizeof(ns2__CaseManagementActionService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CaseManagementActionService);
		if (p)
			((ns2__CaseManagementActionService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CaseManagementActionService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CaseManagementActionService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CaseManagementActionService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CaseManagementActionService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CaseManagementActionService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CaseManagementActionService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CaseManagementActionService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CaseManagementActionService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CaseManagementActionService * SOAP_FMAC4 soap_get_ns2__CaseManagementActionService(struct soap *soap, ns2__CaseManagementActionService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CaseManagementActionService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__FraudUpdateService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__FraudUpdateService::actionCode = NULL;
	this->ns2__FraudUpdateService::markedData = NULL;
	this->ns2__FraudUpdateService::markingReason = NULL;
	this->ns2__FraudUpdateService::markingNotes = NULL;
	this->ns2__FraudUpdateService::markingRequestID = NULL;
	this->ns2__FraudUpdateService::run = NULL;
	/* transient soap skipped */
}

void ns2__FraudUpdateService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__FraudUpdateService::actionCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__FraudUpdateService::markedData);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__FraudUpdateService::markingReason);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__FraudUpdateService::markingNotes);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__FraudUpdateService::markingRequestID);
#endif
}

int ns2__FraudUpdateService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FraudUpdateService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FraudUpdateService(struct soap *soap, const char *tag, int id, const ns2__FraudUpdateService *a, const char *type)
{
	if (((ns2__FraudUpdateService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__FraudUpdateService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FraudUpdateService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:actionCode", -1, (wchar_t*const*)&a->ns2__FraudUpdateService::actionCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:markedData", -1, (wchar_t*const*)&a->ns2__FraudUpdateService::markedData, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:markingReason", -1, (wchar_t*const*)&a->ns2__FraudUpdateService::markingReason, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:markingNotes", -1, (wchar_t*const*)&a->ns2__FraudUpdateService::markingNotes, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:markingRequestID", -1, (wchar_t*const*)&a->ns2__FraudUpdateService::markingRequestID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__FraudUpdateService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FraudUpdateService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FraudUpdateService * SOAP_FMAC4 soap_in_ns2__FraudUpdateService(struct soap *soap, const char *tag, ns2__FraudUpdateService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FraudUpdateService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FraudUpdateService, sizeof(ns2__FraudUpdateService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__FraudUpdateService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__FraudUpdateService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__FraudUpdateService*)a)->run))
		return NULL;
	size_t soap_flag_actionCode1 = 1;
	size_t soap_flag_markedData1 = 1;
	size_t soap_flag_markingReason1 = 1;
	size_t soap_flag_markingNotes1 = 1;
	size_t soap_flag_markingRequestID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_actionCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:actionCode", (wchar_t**)&a->ns2__FraudUpdateService::actionCode, "xsd:string"))
				{	soap_flag_actionCode1--;
					continue;
				}
			if (soap_flag_markedData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:markedData", (wchar_t**)&a->ns2__FraudUpdateService::markedData, "xsd:string"))
				{	soap_flag_markedData1--;
					continue;
				}
			if (soap_flag_markingReason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:markingReason", (wchar_t**)&a->ns2__FraudUpdateService::markingReason, "xsd:string"))
				{	soap_flag_markingReason1--;
					continue;
				}
			if (soap_flag_markingNotes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:markingNotes", (wchar_t**)&a->ns2__FraudUpdateService::markingNotes, "xsd:string"))
				{	soap_flag_markingNotes1--;
					continue;
				}
			if (soap_flag_markingRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:markingRequestID", (wchar_t**)&a->ns2__FraudUpdateService::markingRequestID, "xsd:string"))
				{	soap_flag_markingRequestID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__FraudUpdateService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FraudUpdateService, SOAP_TYPE_ns2__FraudUpdateService, sizeof(ns2__FraudUpdateService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__FraudUpdateService * SOAP_FMAC2 soap_instantiate_ns2__FraudUpdateService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FraudUpdateService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__FraudUpdateService *p;
	size_t k = sizeof(ns2__FraudUpdateService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__FraudUpdateService);
		if (p)
			((ns2__FraudUpdateService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__FraudUpdateService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__FraudUpdateService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__FraudUpdateService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__FraudUpdateService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__FraudUpdateService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:FraudUpdateService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FraudUpdateService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FraudUpdateService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FraudUpdateService * SOAP_FMAC4 soap_get_ns2__FraudUpdateService(struct soap *soap, ns2__FraudUpdateService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FraudUpdateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__RiskUpdateService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RiskUpdateService::actionCode = NULL;
	this->ns2__RiskUpdateService::recordID = NULL;
	this->ns2__RiskUpdateService::recordName = NULL;
	this->ns2__RiskUpdateService::negativeAddress = NULL;
	this->ns2__RiskUpdateService::markingReason = NULL;
	this->ns2__RiskUpdateService::markingNotes = NULL;
	this->ns2__RiskUpdateService::markingRequestID = NULL;
	this->ns2__RiskUpdateService::deviceFingerprintSmartID = NULL;
	this->ns2__RiskUpdateService::deviceFingerprintTrueIPAddress = NULL;
	this->ns2__RiskUpdateService::deviceFingerprintProxyIPAddress = NULL;
	this->ns2__RiskUpdateService::run = NULL;
	/* transient soap skipped */
}

void ns2__RiskUpdateService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RiskUpdateService::actionCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RiskUpdateService::recordID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RiskUpdateService::recordName);
	soap_serialize_PointerTons2__Address(soap, &this->ns2__RiskUpdateService::negativeAddress);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RiskUpdateService::markingReason);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RiskUpdateService::markingNotes);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RiskUpdateService::markingRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RiskUpdateService::deviceFingerprintSmartID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RiskUpdateService::deviceFingerprintTrueIPAddress);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__RiskUpdateService::deviceFingerprintProxyIPAddress);
#endif
}

int ns2__RiskUpdateService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RiskUpdateService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RiskUpdateService(struct soap *soap, const char *tag, int id, const ns2__RiskUpdateService *a, const char *type)
{
	if (((ns2__RiskUpdateService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__RiskUpdateService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RiskUpdateService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:actionCode", -1, (wchar_t*const*)&a->ns2__RiskUpdateService::actionCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:recordID", -1, (wchar_t*const*)&a->ns2__RiskUpdateService::recordID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:recordName", -1, (wchar_t*const*)&a->ns2__RiskUpdateService::recordName, ""))
		return soap->error;
	if (soap_out_PointerTons2__Address(soap, "ns2:negativeAddress", -1, &a->ns2__RiskUpdateService::negativeAddress, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:markingReason", -1, (wchar_t*const*)&a->ns2__RiskUpdateService::markingReason, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:markingNotes", -1, (wchar_t*const*)&a->ns2__RiskUpdateService::markingNotes, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:markingRequestID", -1, (wchar_t*const*)&a->ns2__RiskUpdateService::markingRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:deviceFingerprintSmartID", -1, (wchar_t*const*)&a->ns2__RiskUpdateService::deviceFingerprintSmartID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:deviceFingerprintTrueIPAddress", -1, (wchar_t*const*)&a->ns2__RiskUpdateService::deviceFingerprintTrueIPAddress, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:deviceFingerprintProxyIPAddress", -1, (wchar_t*const*)&a->ns2__RiskUpdateService::deviceFingerprintProxyIPAddress, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__RiskUpdateService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RiskUpdateService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RiskUpdateService * SOAP_FMAC4 soap_in_ns2__RiskUpdateService(struct soap *soap, const char *tag, ns2__RiskUpdateService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RiskUpdateService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RiskUpdateService, sizeof(ns2__RiskUpdateService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__RiskUpdateService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__RiskUpdateService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__RiskUpdateService*)a)->run))
		return NULL;
	size_t soap_flag_actionCode1 = 1;
	size_t soap_flag_recordID1 = 1;
	size_t soap_flag_recordName1 = 1;
	size_t soap_flag_negativeAddress1 = 1;
	size_t soap_flag_markingReason1 = 1;
	size_t soap_flag_markingNotes1 = 1;
	size_t soap_flag_markingRequestID1 = 1;
	size_t soap_flag_deviceFingerprintSmartID1 = 1;
	size_t soap_flag_deviceFingerprintTrueIPAddress1 = 1;
	size_t soap_flag_deviceFingerprintProxyIPAddress1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_actionCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:actionCode", (wchar_t**)&a->ns2__RiskUpdateService::actionCode, "xsd:string"))
				{	soap_flag_actionCode1--;
					continue;
				}
			if (soap_flag_recordID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:recordID", (wchar_t**)&a->ns2__RiskUpdateService::recordID, "xsd:string"))
				{	soap_flag_recordID1--;
					continue;
				}
			if (soap_flag_recordName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:recordName", (wchar_t**)&a->ns2__RiskUpdateService::recordName, "xsd:string"))
				{	soap_flag_recordName1--;
					continue;
				}
			if (soap_flag_negativeAddress1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Address(soap, "ns2:negativeAddress", &a->ns2__RiskUpdateService::negativeAddress, "ns2:Address"))
				{	soap_flag_negativeAddress1--;
					continue;
				}
			if (soap_flag_markingReason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:markingReason", (wchar_t**)&a->ns2__RiskUpdateService::markingReason, "xsd:string"))
				{	soap_flag_markingReason1--;
					continue;
				}
			if (soap_flag_markingNotes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:markingNotes", (wchar_t**)&a->ns2__RiskUpdateService::markingNotes, "xsd:string"))
				{	soap_flag_markingNotes1--;
					continue;
				}
			if (soap_flag_markingRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:markingRequestID", (wchar_t**)&a->ns2__RiskUpdateService::markingRequestID, "xsd:string"))
				{	soap_flag_markingRequestID1--;
					continue;
				}
			if (soap_flag_deviceFingerprintSmartID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:deviceFingerprintSmartID", (wchar_t**)&a->ns2__RiskUpdateService::deviceFingerprintSmartID, "xsd:string"))
				{	soap_flag_deviceFingerprintSmartID1--;
					continue;
				}
			if (soap_flag_deviceFingerprintTrueIPAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:deviceFingerprintTrueIPAddress", (wchar_t**)&a->ns2__RiskUpdateService::deviceFingerprintTrueIPAddress, "xsd:string"))
				{	soap_flag_deviceFingerprintTrueIPAddress1--;
					continue;
				}
			if (soap_flag_deviceFingerprintProxyIPAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:deviceFingerprintProxyIPAddress", (wchar_t**)&a->ns2__RiskUpdateService::deviceFingerprintProxyIPAddress, "xsd:string"))
				{	soap_flag_deviceFingerprintProxyIPAddress1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RiskUpdateService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RiskUpdateService, SOAP_TYPE_ns2__RiskUpdateService, sizeof(ns2__RiskUpdateService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__RiskUpdateService * SOAP_FMAC2 soap_instantiate_ns2__RiskUpdateService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RiskUpdateService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__RiskUpdateService *p;
	size_t k = sizeof(ns2__RiskUpdateService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__RiskUpdateService);
		if (p)
			((ns2__RiskUpdateService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__RiskUpdateService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__RiskUpdateService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__RiskUpdateService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__RiskUpdateService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__RiskUpdateService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:RiskUpdateService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RiskUpdateService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RiskUpdateService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RiskUpdateService * SOAP_FMAC4 soap_get_ns2__RiskUpdateService(struct soap *soap, ns2__RiskUpdateService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RiskUpdateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APCheckStatusService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APCheckStatusService::apInitiateRequestID = NULL;
	this->ns2__APCheckStatusService::reconciliationID = NULL;
	this->ns2__APCheckStatusService::checkStatusRequestID = NULL;
	this->ns2__APCheckStatusService::run = NULL;
	/* transient soap skipped */
}

void ns2__APCheckStatusService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APCheckStatusService::apInitiateRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APCheckStatusService::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APCheckStatusService::checkStatusRequestID);
#endif
}

int ns2__APCheckStatusService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APCheckStatusService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APCheckStatusService(struct soap *soap, const char *tag, int id, const ns2__APCheckStatusService *a, const char *type)
{
	if (((ns2__APCheckStatusService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__APCheckStatusService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APCheckStatusService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:apInitiateRequestID", -1, (wchar_t*const*)&a->ns2__APCheckStatusService::apInitiateRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__APCheckStatusService::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:checkStatusRequestID", -1, (wchar_t*const*)&a->ns2__APCheckStatusService::checkStatusRequestID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APCheckStatusService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APCheckStatusService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APCheckStatusService * SOAP_FMAC4 soap_in_ns2__APCheckStatusService(struct soap *soap, const char *tag, ns2__APCheckStatusService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APCheckStatusService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APCheckStatusService, sizeof(ns2__APCheckStatusService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APCheckStatusService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APCheckStatusService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__APCheckStatusService*)a)->run))
		return NULL;
	size_t soap_flag_apInitiateRequestID1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_checkStatusRequestID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_apInitiateRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:apInitiateRequestID", (wchar_t**)&a->ns2__APCheckStatusService::apInitiateRequestID, "xsd:string"))
				{	soap_flag_apInitiateRequestID1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__APCheckStatusService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_checkStatusRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:checkStatusRequestID", (wchar_t**)&a->ns2__APCheckStatusService::checkStatusRequestID, "xsd:string"))
				{	soap_flag_checkStatusRequestID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__APCheckStatusService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APCheckStatusService, SOAP_TYPE_ns2__APCheckStatusService, sizeof(ns2__APCheckStatusService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APCheckStatusService * SOAP_FMAC2 soap_instantiate_ns2__APCheckStatusService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APCheckStatusService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APCheckStatusService *p;
	size_t k = sizeof(ns2__APCheckStatusService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APCheckStatusService);
		if (p)
			((ns2__APCheckStatusService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APCheckStatusService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APCheckStatusService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APCheckStatusService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APCheckStatusService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APCheckStatusService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APCheckStatusService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APCheckStatusService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APCheckStatusService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APCheckStatusService * SOAP_FMAC4 soap_get_ns2__APCheckStatusService(struct soap *soap, ns2__APCheckStatusService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APCheckStatusService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__APInitiateService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__APInitiateService::returnURL = NULL;
	this->ns2__APInitiateService::productName = NULL;
	this->ns2__APInitiateService::productDescription = NULL;
	this->ns2__APInitiateService::reconciliationID = NULL;
	this->ns2__APInitiateService::bankID = NULL;
	this->ns2__APInitiateService::countryCode = NULL;
	this->ns2__APInitiateService::escrowAgreement = NULL;
	this->ns2__APInitiateService::languageInterface = NULL;
	this->ns2__APInitiateService::intent = NULL;
	this->ns2__APInitiateService::successURL = NULL;
	this->ns2__APInitiateService::cancelURL = NULL;
	this->ns2__APInitiateService::failureURL = NULL;
	this->ns2__APInitiateService::overridePaymentMethod = NULL;
	this->ns2__APInitiateService::run = NULL;
	/* transient soap skipped */
}

void ns2__APInitiateService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APInitiateService::returnURL);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APInitiateService::productName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APInitiateService::productDescription);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APInitiateService::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APInitiateService::bankID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APInitiateService::countryCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APInitiateService::escrowAgreement);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APInitiateService::languageInterface);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APInitiateService::intent);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APInitiateService::successURL);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APInitiateService::cancelURL);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APInitiateService::failureURL);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__APInitiateService::overridePaymentMethod);
#endif
}

int ns2__APInitiateService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__APInitiateService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__APInitiateService(struct soap *soap, const char *tag, int id, const ns2__APInitiateService *a, const char *type)
{
	if (((ns2__APInitiateService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__APInitiateService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__APInitiateService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:returnURL", -1, (wchar_t*const*)&a->ns2__APInitiateService::returnURL, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:productName", -1, (wchar_t*const*)&a->ns2__APInitiateService::productName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:productDescription", -1, (wchar_t*const*)&a->ns2__APInitiateService::productDescription, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__APInitiateService::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:bankID", -1, (wchar_t*const*)&a->ns2__APInitiateService::bankID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:countryCode", -1, (wchar_t*const*)&a->ns2__APInitiateService::countryCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:escrowAgreement", -1, (wchar_t*const*)&a->ns2__APInitiateService::escrowAgreement, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:languageInterface", -1, (wchar_t*const*)&a->ns2__APInitiateService::languageInterface, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:intent", -1, (wchar_t*const*)&a->ns2__APInitiateService::intent, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:successURL", -1, (wchar_t*const*)&a->ns2__APInitiateService::successURL, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cancelURL", -1, (wchar_t*const*)&a->ns2__APInitiateService::cancelURL, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:failureURL", -1, (wchar_t*const*)&a->ns2__APInitiateService::failureURL, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:overridePaymentMethod", -1, (wchar_t*const*)&a->ns2__APInitiateService::overridePaymentMethod, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__APInitiateService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__APInitiateService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__APInitiateService * SOAP_FMAC4 soap_in_ns2__APInitiateService(struct soap *soap, const char *tag, ns2__APInitiateService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__APInitiateService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__APInitiateService, sizeof(ns2__APInitiateService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__APInitiateService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__APInitiateService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__APInitiateService*)a)->run))
		return NULL;
	size_t soap_flag_returnURL1 = 1;
	size_t soap_flag_productName1 = 1;
	size_t soap_flag_productDescription1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_bankID1 = 1;
	size_t soap_flag_countryCode1 = 1;
	size_t soap_flag_escrowAgreement1 = 1;
	size_t soap_flag_languageInterface1 = 1;
	size_t soap_flag_intent1 = 1;
	size_t soap_flag_successURL1 = 1;
	size_t soap_flag_cancelURL1 = 1;
	size_t soap_flag_failureURL1 = 1;
	size_t soap_flag_overridePaymentMethod1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:returnURL", (wchar_t**)&a->ns2__APInitiateService::returnURL, "xsd:string"))
				{	soap_flag_returnURL1--;
					continue;
				}
			if (soap_flag_productName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:productName", (wchar_t**)&a->ns2__APInitiateService::productName, "xsd:string"))
				{	soap_flag_productName1--;
					continue;
				}
			if (soap_flag_productDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:productDescription", (wchar_t**)&a->ns2__APInitiateService::productDescription, "xsd:string"))
				{	soap_flag_productDescription1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__APInitiateService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_bankID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:bankID", (wchar_t**)&a->ns2__APInitiateService::bankID, "xsd:string"))
				{	soap_flag_bankID1--;
					continue;
				}
			if (soap_flag_countryCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:countryCode", (wchar_t**)&a->ns2__APInitiateService::countryCode, "xsd:string"))
				{	soap_flag_countryCode1--;
					continue;
				}
			if (soap_flag_escrowAgreement1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:escrowAgreement", (wchar_t**)&a->ns2__APInitiateService::escrowAgreement, "xsd:string"))
				{	soap_flag_escrowAgreement1--;
					continue;
				}
			if (soap_flag_languageInterface1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:languageInterface", (wchar_t**)&a->ns2__APInitiateService::languageInterface, "xsd:string"))
				{	soap_flag_languageInterface1--;
					continue;
				}
			if (soap_flag_intent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:intent", (wchar_t**)&a->ns2__APInitiateService::intent, "xsd:string"))
				{	soap_flag_intent1--;
					continue;
				}
			if (soap_flag_successURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:successURL", (wchar_t**)&a->ns2__APInitiateService::successURL, "xsd:string"))
				{	soap_flag_successURL1--;
					continue;
				}
			if (soap_flag_cancelURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cancelURL", (wchar_t**)&a->ns2__APInitiateService::cancelURL, "xsd:string"))
				{	soap_flag_cancelURL1--;
					continue;
				}
			if (soap_flag_failureURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:failureURL", (wchar_t**)&a->ns2__APInitiateService::failureURL, "xsd:string"))
				{	soap_flag_failureURL1--;
					continue;
				}
			if (soap_flag_overridePaymentMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:overridePaymentMethod", (wchar_t**)&a->ns2__APInitiateService::overridePaymentMethod, "xsd:string"))
				{	soap_flag_overridePaymentMethod1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__APInitiateService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__APInitiateService, SOAP_TYPE_ns2__APInitiateService, sizeof(ns2__APInitiateService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__APInitiateService * SOAP_FMAC2 soap_instantiate_ns2__APInitiateService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__APInitiateService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__APInitiateService *p;
	size_t k = sizeof(ns2__APInitiateService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__APInitiateService);
		if (p)
			((ns2__APInitiateService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__APInitiateService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__APInitiateService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__APInitiateService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__APInitiateService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__APInitiateService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:APInitiateService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__APInitiateService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__APInitiateService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__APInitiateService * SOAP_FMAC4 soap_get_ns2__APInitiateService(struct soap *soap, ns2__APInitiateService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__APInitiateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Address::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Address::street1 = NULL;
	this->ns2__Address::street2 = NULL;
	this->ns2__Address::city = NULL;
	this->ns2__Address::state = NULL;
	this->ns2__Address::postalCode = NULL;
	this->ns2__Address::country = NULL;
	/* transient soap skipped */
}

void ns2__Address::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Address::street1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Address::street2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Address::city);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Address::state);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Address::postalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Address::country);
#endif
}

int ns2__Address::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Address(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Address(struct soap *soap, const char *tag, int id, const ns2__Address *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Address), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:street1", -1, (wchar_t*const*)&a->ns2__Address::street1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:street2", -1, (wchar_t*const*)&a->ns2__Address::street2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:city", -1, (wchar_t*const*)&a->ns2__Address::city, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:state", -1, (wchar_t*const*)&a->ns2__Address::state, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:postalCode", -1, (wchar_t*const*)&a->ns2__Address::postalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:country", -1, (wchar_t*const*)&a->ns2__Address::country, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Address::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Address(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Address * SOAP_FMAC4 soap_in_ns2__Address(struct soap *soap, const char *tag, ns2__Address *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Address *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Address, sizeof(ns2__Address), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Address)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Address *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_street11 = 1;
	size_t soap_flag_street21 = 1;
	size_t soap_flag_city1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_postalCode1 = 1;
	size_t soap_flag_country1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_street11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:street1", (wchar_t**)&a->ns2__Address::street1, "xsd:string"))
				{	soap_flag_street11--;
					continue;
				}
			if (soap_flag_street21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:street2", (wchar_t**)&a->ns2__Address::street2, "xsd:string"))
				{	soap_flag_street21--;
					continue;
				}
			if (soap_flag_city1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:city", (wchar_t**)&a->ns2__Address::city, "xsd:string"))
				{	soap_flag_city1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:state", (wchar_t**)&a->ns2__Address::state, "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_postalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:postalCode", (wchar_t**)&a->ns2__Address::postalCode, "xsd:string"))
				{	soap_flag_postalCode1--;
					continue;
				}
			if (soap_flag_country1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:country", (wchar_t**)&a->ns2__Address::country, "xsd:string"))
				{	soap_flag_country1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Address, SOAP_TYPE_ns2__Address, sizeof(ns2__Address), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Address * SOAP_FMAC2 soap_instantiate_ns2__Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Address(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Address *p;
	size_t k = sizeof(ns2__Address);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Address);
		if (p)
			((ns2__Address*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Address, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Address*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Address location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Address, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Address::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:Address", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Address::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Address(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Address * SOAP_FMAC4 soap_get_ns2__Address(struct soap *soap, ns2__Address *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PersonalId::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PersonalId::number = NULL;
	this->ns2__PersonalId::type = NULL;
	this->ns2__PersonalId::name = NULL;
	this->ns2__PersonalId::country = NULL;
	this->ns2__PersonalId::address = NULL;
	/* transient soap skipped */
}

void ns2__PersonalId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PersonalId::number);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PersonalId::type);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PersonalId::name);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PersonalId::country);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PersonalId::address);
#endif
}

int ns2__PersonalId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PersonalId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PersonalId(struct soap *soap, const char *tag, int id, const ns2__PersonalId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PersonalId), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:number", -1, (wchar_t*const*)&a->ns2__PersonalId::number, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:type", -1, (wchar_t*const*)&a->ns2__PersonalId::type, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:name", -1, (wchar_t*const*)&a->ns2__PersonalId::name, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:country", -1, (wchar_t*const*)&a->ns2__PersonalId::country, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:address", -1, (wchar_t*const*)&a->ns2__PersonalId::address, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PersonalId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PersonalId(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PersonalId * SOAP_FMAC4 soap_in_ns2__PersonalId(struct soap *soap, const char *tag, ns2__PersonalId *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PersonalId *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PersonalId, sizeof(ns2__PersonalId), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PersonalId)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PersonalId *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_number1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_country1 = 1;
	size_t soap_flag_address1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_number1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:number", (wchar_t**)&a->ns2__PersonalId::number, "xsd:string"))
				{	soap_flag_number1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:type", (wchar_t**)&a->ns2__PersonalId::type, "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:name", (wchar_t**)&a->ns2__PersonalId::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_country1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:country", (wchar_t**)&a->ns2__PersonalId::country, "xsd:string"))
				{	soap_flag_country1--;
					continue;
				}
			if (soap_flag_address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:address", (wchar_t**)&a->ns2__PersonalId::address, "xsd:string"))
				{	soap_flag_address1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PersonalId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PersonalId, SOAP_TYPE_ns2__PersonalId, sizeof(ns2__PersonalId), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PersonalId * SOAP_FMAC2 soap_instantiate_ns2__PersonalId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PersonalId(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PersonalId *p;
	size_t k = sizeof(ns2__PersonalId);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PersonalId);
		if (p)
			((ns2__PersonalId*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PersonalId, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PersonalId*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PersonalId location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PersonalId, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PersonalId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PersonalId", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PersonalId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PersonalId(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PersonalId * SOAP_FMAC4 soap_get_ns2__PersonalId(struct soap *soap, ns2__PersonalId *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PersonalId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__BoletoPaymentService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__BoletoPaymentService::instruction = NULL;
	this->ns2__BoletoPaymentService::expirationDate = NULL;
	this->ns2__BoletoPaymentService::reconciliationID = NULL;
	this->ns2__BoletoPaymentService::run = NULL;
	/* transient soap skipped */
}

void ns2__BoletoPaymentService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BoletoPaymentService::instruction);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BoletoPaymentService::expirationDate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BoletoPaymentService::reconciliationID);
#endif
}

int ns2__BoletoPaymentService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__BoletoPaymentService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BoletoPaymentService(struct soap *soap, const char *tag, int id, const ns2__BoletoPaymentService *a, const char *type)
{
	if (((ns2__BoletoPaymentService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__BoletoPaymentService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BoletoPaymentService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:instruction", -1, (wchar_t*const*)&a->ns2__BoletoPaymentService::instruction, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:expirationDate", -1, (wchar_t*const*)&a->ns2__BoletoPaymentService::expirationDate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__BoletoPaymentService::reconciliationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__BoletoPaymentService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__BoletoPaymentService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__BoletoPaymentService * SOAP_FMAC4 soap_in_ns2__BoletoPaymentService(struct soap *soap, const char *tag, ns2__BoletoPaymentService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__BoletoPaymentService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BoletoPaymentService, sizeof(ns2__BoletoPaymentService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__BoletoPaymentService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__BoletoPaymentService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__BoletoPaymentService*)a)->run))
		return NULL;
	size_t soap_flag_instruction1 = 1;
	size_t soap_flag_expirationDate1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_instruction1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:instruction", (wchar_t**)&a->ns2__BoletoPaymentService::instruction, "xsd:string"))
				{	soap_flag_instruction1--;
					continue;
				}
			if (soap_flag_expirationDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:expirationDate", (wchar_t**)&a->ns2__BoletoPaymentService::expirationDate, "xsd:string"))
				{	soap_flag_expirationDate1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__BoletoPaymentService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__BoletoPaymentService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BoletoPaymentService, SOAP_TYPE_ns2__BoletoPaymentService, sizeof(ns2__BoletoPaymentService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__BoletoPaymentService * SOAP_FMAC2 soap_instantiate_ns2__BoletoPaymentService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__BoletoPaymentService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__BoletoPaymentService *p;
	size_t k = sizeof(ns2__BoletoPaymentService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__BoletoPaymentService);
		if (p)
			((ns2__BoletoPaymentService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__BoletoPaymentService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__BoletoPaymentService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__BoletoPaymentService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__BoletoPaymentService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__BoletoPaymentService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:BoletoPaymentService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__BoletoPaymentService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__BoletoPaymentService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__BoletoPaymentService * SOAP_FMAC4 soap_get_ns2__BoletoPaymentService(struct soap *soap, ns2__BoletoPaymentService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BoletoPaymentService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ChinaRefundService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ChinaRefundService::chinaPaymentRequestID = NULL;
	this->ns2__ChinaRefundService::chinaPaymentRequestToken = NULL;
	this->ns2__ChinaRefundService::refundReason = NULL;
	this->ns2__ChinaRefundService::run = NULL;
	/* transient soap skipped */
}

void ns2__ChinaRefundService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ChinaRefundService::chinaPaymentRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ChinaRefundService::chinaPaymentRequestToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ChinaRefundService::refundReason);
#endif
}

int ns2__ChinaRefundService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ChinaRefundService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ChinaRefundService(struct soap *soap, const char *tag, int id, const ns2__ChinaRefundService *a, const char *type)
{
	if (((ns2__ChinaRefundService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__ChinaRefundService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ChinaRefundService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:chinaPaymentRequestID", -1, (wchar_t*const*)&a->ns2__ChinaRefundService::chinaPaymentRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:chinaPaymentRequestToken", -1, (wchar_t*const*)&a->ns2__ChinaRefundService::chinaPaymentRequestToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:refundReason", -1, (wchar_t*const*)&a->ns2__ChinaRefundService::refundReason, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ChinaRefundService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ChinaRefundService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ChinaRefundService * SOAP_FMAC4 soap_in_ns2__ChinaRefundService(struct soap *soap, const char *tag, ns2__ChinaRefundService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ChinaRefundService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ChinaRefundService, sizeof(ns2__ChinaRefundService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ChinaRefundService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ChinaRefundService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__ChinaRefundService*)a)->run))
		return NULL;
	size_t soap_flag_chinaPaymentRequestID1 = 1;
	size_t soap_flag_chinaPaymentRequestToken1 = 1;
	size_t soap_flag_refundReason1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chinaPaymentRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:chinaPaymentRequestID", (wchar_t**)&a->ns2__ChinaRefundService::chinaPaymentRequestID, "xsd:string"))
				{	soap_flag_chinaPaymentRequestID1--;
					continue;
				}
			if (soap_flag_chinaPaymentRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:chinaPaymentRequestToken", (wchar_t**)&a->ns2__ChinaRefundService::chinaPaymentRequestToken, "xsd:string"))
				{	soap_flag_chinaPaymentRequestToken1--;
					continue;
				}
			if (soap_flag_refundReason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:refundReason", (wchar_t**)&a->ns2__ChinaRefundService::refundReason, "xsd:string"))
				{	soap_flag_refundReason1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ChinaRefundService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ChinaRefundService, SOAP_TYPE_ns2__ChinaRefundService, sizeof(ns2__ChinaRefundService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ChinaRefundService * SOAP_FMAC2 soap_instantiate_ns2__ChinaRefundService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ChinaRefundService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ChinaRefundService *p;
	size_t k = sizeof(ns2__ChinaRefundService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ChinaRefundService);
		if (p)
			((ns2__ChinaRefundService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ChinaRefundService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ChinaRefundService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ChinaRefundService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ChinaRefundService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ChinaRefundService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:ChinaRefundService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ChinaRefundService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ChinaRefundService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ChinaRefundService * SOAP_FMAC4 soap_get_ns2__ChinaRefundService(struct soap *soap, ns2__ChinaRefundService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ChinaRefundService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ChinaPaymentService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ChinaPaymentService::paymentMode = NULL;
	this->ns2__ChinaPaymentService::returnURL = NULL;
	this->ns2__ChinaPaymentService::pickUpAddress = NULL;
	this->ns2__ChinaPaymentService::pickUpPhoneNumber = NULL;
	this->ns2__ChinaPaymentService::pickUpPostalCode = NULL;
	this->ns2__ChinaPaymentService::pickUpName = NULL;
	this->ns2__ChinaPaymentService::run = NULL;
	/* transient soap skipped */
}

void ns2__ChinaPaymentService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ChinaPaymentService::paymentMode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ChinaPaymentService::returnURL);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ChinaPaymentService::pickUpAddress);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ChinaPaymentService::pickUpPhoneNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ChinaPaymentService::pickUpPostalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ChinaPaymentService::pickUpName);
#endif
}

int ns2__ChinaPaymentService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ChinaPaymentService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ChinaPaymentService(struct soap *soap, const char *tag, int id, const ns2__ChinaPaymentService *a, const char *type)
{
	if (((ns2__ChinaPaymentService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__ChinaPaymentService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ChinaPaymentService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentMode", -1, (wchar_t*const*)&a->ns2__ChinaPaymentService::paymentMode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:returnURL", -1, (wchar_t*const*)&a->ns2__ChinaPaymentService::returnURL, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pickUpAddress", -1, (wchar_t*const*)&a->ns2__ChinaPaymentService::pickUpAddress, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pickUpPhoneNumber", -1, (wchar_t*const*)&a->ns2__ChinaPaymentService::pickUpPhoneNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pickUpPostalCode", -1, (wchar_t*const*)&a->ns2__ChinaPaymentService::pickUpPostalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pickUpName", -1, (wchar_t*const*)&a->ns2__ChinaPaymentService::pickUpName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ChinaPaymentService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ChinaPaymentService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ChinaPaymentService * SOAP_FMAC4 soap_in_ns2__ChinaPaymentService(struct soap *soap, const char *tag, ns2__ChinaPaymentService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ChinaPaymentService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ChinaPaymentService, sizeof(ns2__ChinaPaymentService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ChinaPaymentService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ChinaPaymentService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__ChinaPaymentService*)a)->run))
		return NULL;
	size_t soap_flag_paymentMode1 = 1;
	size_t soap_flag_returnURL1 = 1;
	size_t soap_flag_pickUpAddress1 = 1;
	size_t soap_flag_pickUpPhoneNumber1 = 1;
	size_t soap_flag_pickUpPostalCode1 = 1;
	size_t soap_flag_pickUpName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_paymentMode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentMode", (wchar_t**)&a->ns2__ChinaPaymentService::paymentMode, "xsd:string"))
				{	soap_flag_paymentMode1--;
					continue;
				}
			if (soap_flag_returnURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:returnURL", (wchar_t**)&a->ns2__ChinaPaymentService::returnURL, "xsd:string"))
				{	soap_flag_returnURL1--;
					continue;
				}
			if (soap_flag_pickUpAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pickUpAddress", (wchar_t**)&a->ns2__ChinaPaymentService::pickUpAddress, "xsd:string"))
				{	soap_flag_pickUpAddress1--;
					continue;
				}
			if (soap_flag_pickUpPhoneNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pickUpPhoneNumber", (wchar_t**)&a->ns2__ChinaPaymentService::pickUpPhoneNumber, "xsd:string"))
				{	soap_flag_pickUpPhoneNumber1--;
					continue;
				}
			if (soap_flag_pickUpPostalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pickUpPostalCode", (wchar_t**)&a->ns2__ChinaPaymentService::pickUpPostalCode, "xsd:string"))
				{	soap_flag_pickUpPostalCode1--;
					continue;
				}
			if (soap_flag_pickUpName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pickUpName", (wchar_t**)&a->ns2__ChinaPaymentService::pickUpName, "xsd:string"))
				{	soap_flag_pickUpName1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ChinaPaymentService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ChinaPaymentService, SOAP_TYPE_ns2__ChinaPaymentService, sizeof(ns2__ChinaPaymentService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ChinaPaymentService * SOAP_FMAC2 soap_instantiate_ns2__ChinaPaymentService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ChinaPaymentService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ChinaPaymentService *p;
	size_t k = sizeof(ns2__ChinaPaymentService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ChinaPaymentService);
		if (p)
			((ns2__ChinaPaymentService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ChinaPaymentService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ChinaPaymentService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ChinaPaymentService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ChinaPaymentService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ChinaPaymentService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:ChinaPaymentService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ChinaPaymentService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ChinaPaymentService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ChinaPaymentService * SOAP_FMAC4 soap_get_ns2__ChinaPaymentService(struct soap *soap, ns2__ChinaPaymentService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ChinaPaymentService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalPreapprovedUpdateService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalPreapprovedUpdateService::mpID = NULL;
	this->ns2__PayPalPreapprovedUpdateService::reconciliationID = NULL;
	this->ns2__PayPalPreapprovedUpdateService::run = NULL;
	/* transient soap skipped */
}

void ns2__PayPalPreapprovedUpdateService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedUpdateService::mpID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedUpdateService::reconciliationID);
#endif
}

int ns2__PayPalPreapprovedUpdateService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalPreapprovedUpdateService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalPreapprovedUpdateService(struct soap *soap, const char *tag, int id, const ns2__PayPalPreapprovedUpdateService *a, const char *type)
{
	if (((ns2__PayPalPreapprovedUpdateService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PayPalPreapprovedUpdateService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalPreapprovedUpdateService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:mpID", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedUpdateService::mpID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedUpdateService::reconciliationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalPreapprovedUpdateService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalPreapprovedUpdateService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalPreapprovedUpdateService * SOAP_FMAC4 soap_in_ns2__PayPalPreapprovedUpdateService(struct soap *soap, const char *tag, ns2__PayPalPreapprovedUpdateService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalPreapprovedUpdateService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalPreapprovedUpdateService, sizeof(ns2__PayPalPreapprovedUpdateService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalPreapprovedUpdateService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalPreapprovedUpdateService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PayPalPreapprovedUpdateService*)a)->run))
		return NULL;
	size_t soap_flag_mpID1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mpID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:mpID", (wchar_t**)&a->ns2__PayPalPreapprovedUpdateService::mpID, "xsd:string"))
				{	soap_flag_mpID1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__PayPalPreapprovedUpdateService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayPalPreapprovedUpdateService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalPreapprovedUpdateService, SOAP_TYPE_ns2__PayPalPreapprovedUpdateService, sizeof(ns2__PayPalPreapprovedUpdateService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalPreapprovedUpdateService * SOAP_FMAC2 soap_instantiate_ns2__PayPalPreapprovedUpdateService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalPreapprovedUpdateService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalPreapprovedUpdateService *p;
	size_t k = sizeof(ns2__PayPalPreapprovedUpdateService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalPreapprovedUpdateService);
		if (p)
			((ns2__PayPalPreapprovedUpdateService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalPreapprovedUpdateService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalPreapprovedUpdateService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalPreapprovedUpdateService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalPreapprovedUpdateService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalPreapprovedUpdateService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalPreapprovedUpdateService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalPreapprovedUpdateService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalPreapprovedUpdateService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalPreapprovedUpdateService * SOAP_FMAC4 soap_get_ns2__PayPalPreapprovedUpdateService(struct soap *soap, ns2__PayPalPreapprovedUpdateService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalPreapprovedUpdateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalPreapprovedPaymentService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalPreapprovedPaymentService::mpID = NULL;
	this->ns2__PayPalPreapprovedPaymentService::reconciliationID = NULL;
	this->ns2__PayPalPreapprovedPaymentService::run = NULL;
	/* transient soap skipped */
}

void ns2__PayPalPreapprovedPaymentService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentService::mpID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPreapprovedPaymentService::reconciliationID);
#endif
}

int ns2__PayPalPreapprovedPaymentService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalPreapprovedPaymentService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalPreapprovedPaymentService(struct soap *soap, const char *tag, int id, const ns2__PayPalPreapprovedPaymentService *a, const char *type)
{
	if (((ns2__PayPalPreapprovedPaymentService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PayPalPreapprovedPaymentService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalPreapprovedPaymentService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:mpID", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentService::mpID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__PayPalPreapprovedPaymentService::reconciliationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalPreapprovedPaymentService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalPreapprovedPaymentService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalPreapprovedPaymentService * SOAP_FMAC4 soap_in_ns2__PayPalPreapprovedPaymentService(struct soap *soap, const char *tag, ns2__PayPalPreapprovedPaymentService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalPreapprovedPaymentService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalPreapprovedPaymentService, sizeof(ns2__PayPalPreapprovedPaymentService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalPreapprovedPaymentService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalPreapprovedPaymentService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PayPalPreapprovedPaymentService*)a)->run))
		return NULL;
	size_t soap_flag_mpID1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mpID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:mpID", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentService::mpID, "xsd:string"))
				{	soap_flag_mpID1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__PayPalPreapprovedPaymentService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayPalPreapprovedPaymentService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalPreapprovedPaymentService, SOAP_TYPE_ns2__PayPalPreapprovedPaymentService, sizeof(ns2__PayPalPreapprovedPaymentService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalPreapprovedPaymentService * SOAP_FMAC2 soap_instantiate_ns2__PayPalPreapprovedPaymentService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalPreapprovedPaymentService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalPreapprovedPaymentService *p;
	size_t k = sizeof(ns2__PayPalPreapprovedPaymentService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalPreapprovedPaymentService);
		if (p)
			((ns2__PayPalPreapprovedPaymentService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalPreapprovedPaymentService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalPreapprovedPaymentService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalPreapprovedPaymentService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalPreapprovedPaymentService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalPreapprovedPaymentService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalPreapprovedPaymentService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalPreapprovedPaymentService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalPreapprovedPaymentService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalPreapprovedPaymentService * SOAP_FMAC4 soap_get_ns2__PayPalPreapprovedPaymentService(struct soap *soap, ns2__PayPalPreapprovedPaymentService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalPreapprovedPaymentService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalButtonCreateService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalButtonCreateService::buttonType = NULL;
	this->ns2__PayPalButtonCreateService::reconciliationID = NULL;
	this->ns2__PayPalButtonCreateService::run = NULL;
	/* transient soap skipped */
}

void ns2__PayPalButtonCreateService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalButtonCreateService::buttonType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalButtonCreateService::reconciliationID);
#endif
}

int ns2__PayPalButtonCreateService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalButtonCreateService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalButtonCreateService(struct soap *soap, const char *tag, int id, const ns2__PayPalButtonCreateService *a, const char *type)
{
	if (((ns2__PayPalButtonCreateService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PayPalButtonCreateService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalButtonCreateService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:buttonType", -1, (wchar_t*const*)&a->ns2__PayPalButtonCreateService::buttonType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__PayPalButtonCreateService::reconciliationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalButtonCreateService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalButtonCreateService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalButtonCreateService * SOAP_FMAC4 soap_in_ns2__PayPalButtonCreateService(struct soap *soap, const char *tag, ns2__PayPalButtonCreateService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalButtonCreateService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalButtonCreateService, sizeof(ns2__PayPalButtonCreateService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalButtonCreateService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalButtonCreateService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PayPalButtonCreateService*)a)->run))
		return NULL;
	size_t soap_flag_buttonType1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_buttonType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:buttonType", (wchar_t**)&a->ns2__PayPalButtonCreateService::buttonType, "xsd:string"))
				{	soap_flag_buttonType1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__PayPalButtonCreateService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayPalButtonCreateService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalButtonCreateService, SOAP_TYPE_ns2__PayPalButtonCreateService, sizeof(ns2__PayPalButtonCreateService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalButtonCreateService * SOAP_FMAC2 soap_instantiate_ns2__PayPalButtonCreateService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalButtonCreateService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalButtonCreateService *p;
	size_t k = sizeof(ns2__PayPalButtonCreateService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalButtonCreateService);
		if (p)
			((ns2__PayPalButtonCreateService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalButtonCreateService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalButtonCreateService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalButtonCreateService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalButtonCreateService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalButtonCreateService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalButtonCreateService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalButtonCreateService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalButtonCreateService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalButtonCreateService * SOAP_FMAC4 soap_get_ns2__PayPalButtonCreateService(struct soap *soap, ns2__PayPalButtonCreateService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalButtonCreateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PinDebitReversalService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PinDebitReversalService::pinDebitRequestID = NULL;
	this->ns2__PinDebitReversalService::run = NULL;
	/* transient soap skipped */
}

void ns2__PinDebitReversalService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitReversalService::pinDebitRequestID);
#endif
}

int ns2__PinDebitReversalService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PinDebitReversalService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PinDebitReversalService(struct soap *soap, const char *tag, int id, const ns2__PinDebitReversalService *a, const char *type)
{
	if (((ns2__PinDebitReversalService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PinDebitReversalService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PinDebitReversalService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pinDebitRequestID", -1, (wchar_t*const*)&a->ns2__PinDebitReversalService::pinDebitRequestID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PinDebitReversalService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PinDebitReversalService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PinDebitReversalService * SOAP_FMAC4 soap_in_ns2__PinDebitReversalService(struct soap *soap, const char *tag, ns2__PinDebitReversalService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PinDebitReversalService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PinDebitReversalService, sizeof(ns2__PinDebitReversalService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PinDebitReversalService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PinDebitReversalService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PinDebitReversalService*)a)->run))
		return NULL;
	size_t soap_flag_pinDebitRequestID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pinDebitRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pinDebitRequestID", (wchar_t**)&a->ns2__PinDebitReversalService::pinDebitRequestID, "xsd:string"))
				{	soap_flag_pinDebitRequestID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PinDebitReversalService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PinDebitReversalService, SOAP_TYPE_ns2__PinDebitReversalService, sizeof(ns2__PinDebitReversalService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PinDebitReversalService * SOAP_FMAC2 soap_instantiate_ns2__PinDebitReversalService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PinDebitReversalService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PinDebitReversalService *p;
	size_t k = sizeof(ns2__PinDebitReversalService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PinDebitReversalService);
		if (p)
			((ns2__PinDebitReversalService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PinDebitReversalService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PinDebitReversalService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PinDebitReversalService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PinDebitReversalService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PinDebitReversalService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PinDebitReversalService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PinDebitReversalService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PinDebitReversalService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PinDebitReversalService * SOAP_FMAC4 soap_get_ns2__PinDebitReversalService(struct soap *soap, ns2__PinDebitReversalService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PinDebitReversalService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PinDebitCreditService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PinDebitCreditService::networkOrder = NULL;
	this->ns2__PinDebitCreditService::commerceIndicator = NULL;
	this->ns2__PinDebitCreditService::reconciliationID = NULL;
	this->ns2__PinDebitCreditService::overridePaymentMethod = NULL;
	this->ns2__PinDebitCreditService::paymentType = NULL;
	this->ns2__PinDebitCreditService::ebtCategory = NULL;
	this->ns2__PinDebitCreditService::transactionType = NULL;
	this->ns2__PinDebitCreditService::run = NULL;
	/* transient soap skipped */
}

void ns2__PinDebitCreditService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitCreditService::networkOrder);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitCreditService::commerceIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitCreditService::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitCreditService::overridePaymentMethod);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitCreditService::paymentType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitCreditService::ebtCategory);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitCreditService::transactionType);
#endif
}

int ns2__PinDebitCreditService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PinDebitCreditService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PinDebitCreditService(struct soap *soap, const char *tag, int id, const ns2__PinDebitCreditService *a, const char *type)
{
	if (((ns2__PinDebitCreditService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PinDebitCreditService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PinDebitCreditService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:networkOrder", -1, (wchar_t*const*)&a->ns2__PinDebitCreditService::networkOrder, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:commerceIndicator", -1, (wchar_t*const*)&a->ns2__PinDebitCreditService::commerceIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__PinDebitCreditService::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:overridePaymentMethod", -1, (wchar_t*const*)&a->ns2__PinDebitCreditService::overridePaymentMethod, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentType", -1, (wchar_t*const*)&a->ns2__PinDebitCreditService::paymentType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ebtCategory", -1, (wchar_t*const*)&a->ns2__PinDebitCreditService::ebtCategory, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionType", -1, (wchar_t*const*)&a->ns2__PinDebitCreditService::transactionType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PinDebitCreditService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PinDebitCreditService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PinDebitCreditService * SOAP_FMAC4 soap_in_ns2__PinDebitCreditService(struct soap *soap, const char *tag, ns2__PinDebitCreditService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PinDebitCreditService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PinDebitCreditService, sizeof(ns2__PinDebitCreditService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PinDebitCreditService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PinDebitCreditService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PinDebitCreditService*)a)->run))
		return NULL;
	size_t soap_flag_networkOrder1 = 1;
	size_t soap_flag_commerceIndicator1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_overridePaymentMethod1 = 1;
	size_t soap_flag_paymentType1 = 1;
	size_t soap_flag_ebtCategory1 = 1;
	size_t soap_flag_transactionType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_networkOrder1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:networkOrder", (wchar_t**)&a->ns2__PinDebitCreditService::networkOrder, "xsd:string"))
				{	soap_flag_networkOrder1--;
					continue;
				}
			if (soap_flag_commerceIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:commerceIndicator", (wchar_t**)&a->ns2__PinDebitCreditService::commerceIndicator, "xsd:string"))
				{	soap_flag_commerceIndicator1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__PinDebitCreditService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_overridePaymentMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:overridePaymentMethod", (wchar_t**)&a->ns2__PinDebitCreditService::overridePaymentMethod, "xsd:string"))
				{	soap_flag_overridePaymentMethod1--;
					continue;
				}
			if (soap_flag_paymentType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentType", (wchar_t**)&a->ns2__PinDebitCreditService::paymentType, "xsd:string"))
				{	soap_flag_paymentType1--;
					continue;
				}
			if (soap_flag_ebtCategory1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ebtCategory", (wchar_t**)&a->ns2__PinDebitCreditService::ebtCategory, "xsd:string"))
				{	soap_flag_ebtCategory1--;
					continue;
				}
			if (soap_flag_transactionType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionType", (wchar_t**)&a->ns2__PinDebitCreditService::transactionType, "xsd:string"))
				{	soap_flag_transactionType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PinDebitCreditService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PinDebitCreditService, SOAP_TYPE_ns2__PinDebitCreditService, sizeof(ns2__PinDebitCreditService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PinDebitCreditService * SOAP_FMAC2 soap_instantiate_ns2__PinDebitCreditService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PinDebitCreditService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PinDebitCreditService *p;
	size_t k = sizeof(ns2__PinDebitCreditService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PinDebitCreditService);
		if (p)
			((ns2__PinDebitCreditService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PinDebitCreditService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PinDebitCreditService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PinDebitCreditService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PinDebitCreditService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PinDebitCreditService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PinDebitCreditService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PinDebitCreditService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PinDebitCreditService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PinDebitCreditService * SOAP_FMAC4 soap_get_ns2__PinDebitCreditService(struct soap *soap, ns2__PinDebitCreditService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PinDebitCreditService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PinDebitPurchaseService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PinDebitPurchaseService::networkOrder = NULL;
	this->ns2__PinDebitPurchaseService::commerceIndicator = NULL;
	this->ns2__PinDebitPurchaseService::reconciliationID = NULL;
	this->ns2__PinDebitPurchaseService::partialAuthIndicator = NULL;
	this->ns2__PinDebitPurchaseService::overridePaymentMethod = NULL;
	this->ns2__PinDebitPurchaseService::paymentType = NULL;
	this->ns2__PinDebitPurchaseService::ebtCategory = NULL;
	this->ns2__PinDebitPurchaseService::transactionType = NULL;
	this->ns2__PinDebitPurchaseService::ebtVoucherSerialNumber = NULL;
	this->ns2__PinDebitPurchaseService::authorizationCode = NULL;
	this->ns2__PinDebitPurchaseService::run = NULL;
	/* transient soap skipped */
}

void ns2__PinDebitPurchaseService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitPurchaseService::networkOrder);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitPurchaseService::commerceIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitPurchaseService::reconciliationID);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__PinDebitPurchaseService::partialAuthIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitPurchaseService::overridePaymentMethod);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitPurchaseService::paymentType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitPurchaseService::ebtCategory);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitPurchaseService::transactionType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitPurchaseService::ebtVoucherSerialNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinDebitPurchaseService::authorizationCode);
#endif
}

int ns2__PinDebitPurchaseService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PinDebitPurchaseService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PinDebitPurchaseService(struct soap *soap, const char *tag, int id, const ns2__PinDebitPurchaseService *a, const char *type)
{
	if (((ns2__PinDebitPurchaseService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PinDebitPurchaseService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PinDebitPurchaseService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:networkOrder", -1, (wchar_t*const*)&a->ns2__PinDebitPurchaseService::networkOrder, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:commerceIndicator", -1, (wchar_t*const*)&a->ns2__PinDebitPurchaseService::commerceIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__PinDebitPurchaseService::reconciliationID, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:partialAuthIndicator", -1, &a->ns2__PinDebitPurchaseService::partialAuthIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:overridePaymentMethod", -1, (wchar_t*const*)&a->ns2__PinDebitPurchaseService::overridePaymentMethod, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentType", -1, (wchar_t*const*)&a->ns2__PinDebitPurchaseService::paymentType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ebtCategory", -1, (wchar_t*const*)&a->ns2__PinDebitPurchaseService::ebtCategory, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionType", -1, (wchar_t*const*)&a->ns2__PinDebitPurchaseService::transactionType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:ebtVoucherSerialNumber", -1, (wchar_t*const*)&a->ns2__PinDebitPurchaseService::ebtVoucherSerialNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authorizationCode", -1, (wchar_t*const*)&a->ns2__PinDebitPurchaseService::authorizationCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PinDebitPurchaseService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PinDebitPurchaseService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PinDebitPurchaseService * SOAP_FMAC4 soap_in_ns2__PinDebitPurchaseService(struct soap *soap, const char *tag, ns2__PinDebitPurchaseService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PinDebitPurchaseService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PinDebitPurchaseService, sizeof(ns2__PinDebitPurchaseService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PinDebitPurchaseService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PinDebitPurchaseService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PinDebitPurchaseService*)a)->run))
		return NULL;
	size_t soap_flag_networkOrder1 = 1;
	size_t soap_flag_commerceIndicator1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_partialAuthIndicator1 = 1;
	size_t soap_flag_overridePaymentMethod1 = 1;
	size_t soap_flag_paymentType1 = 1;
	size_t soap_flag_ebtCategory1 = 1;
	size_t soap_flag_transactionType1 = 1;
	size_t soap_flag_ebtVoucherSerialNumber1 = 1;
	size_t soap_flag_authorizationCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_networkOrder1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:networkOrder", (wchar_t**)&a->ns2__PinDebitPurchaseService::networkOrder, "xsd:string"))
				{	soap_flag_networkOrder1--;
					continue;
				}
			if (soap_flag_commerceIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:commerceIndicator", (wchar_t**)&a->ns2__PinDebitPurchaseService::commerceIndicator, "xsd:string"))
				{	soap_flag_commerceIndicator1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__PinDebitPurchaseService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_partialAuthIndicator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:partialAuthIndicator", &a->ns2__PinDebitPurchaseService::partialAuthIndicator, "ns2:boolean"))
				{	soap_flag_partialAuthIndicator1--;
					continue;
				}
			if (soap_flag_overridePaymentMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:overridePaymentMethod", (wchar_t**)&a->ns2__PinDebitPurchaseService::overridePaymentMethod, "xsd:string"))
				{	soap_flag_overridePaymentMethod1--;
					continue;
				}
			if (soap_flag_paymentType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentType", (wchar_t**)&a->ns2__PinDebitPurchaseService::paymentType, "xsd:string"))
				{	soap_flag_paymentType1--;
					continue;
				}
			if (soap_flag_ebtCategory1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ebtCategory", (wchar_t**)&a->ns2__PinDebitPurchaseService::ebtCategory, "xsd:string"))
				{	soap_flag_ebtCategory1--;
					continue;
				}
			if (soap_flag_transactionType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionType", (wchar_t**)&a->ns2__PinDebitPurchaseService::transactionType, "xsd:string"))
				{	soap_flag_transactionType1--;
					continue;
				}
			if (soap_flag_ebtVoucherSerialNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:ebtVoucherSerialNumber", (wchar_t**)&a->ns2__PinDebitPurchaseService::ebtVoucherSerialNumber, "xsd:string"))
				{	soap_flag_ebtVoucherSerialNumber1--;
					continue;
				}
			if (soap_flag_authorizationCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authorizationCode", (wchar_t**)&a->ns2__PinDebitPurchaseService::authorizationCode, "xsd:string"))
				{	soap_flag_authorizationCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PinDebitPurchaseService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PinDebitPurchaseService, SOAP_TYPE_ns2__PinDebitPurchaseService, sizeof(ns2__PinDebitPurchaseService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PinDebitPurchaseService * SOAP_FMAC2 soap_instantiate_ns2__PinDebitPurchaseService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PinDebitPurchaseService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PinDebitPurchaseService *p;
	size_t k = sizeof(ns2__PinDebitPurchaseService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PinDebitPurchaseService);
		if (p)
			((ns2__PinDebitPurchaseService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PinDebitPurchaseService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PinDebitPurchaseService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PinDebitPurchaseService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PinDebitPurchaseService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PinDebitPurchaseService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PinDebitPurchaseService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PinDebitPurchaseService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PinDebitPurchaseService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PinDebitPurchaseService * SOAP_FMAC4 soap_get_ns2__PinDebitPurchaseService(struct soap *soap, ns2__PinDebitPurchaseService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PinDebitPurchaseService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PinlessDebitReversalService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PinlessDebitReversalService::pinlessDebitRequestID = NULL;
	this->ns2__PinlessDebitReversalService::pinlessDebitRequestToken = NULL;
	this->ns2__PinlessDebitReversalService::reconciliationID = NULL;
	this->ns2__PinlessDebitReversalService::run = NULL;
	/* transient soap skipped */
}

void ns2__PinlessDebitReversalService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinlessDebitReversalService::pinlessDebitRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinlessDebitReversalService::pinlessDebitRequestToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinlessDebitReversalService::reconciliationID);
#endif
}

int ns2__PinlessDebitReversalService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PinlessDebitReversalService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PinlessDebitReversalService(struct soap *soap, const char *tag, int id, const ns2__PinlessDebitReversalService *a, const char *type)
{
	if (((ns2__PinlessDebitReversalService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PinlessDebitReversalService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PinlessDebitReversalService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pinlessDebitRequestID", -1, (wchar_t*const*)&a->ns2__PinlessDebitReversalService::pinlessDebitRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pinlessDebitRequestToken", -1, (wchar_t*const*)&a->ns2__PinlessDebitReversalService::pinlessDebitRequestToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__PinlessDebitReversalService::reconciliationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PinlessDebitReversalService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PinlessDebitReversalService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PinlessDebitReversalService * SOAP_FMAC4 soap_in_ns2__PinlessDebitReversalService(struct soap *soap, const char *tag, ns2__PinlessDebitReversalService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PinlessDebitReversalService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PinlessDebitReversalService, sizeof(ns2__PinlessDebitReversalService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PinlessDebitReversalService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PinlessDebitReversalService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PinlessDebitReversalService*)a)->run))
		return NULL;
	size_t soap_flag_pinlessDebitRequestID1 = 1;
	size_t soap_flag_pinlessDebitRequestToken1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pinlessDebitRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pinlessDebitRequestID", (wchar_t**)&a->ns2__PinlessDebitReversalService::pinlessDebitRequestID, "xsd:string"))
				{	soap_flag_pinlessDebitRequestID1--;
					continue;
				}
			if (soap_flag_pinlessDebitRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pinlessDebitRequestToken", (wchar_t**)&a->ns2__PinlessDebitReversalService::pinlessDebitRequestToken, "xsd:string"))
				{	soap_flag_pinlessDebitRequestToken1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__PinlessDebitReversalService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PinlessDebitReversalService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PinlessDebitReversalService, SOAP_TYPE_ns2__PinlessDebitReversalService, sizeof(ns2__PinlessDebitReversalService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PinlessDebitReversalService * SOAP_FMAC2 soap_instantiate_ns2__PinlessDebitReversalService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PinlessDebitReversalService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PinlessDebitReversalService *p;
	size_t k = sizeof(ns2__PinlessDebitReversalService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PinlessDebitReversalService);
		if (p)
			((ns2__PinlessDebitReversalService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PinlessDebitReversalService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PinlessDebitReversalService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PinlessDebitReversalService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PinlessDebitReversalService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PinlessDebitReversalService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PinlessDebitReversalService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PinlessDebitReversalService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PinlessDebitReversalService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PinlessDebitReversalService * SOAP_FMAC4 soap_get_ns2__PinlessDebitReversalService(struct soap *soap, ns2__PinlessDebitReversalService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PinlessDebitReversalService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PinlessDebitValidateService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PinlessDebitValidateService::run = NULL;
	/* transient soap skipped */
}

void ns2__PinlessDebitValidateService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__PinlessDebitValidateService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PinlessDebitValidateService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PinlessDebitValidateService(struct soap *soap, const char *tag, int id, const ns2__PinlessDebitValidateService *a, const char *type)
{
	if (((ns2__PinlessDebitValidateService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PinlessDebitValidateService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PinlessDebitValidateService), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PinlessDebitValidateService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PinlessDebitValidateService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PinlessDebitValidateService * SOAP_FMAC4 soap_in_ns2__PinlessDebitValidateService(struct soap *soap, const char *tag, ns2__PinlessDebitValidateService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PinlessDebitValidateService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PinlessDebitValidateService, sizeof(ns2__PinlessDebitValidateService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PinlessDebitValidateService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PinlessDebitValidateService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PinlessDebitValidateService*)a)->run))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PinlessDebitValidateService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PinlessDebitValidateService, SOAP_TYPE_ns2__PinlessDebitValidateService, sizeof(ns2__PinlessDebitValidateService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PinlessDebitValidateService * SOAP_FMAC2 soap_instantiate_ns2__PinlessDebitValidateService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PinlessDebitValidateService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PinlessDebitValidateService *p;
	size_t k = sizeof(ns2__PinlessDebitValidateService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PinlessDebitValidateService);
		if (p)
			((ns2__PinlessDebitValidateService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PinlessDebitValidateService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PinlessDebitValidateService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PinlessDebitValidateService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PinlessDebitValidateService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PinlessDebitValidateService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PinlessDebitValidateService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PinlessDebitValidateService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PinlessDebitValidateService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PinlessDebitValidateService * SOAP_FMAC4 soap_get_ns2__PinlessDebitValidateService(struct soap *soap, ns2__PinlessDebitValidateService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PinlessDebitValidateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PinlessDebitService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PinlessDebitService::reconciliationID = NULL;
	this->ns2__PinlessDebitService::commerceIndicator = NULL;
	this->ns2__PinlessDebitService::run = NULL;
	/* transient soap skipped */
}

void ns2__PinlessDebitService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinlessDebitService::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PinlessDebitService::commerceIndicator);
#endif
}

int ns2__PinlessDebitService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PinlessDebitService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PinlessDebitService(struct soap *soap, const char *tag, int id, const ns2__PinlessDebitService *a, const char *type)
{
	if (((ns2__PinlessDebitService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PinlessDebitService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PinlessDebitService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__PinlessDebitService::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:commerceIndicator", -1, (wchar_t*const*)&a->ns2__PinlessDebitService::commerceIndicator, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PinlessDebitService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PinlessDebitService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PinlessDebitService * SOAP_FMAC4 soap_in_ns2__PinlessDebitService(struct soap *soap, const char *tag, ns2__PinlessDebitService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PinlessDebitService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PinlessDebitService, sizeof(ns2__PinlessDebitService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PinlessDebitService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PinlessDebitService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PinlessDebitService*)a)->run))
		return NULL;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_commerceIndicator1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__PinlessDebitService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_commerceIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:commerceIndicator", (wchar_t**)&a->ns2__PinlessDebitService::commerceIndicator, "xsd:string"))
				{	soap_flag_commerceIndicator1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PinlessDebitService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PinlessDebitService, SOAP_TYPE_ns2__PinlessDebitService, sizeof(ns2__PinlessDebitService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PinlessDebitService * SOAP_FMAC2 soap_instantiate_ns2__PinlessDebitService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PinlessDebitService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PinlessDebitService *p;
	size_t k = sizeof(ns2__PinlessDebitService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PinlessDebitService);
		if (p)
			((ns2__PinlessDebitService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PinlessDebitService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PinlessDebitService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PinlessDebitService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PinlessDebitService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PinlessDebitService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PinlessDebitService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PinlessDebitService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PinlessDebitService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PinlessDebitService * SOAP_FMAC4 soap_get_ns2__PinlessDebitService(struct soap *soap, ns2__PinlessDebitService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PinlessDebitService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__VoidService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__VoidService::voidRequestID = NULL;
	this->ns2__VoidService::voidRequestToken = NULL;
	this->ns2__VoidService::run = NULL;
	/* transient soap skipped */
}

void ns2__VoidService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VoidService::voidRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VoidService::voidRequestToken);
#endif
}

int ns2__VoidService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__VoidService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VoidService(struct soap *soap, const char *tag, int id, const ns2__VoidService *a, const char *type)
{
	if (((ns2__VoidService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__VoidService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VoidService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:voidRequestID", -1, (wchar_t*const*)&a->ns2__VoidService::voidRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:voidRequestToken", -1, (wchar_t*const*)&a->ns2__VoidService::voidRequestToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__VoidService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__VoidService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__VoidService * SOAP_FMAC4 soap_in_ns2__VoidService(struct soap *soap, const char *tag, ns2__VoidService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__VoidService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VoidService, sizeof(ns2__VoidService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__VoidService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__VoidService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__VoidService*)a)->run))
		return NULL;
	size_t soap_flag_voidRequestID1 = 1;
	size_t soap_flag_voidRequestToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_voidRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:voidRequestID", (wchar_t**)&a->ns2__VoidService::voidRequestID, "xsd:string"))
				{	soap_flag_voidRequestID1--;
					continue;
				}
			if (soap_flag_voidRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:voidRequestToken", (wchar_t**)&a->ns2__VoidService::voidRequestToken, "xsd:string"))
				{	soap_flag_voidRequestToken1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__VoidService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VoidService, SOAP_TYPE_ns2__VoidService, sizeof(ns2__VoidService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__VoidService * SOAP_FMAC2 soap_instantiate_ns2__VoidService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__VoidService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__VoidService *p;
	size_t k = sizeof(ns2__VoidService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__VoidService);
		if (p)
			((ns2__VoidService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__VoidService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__VoidService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__VoidService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__VoidService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__VoidService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:VoidService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__VoidService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__VoidService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__VoidService * SOAP_FMAC4 soap_get_ns2__VoidService(struct soap *soap, ns2__VoidService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VoidService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalDoRefTransactionService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalDoRefTransactionService::paypalBillingAgreementId = NULL;
	this->ns2__PayPalDoRefTransactionService::paypalPaymentType = NULL;
	this->ns2__PayPalDoRefTransactionService::paypalReqconfirmshipping = NULL;
	this->ns2__PayPalDoRefTransactionService::paypalReturnFmfDetails = NULL;
	this->ns2__PayPalDoRefTransactionService::paypalSoftDescriptor = NULL;
	this->ns2__PayPalDoRefTransactionService::paypalShippingdiscount = NULL;
	this->ns2__PayPalDoRefTransactionService::paypalDesc = NULL;
	this->ns2__PayPalDoRefTransactionService::invoiceNumber = NULL;
	this->ns2__PayPalDoRefTransactionService::paypalEcNotifyUrl = NULL;
	this->ns2__PayPalDoRefTransactionService::run = NULL;
	/* transient soap skipped */
}

void ns2__PayPalDoRefTransactionService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionService::paypalBillingAgreementId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionService::paypalPaymentType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionService::paypalReqconfirmshipping);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionService::paypalReturnFmfDetails);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionService::paypalSoftDescriptor);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionService::paypalShippingdiscount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionService::paypalDesc);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionService::invoiceNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoRefTransactionService::paypalEcNotifyUrl);
#endif
}

int ns2__PayPalDoRefTransactionService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalDoRefTransactionService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalDoRefTransactionService(struct soap *soap, const char *tag, int id, const ns2__PayPalDoRefTransactionService *a, const char *type)
{
	if (((ns2__PayPalDoRefTransactionService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PayPalDoRefTransactionService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalDoRefTransactionService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalBillingAgreementId", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionService::paypalBillingAgreementId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPaymentType", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionService::paypalPaymentType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalReqconfirmshipping", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionService::paypalReqconfirmshipping, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalReturnFmfDetails", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionService::paypalReturnFmfDetails, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalSoftDescriptor", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionService::paypalSoftDescriptor, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalShippingdiscount", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionService::paypalShippingdiscount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalDesc", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionService::paypalDesc, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:invoiceNumber", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionService::invoiceNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalEcNotifyUrl", -1, (wchar_t*const*)&a->ns2__PayPalDoRefTransactionService::paypalEcNotifyUrl, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalDoRefTransactionService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalDoRefTransactionService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalDoRefTransactionService * SOAP_FMAC4 soap_in_ns2__PayPalDoRefTransactionService(struct soap *soap, const char *tag, ns2__PayPalDoRefTransactionService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalDoRefTransactionService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalDoRefTransactionService, sizeof(ns2__PayPalDoRefTransactionService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalDoRefTransactionService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalDoRefTransactionService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PayPalDoRefTransactionService*)a)->run))
		return NULL;
	size_t soap_flag_paypalBillingAgreementId1 = 1;
	size_t soap_flag_paypalPaymentType1 = 1;
	size_t soap_flag_paypalReqconfirmshipping1 = 1;
	size_t soap_flag_paypalReturnFmfDetails1 = 1;
	size_t soap_flag_paypalSoftDescriptor1 = 1;
	size_t soap_flag_paypalShippingdiscount1 = 1;
	size_t soap_flag_paypalDesc1 = 1;
	size_t soap_flag_invoiceNumber1 = 1;
	size_t soap_flag_paypalEcNotifyUrl1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_paypalBillingAgreementId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalBillingAgreementId", (wchar_t**)&a->ns2__PayPalDoRefTransactionService::paypalBillingAgreementId, "xsd:string"))
				{	soap_flag_paypalBillingAgreementId1--;
					continue;
				}
			if (soap_flag_paypalPaymentType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPaymentType", (wchar_t**)&a->ns2__PayPalDoRefTransactionService::paypalPaymentType, "xsd:string"))
				{	soap_flag_paypalPaymentType1--;
					continue;
				}
			if (soap_flag_paypalReqconfirmshipping1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalReqconfirmshipping", (wchar_t**)&a->ns2__PayPalDoRefTransactionService::paypalReqconfirmshipping, "xsd:string"))
				{	soap_flag_paypalReqconfirmshipping1--;
					continue;
				}
			if (soap_flag_paypalReturnFmfDetails1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalReturnFmfDetails", (wchar_t**)&a->ns2__PayPalDoRefTransactionService::paypalReturnFmfDetails, "xsd:string"))
				{	soap_flag_paypalReturnFmfDetails1--;
					continue;
				}
			if (soap_flag_paypalSoftDescriptor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalSoftDescriptor", (wchar_t**)&a->ns2__PayPalDoRefTransactionService::paypalSoftDescriptor, "xsd:string"))
				{	soap_flag_paypalSoftDescriptor1--;
					continue;
				}
			if (soap_flag_paypalShippingdiscount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalShippingdiscount", (wchar_t**)&a->ns2__PayPalDoRefTransactionService::paypalShippingdiscount, "xsd:string"))
				{	soap_flag_paypalShippingdiscount1--;
					continue;
				}
			if (soap_flag_paypalDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalDesc", (wchar_t**)&a->ns2__PayPalDoRefTransactionService::paypalDesc, "xsd:string"))
				{	soap_flag_paypalDesc1--;
					continue;
				}
			if (soap_flag_invoiceNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:invoiceNumber", (wchar_t**)&a->ns2__PayPalDoRefTransactionService::invoiceNumber, "xsd:string"))
				{	soap_flag_invoiceNumber1--;
					continue;
				}
			if (soap_flag_paypalEcNotifyUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalEcNotifyUrl", (wchar_t**)&a->ns2__PayPalDoRefTransactionService::paypalEcNotifyUrl, "xsd:string"))
				{	soap_flag_paypalEcNotifyUrl1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayPalDoRefTransactionService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalDoRefTransactionService, SOAP_TYPE_ns2__PayPalDoRefTransactionService, sizeof(ns2__PayPalDoRefTransactionService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalDoRefTransactionService * SOAP_FMAC2 soap_instantiate_ns2__PayPalDoRefTransactionService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalDoRefTransactionService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalDoRefTransactionService *p;
	size_t k = sizeof(ns2__PayPalDoRefTransactionService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalDoRefTransactionService);
		if (p)
			((ns2__PayPalDoRefTransactionService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalDoRefTransactionService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalDoRefTransactionService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalDoRefTransactionService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalDoRefTransactionService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalDoRefTransactionService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalDoRefTransactionService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalDoRefTransactionService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalDoRefTransactionService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalDoRefTransactionService * SOAP_FMAC4 soap_get_ns2__PayPalDoRefTransactionService(struct soap *soap, ns2__PayPalDoRefTransactionService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalDoRefTransactionService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalCreateAgreementService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalCreateAgreementService::paypalToken = NULL;
	this->ns2__PayPalCreateAgreementService::paypalEcSetRequestID = NULL;
	this->ns2__PayPalCreateAgreementService::paypalEcSetRequestToken = NULL;
	this->ns2__PayPalCreateAgreementService::run = NULL;
	/* transient soap skipped */
}

void ns2__PayPalCreateAgreementService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalCreateAgreementService::paypalToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalCreateAgreementService::paypalEcSetRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalCreateAgreementService::paypalEcSetRequestToken);
#endif
}

int ns2__PayPalCreateAgreementService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalCreateAgreementService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalCreateAgreementService(struct soap *soap, const char *tag, int id, const ns2__PayPalCreateAgreementService *a, const char *type)
{
	if (((ns2__PayPalCreateAgreementService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PayPalCreateAgreementService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalCreateAgreementService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalToken", -1, (wchar_t*const*)&a->ns2__PayPalCreateAgreementService::paypalToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalEcSetRequestID", -1, (wchar_t*const*)&a->ns2__PayPalCreateAgreementService::paypalEcSetRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalEcSetRequestToken", -1, (wchar_t*const*)&a->ns2__PayPalCreateAgreementService::paypalEcSetRequestToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalCreateAgreementService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalCreateAgreementService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalCreateAgreementService * SOAP_FMAC4 soap_in_ns2__PayPalCreateAgreementService(struct soap *soap, const char *tag, ns2__PayPalCreateAgreementService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalCreateAgreementService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalCreateAgreementService, sizeof(ns2__PayPalCreateAgreementService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalCreateAgreementService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalCreateAgreementService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PayPalCreateAgreementService*)a)->run))
		return NULL;
	size_t soap_flag_paypalToken1 = 1;
	size_t soap_flag_paypalEcSetRequestID1 = 1;
	size_t soap_flag_paypalEcSetRequestToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_paypalToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalToken", (wchar_t**)&a->ns2__PayPalCreateAgreementService::paypalToken, "xsd:string"))
				{	soap_flag_paypalToken1--;
					continue;
				}
			if (soap_flag_paypalEcSetRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalEcSetRequestID", (wchar_t**)&a->ns2__PayPalCreateAgreementService::paypalEcSetRequestID, "xsd:string"))
				{	soap_flag_paypalEcSetRequestID1--;
					continue;
				}
			if (soap_flag_paypalEcSetRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalEcSetRequestToken", (wchar_t**)&a->ns2__PayPalCreateAgreementService::paypalEcSetRequestToken, "xsd:string"))
				{	soap_flag_paypalEcSetRequestToken1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayPalCreateAgreementService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalCreateAgreementService, SOAP_TYPE_ns2__PayPalCreateAgreementService, sizeof(ns2__PayPalCreateAgreementService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalCreateAgreementService * SOAP_FMAC2 soap_instantiate_ns2__PayPalCreateAgreementService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalCreateAgreementService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalCreateAgreementService *p;
	size_t k = sizeof(ns2__PayPalCreateAgreementService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalCreateAgreementService);
		if (p)
			((ns2__PayPalCreateAgreementService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalCreateAgreementService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalCreateAgreementService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalCreateAgreementService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalCreateAgreementService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalCreateAgreementService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalCreateAgreementService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalCreateAgreementService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalCreateAgreementService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalCreateAgreementService * SOAP_FMAC4 soap_get_ns2__PayPalCreateAgreementService(struct soap *soap, ns2__PayPalCreateAgreementService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalCreateAgreementService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalUpdateAgreementService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalUpdateAgreementService::paypalBillingAgreementId = NULL;
	this->ns2__PayPalUpdateAgreementService::paypalBillingAgreementStatus = NULL;
	this->ns2__PayPalUpdateAgreementService::paypalBillingAgreementDesc = NULL;
	this->ns2__PayPalUpdateAgreementService::paypalBillingAgreementCustom = NULL;
	this->ns2__PayPalUpdateAgreementService::run = NULL;
	/* transient soap skipped */
}

void ns2__PayPalUpdateAgreementService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalUpdateAgreementService::paypalBillingAgreementId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalUpdateAgreementService::paypalBillingAgreementStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalUpdateAgreementService::paypalBillingAgreementDesc);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalUpdateAgreementService::paypalBillingAgreementCustom);
#endif
}

int ns2__PayPalUpdateAgreementService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalUpdateAgreementService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalUpdateAgreementService(struct soap *soap, const char *tag, int id, const ns2__PayPalUpdateAgreementService *a, const char *type)
{
	if (((ns2__PayPalUpdateAgreementService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PayPalUpdateAgreementService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalUpdateAgreementService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalBillingAgreementId", -1, (wchar_t*const*)&a->ns2__PayPalUpdateAgreementService::paypalBillingAgreementId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalBillingAgreementStatus", -1, (wchar_t*const*)&a->ns2__PayPalUpdateAgreementService::paypalBillingAgreementStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalBillingAgreementDesc", -1, (wchar_t*const*)&a->ns2__PayPalUpdateAgreementService::paypalBillingAgreementDesc, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalBillingAgreementCustom", -1, (wchar_t*const*)&a->ns2__PayPalUpdateAgreementService::paypalBillingAgreementCustom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalUpdateAgreementService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalUpdateAgreementService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalUpdateAgreementService * SOAP_FMAC4 soap_in_ns2__PayPalUpdateAgreementService(struct soap *soap, const char *tag, ns2__PayPalUpdateAgreementService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalUpdateAgreementService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalUpdateAgreementService, sizeof(ns2__PayPalUpdateAgreementService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalUpdateAgreementService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalUpdateAgreementService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PayPalUpdateAgreementService*)a)->run))
		return NULL;
	size_t soap_flag_paypalBillingAgreementId1 = 1;
	size_t soap_flag_paypalBillingAgreementStatus1 = 1;
	size_t soap_flag_paypalBillingAgreementDesc1 = 1;
	size_t soap_flag_paypalBillingAgreementCustom1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_paypalBillingAgreementId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalBillingAgreementId", (wchar_t**)&a->ns2__PayPalUpdateAgreementService::paypalBillingAgreementId, "xsd:string"))
				{	soap_flag_paypalBillingAgreementId1--;
					continue;
				}
			if (soap_flag_paypalBillingAgreementStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalBillingAgreementStatus", (wchar_t**)&a->ns2__PayPalUpdateAgreementService::paypalBillingAgreementStatus, "xsd:string"))
				{	soap_flag_paypalBillingAgreementStatus1--;
					continue;
				}
			if (soap_flag_paypalBillingAgreementDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalBillingAgreementDesc", (wchar_t**)&a->ns2__PayPalUpdateAgreementService::paypalBillingAgreementDesc, "xsd:string"))
				{	soap_flag_paypalBillingAgreementDesc1--;
					continue;
				}
			if (soap_flag_paypalBillingAgreementCustom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalBillingAgreementCustom", (wchar_t**)&a->ns2__PayPalUpdateAgreementService::paypalBillingAgreementCustom, "xsd:string"))
				{	soap_flag_paypalBillingAgreementCustom1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayPalUpdateAgreementService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalUpdateAgreementService, SOAP_TYPE_ns2__PayPalUpdateAgreementService, sizeof(ns2__PayPalUpdateAgreementService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalUpdateAgreementService * SOAP_FMAC2 soap_instantiate_ns2__PayPalUpdateAgreementService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalUpdateAgreementService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalUpdateAgreementService *p;
	size_t k = sizeof(ns2__PayPalUpdateAgreementService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalUpdateAgreementService);
		if (p)
			((ns2__PayPalUpdateAgreementService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalUpdateAgreementService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalUpdateAgreementService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalUpdateAgreementService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalUpdateAgreementService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalUpdateAgreementService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalUpdateAgreementService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalUpdateAgreementService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalUpdateAgreementService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalUpdateAgreementService * SOAP_FMAC4 soap_get_ns2__PayPalUpdateAgreementService(struct soap *soap, ns2__PayPalUpdateAgreementService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalUpdateAgreementService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalAuthorizationService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalAuthorizationService::paypalOrderId = NULL;
	this->ns2__PayPalAuthorizationService::paypalEcOrderSetupRequestID = NULL;
	this->ns2__PayPalAuthorizationService::paypalEcOrderSetupRequestToken = NULL;
	this->ns2__PayPalAuthorizationService::paypalDoRefTransactionRequestID = NULL;
	this->ns2__PayPalAuthorizationService::paypalDoRefTransactionRequestToken = NULL;
	this->ns2__PayPalAuthorizationService::paypalCustomerEmail = NULL;
	this->ns2__PayPalAuthorizationService::run = NULL;
	/* transient soap skipped */
}

void ns2__PayPalAuthorizationService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthorizationService::paypalOrderId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthorizationService::paypalEcOrderSetupRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthorizationService::paypalEcOrderSetupRequestToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthorizationService::paypalDoRefTransactionRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthorizationService::paypalDoRefTransactionRequestToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthorizationService::paypalCustomerEmail);
#endif
}

int ns2__PayPalAuthorizationService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalAuthorizationService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalAuthorizationService(struct soap *soap, const char *tag, int id, const ns2__PayPalAuthorizationService *a, const char *type)
{
	if (((ns2__PayPalAuthorizationService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PayPalAuthorizationService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalAuthorizationService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalOrderId", -1, (wchar_t*const*)&a->ns2__PayPalAuthorizationService::paypalOrderId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalEcOrderSetupRequestID", -1, (wchar_t*const*)&a->ns2__PayPalAuthorizationService::paypalEcOrderSetupRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalEcOrderSetupRequestToken", -1, (wchar_t*const*)&a->ns2__PayPalAuthorizationService::paypalEcOrderSetupRequestToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalDoRefTransactionRequestID", -1, (wchar_t*const*)&a->ns2__PayPalAuthorizationService::paypalDoRefTransactionRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalDoRefTransactionRequestToken", -1, (wchar_t*const*)&a->ns2__PayPalAuthorizationService::paypalDoRefTransactionRequestToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalCustomerEmail", -1, (wchar_t*const*)&a->ns2__PayPalAuthorizationService::paypalCustomerEmail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalAuthorizationService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalAuthorizationService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalAuthorizationService * SOAP_FMAC4 soap_in_ns2__PayPalAuthorizationService(struct soap *soap, const char *tag, ns2__PayPalAuthorizationService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalAuthorizationService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalAuthorizationService, sizeof(ns2__PayPalAuthorizationService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalAuthorizationService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalAuthorizationService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PayPalAuthorizationService*)a)->run))
		return NULL;
	size_t soap_flag_paypalOrderId1 = 1;
	size_t soap_flag_paypalEcOrderSetupRequestID1 = 1;
	size_t soap_flag_paypalEcOrderSetupRequestToken1 = 1;
	size_t soap_flag_paypalDoRefTransactionRequestID1 = 1;
	size_t soap_flag_paypalDoRefTransactionRequestToken1 = 1;
	size_t soap_flag_paypalCustomerEmail1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_paypalOrderId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalOrderId", (wchar_t**)&a->ns2__PayPalAuthorizationService::paypalOrderId, "xsd:string"))
				{	soap_flag_paypalOrderId1--;
					continue;
				}
			if (soap_flag_paypalEcOrderSetupRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalEcOrderSetupRequestID", (wchar_t**)&a->ns2__PayPalAuthorizationService::paypalEcOrderSetupRequestID, "xsd:string"))
				{	soap_flag_paypalEcOrderSetupRequestID1--;
					continue;
				}
			if (soap_flag_paypalEcOrderSetupRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalEcOrderSetupRequestToken", (wchar_t**)&a->ns2__PayPalAuthorizationService::paypalEcOrderSetupRequestToken, "xsd:string"))
				{	soap_flag_paypalEcOrderSetupRequestToken1--;
					continue;
				}
			if (soap_flag_paypalDoRefTransactionRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalDoRefTransactionRequestID", (wchar_t**)&a->ns2__PayPalAuthorizationService::paypalDoRefTransactionRequestID, "xsd:string"))
				{	soap_flag_paypalDoRefTransactionRequestID1--;
					continue;
				}
			if (soap_flag_paypalDoRefTransactionRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalDoRefTransactionRequestToken", (wchar_t**)&a->ns2__PayPalAuthorizationService::paypalDoRefTransactionRequestToken, "xsd:string"))
				{	soap_flag_paypalDoRefTransactionRequestToken1--;
					continue;
				}
			if (soap_flag_paypalCustomerEmail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalCustomerEmail", (wchar_t**)&a->ns2__PayPalAuthorizationService::paypalCustomerEmail, "xsd:string"))
				{	soap_flag_paypalCustomerEmail1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayPalAuthorizationService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalAuthorizationService, SOAP_TYPE_ns2__PayPalAuthorizationService, sizeof(ns2__PayPalAuthorizationService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalAuthorizationService * SOAP_FMAC2 soap_instantiate_ns2__PayPalAuthorizationService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalAuthorizationService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalAuthorizationService *p;
	size_t k = sizeof(ns2__PayPalAuthorizationService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalAuthorizationService);
		if (p)
			((ns2__PayPalAuthorizationService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalAuthorizationService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalAuthorizationService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalAuthorizationService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalAuthorizationService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalAuthorizationService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalAuthorizationService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalAuthorizationService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalAuthorizationService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalAuthorizationService * SOAP_FMAC4 soap_get_ns2__PayPalAuthorizationService(struct soap *soap, ns2__PayPalAuthorizationService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalAuthorizationService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalEcOrderSetupService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalEcOrderSetupService::paypalToken = NULL;
	this->ns2__PayPalEcOrderSetupService::paypalPayerId = NULL;
	this->ns2__PayPalEcOrderSetupService::paypalCustomerEmail = NULL;
	this->ns2__PayPalEcOrderSetupService::paypalDesc = NULL;
	this->ns2__PayPalEcOrderSetupService::paypalEcSetRequestID = NULL;
	this->ns2__PayPalEcOrderSetupService::paypalEcSetRequestToken = NULL;
	this->ns2__PayPalEcOrderSetupService::promoCode0 = NULL;
	this->ns2__PayPalEcOrderSetupService::invoiceNumber = NULL;
	this->ns2__PayPalEcOrderSetupService::run = NULL;
	/* transient soap skipped */
}

void ns2__PayPalEcOrderSetupService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupService::paypalToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupService::paypalPayerId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupService::paypalCustomerEmail);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupService::paypalDesc);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupService::paypalEcSetRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupService::paypalEcSetRequestToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupService::promoCode0);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcOrderSetupService::invoiceNumber);
#endif
}

int ns2__PayPalEcOrderSetupService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalEcOrderSetupService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalEcOrderSetupService(struct soap *soap, const char *tag, int id, const ns2__PayPalEcOrderSetupService *a, const char *type)
{
	if (((ns2__PayPalEcOrderSetupService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PayPalEcOrderSetupService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalEcOrderSetupService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalToken", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupService::paypalToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPayerId", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupService::paypalPayerId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalCustomerEmail", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupService::paypalCustomerEmail, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalDesc", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupService::paypalDesc, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalEcSetRequestID", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupService::paypalEcSetRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalEcSetRequestToken", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupService::paypalEcSetRequestToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:promoCode0", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupService::promoCode0, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:invoiceNumber", -1, (wchar_t*const*)&a->ns2__PayPalEcOrderSetupService::invoiceNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalEcOrderSetupService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalEcOrderSetupService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalEcOrderSetupService * SOAP_FMAC4 soap_in_ns2__PayPalEcOrderSetupService(struct soap *soap, const char *tag, ns2__PayPalEcOrderSetupService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalEcOrderSetupService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalEcOrderSetupService, sizeof(ns2__PayPalEcOrderSetupService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalEcOrderSetupService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalEcOrderSetupService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PayPalEcOrderSetupService*)a)->run))
		return NULL;
	size_t soap_flag_paypalToken1 = 1;
	size_t soap_flag_paypalPayerId1 = 1;
	size_t soap_flag_paypalCustomerEmail1 = 1;
	size_t soap_flag_paypalDesc1 = 1;
	size_t soap_flag_paypalEcSetRequestID1 = 1;
	size_t soap_flag_paypalEcSetRequestToken1 = 1;
	size_t soap_flag_promoCode01 = 1;
	size_t soap_flag_invoiceNumber1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_paypalToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalToken", (wchar_t**)&a->ns2__PayPalEcOrderSetupService::paypalToken, "xsd:string"))
				{	soap_flag_paypalToken1--;
					continue;
				}
			if (soap_flag_paypalPayerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPayerId", (wchar_t**)&a->ns2__PayPalEcOrderSetupService::paypalPayerId, "xsd:string"))
				{	soap_flag_paypalPayerId1--;
					continue;
				}
			if (soap_flag_paypalCustomerEmail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalCustomerEmail", (wchar_t**)&a->ns2__PayPalEcOrderSetupService::paypalCustomerEmail, "xsd:string"))
				{	soap_flag_paypalCustomerEmail1--;
					continue;
				}
			if (soap_flag_paypalDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalDesc", (wchar_t**)&a->ns2__PayPalEcOrderSetupService::paypalDesc, "xsd:string"))
				{	soap_flag_paypalDesc1--;
					continue;
				}
			if (soap_flag_paypalEcSetRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalEcSetRequestID", (wchar_t**)&a->ns2__PayPalEcOrderSetupService::paypalEcSetRequestID, "xsd:string"))
				{	soap_flag_paypalEcSetRequestID1--;
					continue;
				}
			if (soap_flag_paypalEcSetRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalEcSetRequestToken", (wchar_t**)&a->ns2__PayPalEcOrderSetupService::paypalEcSetRequestToken, "xsd:string"))
				{	soap_flag_paypalEcSetRequestToken1--;
					continue;
				}
			if (soap_flag_promoCode01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:promoCode0", (wchar_t**)&a->ns2__PayPalEcOrderSetupService::promoCode0, "xsd:string"))
				{	soap_flag_promoCode01--;
					continue;
				}
			if (soap_flag_invoiceNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:invoiceNumber", (wchar_t**)&a->ns2__PayPalEcOrderSetupService::invoiceNumber, "xsd:string"))
				{	soap_flag_invoiceNumber1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayPalEcOrderSetupService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalEcOrderSetupService, SOAP_TYPE_ns2__PayPalEcOrderSetupService, sizeof(ns2__PayPalEcOrderSetupService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalEcOrderSetupService * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcOrderSetupService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalEcOrderSetupService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalEcOrderSetupService *p;
	size_t k = sizeof(ns2__PayPalEcOrderSetupService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalEcOrderSetupService);
		if (p)
			((ns2__PayPalEcOrderSetupService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalEcOrderSetupService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalEcOrderSetupService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalEcOrderSetupService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalEcOrderSetupService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalEcOrderSetupService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalEcOrderSetupService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalEcOrderSetupService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalEcOrderSetupService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalEcOrderSetupService * SOAP_FMAC4 soap_get_ns2__PayPalEcOrderSetupService(struct soap *soap, ns2__PayPalEcOrderSetupService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalEcOrderSetupService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalRefundService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalRefundService::paypalDoCaptureRequestID = NULL;
	this->ns2__PayPalRefundService::paypalDoCaptureRequestToken = NULL;
	this->ns2__PayPalRefundService::paypalCaptureId = NULL;
	this->ns2__PayPalRefundService::paypalNote = NULL;
	this->ns2__PayPalRefundService::run = NULL;
	/* transient soap skipped */
}

void ns2__PayPalRefundService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalRefundService::paypalDoCaptureRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalRefundService::paypalDoCaptureRequestToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalRefundService::paypalCaptureId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalRefundService::paypalNote);
#endif
}

int ns2__PayPalRefundService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalRefundService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalRefundService(struct soap *soap, const char *tag, int id, const ns2__PayPalRefundService *a, const char *type)
{
	if (((ns2__PayPalRefundService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PayPalRefundService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalRefundService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalDoCaptureRequestID", -1, (wchar_t*const*)&a->ns2__PayPalRefundService::paypalDoCaptureRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalDoCaptureRequestToken", -1, (wchar_t*const*)&a->ns2__PayPalRefundService::paypalDoCaptureRequestToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalCaptureId", -1, (wchar_t*const*)&a->ns2__PayPalRefundService::paypalCaptureId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalNote", -1, (wchar_t*const*)&a->ns2__PayPalRefundService::paypalNote, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalRefundService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalRefundService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalRefundService * SOAP_FMAC4 soap_in_ns2__PayPalRefundService(struct soap *soap, const char *tag, ns2__PayPalRefundService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalRefundService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalRefundService, sizeof(ns2__PayPalRefundService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalRefundService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalRefundService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PayPalRefundService*)a)->run))
		return NULL;
	size_t soap_flag_paypalDoCaptureRequestID1 = 1;
	size_t soap_flag_paypalDoCaptureRequestToken1 = 1;
	size_t soap_flag_paypalCaptureId1 = 1;
	size_t soap_flag_paypalNote1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_paypalDoCaptureRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalDoCaptureRequestID", (wchar_t**)&a->ns2__PayPalRefundService::paypalDoCaptureRequestID, "xsd:string"))
				{	soap_flag_paypalDoCaptureRequestID1--;
					continue;
				}
			if (soap_flag_paypalDoCaptureRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalDoCaptureRequestToken", (wchar_t**)&a->ns2__PayPalRefundService::paypalDoCaptureRequestToken, "xsd:string"))
				{	soap_flag_paypalDoCaptureRequestToken1--;
					continue;
				}
			if (soap_flag_paypalCaptureId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalCaptureId", (wchar_t**)&a->ns2__PayPalRefundService::paypalCaptureId, "xsd:string"))
				{	soap_flag_paypalCaptureId1--;
					continue;
				}
			if (soap_flag_paypalNote1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalNote", (wchar_t**)&a->ns2__PayPalRefundService::paypalNote, "xsd:string"))
				{	soap_flag_paypalNote1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayPalRefundService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalRefundService, SOAP_TYPE_ns2__PayPalRefundService, sizeof(ns2__PayPalRefundService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalRefundService * SOAP_FMAC2 soap_instantiate_ns2__PayPalRefundService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalRefundService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalRefundService *p;
	size_t k = sizeof(ns2__PayPalRefundService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalRefundService);
		if (p)
			((ns2__PayPalRefundService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalRefundService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalRefundService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalRefundService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalRefundService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalRefundService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalRefundService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalRefundService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalRefundService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalRefundService * SOAP_FMAC4 soap_get_ns2__PayPalRefundService(struct soap *soap, ns2__PayPalRefundService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalRefundService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalAuthReversalService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalAuthReversalService::paypalAuthorizationId = NULL;
	this->ns2__PayPalAuthReversalService::paypalEcDoPaymentRequestID = NULL;
	this->ns2__PayPalAuthReversalService::paypalEcDoPaymentRequestToken = NULL;
	this->ns2__PayPalAuthReversalService::paypalAuthorizationRequestID = NULL;
	this->ns2__PayPalAuthReversalService::paypalAuthorizationRequestToken = NULL;
	this->ns2__PayPalAuthReversalService::paypalEcOrderSetupRequestID = NULL;
	this->ns2__PayPalAuthReversalService::paypalEcOrderSetupRequestToken = NULL;
	this->ns2__PayPalAuthReversalService::run = NULL;
	/* transient soap skipped */
}

void ns2__PayPalAuthReversalService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthReversalService::paypalAuthorizationId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthReversalService::paypalEcDoPaymentRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthReversalService::paypalEcDoPaymentRequestToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthReversalService::paypalAuthorizationRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthReversalService::paypalAuthorizationRequestToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthReversalService::paypalEcOrderSetupRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalAuthReversalService::paypalEcOrderSetupRequestToken);
#endif
}

int ns2__PayPalAuthReversalService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalAuthReversalService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalAuthReversalService(struct soap *soap, const char *tag, int id, const ns2__PayPalAuthReversalService *a, const char *type)
{
	if (((ns2__PayPalAuthReversalService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PayPalAuthReversalService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalAuthReversalService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalAuthorizationId", -1, (wchar_t*const*)&a->ns2__PayPalAuthReversalService::paypalAuthorizationId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalEcDoPaymentRequestID", -1, (wchar_t*const*)&a->ns2__PayPalAuthReversalService::paypalEcDoPaymentRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalEcDoPaymentRequestToken", -1, (wchar_t*const*)&a->ns2__PayPalAuthReversalService::paypalEcDoPaymentRequestToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalAuthorizationRequestID", -1, (wchar_t*const*)&a->ns2__PayPalAuthReversalService::paypalAuthorizationRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalAuthorizationRequestToken", -1, (wchar_t*const*)&a->ns2__PayPalAuthReversalService::paypalAuthorizationRequestToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalEcOrderSetupRequestID", -1, (wchar_t*const*)&a->ns2__PayPalAuthReversalService::paypalEcOrderSetupRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalEcOrderSetupRequestToken", -1, (wchar_t*const*)&a->ns2__PayPalAuthReversalService::paypalEcOrderSetupRequestToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalAuthReversalService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalAuthReversalService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalAuthReversalService * SOAP_FMAC4 soap_in_ns2__PayPalAuthReversalService(struct soap *soap, const char *tag, ns2__PayPalAuthReversalService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalAuthReversalService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalAuthReversalService, sizeof(ns2__PayPalAuthReversalService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalAuthReversalService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalAuthReversalService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PayPalAuthReversalService*)a)->run))
		return NULL;
	size_t soap_flag_paypalAuthorizationId1 = 1;
	size_t soap_flag_paypalEcDoPaymentRequestID1 = 1;
	size_t soap_flag_paypalEcDoPaymentRequestToken1 = 1;
	size_t soap_flag_paypalAuthorizationRequestID1 = 1;
	size_t soap_flag_paypalAuthorizationRequestToken1 = 1;
	size_t soap_flag_paypalEcOrderSetupRequestID1 = 1;
	size_t soap_flag_paypalEcOrderSetupRequestToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_paypalAuthorizationId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalAuthorizationId", (wchar_t**)&a->ns2__PayPalAuthReversalService::paypalAuthorizationId, "xsd:string"))
				{	soap_flag_paypalAuthorizationId1--;
					continue;
				}
			if (soap_flag_paypalEcDoPaymentRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalEcDoPaymentRequestID", (wchar_t**)&a->ns2__PayPalAuthReversalService::paypalEcDoPaymentRequestID, "xsd:string"))
				{	soap_flag_paypalEcDoPaymentRequestID1--;
					continue;
				}
			if (soap_flag_paypalEcDoPaymentRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalEcDoPaymentRequestToken", (wchar_t**)&a->ns2__PayPalAuthReversalService::paypalEcDoPaymentRequestToken, "xsd:string"))
				{	soap_flag_paypalEcDoPaymentRequestToken1--;
					continue;
				}
			if (soap_flag_paypalAuthorizationRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalAuthorizationRequestID", (wchar_t**)&a->ns2__PayPalAuthReversalService::paypalAuthorizationRequestID, "xsd:string"))
				{	soap_flag_paypalAuthorizationRequestID1--;
					continue;
				}
			if (soap_flag_paypalAuthorizationRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalAuthorizationRequestToken", (wchar_t**)&a->ns2__PayPalAuthReversalService::paypalAuthorizationRequestToken, "xsd:string"))
				{	soap_flag_paypalAuthorizationRequestToken1--;
					continue;
				}
			if (soap_flag_paypalEcOrderSetupRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalEcOrderSetupRequestID", (wchar_t**)&a->ns2__PayPalAuthReversalService::paypalEcOrderSetupRequestID, "xsd:string"))
				{	soap_flag_paypalEcOrderSetupRequestID1--;
					continue;
				}
			if (soap_flag_paypalEcOrderSetupRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalEcOrderSetupRequestToken", (wchar_t**)&a->ns2__PayPalAuthReversalService::paypalEcOrderSetupRequestToken, "xsd:string"))
				{	soap_flag_paypalEcOrderSetupRequestToken1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayPalAuthReversalService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalAuthReversalService, SOAP_TYPE_ns2__PayPalAuthReversalService, sizeof(ns2__PayPalAuthReversalService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalAuthReversalService * SOAP_FMAC2 soap_instantiate_ns2__PayPalAuthReversalService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalAuthReversalService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalAuthReversalService *p;
	size_t k = sizeof(ns2__PayPalAuthReversalService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalAuthReversalService);
		if (p)
			((ns2__PayPalAuthReversalService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalAuthReversalService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalAuthReversalService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalAuthReversalService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalAuthReversalService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalAuthReversalService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalAuthReversalService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalAuthReversalService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalAuthReversalService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalAuthReversalService * SOAP_FMAC4 soap_get_ns2__PayPalAuthReversalService(struct soap *soap, ns2__PayPalAuthReversalService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalAuthReversalService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalDoCaptureService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalDoCaptureService::paypalAuthorizationId = NULL;
	this->ns2__PayPalDoCaptureService::completeType = NULL;
	this->ns2__PayPalDoCaptureService::paypalEcDoPaymentRequestID = NULL;
	this->ns2__PayPalDoCaptureService::paypalEcDoPaymentRequestToken = NULL;
	this->ns2__PayPalDoCaptureService::paypalAuthorizationRequestID = NULL;
	this->ns2__PayPalDoCaptureService::paypalAuthorizationRequestToken = NULL;
	this->ns2__PayPalDoCaptureService::invoiceNumber = NULL;
	this->ns2__PayPalDoCaptureService::run = NULL;
	/* transient soap skipped */
}

void ns2__PayPalDoCaptureService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureService::paypalAuthorizationId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureService::completeType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureService::paypalEcDoPaymentRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureService::paypalEcDoPaymentRequestToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureService::paypalAuthorizationRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureService::paypalAuthorizationRequestToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalDoCaptureService::invoiceNumber);
#endif
}

int ns2__PayPalDoCaptureService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalDoCaptureService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalDoCaptureService(struct soap *soap, const char *tag, int id, const ns2__PayPalDoCaptureService *a, const char *type)
{
	if (((ns2__PayPalDoCaptureService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PayPalDoCaptureService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalDoCaptureService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalAuthorizationId", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureService::paypalAuthorizationId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:completeType", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureService::completeType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalEcDoPaymentRequestID", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureService::paypalEcDoPaymentRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalEcDoPaymentRequestToken", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureService::paypalEcDoPaymentRequestToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalAuthorizationRequestID", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureService::paypalAuthorizationRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalAuthorizationRequestToken", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureService::paypalAuthorizationRequestToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:invoiceNumber", -1, (wchar_t*const*)&a->ns2__PayPalDoCaptureService::invoiceNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalDoCaptureService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalDoCaptureService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalDoCaptureService * SOAP_FMAC4 soap_in_ns2__PayPalDoCaptureService(struct soap *soap, const char *tag, ns2__PayPalDoCaptureService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalDoCaptureService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalDoCaptureService, sizeof(ns2__PayPalDoCaptureService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalDoCaptureService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalDoCaptureService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PayPalDoCaptureService*)a)->run))
		return NULL;
	size_t soap_flag_paypalAuthorizationId1 = 1;
	size_t soap_flag_completeType1 = 1;
	size_t soap_flag_paypalEcDoPaymentRequestID1 = 1;
	size_t soap_flag_paypalEcDoPaymentRequestToken1 = 1;
	size_t soap_flag_paypalAuthorizationRequestID1 = 1;
	size_t soap_flag_paypalAuthorizationRequestToken1 = 1;
	size_t soap_flag_invoiceNumber1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_paypalAuthorizationId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalAuthorizationId", (wchar_t**)&a->ns2__PayPalDoCaptureService::paypalAuthorizationId, "xsd:string"))
				{	soap_flag_paypalAuthorizationId1--;
					continue;
				}
			if (soap_flag_completeType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:completeType", (wchar_t**)&a->ns2__PayPalDoCaptureService::completeType, "xsd:string"))
				{	soap_flag_completeType1--;
					continue;
				}
			if (soap_flag_paypalEcDoPaymentRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalEcDoPaymentRequestID", (wchar_t**)&a->ns2__PayPalDoCaptureService::paypalEcDoPaymentRequestID, "xsd:string"))
				{	soap_flag_paypalEcDoPaymentRequestID1--;
					continue;
				}
			if (soap_flag_paypalEcDoPaymentRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalEcDoPaymentRequestToken", (wchar_t**)&a->ns2__PayPalDoCaptureService::paypalEcDoPaymentRequestToken, "xsd:string"))
				{	soap_flag_paypalEcDoPaymentRequestToken1--;
					continue;
				}
			if (soap_flag_paypalAuthorizationRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalAuthorizationRequestID", (wchar_t**)&a->ns2__PayPalDoCaptureService::paypalAuthorizationRequestID, "xsd:string"))
				{	soap_flag_paypalAuthorizationRequestID1--;
					continue;
				}
			if (soap_flag_paypalAuthorizationRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalAuthorizationRequestToken", (wchar_t**)&a->ns2__PayPalDoCaptureService::paypalAuthorizationRequestToken, "xsd:string"))
				{	soap_flag_paypalAuthorizationRequestToken1--;
					continue;
				}
			if (soap_flag_invoiceNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:invoiceNumber", (wchar_t**)&a->ns2__PayPalDoCaptureService::invoiceNumber, "xsd:string"))
				{	soap_flag_invoiceNumber1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayPalDoCaptureService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalDoCaptureService, SOAP_TYPE_ns2__PayPalDoCaptureService, sizeof(ns2__PayPalDoCaptureService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalDoCaptureService * SOAP_FMAC2 soap_instantiate_ns2__PayPalDoCaptureService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalDoCaptureService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalDoCaptureService *p;
	size_t k = sizeof(ns2__PayPalDoCaptureService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalDoCaptureService);
		if (p)
			((ns2__PayPalDoCaptureService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalDoCaptureService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalDoCaptureService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalDoCaptureService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalDoCaptureService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalDoCaptureService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalDoCaptureService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalDoCaptureService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalDoCaptureService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalDoCaptureService * SOAP_FMAC4 soap_get_ns2__PayPalDoCaptureService(struct soap *soap, ns2__PayPalDoCaptureService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalDoCaptureService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalEcDoPaymentService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalEcDoPaymentService::paypalToken = NULL;
	this->ns2__PayPalEcDoPaymentService::paypalPayerId = NULL;
	this->ns2__PayPalEcDoPaymentService::paypalCustomerEmail = NULL;
	this->ns2__PayPalEcDoPaymentService::paypalDesc = NULL;
	this->ns2__PayPalEcDoPaymentService::paypalEcSetRequestID = NULL;
	this->ns2__PayPalEcDoPaymentService::paypalEcSetRequestToken = NULL;
	this->ns2__PayPalEcDoPaymentService::promoCode0 = NULL;
	this->ns2__PayPalEcDoPaymentService::invoiceNumber = NULL;
	this->ns2__PayPalEcDoPaymentService::run = NULL;
	/* transient soap skipped */
}

void ns2__PayPalEcDoPaymentService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentService::paypalToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentService::paypalPayerId);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentService::paypalCustomerEmail);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentService::paypalDesc);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentService::paypalEcSetRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentService::paypalEcSetRequestToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentService::promoCode0);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcDoPaymentService::invoiceNumber);
#endif
}

int ns2__PayPalEcDoPaymentService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalEcDoPaymentService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalEcDoPaymentService(struct soap *soap, const char *tag, int id, const ns2__PayPalEcDoPaymentService *a, const char *type)
{
	if (((ns2__PayPalEcDoPaymentService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PayPalEcDoPaymentService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalEcDoPaymentService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalToken", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentService::paypalToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPayerId", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentService::paypalPayerId, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalCustomerEmail", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentService::paypalCustomerEmail, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalDesc", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentService::paypalDesc, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalEcSetRequestID", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentService::paypalEcSetRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalEcSetRequestToken", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentService::paypalEcSetRequestToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:promoCode0", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentService::promoCode0, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:invoiceNumber", -1, (wchar_t*const*)&a->ns2__PayPalEcDoPaymentService::invoiceNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalEcDoPaymentService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalEcDoPaymentService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalEcDoPaymentService * SOAP_FMAC4 soap_in_ns2__PayPalEcDoPaymentService(struct soap *soap, const char *tag, ns2__PayPalEcDoPaymentService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalEcDoPaymentService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalEcDoPaymentService, sizeof(ns2__PayPalEcDoPaymentService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalEcDoPaymentService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalEcDoPaymentService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PayPalEcDoPaymentService*)a)->run))
		return NULL;
	size_t soap_flag_paypalToken1 = 1;
	size_t soap_flag_paypalPayerId1 = 1;
	size_t soap_flag_paypalCustomerEmail1 = 1;
	size_t soap_flag_paypalDesc1 = 1;
	size_t soap_flag_paypalEcSetRequestID1 = 1;
	size_t soap_flag_paypalEcSetRequestToken1 = 1;
	size_t soap_flag_promoCode01 = 1;
	size_t soap_flag_invoiceNumber1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_paypalToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalToken", (wchar_t**)&a->ns2__PayPalEcDoPaymentService::paypalToken, "xsd:string"))
				{	soap_flag_paypalToken1--;
					continue;
				}
			if (soap_flag_paypalPayerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPayerId", (wchar_t**)&a->ns2__PayPalEcDoPaymentService::paypalPayerId, "xsd:string"))
				{	soap_flag_paypalPayerId1--;
					continue;
				}
			if (soap_flag_paypalCustomerEmail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalCustomerEmail", (wchar_t**)&a->ns2__PayPalEcDoPaymentService::paypalCustomerEmail, "xsd:string"))
				{	soap_flag_paypalCustomerEmail1--;
					continue;
				}
			if (soap_flag_paypalDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalDesc", (wchar_t**)&a->ns2__PayPalEcDoPaymentService::paypalDesc, "xsd:string"))
				{	soap_flag_paypalDesc1--;
					continue;
				}
			if (soap_flag_paypalEcSetRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalEcSetRequestID", (wchar_t**)&a->ns2__PayPalEcDoPaymentService::paypalEcSetRequestID, "xsd:string"))
				{	soap_flag_paypalEcSetRequestID1--;
					continue;
				}
			if (soap_flag_paypalEcSetRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalEcSetRequestToken", (wchar_t**)&a->ns2__PayPalEcDoPaymentService::paypalEcSetRequestToken, "xsd:string"))
				{	soap_flag_paypalEcSetRequestToken1--;
					continue;
				}
			if (soap_flag_promoCode01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:promoCode0", (wchar_t**)&a->ns2__PayPalEcDoPaymentService::promoCode0, "xsd:string"))
				{	soap_flag_promoCode01--;
					continue;
				}
			if (soap_flag_invoiceNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:invoiceNumber", (wchar_t**)&a->ns2__PayPalEcDoPaymentService::invoiceNumber, "xsd:string"))
				{	soap_flag_invoiceNumber1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayPalEcDoPaymentService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalEcDoPaymentService, SOAP_TYPE_ns2__PayPalEcDoPaymentService, sizeof(ns2__PayPalEcDoPaymentService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalEcDoPaymentService * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcDoPaymentService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalEcDoPaymentService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalEcDoPaymentService *p;
	size_t k = sizeof(ns2__PayPalEcDoPaymentService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalEcDoPaymentService);
		if (p)
			((ns2__PayPalEcDoPaymentService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalEcDoPaymentService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalEcDoPaymentService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalEcDoPaymentService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalEcDoPaymentService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalEcDoPaymentService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalEcDoPaymentService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalEcDoPaymentService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalEcDoPaymentService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalEcDoPaymentService * SOAP_FMAC4 soap_get_ns2__PayPalEcDoPaymentService(struct soap *soap, ns2__PayPalEcDoPaymentService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalEcDoPaymentService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalEcGetDetailsService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalEcGetDetailsService::paypalToken = NULL;
	this->ns2__PayPalEcGetDetailsService::paypalEcSetRequestID = NULL;
	this->ns2__PayPalEcGetDetailsService::paypalEcSetRequestToken = NULL;
	this->ns2__PayPalEcGetDetailsService::run = NULL;
	/* transient soap skipped */
}

void ns2__PayPalEcGetDetailsService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsService::paypalToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsService::paypalEcSetRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcGetDetailsService::paypalEcSetRequestToken);
#endif
}

int ns2__PayPalEcGetDetailsService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalEcGetDetailsService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalEcGetDetailsService(struct soap *soap, const char *tag, int id, const ns2__PayPalEcGetDetailsService *a, const char *type)
{
	if (((ns2__PayPalEcGetDetailsService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PayPalEcGetDetailsService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalEcGetDetailsService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalToken", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsService::paypalToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalEcSetRequestID", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsService::paypalEcSetRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalEcSetRequestToken", -1, (wchar_t*const*)&a->ns2__PayPalEcGetDetailsService::paypalEcSetRequestToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalEcGetDetailsService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalEcGetDetailsService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalEcGetDetailsService * SOAP_FMAC4 soap_in_ns2__PayPalEcGetDetailsService(struct soap *soap, const char *tag, ns2__PayPalEcGetDetailsService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalEcGetDetailsService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalEcGetDetailsService, sizeof(ns2__PayPalEcGetDetailsService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalEcGetDetailsService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalEcGetDetailsService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PayPalEcGetDetailsService*)a)->run))
		return NULL;
	size_t soap_flag_paypalToken1 = 1;
	size_t soap_flag_paypalEcSetRequestID1 = 1;
	size_t soap_flag_paypalEcSetRequestToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_paypalToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalToken", (wchar_t**)&a->ns2__PayPalEcGetDetailsService::paypalToken, "xsd:string"))
				{	soap_flag_paypalToken1--;
					continue;
				}
			if (soap_flag_paypalEcSetRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalEcSetRequestID", (wchar_t**)&a->ns2__PayPalEcGetDetailsService::paypalEcSetRequestID, "xsd:string"))
				{	soap_flag_paypalEcSetRequestID1--;
					continue;
				}
			if (soap_flag_paypalEcSetRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalEcSetRequestToken", (wchar_t**)&a->ns2__PayPalEcGetDetailsService::paypalEcSetRequestToken, "xsd:string"))
				{	soap_flag_paypalEcSetRequestToken1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayPalEcGetDetailsService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalEcGetDetailsService, SOAP_TYPE_ns2__PayPalEcGetDetailsService, sizeof(ns2__PayPalEcGetDetailsService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalEcGetDetailsService * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcGetDetailsService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalEcGetDetailsService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalEcGetDetailsService *p;
	size_t k = sizeof(ns2__PayPalEcGetDetailsService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalEcGetDetailsService);
		if (p)
			((ns2__PayPalEcGetDetailsService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalEcGetDetailsService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalEcGetDetailsService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalEcGetDetailsService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalEcGetDetailsService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalEcGetDetailsService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalEcGetDetailsService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalEcGetDetailsService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalEcGetDetailsService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalEcGetDetailsService * SOAP_FMAC4 soap_get_ns2__PayPalEcGetDetailsService(struct soap *soap, ns2__PayPalEcGetDetailsService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalEcGetDetailsService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalEcSetService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalEcSetService::paypalReturn = NULL;
	this->ns2__PayPalEcSetService::paypalCancelReturn = NULL;
	this->ns2__PayPalEcSetService::paypalMaxamt = NULL;
	this->ns2__PayPalEcSetService::paypalCustomerEmail = NULL;
	this->ns2__PayPalEcSetService::paypalDesc = NULL;
	this->ns2__PayPalEcSetService::paypalReqconfirmshipping = NULL;
	this->ns2__PayPalEcSetService::paypalNoshipping = NULL;
	this->ns2__PayPalEcSetService::paypalAddressOverride = NULL;
	this->ns2__PayPalEcSetService::paypalToken = NULL;
	this->ns2__PayPalEcSetService::paypalLc = NULL;
	this->ns2__PayPalEcSetService::paypalPagestyle = NULL;
	this->ns2__PayPalEcSetService::paypalHdrimg = NULL;
	this->ns2__PayPalEcSetService::paypalHdrbordercolor = NULL;
	this->ns2__PayPalEcSetService::paypalHdrbackcolor = NULL;
	this->ns2__PayPalEcSetService::paypalPayflowcolor = NULL;
	this->ns2__PayPalEcSetService::paypalEcSetRequestID = NULL;
	this->ns2__PayPalEcSetService::paypalEcSetRequestToken = NULL;
	this->ns2__PayPalEcSetService::promoCode0 = NULL;
	this->ns2__PayPalEcSetService::requestBillingAddress = NULL;
	this->ns2__PayPalEcSetService::invoiceNumber = NULL;
	this->ns2__PayPalEcSetService::paypalBillingType = NULL;
	this->ns2__PayPalEcSetService::paypalBillingAgreementDesc = NULL;
	this->ns2__PayPalEcSetService::paypalPaymentType = NULL;
	this->ns2__PayPalEcSetService::paypalBillingAgreementCustom = NULL;
	this->ns2__PayPalEcSetService::paypalLogoimg = NULL;
	this->ns2__PayPalEcSetService::run = NULL;
	/* transient soap skipped */
}

void ns2__PayPalEcSetService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::paypalReturn);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::paypalCancelReturn);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::paypalMaxamt);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::paypalCustomerEmail);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::paypalDesc);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::paypalReqconfirmshipping);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::paypalNoshipping);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::paypalAddressOverride);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::paypalToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::paypalLc);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::paypalPagestyle);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::paypalHdrimg);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::paypalHdrbordercolor);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::paypalHdrbackcolor);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::paypalPayflowcolor);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::paypalEcSetRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::paypalEcSetRequestToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::promoCode0);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::requestBillingAddress);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::invoiceNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::paypalBillingType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::paypalBillingAgreementDesc);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::paypalPaymentType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::paypalBillingAgreementCustom);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalEcSetService::paypalLogoimg);
#endif
}

int ns2__PayPalEcSetService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalEcSetService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalEcSetService(struct soap *soap, const char *tag, int id, const ns2__PayPalEcSetService *a, const char *type)
{
	if (((ns2__PayPalEcSetService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PayPalEcSetService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalEcSetService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalReturn", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::paypalReturn, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalCancelReturn", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::paypalCancelReturn, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalMaxamt", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::paypalMaxamt, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalCustomerEmail", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::paypalCustomerEmail, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalDesc", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::paypalDesc, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalReqconfirmshipping", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::paypalReqconfirmshipping, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalNoshipping", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::paypalNoshipping, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalAddressOverride", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::paypalAddressOverride, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalToken", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::paypalToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalLc", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::paypalLc, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPagestyle", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::paypalPagestyle, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalHdrimg", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::paypalHdrimg, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalHdrbordercolor", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::paypalHdrbordercolor, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalHdrbackcolor", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::paypalHdrbackcolor, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPayflowcolor", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::paypalPayflowcolor, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalEcSetRequestID", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::paypalEcSetRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalEcSetRequestToken", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::paypalEcSetRequestToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:promoCode0", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::promoCode0, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:requestBillingAddress", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::requestBillingAddress, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:invoiceNumber", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::invoiceNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalBillingType", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::paypalBillingType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalBillingAgreementDesc", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::paypalBillingAgreementDesc, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalPaymentType", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::paypalPaymentType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalBillingAgreementCustom", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::paypalBillingAgreementCustom, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paypalLogoimg", -1, (wchar_t*const*)&a->ns2__PayPalEcSetService::paypalLogoimg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalEcSetService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalEcSetService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalEcSetService * SOAP_FMAC4 soap_in_ns2__PayPalEcSetService(struct soap *soap, const char *tag, ns2__PayPalEcSetService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalEcSetService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalEcSetService, sizeof(ns2__PayPalEcSetService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalEcSetService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalEcSetService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PayPalEcSetService*)a)->run))
		return NULL;
	size_t soap_flag_paypalReturn1 = 1;
	size_t soap_flag_paypalCancelReturn1 = 1;
	size_t soap_flag_paypalMaxamt1 = 1;
	size_t soap_flag_paypalCustomerEmail1 = 1;
	size_t soap_flag_paypalDesc1 = 1;
	size_t soap_flag_paypalReqconfirmshipping1 = 1;
	size_t soap_flag_paypalNoshipping1 = 1;
	size_t soap_flag_paypalAddressOverride1 = 1;
	size_t soap_flag_paypalToken1 = 1;
	size_t soap_flag_paypalLc1 = 1;
	size_t soap_flag_paypalPagestyle1 = 1;
	size_t soap_flag_paypalHdrimg1 = 1;
	size_t soap_flag_paypalHdrbordercolor1 = 1;
	size_t soap_flag_paypalHdrbackcolor1 = 1;
	size_t soap_flag_paypalPayflowcolor1 = 1;
	size_t soap_flag_paypalEcSetRequestID1 = 1;
	size_t soap_flag_paypalEcSetRequestToken1 = 1;
	size_t soap_flag_promoCode01 = 1;
	size_t soap_flag_requestBillingAddress1 = 1;
	size_t soap_flag_invoiceNumber1 = 1;
	size_t soap_flag_paypalBillingType1 = 1;
	size_t soap_flag_paypalBillingAgreementDesc1 = 1;
	size_t soap_flag_paypalPaymentType1 = 1;
	size_t soap_flag_paypalBillingAgreementCustom1 = 1;
	size_t soap_flag_paypalLogoimg1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_paypalReturn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalReturn", (wchar_t**)&a->ns2__PayPalEcSetService::paypalReturn, "xsd:string"))
				{	soap_flag_paypalReturn1--;
					continue;
				}
			if (soap_flag_paypalCancelReturn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalCancelReturn", (wchar_t**)&a->ns2__PayPalEcSetService::paypalCancelReturn, "xsd:string"))
				{	soap_flag_paypalCancelReturn1--;
					continue;
				}
			if (soap_flag_paypalMaxamt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalMaxamt", (wchar_t**)&a->ns2__PayPalEcSetService::paypalMaxamt, "xsd:string"))
				{	soap_flag_paypalMaxamt1--;
					continue;
				}
			if (soap_flag_paypalCustomerEmail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalCustomerEmail", (wchar_t**)&a->ns2__PayPalEcSetService::paypalCustomerEmail, "xsd:string"))
				{	soap_flag_paypalCustomerEmail1--;
					continue;
				}
			if (soap_flag_paypalDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalDesc", (wchar_t**)&a->ns2__PayPalEcSetService::paypalDesc, "xsd:string"))
				{	soap_flag_paypalDesc1--;
					continue;
				}
			if (soap_flag_paypalReqconfirmshipping1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalReqconfirmshipping", (wchar_t**)&a->ns2__PayPalEcSetService::paypalReqconfirmshipping, "xsd:string"))
				{	soap_flag_paypalReqconfirmshipping1--;
					continue;
				}
			if (soap_flag_paypalNoshipping1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalNoshipping", (wchar_t**)&a->ns2__PayPalEcSetService::paypalNoshipping, "xsd:string"))
				{	soap_flag_paypalNoshipping1--;
					continue;
				}
			if (soap_flag_paypalAddressOverride1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalAddressOverride", (wchar_t**)&a->ns2__PayPalEcSetService::paypalAddressOverride, "xsd:string"))
				{	soap_flag_paypalAddressOverride1--;
					continue;
				}
			if (soap_flag_paypalToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalToken", (wchar_t**)&a->ns2__PayPalEcSetService::paypalToken, "xsd:string"))
				{	soap_flag_paypalToken1--;
					continue;
				}
			if (soap_flag_paypalLc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalLc", (wchar_t**)&a->ns2__PayPalEcSetService::paypalLc, "xsd:string"))
				{	soap_flag_paypalLc1--;
					continue;
				}
			if (soap_flag_paypalPagestyle1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPagestyle", (wchar_t**)&a->ns2__PayPalEcSetService::paypalPagestyle, "xsd:string"))
				{	soap_flag_paypalPagestyle1--;
					continue;
				}
			if (soap_flag_paypalHdrimg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalHdrimg", (wchar_t**)&a->ns2__PayPalEcSetService::paypalHdrimg, "xsd:string"))
				{	soap_flag_paypalHdrimg1--;
					continue;
				}
			if (soap_flag_paypalHdrbordercolor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalHdrbordercolor", (wchar_t**)&a->ns2__PayPalEcSetService::paypalHdrbordercolor, "xsd:string"))
				{	soap_flag_paypalHdrbordercolor1--;
					continue;
				}
			if (soap_flag_paypalHdrbackcolor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalHdrbackcolor", (wchar_t**)&a->ns2__PayPalEcSetService::paypalHdrbackcolor, "xsd:string"))
				{	soap_flag_paypalHdrbackcolor1--;
					continue;
				}
			if (soap_flag_paypalPayflowcolor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPayflowcolor", (wchar_t**)&a->ns2__PayPalEcSetService::paypalPayflowcolor, "xsd:string"))
				{	soap_flag_paypalPayflowcolor1--;
					continue;
				}
			if (soap_flag_paypalEcSetRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalEcSetRequestID", (wchar_t**)&a->ns2__PayPalEcSetService::paypalEcSetRequestID, "xsd:string"))
				{	soap_flag_paypalEcSetRequestID1--;
					continue;
				}
			if (soap_flag_paypalEcSetRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalEcSetRequestToken", (wchar_t**)&a->ns2__PayPalEcSetService::paypalEcSetRequestToken, "xsd:string"))
				{	soap_flag_paypalEcSetRequestToken1--;
					continue;
				}
			if (soap_flag_promoCode01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:promoCode0", (wchar_t**)&a->ns2__PayPalEcSetService::promoCode0, "xsd:string"))
				{	soap_flag_promoCode01--;
					continue;
				}
			if (soap_flag_requestBillingAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:requestBillingAddress", (wchar_t**)&a->ns2__PayPalEcSetService::requestBillingAddress, "xsd:string"))
				{	soap_flag_requestBillingAddress1--;
					continue;
				}
			if (soap_flag_invoiceNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:invoiceNumber", (wchar_t**)&a->ns2__PayPalEcSetService::invoiceNumber, "xsd:string"))
				{	soap_flag_invoiceNumber1--;
					continue;
				}
			if (soap_flag_paypalBillingType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalBillingType", (wchar_t**)&a->ns2__PayPalEcSetService::paypalBillingType, "xsd:string"))
				{	soap_flag_paypalBillingType1--;
					continue;
				}
			if (soap_flag_paypalBillingAgreementDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalBillingAgreementDesc", (wchar_t**)&a->ns2__PayPalEcSetService::paypalBillingAgreementDesc, "xsd:string"))
				{	soap_flag_paypalBillingAgreementDesc1--;
					continue;
				}
			if (soap_flag_paypalPaymentType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalPaymentType", (wchar_t**)&a->ns2__PayPalEcSetService::paypalPaymentType, "xsd:string"))
				{	soap_flag_paypalPaymentType1--;
					continue;
				}
			if (soap_flag_paypalBillingAgreementCustom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalBillingAgreementCustom", (wchar_t**)&a->ns2__PayPalEcSetService::paypalBillingAgreementCustom, "xsd:string"))
				{	soap_flag_paypalBillingAgreementCustom1--;
					continue;
				}
			if (soap_flag_paypalLogoimg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paypalLogoimg", (wchar_t**)&a->ns2__PayPalEcSetService::paypalLogoimg, "xsd:string"))
				{	soap_flag_paypalLogoimg1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayPalEcSetService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalEcSetService, SOAP_TYPE_ns2__PayPalEcSetService, sizeof(ns2__PayPalEcSetService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalEcSetService * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcSetService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalEcSetService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalEcSetService *p;
	size_t k = sizeof(ns2__PayPalEcSetService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalEcSetService);
		if (p)
			((ns2__PayPalEcSetService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalEcSetService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalEcSetService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalEcSetService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalEcSetService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalEcSetService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalEcSetService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalEcSetService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalEcSetService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalEcSetService * SOAP_FMAC4 soap_get_ns2__PayPalEcSetService(struct soap *soap, ns2__PayPalEcSetService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalEcSetService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalCreditService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalCreditService::payPalPaymentRequestID = NULL;
	this->ns2__PayPalCreditService::reconciliationID = NULL;
	this->ns2__PayPalCreditService::payPalPaymentRequestToken = NULL;
	this->ns2__PayPalCreditService::run = NULL;
	/* transient soap skipped */
}

void ns2__PayPalCreditService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalCreditService::payPalPaymentRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalCreditService::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalCreditService::payPalPaymentRequestToken);
#endif
}

int ns2__PayPalCreditService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalCreditService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalCreditService(struct soap *soap, const char *tag, int id, const ns2__PayPalCreditService *a, const char *type)
{
	if (((ns2__PayPalCreditService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PayPalCreditService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalCreditService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payPalPaymentRequestID", -1, (wchar_t*const*)&a->ns2__PayPalCreditService::payPalPaymentRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__PayPalCreditService::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:payPalPaymentRequestToken", -1, (wchar_t*const*)&a->ns2__PayPalCreditService::payPalPaymentRequestToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalCreditService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalCreditService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalCreditService * SOAP_FMAC4 soap_in_ns2__PayPalCreditService(struct soap *soap, const char *tag, ns2__PayPalCreditService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalCreditService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalCreditService, sizeof(ns2__PayPalCreditService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalCreditService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalCreditService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PayPalCreditService*)a)->run))
		return NULL;
	size_t soap_flag_payPalPaymentRequestID1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_payPalPaymentRequestToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_payPalPaymentRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payPalPaymentRequestID", (wchar_t**)&a->ns2__PayPalCreditService::payPalPaymentRequestID, "xsd:string"))
				{	soap_flag_payPalPaymentRequestID1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__PayPalCreditService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_payPalPaymentRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:payPalPaymentRequestToken", (wchar_t**)&a->ns2__PayPalCreditService::payPalPaymentRequestToken, "xsd:string"))
				{	soap_flag_payPalPaymentRequestToken1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayPalCreditService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalCreditService, SOAP_TYPE_ns2__PayPalCreditService, sizeof(ns2__PayPalCreditService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalCreditService * SOAP_FMAC2 soap_instantiate_ns2__PayPalCreditService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalCreditService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalCreditService *p;
	size_t k = sizeof(ns2__PayPalCreditService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalCreditService);
		if (p)
			((ns2__PayPalCreditService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalCreditService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalCreditService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalCreditService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalCreditService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalCreditService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalCreditService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalCreditService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalCreditService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalCreditService * SOAP_FMAC4 soap_get_ns2__PayPalCreditService(struct soap *soap, ns2__PayPalCreditService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalCreditService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayPalPaymentService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayPalPaymentService::cancelURL = NULL;
	this->ns2__PayPalPaymentService::successURL = NULL;
	this->ns2__PayPalPaymentService::reconciliationID = NULL;
	this->ns2__PayPalPaymentService::run = NULL;
	/* transient soap skipped */
}

void ns2__PayPalPaymentService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPaymentService::cancelURL);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPaymentService::successURL);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayPalPaymentService::reconciliationID);
#endif
}

int ns2__PayPalPaymentService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayPalPaymentService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayPalPaymentService(struct soap *soap, const char *tag, int id, const ns2__PayPalPaymentService *a, const char *type)
{
	if (((ns2__PayPalPaymentService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PayPalPaymentService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayPalPaymentService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cancelURL", -1, (wchar_t*const*)&a->ns2__PayPalPaymentService::cancelURL, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:successURL", -1, (wchar_t*const*)&a->ns2__PayPalPaymentService::successURL, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__PayPalPaymentService::reconciliationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayPalPaymentService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayPalPaymentService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayPalPaymentService * SOAP_FMAC4 soap_in_ns2__PayPalPaymentService(struct soap *soap, const char *tag, ns2__PayPalPaymentService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayPalPaymentService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayPalPaymentService, sizeof(ns2__PayPalPaymentService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayPalPaymentService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayPalPaymentService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PayPalPaymentService*)a)->run))
		return NULL;
	size_t soap_flag_cancelURL1 = 1;
	size_t soap_flag_successURL1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cancelURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cancelURL", (wchar_t**)&a->ns2__PayPalPaymentService::cancelURL, "xsd:string"))
				{	soap_flag_cancelURL1--;
					continue;
				}
			if (soap_flag_successURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:successURL", (wchar_t**)&a->ns2__PayPalPaymentService::successURL, "xsd:string"))
				{	soap_flag_successURL1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__PayPalPaymentService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayPalPaymentService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayPalPaymentService, SOAP_TYPE_ns2__PayPalPaymentService, sizeof(ns2__PayPalPaymentService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayPalPaymentService * SOAP_FMAC2 soap_instantiate_ns2__PayPalPaymentService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayPalPaymentService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayPalPaymentService *p;
	size_t k = sizeof(ns2__PayPalPaymentService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayPalPaymentService);
		if (p)
			((ns2__PayPalPaymentService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayPalPaymentService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayPalPaymentService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayPalPaymentService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayPalPaymentService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayPalPaymentService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayPalPaymentService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayPalPaymentService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayPalPaymentService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayPalPaymentService * SOAP_FMAC4 soap_get_ns2__PayPalPaymentService(struct soap *soap, ns2__PayPalPaymentService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayPalPaymentService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PaySubscriptionDeleteService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PaySubscriptionDeleteService::run = NULL;
	/* transient soap skipped */
}

void ns2__PaySubscriptionDeleteService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__PaySubscriptionDeleteService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PaySubscriptionDeleteService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PaySubscriptionDeleteService(struct soap *soap, const char *tag, int id, const ns2__PaySubscriptionDeleteService *a, const char *type)
{
	if (((ns2__PaySubscriptionDeleteService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PaySubscriptionDeleteService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PaySubscriptionDeleteService), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PaySubscriptionDeleteService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PaySubscriptionDeleteService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PaySubscriptionDeleteService * SOAP_FMAC4 soap_in_ns2__PaySubscriptionDeleteService(struct soap *soap, const char *tag, ns2__PaySubscriptionDeleteService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PaySubscriptionDeleteService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PaySubscriptionDeleteService, sizeof(ns2__PaySubscriptionDeleteService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PaySubscriptionDeleteService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PaySubscriptionDeleteService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PaySubscriptionDeleteService*)a)->run))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PaySubscriptionDeleteService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PaySubscriptionDeleteService, SOAP_TYPE_ns2__PaySubscriptionDeleteService, sizeof(ns2__PaySubscriptionDeleteService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PaySubscriptionDeleteService * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionDeleteService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PaySubscriptionDeleteService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PaySubscriptionDeleteService *p;
	size_t k = sizeof(ns2__PaySubscriptionDeleteService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PaySubscriptionDeleteService);
		if (p)
			((ns2__PaySubscriptionDeleteService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PaySubscriptionDeleteService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PaySubscriptionDeleteService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PaySubscriptionDeleteService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PaySubscriptionDeleteService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PaySubscriptionDeleteService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PaySubscriptionDeleteService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PaySubscriptionDeleteService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PaySubscriptionDeleteService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PaySubscriptionDeleteService * SOAP_FMAC4 soap_get_ns2__PaySubscriptionDeleteService(struct soap *soap, ns2__PaySubscriptionDeleteService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PaySubscriptionDeleteService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PaySubscriptionRetrieveService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PaySubscriptionRetrieveService::run = NULL;
	/* transient soap skipped */
}

void ns2__PaySubscriptionRetrieveService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__PaySubscriptionRetrieveService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PaySubscriptionRetrieveService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PaySubscriptionRetrieveService(struct soap *soap, const char *tag, int id, const ns2__PaySubscriptionRetrieveService *a, const char *type)
{
	if (((ns2__PaySubscriptionRetrieveService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PaySubscriptionRetrieveService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PaySubscriptionRetrieveService), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PaySubscriptionRetrieveService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PaySubscriptionRetrieveService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PaySubscriptionRetrieveService * SOAP_FMAC4 soap_in_ns2__PaySubscriptionRetrieveService(struct soap *soap, const char *tag, ns2__PaySubscriptionRetrieveService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PaySubscriptionRetrieveService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PaySubscriptionRetrieveService, sizeof(ns2__PaySubscriptionRetrieveService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PaySubscriptionRetrieveService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PaySubscriptionRetrieveService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PaySubscriptionRetrieveService*)a)->run))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PaySubscriptionRetrieveService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PaySubscriptionRetrieveService, SOAP_TYPE_ns2__PaySubscriptionRetrieveService, sizeof(ns2__PaySubscriptionRetrieveService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PaySubscriptionRetrieveService * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionRetrieveService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PaySubscriptionRetrieveService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PaySubscriptionRetrieveService *p;
	size_t k = sizeof(ns2__PaySubscriptionRetrieveService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PaySubscriptionRetrieveService);
		if (p)
			((ns2__PaySubscriptionRetrieveService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PaySubscriptionRetrieveService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PaySubscriptionRetrieveService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PaySubscriptionRetrieveService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PaySubscriptionRetrieveService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PaySubscriptionRetrieveService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PaySubscriptionRetrieveService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PaySubscriptionRetrieveService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PaySubscriptionRetrieveService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PaySubscriptionRetrieveService * SOAP_FMAC4 soap_get_ns2__PaySubscriptionRetrieveService(struct soap *soap, ns2__PaySubscriptionRetrieveService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PaySubscriptionRetrieveService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PaySubscriptionEventUpdateService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PaySubscriptionEventUpdateService::action = NULL;
	this->ns2__PaySubscriptionEventUpdateService::run = NULL;
	/* transient soap skipped */
}

void ns2__PaySubscriptionEventUpdateService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionEventUpdateService::action);
#endif
}

int ns2__PaySubscriptionEventUpdateService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PaySubscriptionEventUpdateService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PaySubscriptionEventUpdateService(struct soap *soap, const char *tag, int id, const ns2__PaySubscriptionEventUpdateService *a, const char *type)
{
	if (((ns2__PaySubscriptionEventUpdateService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PaySubscriptionEventUpdateService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PaySubscriptionEventUpdateService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:action", -1, (wchar_t*const*)&a->ns2__PaySubscriptionEventUpdateService::action, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PaySubscriptionEventUpdateService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PaySubscriptionEventUpdateService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PaySubscriptionEventUpdateService * SOAP_FMAC4 soap_in_ns2__PaySubscriptionEventUpdateService(struct soap *soap, const char *tag, ns2__PaySubscriptionEventUpdateService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PaySubscriptionEventUpdateService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PaySubscriptionEventUpdateService, sizeof(ns2__PaySubscriptionEventUpdateService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PaySubscriptionEventUpdateService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PaySubscriptionEventUpdateService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PaySubscriptionEventUpdateService*)a)->run))
		return NULL;
	size_t soap_flag_action1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_action1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:action", (wchar_t**)&a->ns2__PaySubscriptionEventUpdateService::action, "xsd:string"))
				{	soap_flag_action1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PaySubscriptionEventUpdateService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PaySubscriptionEventUpdateService, SOAP_TYPE_ns2__PaySubscriptionEventUpdateService, sizeof(ns2__PaySubscriptionEventUpdateService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PaySubscriptionEventUpdateService * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionEventUpdateService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PaySubscriptionEventUpdateService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PaySubscriptionEventUpdateService *p;
	size_t k = sizeof(ns2__PaySubscriptionEventUpdateService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PaySubscriptionEventUpdateService);
		if (p)
			((ns2__PaySubscriptionEventUpdateService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PaySubscriptionEventUpdateService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PaySubscriptionEventUpdateService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PaySubscriptionEventUpdateService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PaySubscriptionEventUpdateService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PaySubscriptionEventUpdateService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PaySubscriptionEventUpdateService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PaySubscriptionEventUpdateService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PaySubscriptionEventUpdateService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PaySubscriptionEventUpdateService * SOAP_FMAC4 soap_get_ns2__PaySubscriptionEventUpdateService(struct soap *soap, ns2__PaySubscriptionEventUpdateService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PaySubscriptionEventUpdateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PaySubscriptionUpdateService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PaySubscriptionUpdateService::run = NULL;
	/* transient soap skipped */
}

void ns2__PaySubscriptionUpdateService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__PaySubscriptionUpdateService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PaySubscriptionUpdateService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PaySubscriptionUpdateService(struct soap *soap, const char *tag, int id, const ns2__PaySubscriptionUpdateService *a, const char *type)
{
	if (((ns2__PaySubscriptionUpdateService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PaySubscriptionUpdateService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PaySubscriptionUpdateService), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PaySubscriptionUpdateService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PaySubscriptionUpdateService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PaySubscriptionUpdateService * SOAP_FMAC4 soap_in_ns2__PaySubscriptionUpdateService(struct soap *soap, const char *tag, ns2__PaySubscriptionUpdateService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PaySubscriptionUpdateService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PaySubscriptionUpdateService, sizeof(ns2__PaySubscriptionUpdateService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PaySubscriptionUpdateService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PaySubscriptionUpdateService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PaySubscriptionUpdateService*)a)->run))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PaySubscriptionUpdateService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PaySubscriptionUpdateService, SOAP_TYPE_ns2__PaySubscriptionUpdateService, sizeof(ns2__PaySubscriptionUpdateService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PaySubscriptionUpdateService * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionUpdateService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PaySubscriptionUpdateService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PaySubscriptionUpdateService *p;
	size_t k = sizeof(ns2__PaySubscriptionUpdateService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PaySubscriptionUpdateService);
		if (p)
			((ns2__PaySubscriptionUpdateService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PaySubscriptionUpdateService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PaySubscriptionUpdateService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PaySubscriptionUpdateService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PaySubscriptionUpdateService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PaySubscriptionUpdateService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PaySubscriptionUpdateService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PaySubscriptionUpdateService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PaySubscriptionUpdateService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PaySubscriptionUpdateService * SOAP_FMAC4 soap_get_ns2__PaySubscriptionUpdateService(struct soap *soap, ns2__PaySubscriptionUpdateService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PaySubscriptionUpdateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PaySubscriptionCreateService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PaySubscriptionCreateService::paymentRequestID = NULL;
	this->ns2__PaySubscriptionCreateService::paymentRequestToken = NULL;
	this->ns2__PaySubscriptionCreateService::disableAutoAuth = NULL;
	this->ns2__PaySubscriptionCreateService::run = NULL;
	/* transient soap skipped */
}

void ns2__PaySubscriptionCreateService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionCreateService::paymentRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PaySubscriptionCreateService::paymentRequestToken);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__PaySubscriptionCreateService::disableAutoAuth);
#endif
}

int ns2__PaySubscriptionCreateService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PaySubscriptionCreateService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PaySubscriptionCreateService(struct soap *soap, const char *tag, int id, const ns2__PaySubscriptionCreateService *a, const char *type)
{
	if (((ns2__PaySubscriptionCreateService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PaySubscriptionCreateService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PaySubscriptionCreateService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentRequestID", -1, (wchar_t*const*)&a->ns2__PaySubscriptionCreateService::paymentRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paymentRequestToken", -1, (wchar_t*const*)&a->ns2__PaySubscriptionCreateService::paymentRequestToken, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:disableAutoAuth", -1, &a->ns2__PaySubscriptionCreateService::disableAutoAuth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PaySubscriptionCreateService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PaySubscriptionCreateService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PaySubscriptionCreateService * SOAP_FMAC4 soap_in_ns2__PaySubscriptionCreateService(struct soap *soap, const char *tag, ns2__PaySubscriptionCreateService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PaySubscriptionCreateService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PaySubscriptionCreateService, sizeof(ns2__PaySubscriptionCreateService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PaySubscriptionCreateService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PaySubscriptionCreateService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PaySubscriptionCreateService*)a)->run))
		return NULL;
	size_t soap_flag_paymentRequestID1 = 1;
	size_t soap_flag_paymentRequestToken1 = 1;
	size_t soap_flag_disableAutoAuth1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_paymentRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentRequestID", (wchar_t**)&a->ns2__PaySubscriptionCreateService::paymentRequestID, "xsd:string"))
				{	soap_flag_paymentRequestID1--;
					continue;
				}
			if (soap_flag_paymentRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paymentRequestToken", (wchar_t**)&a->ns2__PaySubscriptionCreateService::paymentRequestToken, "xsd:string"))
				{	soap_flag_paymentRequestToken1--;
					continue;
				}
			if (soap_flag_disableAutoAuth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:disableAutoAuth", &a->ns2__PaySubscriptionCreateService::disableAutoAuth, "ns2:boolean"))
				{	soap_flag_disableAutoAuth1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PaySubscriptionCreateService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PaySubscriptionCreateService, SOAP_TYPE_ns2__PaySubscriptionCreateService, sizeof(ns2__PaySubscriptionCreateService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PaySubscriptionCreateService * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionCreateService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PaySubscriptionCreateService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PaySubscriptionCreateService *p;
	size_t k = sizeof(ns2__PaySubscriptionCreateService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PaySubscriptionCreateService);
		if (p)
			((ns2__PaySubscriptionCreateService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PaySubscriptionCreateService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PaySubscriptionCreateService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PaySubscriptionCreateService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PaySubscriptionCreateService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PaySubscriptionCreateService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PaySubscriptionCreateService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PaySubscriptionCreateService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PaySubscriptionCreateService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PaySubscriptionCreateService * SOAP_FMAC4 soap_get_ns2__PaySubscriptionCreateService(struct soap *soap, ns2__PaySubscriptionCreateService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PaySubscriptionCreateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DirectDebitValidateService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DirectDebitValidateService::directDebitValidateText = NULL;
	this->ns2__DirectDebitValidateService::run = NULL;
	/* transient soap skipped */
}

void ns2__DirectDebitValidateService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitValidateService::directDebitValidateText);
#endif
}

int ns2__DirectDebitValidateService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DirectDebitValidateService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DirectDebitValidateService(struct soap *soap, const char *tag, int id, const ns2__DirectDebitValidateService *a, const char *type)
{
	if (((ns2__DirectDebitValidateService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__DirectDebitValidateService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DirectDebitValidateService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:directDebitValidateText", -1, (wchar_t*const*)&a->ns2__DirectDebitValidateService::directDebitValidateText, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DirectDebitValidateService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DirectDebitValidateService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DirectDebitValidateService * SOAP_FMAC4 soap_in_ns2__DirectDebitValidateService(struct soap *soap, const char *tag, ns2__DirectDebitValidateService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DirectDebitValidateService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DirectDebitValidateService, sizeof(ns2__DirectDebitValidateService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DirectDebitValidateService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DirectDebitValidateService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__DirectDebitValidateService*)a)->run))
		return NULL;
	size_t soap_flag_directDebitValidateText1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_directDebitValidateText1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:directDebitValidateText", (wchar_t**)&a->ns2__DirectDebitValidateService::directDebitValidateText, "xsd:string"))
				{	soap_flag_directDebitValidateText1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DirectDebitValidateService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DirectDebitValidateService, SOAP_TYPE_ns2__DirectDebitValidateService, sizeof(ns2__DirectDebitValidateService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DirectDebitValidateService * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitValidateService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DirectDebitValidateService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DirectDebitValidateService *p;
	size_t k = sizeof(ns2__DirectDebitValidateService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DirectDebitValidateService);
		if (p)
			((ns2__DirectDebitValidateService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DirectDebitValidateService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DirectDebitValidateService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DirectDebitValidateService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DirectDebitValidateService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DirectDebitValidateService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:DirectDebitValidateService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DirectDebitValidateService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DirectDebitValidateService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DirectDebitValidateService * SOAP_FMAC4 soap_get_ns2__DirectDebitValidateService(struct soap *soap, ns2__DirectDebitValidateService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DirectDebitValidateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DirectDebitRefundService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DirectDebitRefundService::directDebitRequestID = NULL;
	this->ns2__DirectDebitRefundService::reconciliationID = NULL;
	this->ns2__DirectDebitRefundService::directDebitRequestToken = NULL;
	this->ns2__DirectDebitRefundService::directDebitType = NULL;
	this->ns2__DirectDebitRefundService::recurringType = NULL;
	this->ns2__DirectDebitRefundService::mandateID = NULL;
	this->ns2__DirectDebitRefundService::mandateAuthenticationDate = NULL;
	this->ns2__DirectDebitRefundService::run = NULL;
	/* transient soap skipped */
}

void ns2__DirectDebitRefundService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitRefundService::directDebitRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitRefundService::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitRefundService::directDebitRequestToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitRefundService::directDebitType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitRefundService::recurringType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitRefundService::mandateID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitRefundService::mandateAuthenticationDate);
#endif
}

int ns2__DirectDebitRefundService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DirectDebitRefundService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DirectDebitRefundService(struct soap *soap, const char *tag, int id, const ns2__DirectDebitRefundService *a, const char *type)
{
	if (((ns2__DirectDebitRefundService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__DirectDebitRefundService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DirectDebitRefundService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:directDebitRequestID", -1, (wchar_t*const*)&a->ns2__DirectDebitRefundService::directDebitRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__DirectDebitRefundService::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:directDebitRequestToken", -1, (wchar_t*const*)&a->ns2__DirectDebitRefundService::directDebitRequestToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:directDebitType", -1, (wchar_t*const*)&a->ns2__DirectDebitRefundService::directDebitType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:recurringType", -1, (wchar_t*const*)&a->ns2__DirectDebitRefundService::recurringType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:mandateID", -1, (wchar_t*const*)&a->ns2__DirectDebitRefundService::mandateID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:mandateAuthenticationDate", -1, (wchar_t*const*)&a->ns2__DirectDebitRefundService::mandateAuthenticationDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DirectDebitRefundService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DirectDebitRefundService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DirectDebitRefundService * SOAP_FMAC4 soap_in_ns2__DirectDebitRefundService(struct soap *soap, const char *tag, ns2__DirectDebitRefundService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DirectDebitRefundService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DirectDebitRefundService, sizeof(ns2__DirectDebitRefundService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DirectDebitRefundService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DirectDebitRefundService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__DirectDebitRefundService*)a)->run))
		return NULL;
	size_t soap_flag_directDebitRequestID1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_directDebitRequestToken1 = 1;
	size_t soap_flag_directDebitType1 = 1;
	size_t soap_flag_recurringType1 = 1;
	size_t soap_flag_mandateID1 = 1;
	size_t soap_flag_mandateAuthenticationDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_directDebitRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:directDebitRequestID", (wchar_t**)&a->ns2__DirectDebitRefundService::directDebitRequestID, "xsd:string"))
				{	soap_flag_directDebitRequestID1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__DirectDebitRefundService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_directDebitRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:directDebitRequestToken", (wchar_t**)&a->ns2__DirectDebitRefundService::directDebitRequestToken, "xsd:string"))
				{	soap_flag_directDebitRequestToken1--;
					continue;
				}
			if (soap_flag_directDebitType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:directDebitType", (wchar_t**)&a->ns2__DirectDebitRefundService::directDebitType, "xsd:string"))
				{	soap_flag_directDebitType1--;
					continue;
				}
			if (soap_flag_recurringType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:recurringType", (wchar_t**)&a->ns2__DirectDebitRefundService::recurringType, "xsd:string"))
				{	soap_flag_recurringType1--;
					continue;
				}
			if (soap_flag_mandateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:mandateID", (wchar_t**)&a->ns2__DirectDebitRefundService::mandateID, "xsd:string"))
				{	soap_flag_mandateID1--;
					continue;
				}
			if (soap_flag_mandateAuthenticationDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:mandateAuthenticationDate", (wchar_t**)&a->ns2__DirectDebitRefundService::mandateAuthenticationDate, "xsd:string"))
				{	soap_flag_mandateAuthenticationDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DirectDebitRefundService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DirectDebitRefundService, SOAP_TYPE_ns2__DirectDebitRefundService, sizeof(ns2__DirectDebitRefundService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DirectDebitRefundService * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitRefundService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DirectDebitRefundService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DirectDebitRefundService *p;
	size_t k = sizeof(ns2__DirectDebitRefundService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DirectDebitRefundService);
		if (p)
			((ns2__DirectDebitRefundService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DirectDebitRefundService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DirectDebitRefundService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DirectDebitRefundService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DirectDebitRefundService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DirectDebitRefundService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:DirectDebitRefundService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DirectDebitRefundService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DirectDebitRefundService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DirectDebitRefundService * SOAP_FMAC4 soap_get_ns2__DirectDebitRefundService(struct soap *soap, ns2__DirectDebitRefundService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DirectDebitRefundService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DirectDebitService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DirectDebitService::dateCollect = NULL;
	this->ns2__DirectDebitService::directDebitText = NULL;
	this->ns2__DirectDebitService::authorizationID = NULL;
	this->ns2__DirectDebitService::transactionType = NULL;
	this->ns2__DirectDebitService::directDebitType = NULL;
	this->ns2__DirectDebitService::validateRequestID = NULL;
	this->ns2__DirectDebitService::recurringType = NULL;
	this->ns2__DirectDebitService::mandateID = NULL;
	this->ns2__DirectDebitService::validateRequestToken = NULL;
	this->ns2__DirectDebitService::reconciliationID = NULL;
	this->ns2__DirectDebitService::mandateAuthenticationDate = NULL;
	this->ns2__DirectDebitService::run = NULL;
	/* transient soap skipped */
}

void ns2__DirectDebitService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitService::dateCollect);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitService::directDebitText);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitService::authorizationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitService::transactionType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitService::directDebitType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitService::validateRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitService::recurringType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitService::mandateID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitService::validateRequestToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitService::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitService::mandateAuthenticationDate);
#endif
}

int ns2__DirectDebitService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DirectDebitService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DirectDebitService(struct soap *soap, const char *tag, int id, const ns2__DirectDebitService *a, const char *type)
{
	if (((ns2__DirectDebitService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__DirectDebitService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DirectDebitService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:dateCollect", -1, (wchar_t*const*)&a->ns2__DirectDebitService::dateCollect, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:directDebitText", -1, (wchar_t*const*)&a->ns2__DirectDebitService::directDebitText, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authorizationID", -1, (wchar_t*const*)&a->ns2__DirectDebitService::authorizationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionType", -1, (wchar_t*const*)&a->ns2__DirectDebitService::transactionType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:directDebitType", -1, (wchar_t*const*)&a->ns2__DirectDebitService::directDebitType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:validateRequestID", -1, (wchar_t*const*)&a->ns2__DirectDebitService::validateRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:recurringType", -1, (wchar_t*const*)&a->ns2__DirectDebitService::recurringType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:mandateID", -1, (wchar_t*const*)&a->ns2__DirectDebitService::mandateID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:validateRequestToken", -1, (wchar_t*const*)&a->ns2__DirectDebitService::validateRequestToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__DirectDebitService::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:mandateAuthenticationDate", -1, (wchar_t*const*)&a->ns2__DirectDebitService::mandateAuthenticationDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DirectDebitService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DirectDebitService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DirectDebitService * SOAP_FMAC4 soap_in_ns2__DirectDebitService(struct soap *soap, const char *tag, ns2__DirectDebitService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DirectDebitService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DirectDebitService, sizeof(ns2__DirectDebitService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DirectDebitService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DirectDebitService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__DirectDebitService*)a)->run))
		return NULL;
	size_t soap_flag_dateCollect1 = 1;
	size_t soap_flag_directDebitText1 = 1;
	size_t soap_flag_authorizationID1 = 1;
	size_t soap_flag_transactionType1 = 1;
	size_t soap_flag_directDebitType1 = 1;
	size_t soap_flag_validateRequestID1 = 1;
	size_t soap_flag_recurringType1 = 1;
	size_t soap_flag_mandateID1 = 1;
	size_t soap_flag_validateRequestToken1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_mandateAuthenticationDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dateCollect1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:dateCollect", (wchar_t**)&a->ns2__DirectDebitService::dateCollect, "xsd:string"))
				{	soap_flag_dateCollect1--;
					continue;
				}
			if (soap_flag_directDebitText1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:directDebitText", (wchar_t**)&a->ns2__DirectDebitService::directDebitText, "xsd:string"))
				{	soap_flag_directDebitText1--;
					continue;
				}
			if (soap_flag_authorizationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authorizationID", (wchar_t**)&a->ns2__DirectDebitService::authorizationID, "xsd:string"))
				{	soap_flag_authorizationID1--;
					continue;
				}
			if (soap_flag_transactionType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionType", (wchar_t**)&a->ns2__DirectDebitService::transactionType, "xsd:string"))
				{	soap_flag_transactionType1--;
					continue;
				}
			if (soap_flag_directDebitType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:directDebitType", (wchar_t**)&a->ns2__DirectDebitService::directDebitType, "xsd:string"))
				{	soap_flag_directDebitType1--;
					continue;
				}
			if (soap_flag_validateRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:validateRequestID", (wchar_t**)&a->ns2__DirectDebitService::validateRequestID, "xsd:string"))
				{	soap_flag_validateRequestID1--;
					continue;
				}
			if (soap_flag_recurringType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:recurringType", (wchar_t**)&a->ns2__DirectDebitService::recurringType, "xsd:string"))
				{	soap_flag_recurringType1--;
					continue;
				}
			if (soap_flag_mandateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:mandateID", (wchar_t**)&a->ns2__DirectDebitService::mandateID, "xsd:string"))
				{	soap_flag_mandateID1--;
					continue;
				}
			if (soap_flag_validateRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:validateRequestToken", (wchar_t**)&a->ns2__DirectDebitService::validateRequestToken, "xsd:string"))
				{	soap_flag_validateRequestToken1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__DirectDebitService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_mandateAuthenticationDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:mandateAuthenticationDate", (wchar_t**)&a->ns2__DirectDebitService::mandateAuthenticationDate, "xsd:string"))
				{	soap_flag_mandateAuthenticationDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DirectDebitService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DirectDebitService, SOAP_TYPE_ns2__DirectDebitService, sizeof(ns2__DirectDebitService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DirectDebitService * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DirectDebitService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DirectDebitService *p;
	size_t k = sizeof(ns2__DirectDebitService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DirectDebitService);
		if (p)
			((ns2__DirectDebitService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DirectDebitService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DirectDebitService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DirectDebitService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DirectDebitService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DirectDebitService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:DirectDebitService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DirectDebitService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DirectDebitService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DirectDebitService * SOAP_FMAC4 soap_get_ns2__DirectDebitService(struct soap *soap, ns2__DirectDebitService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DirectDebitService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DirectDebitMandateService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DirectDebitMandateService::mandateDescriptor = NULL;
	this->ns2__DirectDebitMandateService::firstDebitDate = NULL;
	this->ns2__DirectDebitMandateService::run = NULL;
	/* transient soap skipped */
}

void ns2__DirectDebitMandateService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitMandateService::mandateDescriptor);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DirectDebitMandateService::firstDebitDate);
#endif
}

int ns2__DirectDebitMandateService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DirectDebitMandateService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DirectDebitMandateService(struct soap *soap, const char *tag, int id, const ns2__DirectDebitMandateService *a, const char *type)
{
	if (((ns2__DirectDebitMandateService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__DirectDebitMandateService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DirectDebitMandateService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:mandateDescriptor", -1, (wchar_t*const*)&a->ns2__DirectDebitMandateService::mandateDescriptor, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:firstDebitDate", -1, (wchar_t*const*)&a->ns2__DirectDebitMandateService::firstDebitDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DirectDebitMandateService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DirectDebitMandateService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DirectDebitMandateService * SOAP_FMAC4 soap_in_ns2__DirectDebitMandateService(struct soap *soap, const char *tag, ns2__DirectDebitMandateService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DirectDebitMandateService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DirectDebitMandateService, sizeof(ns2__DirectDebitMandateService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DirectDebitMandateService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DirectDebitMandateService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__DirectDebitMandateService*)a)->run))
		return NULL;
	size_t soap_flag_mandateDescriptor1 = 1;
	size_t soap_flag_firstDebitDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mandateDescriptor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:mandateDescriptor", (wchar_t**)&a->ns2__DirectDebitMandateService::mandateDescriptor, "xsd:string"))
				{	soap_flag_mandateDescriptor1--;
					continue;
				}
			if (soap_flag_firstDebitDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:firstDebitDate", (wchar_t**)&a->ns2__DirectDebitMandateService::firstDebitDate, "xsd:string"))
				{	soap_flag_firstDebitDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DirectDebitMandateService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DirectDebitMandateService, SOAP_TYPE_ns2__DirectDebitMandateService, sizeof(ns2__DirectDebitMandateService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DirectDebitMandateService * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitMandateService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DirectDebitMandateService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DirectDebitMandateService *p;
	size_t k = sizeof(ns2__DirectDebitMandateService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DirectDebitMandateService);
		if (p)
			((ns2__DirectDebitMandateService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DirectDebitMandateService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DirectDebitMandateService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DirectDebitMandateService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DirectDebitMandateService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DirectDebitMandateService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:DirectDebitMandateService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DirectDebitMandateService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DirectDebitMandateService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DirectDebitMandateService * SOAP_FMAC4 soap_get_ns2__DirectDebitMandateService(struct soap *soap, ns2__DirectDebitMandateService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DirectDebitMandateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__BankTransferRealTimeService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__BankTransferRealTimeService::bankTransferRealTimeType = NULL;
	this->ns2__BankTransferRealTimeService::run = NULL;
	/* transient soap skipped */
}

void ns2__BankTransferRealTimeService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferRealTimeService::bankTransferRealTimeType);
#endif
}

int ns2__BankTransferRealTimeService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__BankTransferRealTimeService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BankTransferRealTimeService(struct soap *soap, const char *tag, int id, const ns2__BankTransferRealTimeService *a, const char *type)
{
	if (((ns2__BankTransferRealTimeService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__BankTransferRealTimeService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BankTransferRealTimeService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:bankTransferRealTimeType", -1, (wchar_t*const*)&a->ns2__BankTransferRealTimeService::bankTransferRealTimeType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__BankTransferRealTimeService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__BankTransferRealTimeService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__BankTransferRealTimeService * SOAP_FMAC4 soap_in_ns2__BankTransferRealTimeService(struct soap *soap, const char *tag, ns2__BankTransferRealTimeService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__BankTransferRealTimeService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BankTransferRealTimeService, sizeof(ns2__BankTransferRealTimeService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__BankTransferRealTimeService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__BankTransferRealTimeService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__BankTransferRealTimeService*)a)->run))
		return NULL;
	size_t soap_flag_bankTransferRealTimeType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bankTransferRealTimeType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:bankTransferRealTimeType", (wchar_t**)&a->ns2__BankTransferRealTimeService::bankTransferRealTimeType, "xsd:string"))
				{	soap_flag_bankTransferRealTimeType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__BankTransferRealTimeService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BankTransferRealTimeService, SOAP_TYPE_ns2__BankTransferRealTimeService, sizeof(ns2__BankTransferRealTimeService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__BankTransferRealTimeService * SOAP_FMAC2 soap_instantiate_ns2__BankTransferRealTimeService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__BankTransferRealTimeService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__BankTransferRealTimeService *p;
	size_t k = sizeof(ns2__BankTransferRealTimeService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__BankTransferRealTimeService);
		if (p)
			((ns2__BankTransferRealTimeService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__BankTransferRealTimeService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__BankTransferRealTimeService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__BankTransferRealTimeService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__BankTransferRealTimeService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__BankTransferRealTimeService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:BankTransferRealTimeService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__BankTransferRealTimeService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__BankTransferRealTimeService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__BankTransferRealTimeService * SOAP_FMAC4 soap_get_ns2__BankTransferRealTimeService(struct soap *soap, ns2__BankTransferRealTimeService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BankTransferRealTimeService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__BankTransferRefundService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__BankTransferRefundService::bankTransferRequestID = NULL;
	this->ns2__BankTransferRefundService::bankTransferRealTimeRequestID = NULL;
	this->ns2__BankTransferRefundService::reconciliationID = NULL;
	this->ns2__BankTransferRefundService::bankTransferRealTimeReconciliationID = NULL;
	this->ns2__BankTransferRefundService::bankTransferRequestToken = NULL;
	this->ns2__BankTransferRefundService::bankTransferRealTimeRequestToken = NULL;
	this->ns2__BankTransferRefundService::run = NULL;
	/* transient soap skipped */
}

void ns2__BankTransferRefundService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferRefundService::bankTransferRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferRefundService::bankTransferRealTimeRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferRefundService::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferRefundService::bankTransferRealTimeReconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferRefundService::bankTransferRequestToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__BankTransferRefundService::bankTransferRealTimeRequestToken);
#endif
}

int ns2__BankTransferRefundService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__BankTransferRefundService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BankTransferRefundService(struct soap *soap, const char *tag, int id, const ns2__BankTransferRefundService *a, const char *type)
{
	if (((ns2__BankTransferRefundService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__BankTransferRefundService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BankTransferRefundService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:bankTransferRequestID", -1, (wchar_t*const*)&a->ns2__BankTransferRefundService::bankTransferRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:bankTransferRealTimeRequestID", -1, (wchar_t*const*)&a->ns2__BankTransferRefundService::bankTransferRealTimeRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__BankTransferRefundService::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:bankTransferRealTimeReconciliationID", -1, (wchar_t*const*)&a->ns2__BankTransferRefundService::bankTransferRealTimeReconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:bankTransferRequestToken", -1, (wchar_t*const*)&a->ns2__BankTransferRefundService::bankTransferRequestToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:bankTransferRealTimeRequestToken", -1, (wchar_t*const*)&a->ns2__BankTransferRefundService::bankTransferRealTimeRequestToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__BankTransferRefundService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__BankTransferRefundService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__BankTransferRefundService * SOAP_FMAC4 soap_in_ns2__BankTransferRefundService(struct soap *soap, const char *tag, ns2__BankTransferRefundService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__BankTransferRefundService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BankTransferRefundService, sizeof(ns2__BankTransferRefundService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__BankTransferRefundService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__BankTransferRefundService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__BankTransferRefundService*)a)->run))
		return NULL;
	size_t soap_flag_bankTransferRequestID1 = 1;
	size_t soap_flag_bankTransferRealTimeRequestID1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_bankTransferRealTimeReconciliationID1 = 1;
	size_t soap_flag_bankTransferRequestToken1 = 1;
	size_t soap_flag_bankTransferRealTimeRequestToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bankTransferRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:bankTransferRequestID", (wchar_t**)&a->ns2__BankTransferRefundService::bankTransferRequestID, "xsd:string"))
				{	soap_flag_bankTransferRequestID1--;
					continue;
				}
			if (soap_flag_bankTransferRealTimeRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:bankTransferRealTimeRequestID", (wchar_t**)&a->ns2__BankTransferRefundService::bankTransferRealTimeRequestID, "xsd:string"))
				{	soap_flag_bankTransferRealTimeRequestID1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__BankTransferRefundService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_bankTransferRealTimeReconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:bankTransferRealTimeReconciliationID", (wchar_t**)&a->ns2__BankTransferRefundService::bankTransferRealTimeReconciliationID, "xsd:string"))
				{	soap_flag_bankTransferRealTimeReconciliationID1--;
					continue;
				}
			if (soap_flag_bankTransferRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:bankTransferRequestToken", (wchar_t**)&a->ns2__BankTransferRefundService::bankTransferRequestToken, "xsd:string"))
				{	soap_flag_bankTransferRequestToken1--;
					continue;
				}
			if (soap_flag_bankTransferRealTimeRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:bankTransferRealTimeRequestToken", (wchar_t**)&a->ns2__BankTransferRefundService::bankTransferRealTimeRequestToken, "xsd:string"))
				{	soap_flag_bankTransferRealTimeRequestToken1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__BankTransferRefundService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BankTransferRefundService, SOAP_TYPE_ns2__BankTransferRefundService, sizeof(ns2__BankTransferRefundService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__BankTransferRefundService * SOAP_FMAC2 soap_instantiate_ns2__BankTransferRefundService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__BankTransferRefundService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__BankTransferRefundService *p;
	size_t k = sizeof(ns2__BankTransferRefundService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__BankTransferRefundService);
		if (p)
			((ns2__BankTransferRefundService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__BankTransferRefundService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__BankTransferRefundService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__BankTransferRefundService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__BankTransferRefundService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__BankTransferRefundService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:BankTransferRefundService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__BankTransferRefundService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__BankTransferRefundService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__BankTransferRefundService * SOAP_FMAC4 soap_get_ns2__BankTransferRefundService(struct soap *soap, ns2__BankTransferRefundService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BankTransferRefundService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__BankTransferService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__BankTransferService::run = NULL;
	/* transient soap skipped */
}

void ns2__BankTransferService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__BankTransferService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__BankTransferService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__BankTransferService(struct soap *soap, const char *tag, int id, const ns2__BankTransferService *a, const char *type)
{
	if (((ns2__BankTransferService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__BankTransferService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__BankTransferService), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__BankTransferService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__BankTransferService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__BankTransferService * SOAP_FMAC4 soap_in_ns2__BankTransferService(struct soap *soap, const char *tag, ns2__BankTransferService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__BankTransferService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__BankTransferService, sizeof(ns2__BankTransferService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__BankTransferService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__BankTransferService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__BankTransferService*)a)->run))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__BankTransferService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__BankTransferService, SOAP_TYPE_ns2__BankTransferService, sizeof(ns2__BankTransferService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__BankTransferService * SOAP_FMAC2 soap_instantiate_ns2__BankTransferService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__BankTransferService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__BankTransferService *p;
	size_t k = sizeof(ns2__BankTransferService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__BankTransferService);
		if (p)
			((ns2__BankTransferService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__BankTransferService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__BankTransferService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__BankTransferService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__BankTransferService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__BankTransferService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:BankTransferService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__BankTransferService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__BankTransferService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__BankTransferService * SOAP_FMAC4 soap_get_ns2__BankTransferService(struct soap *soap, ns2__BankTransferService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__BankTransferService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__FXRatesService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__FXRatesService::run = NULL;
	/* transient soap skipped */
}

void ns2__FXRatesService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__FXRatesService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FXRatesService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FXRatesService(struct soap *soap, const char *tag, int id, const ns2__FXRatesService *a, const char *type)
{
	if (((ns2__FXRatesService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__FXRatesService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FXRatesService), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__FXRatesService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FXRatesService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FXRatesService * SOAP_FMAC4 soap_in_ns2__FXRatesService(struct soap *soap, const char *tag, ns2__FXRatesService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FXRatesService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FXRatesService, sizeof(ns2__FXRatesService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__FXRatesService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__FXRatesService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__FXRatesService*)a)->run))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__FXRatesService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FXRatesService, SOAP_TYPE_ns2__FXRatesService, sizeof(ns2__FXRatesService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__FXRatesService * SOAP_FMAC2 soap_instantiate_ns2__FXRatesService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FXRatesService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__FXRatesService *p;
	size_t k = sizeof(ns2__FXRatesService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__FXRatesService);
		if (p)
			((ns2__FXRatesService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__FXRatesService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__FXRatesService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__FXRatesService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__FXRatesService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__FXRatesService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:FXRatesService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FXRatesService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FXRatesService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FXRatesService * SOAP_FMAC4 soap_get_ns2__FXRatesService(struct soap *soap, ns2__FXRatesService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FXRatesService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ExportService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ExportService::addressOperator = NULL;
	this->ns2__ExportService::addressWeight = NULL;
	this->ns2__ExportService::companyWeight = NULL;
	this->ns2__ExportService::nameWeight = NULL;
	this->ns2__ExportService::run = NULL;
	/* transient soap skipped */
}

void ns2__ExportService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ExportService::addressOperator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ExportService::addressWeight);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ExportService::companyWeight);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ExportService::nameWeight);
#endif
}

int ns2__ExportService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ExportService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ExportService(struct soap *soap, const char *tag, int id, const ns2__ExportService *a, const char *type)
{
	if (((ns2__ExportService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__ExportService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ExportService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:addressOperator", -1, (wchar_t*const*)&a->ns2__ExportService::addressOperator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:addressWeight", -1, (wchar_t*const*)&a->ns2__ExportService::addressWeight, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:companyWeight", -1, (wchar_t*const*)&a->ns2__ExportService::companyWeight, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:nameWeight", -1, (wchar_t*const*)&a->ns2__ExportService::nameWeight, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ExportService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ExportService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ExportService * SOAP_FMAC4 soap_in_ns2__ExportService(struct soap *soap, const char *tag, ns2__ExportService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ExportService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ExportService, sizeof(ns2__ExportService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ExportService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ExportService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__ExportService*)a)->run))
		return NULL;
	size_t soap_flag_addressOperator1 = 1;
	size_t soap_flag_addressWeight1 = 1;
	size_t soap_flag_companyWeight1 = 1;
	size_t soap_flag_nameWeight1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_addressOperator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:addressOperator", (wchar_t**)&a->ns2__ExportService::addressOperator, "xsd:string"))
				{	soap_flag_addressOperator1--;
					continue;
				}
			if (soap_flag_addressWeight1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:addressWeight", (wchar_t**)&a->ns2__ExportService::addressWeight, "xsd:string"))
				{	soap_flag_addressWeight1--;
					continue;
				}
			if (soap_flag_companyWeight1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:companyWeight", (wchar_t**)&a->ns2__ExportService::companyWeight, "xsd:string"))
				{	soap_flag_companyWeight1--;
					continue;
				}
			if (soap_flag_nameWeight1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:nameWeight", (wchar_t**)&a->ns2__ExportService::nameWeight, "xsd:string"))
				{	soap_flag_nameWeight1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ExportService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ExportService, SOAP_TYPE_ns2__ExportService, sizeof(ns2__ExportService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ExportService * SOAP_FMAC2 soap_instantiate_ns2__ExportService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ExportService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ExportService *p;
	size_t k = sizeof(ns2__ExportService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ExportService);
		if (p)
			((ns2__ExportService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ExportService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ExportService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ExportService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ExportService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ExportService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:ExportService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ExportService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ExportService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ExportService * SOAP_FMAC4 soap_get_ns2__ExportService(struct soap *soap, ns2__ExportService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ExportService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DAVService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DAVService::run = NULL;
	/* transient soap skipped */
}

void ns2__DAVService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__DAVService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DAVService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DAVService(struct soap *soap, const char *tag, int id, const ns2__DAVService *a, const char *type)
{
	if (((ns2__DAVService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__DAVService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DAVService), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DAVService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DAVService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DAVService * SOAP_FMAC4 soap_in_ns2__DAVService(struct soap *soap, const char *tag, ns2__DAVService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DAVService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DAVService, sizeof(ns2__DAVService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DAVService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DAVService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__DAVService*)a)->run))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DAVService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DAVService, SOAP_TYPE_ns2__DAVService, sizeof(ns2__DAVService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DAVService * SOAP_FMAC2 soap_instantiate_ns2__DAVService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DAVService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DAVService *p;
	size_t k = sizeof(ns2__DAVService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DAVService);
		if (p)
			((ns2__DAVService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DAVService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DAVService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DAVService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DAVService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DAVService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:DAVService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DAVService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DAVService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DAVService * SOAP_FMAC4 soap_get_ns2__DAVService(struct soap *soap, ns2__DAVService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DAVService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__AFSService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__AFSService::avsCode = NULL;
	this->ns2__AFSService::cvCode = NULL;
	this->ns2__AFSService::disableAVSScoring = NULL;
	this->ns2__AFSService::customRiskModel = NULL;
	this->ns2__AFSService::run = NULL;
	/* transient soap skipped */
}

void ns2__AFSService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSService::avsCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSService::cvCode);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__AFSService::disableAVSScoring);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__AFSService::customRiskModel);
#endif
}

int ns2__AFSService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AFSService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AFSService(struct soap *soap, const char *tag, int id, const ns2__AFSService *a, const char *type)
{
	if (((ns2__AFSService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__AFSService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AFSService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:avsCode", -1, (wchar_t*const*)&a->ns2__AFSService::avsCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cvCode", -1, (wchar_t*const*)&a->ns2__AFSService::cvCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:disableAVSScoring", -1, &a->ns2__AFSService::disableAVSScoring, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:customRiskModel", -1, (wchar_t*const*)&a->ns2__AFSService::customRiskModel, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__AFSService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AFSService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AFSService * SOAP_FMAC4 soap_in_ns2__AFSService(struct soap *soap, const char *tag, ns2__AFSService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AFSService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AFSService, sizeof(ns2__AFSService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__AFSService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__AFSService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__AFSService*)a)->run))
		return NULL;
	size_t soap_flag_avsCode1 = 1;
	size_t soap_flag_cvCode1 = 1;
	size_t soap_flag_disableAVSScoring1 = 1;
	size_t soap_flag_customRiskModel1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_avsCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:avsCode", (wchar_t**)&a->ns2__AFSService::avsCode, "xsd:string"))
				{	soap_flag_avsCode1--;
					continue;
				}
			if (soap_flag_cvCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cvCode", (wchar_t**)&a->ns2__AFSService::cvCode, "xsd:string"))
				{	soap_flag_cvCode1--;
					continue;
				}
			if (soap_flag_disableAVSScoring1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:disableAVSScoring", &a->ns2__AFSService::disableAVSScoring, "ns2:boolean"))
				{	soap_flag_disableAVSScoring1--;
					continue;
				}
			if (soap_flag_customRiskModel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:customRiskModel", (wchar_t**)&a->ns2__AFSService::customRiskModel, "xsd:string"))
				{	soap_flag_customRiskModel1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AFSService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AFSService, SOAP_TYPE_ns2__AFSService, sizeof(ns2__AFSService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__AFSService * SOAP_FMAC2 soap_instantiate_ns2__AFSService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AFSService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__AFSService *p;
	size_t k = sizeof(ns2__AFSService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__AFSService);
		if (p)
			((ns2__AFSService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__AFSService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__AFSService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__AFSService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__AFSService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__AFSService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:AFSService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AFSService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AFSService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AFSService * SOAP_FMAC4 soap_get_ns2__AFSService(struct soap *soap, ns2__AFSService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AFSService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__DMEService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__DMEService::eventType = NULL;
	this->ns2__DMEService::eventPolicy = NULL;
	this->ns2__DMEService::run = NULL;
	/* transient soap skipped */
}

void ns2__DMEService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DMEService::eventType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__DMEService::eventPolicy);
#endif
}

int ns2__DMEService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DMEService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DMEService(struct soap *soap, const char *tag, int id, const ns2__DMEService *a, const char *type)
{
	if (((ns2__DMEService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__DMEService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DMEService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:eventType", -1, (wchar_t*const*)&a->ns2__DMEService::eventType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:eventPolicy", -1, (wchar_t*const*)&a->ns2__DMEService::eventPolicy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__DMEService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DMEService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DMEService * SOAP_FMAC4 soap_in_ns2__DMEService(struct soap *soap, const char *tag, ns2__DMEService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DMEService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DMEService, sizeof(ns2__DMEService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__DMEService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__DMEService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__DMEService*)a)->run))
		return NULL;
	size_t soap_flag_eventType1 = 1;
	size_t soap_flag_eventPolicy1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eventType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:eventType", (wchar_t**)&a->ns2__DMEService::eventType, "xsd:string"))
				{	soap_flag_eventType1--;
					continue;
				}
			if (soap_flag_eventPolicy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:eventPolicy", (wchar_t**)&a->ns2__DMEService::eventPolicy, "xsd:string"))
				{	soap_flag_eventPolicy1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DMEService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DMEService, SOAP_TYPE_ns2__DMEService, sizeof(ns2__DMEService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__DMEService * SOAP_FMAC2 soap_instantiate_ns2__DMEService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DMEService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__DMEService *p;
	size_t k = sizeof(ns2__DMEService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__DMEService);
		if (p)
			((ns2__DMEService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__DMEService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__DMEService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__DMEService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__DMEService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__DMEService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:DMEService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DMEService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DMEService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DMEService * SOAP_FMAC4 soap_get_ns2__DMEService(struct soap *soap, ns2__DMEService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DMEService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__TaxService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__TaxService::nexus = NULL;
	this->ns2__TaxService::noNexus = NULL;
	this->ns2__TaxService::orderAcceptanceCity = NULL;
	this->ns2__TaxService::orderAcceptanceCounty = NULL;
	this->ns2__TaxService::orderAcceptanceCountry = NULL;
	this->ns2__TaxService::orderAcceptanceState = NULL;
	this->ns2__TaxService::orderAcceptancePostalCode = NULL;
	this->ns2__TaxService::orderOriginCity = NULL;
	this->ns2__TaxService::orderOriginCounty = NULL;
	this->ns2__TaxService::orderOriginCountry = NULL;
	this->ns2__TaxService::orderOriginState = NULL;
	this->ns2__TaxService::orderOriginPostalCode = NULL;
	this->ns2__TaxService::sellerRegistration = NULL;
	this->ns2__TaxService::sellerRegistration0 = NULL;
	this->ns2__TaxService::sellerRegistration1 = NULL;
	this->ns2__TaxService::sellerRegistration2 = NULL;
	this->ns2__TaxService::sellerRegistration3 = NULL;
	this->ns2__TaxService::sellerRegistration4 = NULL;
	this->ns2__TaxService::sellerRegistration5 = NULL;
	this->ns2__TaxService::sellerRegistration6 = NULL;
	this->ns2__TaxService::sellerRegistration7 = NULL;
	this->ns2__TaxService::sellerRegistration8 = NULL;
	this->ns2__TaxService::sellerRegistration9 = NULL;
	this->ns2__TaxService::buyerRegistration = NULL;
	this->ns2__TaxService::middlemanRegistration = NULL;
	this->ns2__TaxService::pointOfTitleTransfer = NULL;
	this->ns2__TaxService::run = NULL;
	/* transient soap skipped */
}

void ns2__TaxService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::nexus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::noNexus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::orderAcceptanceCity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::orderAcceptanceCounty);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::orderAcceptanceCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::orderAcceptanceState);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::orderAcceptancePostalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::orderOriginCity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::orderOriginCounty);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::orderOriginCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::orderOriginState);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::orderOriginPostalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::sellerRegistration);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::sellerRegistration0);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::sellerRegistration1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::sellerRegistration2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::sellerRegistration3);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::sellerRegistration4);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::sellerRegistration5);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::sellerRegistration6);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::sellerRegistration7);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::sellerRegistration8);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::sellerRegistration9);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::buyerRegistration);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::middlemanRegistration);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__TaxService::pointOfTitleTransfer);
#endif
}

int ns2__TaxService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TaxService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TaxService(struct soap *soap, const char *tag, int id, const ns2__TaxService *a, const char *type)
{
	if (((ns2__TaxService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__TaxService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TaxService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:nexus", -1, (wchar_t*const*)&a->ns2__TaxService::nexus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:noNexus", -1, (wchar_t*const*)&a->ns2__TaxService::noNexus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderAcceptanceCity", -1, (wchar_t*const*)&a->ns2__TaxService::orderAcceptanceCity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderAcceptanceCounty", -1, (wchar_t*const*)&a->ns2__TaxService::orderAcceptanceCounty, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderAcceptanceCountry", -1, (wchar_t*const*)&a->ns2__TaxService::orderAcceptanceCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderAcceptanceState", -1, (wchar_t*const*)&a->ns2__TaxService::orderAcceptanceState, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderAcceptancePostalCode", -1, (wchar_t*const*)&a->ns2__TaxService::orderAcceptancePostalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderOriginCity", -1, (wchar_t*const*)&a->ns2__TaxService::orderOriginCity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderOriginCounty", -1, (wchar_t*const*)&a->ns2__TaxService::orderOriginCounty, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderOriginCountry", -1, (wchar_t*const*)&a->ns2__TaxService::orderOriginCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderOriginState", -1, (wchar_t*const*)&a->ns2__TaxService::orderOriginState, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderOriginPostalCode", -1, (wchar_t*const*)&a->ns2__TaxService::orderOriginPostalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sellerRegistration", -1, (wchar_t*const*)&a->ns2__TaxService::sellerRegistration, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sellerRegistration0", -1, (wchar_t*const*)&a->ns2__TaxService::sellerRegistration0, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sellerRegistration1", -1, (wchar_t*const*)&a->ns2__TaxService::sellerRegistration1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sellerRegistration2", -1, (wchar_t*const*)&a->ns2__TaxService::sellerRegistration2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sellerRegistration3", -1, (wchar_t*const*)&a->ns2__TaxService::sellerRegistration3, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sellerRegistration4", -1, (wchar_t*const*)&a->ns2__TaxService::sellerRegistration4, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sellerRegistration5", -1, (wchar_t*const*)&a->ns2__TaxService::sellerRegistration5, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sellerRegistration6", -1, (wchar_t*const*)&a->ns2__TaxService::sellerRegistration6, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sellerRegistration7", -1, (wchar_t*const*)&a->ns2__TaxService::sellerRegistration7, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sellerRegistration8", -1, (wchar_t*const*)&a->ns2__TaxService::sellerRegistration8, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sellerRegistration9", -1, (wchar_t*const*)&a->ns2__TaxService::sellerRegistration9, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:buyerRegistration", -1, (wchar_t*const*)&a->ns2__TaxService::buyerRegistration, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:middlemanRegistration", -1, (wchar_t*const*)&a->ns2__TaxService::middlemanRegistration, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pointOfTitleTransfer", -1, (wchar_t*const*)&a->ns2__TaxService::pointOfTitleTransfer, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__TaxService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TaxService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TaxService * SOAP_FMAC4 soap_in_ns2__TaxService(struct soap *soap, const char *tag, ns2__TaxService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TaxService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TaxService, sizeof(ns2__TaxService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__TaxService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__TaxService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__TaxService*)a)->run))
		return NULL;
	size_t soap_flag_nexus1 = 1;
	size_t soap_flag_noNexus1 = 1;
	size_t soap_flag_orderAcceptanceCity1 = 1;
	size_t soap_flag_orderAcceptanceCounty1 = 1;
	size_t soap_flag_orderAcceptanceCountry1 = 1;
	size_t soap_flag_orderAcceptanceState1 = 1;
	size_t soap_flag_orderAcceptancePostalCode1 = 1;
	size_t soap_flag_orderOriginCity1 = 1;
	size_t soap_flag_orderOriginCounty1 = 1;
	size_t soap_flag_orderOriginCountry1 = 1;
	size_t soap_flag_orderOriginState1 = 1;
	size_t soap_flag_orderOriginPostalCode1 = 1;
	size_t soap_flag_sellerRegistration1 = 1;
	size_t soap_flag_sellerRegistration01 = 1;
	size_t soap_flag_sellerRegistration11 = 1;
	size_t soap_flag_sellerRegistration21 = 1;
	size_t soap_flag_sellerRegistration31 = 1;
	size_t soap_flag_sellerRegistration41 = 1;
	size_t soap_flag_sellerRegistration51 = 1;
	size_t soap_flag_sellerRegistration61 = 1;
	size_t soap_flag_sellerRegistration71 = 1;
	size_t soap_flag_sellerRegistration81 = 1;
	size_t soap_flag_sellerRegistration91 = 1;
	size_t soap_flag_buyerRegistration1 = 1;
	size_t soap_flag_middlemanRegistration1 = 1;
	size_t soap_flag_pointOfTitleTransfer1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nexus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:nexus", (wchar_t**)&a->ns2__TaxService::nexus, "xsd:string"))
				{	soap_flag_nexus1--;
					continue;
				}
			if (soap_flag_noNexus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:noNexus", (wchar_t**)&a->ns2__TaxService::noNexus, "xsd:string"))
				{	soap_flag_noNexus1--;
					continue;
				}
			if (soap_flag_orderAcceptanceCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderAcceptanceCity", (wchar_t**)&a->ns2__TaxService::orderAcceptanceCity, "xsd:string"))
				{	soap_flag_orderAcceptanceCity1--;
					continue;
				}
			if (soap_flag_orderAcceptanceCounty1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderAcceptanceCounty", (wchar_t**)&a->ns2__TaxService::orderAcceptanceCounty, "xsd:string"))
				{	soap_flag_orderAcceptanceCounty1--;
					continue;
				}
			if (soap_flag_orderAcceptanceCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderAcceptanceCountry", (wchar_t**)&a->ns2__TaxService::orderAcceptanceCountry, "xsd:string"))
				{	soap_flag_orderAcceptanceCountry1--;
					continue;
				}
			if (soap_flag_orderAcceptanceState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderAcceptanceState", (wchar_t**)&a->ns2__TaxService::orderAcceptanceState, "xsd:string"))
				{	soap_flag_orderAcceptanceState1--;
					continue;
				}
			if (soap_flag_orderAcceptancePostalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderAcceptancePostalCode", (wchar_t**)&a->ns2__TaxService::orderAcceptancePostalCode, "xsd:string"))
				{	soap_flag_orderAcceptancePostalCode1--;
					continue;
				}
			if (soap_flag_orderOriginCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderOriginCity", (wchar_t**)&a->ns2__TaxService::orderOriginCity, "xsd:string"))
				{	soap_flag_orderOriginCity1--;
					continue;
				}
			if (soap_flag_orderOriginCounty1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderOriginCounty", (wchar_t**)&a->ns2__TaxService::orderOriginCounty, "xsd:string"))
				{	soap_flag_orderOriginCounty1--;
					continue;
				}
			if (soap_flag_orderOriginCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderOriginCountry", (wchar_t**)&a->ns2__TaxService::orderOriginCountry, "xsd:string"))
				{	soap_flag_orderOriginCountry1--;
					continue;
				}
			if (soap_flag_orderOriginState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderOriginState", (wchar_t**)&a->ns2__TaxService::orderOriginState, "xsd:string"))
				{	soap_flag_orderOriginState1--;
					continue;
				}
			if (soap_flag_orderOriginPostalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderOriginPostalCode", (wchar_t**)&a->ns2__TaxService::orderOriginPostalCode, "xsd:string"))
				{	soap_flag_orderOriginPostalCode1--;
					continue;
				}
			if (soap_flag_sellerRegistration1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sellerRegistration", (wchar_t**)&a->ns2__TaxService::sellerRegistration, "xsd:string"))
				{	soap_flag_sellerRegistration1--;
					continue;
				}
			if (soap_flag_sellerRegistration01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sellerRegistration0", (wchar_t**)&a->ns2__TaxService::sellerRegistration0, "xsd:string"))
				{	soap_flag_sellerRegistration01--;
					continue;
				}
			if (soap_flag_sellerRegistration11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sellerRegistration1", (wchar_t**)&a->ns2__TaxService::sellerRegistration1, "xsd:string"))
				{	soap_flag_sellerRegistration11--;
					continue;
				}
			if (soap_flag_sellerRegistration21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sellerRegistration2", (wchar_t**)&a->ns2__TaxService::sellerRegistration2, "xsd:string"))
				{	soap_flag_sellerRegistration21--;
					continue;
				}
			if (soap_flag_sellerRegistration31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sellerRegistration3", (wchar_t**)&a->ns2__TaxService::sellerRegistration3, "xsd:string"))
				{	soap_flag_sellerRegistration31--;
					continue;
				}
			if (soap_flag_sellerRegistration41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sellerRegistration4", (wchar_t**)&a->ns2__TaxService::sellerRegistration4, "xsd:string"))
				{	soap_flag_sellerRegistration41--;
					continue;
				}
			if (soap_flag_sellerRegistration51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sellerRegistration5", (wchar_t**)&a->ns2__TaxService::sellerRegistration5, "xsd:string"))
				{	soap_flag_sellerRegistration51--;
					continue;
				}
			if (soap_flag_sellerRegistration61 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sellerRegistration6", (wchar_t**)&a->ns2__TaxService::sellerRegistration6, "xsd:string"))
				{	soap_flag_sellerRegistration61--;
					continue;
				}
			if (soap_flag_sellerRegistration71 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sellerRegistration7", (wchar_t**)&a->ns2__TaxService::sellerRegistration7, "xsd:string"))
				{	soap_flag_sellerRegistration71--;
					continue;
				}
			if (soap_flag_sellerRegistration81 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sellerRegistration8", (wchar_t**)&a->ns2__TaxService::sellerRegistration8, "xsd:string"))
				{	soap_flag_sellerRegistration81--;
					continue;
				}
			if (soap_flag_sellerRegistration91 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sellerRegistration9", (wchar_t**)&a->ns2__TaxService::sellerRegistration9, "xsd:string"))
				{	soap_flag_sellerRegistration91--;
					continue;
				}
			if (soap_flag_buyerRegistration1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:buyerRegistration", (wchar_t**)&a->ns2__TaxService::buyerRegistration, "xsd:string"))
				{	soap_flag_buyerRegistration1--;
					continue;
				}
			if (soap_flag_middlemanRegistration1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:middlemanRegistration", (wchar_t**)&a->ns2__TaxService::middlemanRegistration, "xsd:string"))
				{	soap_flag_middlemanRegistration1--;
					continue;
				}
			if (soap_flag_pointOfTitleTransfer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pointOfTitleTransfer", (wchar_t**)&a->ns2__TaxService::pointOfTitleTransfer, "xsd:string"))
				{	soap_flag_pointOfTitleTransfer1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__TaxService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TaxService, SOAP_TYPE_ns2__TaxService, sizeof(ns2__TaxService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__TaxService * SOAP_FMAC2 soap_instantiate_ns2__TaxService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TaxService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__TaxService *p;
	size_t k = sizeof(ns2__TaxService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__TaxService);
		if (p)
			((ns2__TaxService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__TaxService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__TaxService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__TaxService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__TaxService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__TaxService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:TaxService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TaxService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TaxService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TaxService * SOAP_FMAC4 soap_get_ns2__TaxService(struct soap *soap, ns2__TaxService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TaxService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayerAuthValidateService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayerAuthValidateService::signedPARes = NULL;
	this->ns2__PayerAuthValidateService::run = NULL;
	/* transient soap skipped */
}

void ns2__PayerAuthValidateService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthValidateService::signedPARes);
#endif
}

int ns2__PayerAuthValidateService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayerAuthValidateService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayerAuthValidateService(struct soap *soap, const char *tag, int id, const ns2__PayerAuthValidateService *a, const char *type)
{
	if (((ns2__PayerAuthValidateService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PayerAuthValidateService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayerAuthValidateService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:signedPARes", -1, (wchar_t*const*)&a->ns2__PayerAuthValidateService::signedPARes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayerAuthValidateService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayerAuthValidateService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayerAuthValidateService * SOAP_FMAC4 soap_in_ns2__PayerAuthValidateService(struct soap *soap, const char *tag, ns2__PayerAuthValidateService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayerAuthValidateService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayerAuthValidateService, sizeof(ns2__PayerAuthValidateService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayerAuthValidateService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayerAuthValidateService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PayerAuthValidateService*)a)->run))
		return NULL;
	size_t soap_flag_signedPARes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_signedPARes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:signedPARes", (wchar_t**)&a->ns2__PayerAuthValidateService::signedPARes, "xsd:string"))
				{	soap_flag_signedPARes1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayerAuthValidateService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayerAuthValidateService, SOAP_TYPE_ns2__PayerAuthValidateService, sizeof(ns2__PayerAuthValidateService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayerAuthValidateService * SOAP_FMAC2 soap_instantiate_ns2__PayerAuthValidateService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayerAuthValidateService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayerAuthValidateService *p;
	size_t k = sizeof(ns2__PayerAuthValidateService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayerAuthValidateService);
		if (p)
			((ns2__PayerAuthValidateService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayerAuthValidateService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayerAuthValidateService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayerAuthValidateService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayerAuthValidateService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayerAuthValidateService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayerAuthValidateService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayerAuthValidateService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayerAuthValidateService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayerAuthValidateService * SOAP_FMAC4 soap_get_ns2__PayerAuthValidateService(struct soap *soap, ns2__PayerAuthValidateService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayerAuthValidateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__PayerAuthEnrollService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__PayerAuthEnrollService::httpAccept = NULL;
	this->ns2__PayerAuthEnrollService::httpUserAgent = NULL;
	this->ns2__PayerAuthEnrollService::merchantName = NULL;
	this->ns2__PayerAuthEnrollService::merchantURL = NULL;
	this->ns2__PayerAuthEnrollService::purchaseDescription = NULL;
	this->ns2__PayerAuthEnrollService::purchaseTime = NULL;
	this->ns2__PayerAuthEnrollService::countryCode = NULL;
	this->ns2__PayerAuthEnrollService::acquirerBin = NULL;
	this->ns2__PayerAuthEnrollService::loginID = NULL;
	this->ns2__PayerAuthEnrollService::password = NULL;
	this->ns2__PayerAuthEnrollService::merchantID = NULL;
	this->ns2__PayerAuthEnrollService::overridePaymentMethod = NULL;
	this->ns2__PayerAuthEnrollService::mobilePhone = NULL;
	this->ns2__PayerAuthEnrollService::MCC = NULL;
	this->ns2__PayerAuthEnrollService::productCode = NULL;
	this->ns2__PayerAuthEnrollService::run = NULL;
	/* transient soap skipped */
}

void ns2__PayerAuthEnrollService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollService::httpAccept);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollService::httpUserAgent);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollService::merchantName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollService::merchantURL);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollService::purchaseDescription);
	soap_serialize_PointerTons2__dateTime(soap, &this->ns2__PayerAuthEnrollService::purchaseTime);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollService::countryCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollService::acquirerBin);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollService::loginID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollService::password);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollService::merchantID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollService::overridePaymentMethod);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollService::mobilePhone);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollService::MCC);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__PayerAuthEnrollService::productCode);
#endif
}

int ns2__PayerAuthEnrollService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayerAuthEnrollService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayerAuthEnrollService(struct soap *soap, const char *tag, int id, const ns2__PayerAuthEnrollService *a, const char *type)
{
	if (((ns2__PayerAuthEnrollService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__PayerAuthEnrollService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayerAuthEnrollService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:httpAccept", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollService::httpAccept, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:httpUserAgent", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollService::httpUserAgent, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantName", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollService::merchantName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantURL", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollService::merchantURL, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:purchaseDescription", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollService::purchaseDescription, ""))
		return soap->error;
	if (soap_out_PointerTons2__dateTime(soap, "ns2:purchaseTime", -1, &a->ns2__PayerAuthEnrollService::purchaseTime, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:countryCode", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollService::countryCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:acquirerBin", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollService::acquirerBin, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:loginID", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollService::loginID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:password", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollService::password, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantID", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollService::merchantID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:overridePaymentMethod", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollService::overridePaymentMethod, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:mobilePhone", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollService::mobilePhone, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:MCC", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollService::MCC, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:productCode", -1, (wchar_t*const*)&a->ns2__PayerAuthEnrollService::productCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__PayerAuthEnrollService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayerAuthEnrollService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayerAuthEnrollService * SOAP_FMAC4 soap_in_ns2__PayerAuthEnrollService(struct soap *soap, const char *tag, ns2__PayerAuthEnrollService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayerAuthEnrollService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayerAuthEnrollService, sizeof(ns2__PayerAuthEnrollService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__PayerAuthEnrollService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__PayerAuthEnrollService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__PayerAuthEnrollService*)a)->run))
		return NULL;
	size_t soap_flag_httpAccept1 = 1;
	size_t soap_flag_httpUserAgent1 = 1;
	size_t soap_flag_merchantName1 = 1;
	size_t soap_flag_merchantURL1 = 1;
	size_t soap_flag_purchaseDescription1 = 1;
	size_t soap_flag_purchaseTime1 = 1;
	size_t soap_flag_countryCode1 = 1;
	size_t soap_flag_acquirerBin1 = 1;
	size_t soap_flag_loginID1 = 1;
	size_t soap_flag_password1 = 1;
	size_t soap_flag_merchantID1 = 1;
	size_t soap_flag_overridePaymentMethod1 = 1;
	size_t soap_flag_mobilePhone1 = 1;
	size_t soap_flag_MCC1 = 1;
	size_t soap_flag_productCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_httpAccept1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:httpAccept", (wchar_t**)&a->ns2__PayerAuthEnrollService::httpAccept, "xsd:string"))
				{	soap_flag_httpAccept1--;
					continue;
				}
			if (soap_flag_httpUserAgent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:httpUserAgent", (wchar_t**)&a->ns2__PayerAuthEnrollService::httpUserAgent, "xsd:string"))
				{	soap_flag_httpUserAgent1--;
					continue;
				}
			if (soap_flag_merchantName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantName", (wchar_t**)&a->ns2__PayerAuthEnrollService::merchantName, "xsd:string"))
				{	soap_flag_merchantName1--;
					continue;
				}
			if (soap_flag_merchantURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantURL", (wchar_t**)&a->ns2__PayerAuthEnrollService::merchantURL, "xsd:string"))
				{	soap_flag_merchantURL1--;
					continue;
				}
			if (soap_flag_purchaseDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:purchaseDescription", (wchar_t**)&a->ns2__PayerAuthEnrollService::purchaseDescription, "xsd:string"))
				{	soap_flag_purchaseDescription1--;
					continue;
				}
			if (soap_flag_purchaseTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__dateTime(soap, "ns2:purchaseTime", &a->ns2__PayerAuthEnrollService::purchaseTime, "ns2:dateTime"))
				{	soap_flag_purchaseTime1--;
					continue;
				}
			if (soap_flag_countryCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:countryCode", (wchar_t**)&a->ns2__PayerAuthEnrollService::countryCode, "xsd:string"))
				{	soap_flag_countryCode1--;
					continue;
				}
			if (soap_flag_acquirerBin1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:acquirerBin", (wchar_t**)&a->ns2__PayerAuthEnrollService::acquirerBin, "xsd:string"))
				{	soap_flag_acquirerBin1--;
					continue;
				}
			if (soap_flag_loginID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:loginID", (wchar_t**)&a->ns2__PayerAuthEnrollService::loginID, "xsd:string"))
				{	soap_flag_loginID1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:password", (wchar_t**)&a->ns2__PayerAuthEnrollService::password, "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap_flag_merchantID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantID", (wchar_t**)&a->ns2__PayerAuthEnrollService::merchantID, "xsd:string"))
				{	soap_flag_merchantID1--;
					continue;
				}
			if (soap_flag_overridePaymentMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:overridePaymentMethod", (wchar_t**)&a->ns2__PayerAuthEnrollService::overridePaymentMethod, "xsd:string"))
				{	soap_flag_overridePaymentMethod1--;
					continue;
				}
			if (soap_flag_mobilePhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:mobilePhone", (wchar_t**)&a->ns2__PayerAuthEnrollService::mobilePhone, "xsd:string"))
				{	soap_flag_mobilePhone1--;
					continue;
				}
			if (soap_flag_MCC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:MCC", (wchar_t**)&a->ns2__PayerAuthEnrollService::MCC, "xsd:string"))
				{	soap_flag_MCC1--;
					continue;
				}
			if (soap_flag_productCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:productCode", (wchar_t**)&a->ns2__PayerAuthEnrollService::productCode, "xsd:string"))
				{	soap_flag_productCode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayerAuthEnrollService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PayerAuthEnrollService, SOAP_TYPE_ns2__PayerAuthEnrollService, sizeof(ns2__PayerAuthEnrollService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__PayerAuthEnrollService * SOAP_FMAC2 soap_instantiate_ns2__PayerAuthEnrollService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayerAuthEnrollService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__PayerAuthEnrollService *p;
	size_t k = sizeof(ns2__PayerAuthEnrollService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__PayerAuthEnrollService);
		if (p)
			((ns2__PayerAuthEnrollService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__PayerAuthEnrollService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__PayerAuthEnrollService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__PayerAuthEnrollService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__PayerAuthEnrollService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__PayerAuthEnrollService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:PayerAuthEnrollService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PayerAuthEnrollService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayerAuthEnrollService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayerAuthEnrollService * SOAP_FMAC4 soap_get_ns2__PayerAuthEnrollService(struct soap *soap, ns2__PayerAuthEnrollService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayerAuthEnrollService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ECAuthenticateService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ECAuthenticateService::referenceNumber = NULL;
	this->ns2__ECAuthenticateService::run = NULL;
	/* transient soap skipped */
}

void ns2__ECAuthenticateService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECAuthenticateService::referenceNumber);
#endif
}

int ns2__ECAuthenticateService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ECAuthenticateService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ECAuthenticateService(struct soap *soap, const char *tag, int id, const ns2__ECAuthenticateService *a, const char *type)
{
	if (((ns2__ECAuthenticateService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__ECAuthenticateService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ECAuthenticateService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:referenceNumber", -1, (wchar_t*const*)&a->ns2__ECAuthenticateService::referenceNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ECAuthenticateService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ECAuthenticateService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ECAuthenticateService * SOAP_FMAC4 soap_in_ns2__ECAuthenticateService(struct soap *soap, const char *tag, ns2__ECAuthenticateService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ECAuthenticateService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ECAuthenticateService, sizeof(ns2__ECAuthenticateService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ECAuthenticateService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ECAuthenticateService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__ECAuthenticateService*)a)->run))
		return NULL;
	size_t soap_flag_referenceNumber1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_referenceNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:referenceNumber", (wchar_t**)&a->ns2__ECAuthenticateService::referenceNumber, "xsd:string"))
				{	soap_flag_referenceNumber1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ECAuthenticateService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ECAuthenticateService, SOAP_TYPE_ns2__ECAuthenticateService, sizeof(ns2__ECAuthenticateService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ECAuthenticateService * SOAP_FMAC2 soap_instantiate_ns2__ECAuthenticateService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ECAuthenticateService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ECAuthenticateService *p;
	size_t k = sizeof(ns2__ECAuthenticateService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ECAuthenticateService);
		if (p)
			((ns2__ECAuthenticateService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ECAuthenticateService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ECAuthenticateService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ECAuthenticateService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ECAuthenticateService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ECAuthenticateService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:ECAuthenticateService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ECAuthenticateService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ECAuthenticateService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ECAuthenticateService * SOAP_FMAC4 soap_get_ns2__ECAuthenticateService(struct soap *soap, ns2__ECAuthenticateService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ECAuthenticateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ECCreditService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ECCreditService::referenceNumber = NULL;
	this->ns2__ECCreditService::settlementMethod = NULL;
	this->ns2__ECCreditService::transactionToken = NULL;
	this->ns2__ECCreditService::debitRequestID = NULL;
	this->ns2__ECCreditService::partialPaymentID = NULL;
	this->ns2__ECCreditService::commerceIndicator = NULL;
	this->ns2__ECCreditService::debitRequestToken = NULL;
	this->ns2__ECCreditService::effectiveDate = NULL;
	this->ns2__ECCreditService::run = NULL;
	/* transient soap skipped */
}

void ns2__ECCreditService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECCreditService::referenceNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECCreditService::settlementMethod);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECCreditService::transactionToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECCreditService::debitRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECCreditService::partialPaymentID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECCreditService::commerceIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECCreditService::debitRequestToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECCreditService::effectiveDate);
#endif
}

int ns2__ECCreditService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ECCreditService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ECCreditService(struct soap *soap, const char *tag, int id, const ns2__ECCreditService *a, const char *type)
{
	if (((ns2__ECCreditService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__ECCreditService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ECCreditService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:referenceNumber", -1, (wchar_t*const*)&a->ns2__ECCreditService::referenceNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:settlementMethod", -1, (wchar_t*const*)&a->ns2__ECCreditService::settlementMethod, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionToken", -1, (wchar_t*const*)&a->ns2__ECCreditService::transactionToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:debitRequestID", -1, (wchar_t*const*)&a->ns2__ECCreditService::debitRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:partialPaymentID", -1, (wchar_t*const*)&a->ns2__ECCreditService::partialPaymentID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:commerceIndicator", -1, (wchar_t*const*)&a->ns2__ECCreditService::commerceIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:debitRequestToken", -1, (wchar_t*const*)&a->ns2__ECCreditService::debitRequestToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:effectiveDate", -1, (wchar_t*const*)&a->ns2__ECCreditService::effectiveDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ECCreditService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ECCreditService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ECCreditService * SOAP_FMAC4 soap_in_ns2__ECCreditService(struct soap *soap, const char *tag, ns2__ECCreditService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ECCreditService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ECCreditService, sizeof(ns2__ECCreditService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ECCreditService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ECCreditService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__ECCreditService*)a)->run))
		return NULL;
	size_t soap_flag_referenceNumber1 = 1;
	size_t soap_flag_settlementMethod1 = 1;
	size_t soap_flag_transactionToken1 = 1;
	size_t soap_flag_debitRequestID1 = 1;
	size_t soap_flag_partialPaymentID1 = 1;
	size_t soap_flag_commerceIndicator1 = 1;
	size_t soap_flag_debitRequestToken1 = 1;
	size_t soap_flag_effectiveDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_referenceNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:referenceNumber", (wchar_t**)&a->ns2__ECCreditService::referenceNumber, "xsd:string"))
				{	soap_flag_referenceNumber1--;
					continue;
				}
			if (soap_flag_settlementMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:settlementMethod", (wchar_t**)&a->ns2__ECCreditService::settlementMethod, "xsd:string"))
				{	soap_flag_settlementMethod1--;
					continue;
				}
			if (soap_flag_transactionToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionToken", (wchar_t**)&a->ns2__ECCreditService::transactionToken, "xsd:string"))
				{	soap_flag_transactionToken1--;
					continue;
				}
			if (soap_flag_debitRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:debitRequestID", (wchar_t**)&a->ns2__ECCreditService::debitRequestID, "xsd:string"))
				{	soap_flag_debitRequestID1--;
					continue;
				}
			if (soap_flag_partialPaymentID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:partialPaymentID", (wchar_t**)&a->ns2__ECCreditService::partialPaymentID, "xsd:string"))
				{	soap_flag_partialPaymentID1--;
					continue;
				}
			if (soap_flag_commerceIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:commerceIndicator", (wchar_t**)&a->ns2__ECCreditService::commerceIndicator, "xsd:string"))
				{	soap_flag_commerceIndicator1--;
					continue;
				}
			if (soap_flag_debitRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:debitRequestToken", (wchar_t**)&a->ns2__ECCreditService::debitRequestToken, "xsd:string"))
				{	soap_flag_debitRequestToken1--;
					continue;
				}
			if (soap_flag_effectiveDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:effectiveDate", (wchar_t**)&a->ns2__ECCreditService::effectiveDate, "xsd:string"))
				{	soap_flag_effectiveDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ECCreditService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ECCreditService, SOAP_TYPE_ns2__ECCreditService, sizeof(ns2__ECCreditService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ECCreditService * SOAP_FMAC2 soap_instantiate_ns2__ECCreditService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ECCreditService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ECCreditService *p;
	size_t k = sizeof(ns2__ECCreditService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ECCreditService);
		if (p)
			((ns2__ECCreditService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ECCreditService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ECCreditService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ECCreditService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ECCreditService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ECCreditService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:ECCreditService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ECCreditService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ECCreditService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ECCreditService * SOAP_FMAC4 soap_get_ns2__ECCreditService(struct soap *soap, ns2__ECCreditService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ECCreditService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ECDebitService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ECDebitService::paymentMode = NULL;
	this->ns2__ECDebitService::referenceNumber = NULL;
	this->ns2__ECDebitService::settlementMethod = NULL;
	this->ns2__ECDebitService::transactionToken = NULL;
	this->ns2__ECDebitService::verificationLevel = NULL;
	this->ns2__ECDebitService::partialPaymentID = NULL;
	this->ns2__ECDebitService::commerceIndicator = NULL;
	this->ns2__ECDebitService::debitRequestID = NULL;
	this->ns2__ECDebitService::effectiveDate = NULL;
	this->ns2__ECDebitService::run = NULL;
	/* transient soap skipped */
}

void ns2__ECDebitService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__ECDebitService::paymentMode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECDebitService::referenceNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECDebitService::settlementMethod);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECDebitService::transactionToken);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__ECDebitService::verificationLevel);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECDebitService::partialPaymentID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECDebitService::commerceIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECDebitService::debitRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__ECDebitService::effectiveDate);
#endif
}

int ns2__ECDebitService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ECDebitService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ECDebitService(struct soap *soap, const char *tag, int id, const ns2__ECDebitService *a, const char *type)
{
	if (((ns2__ECDebitService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__ECDebitService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ECDebitService), type))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:paymentMode", -1, &a->ns2__ECDebitService::paymentMode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:referenceNumber", -1, (wchar_t*const*)&a->ns2__ECDebitService::referenceNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:settlementMethod", -1, (wchar_t*const*)&a->ns2__ECDebitService::settlementMethod, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionToken", -1, (wchar_t*const*)&a->ns2__ECDebitService::transactionToken, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:verificationLevel", -1, &a->ns2__ECDebitService::verificationLevel, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:partialPaymentID", -1, (wchar_t*const*)&a->ns2__ECDebitService::partialPaymentID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:commerceIndicator", -1, (wchar_t*const*)&a->ns2__ECDebitService::commerceIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:debitRequestID", -1, (wchar_t*const*)&a->ns2__ECDebitService::debitRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:effectiveDate", -1, (wchar_t*const*)&a->ns2__ECDebitService::effectiveDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ECDebitService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ECDebitService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ECDebitService * SOAP_FMAC4 soap_in_ns2__ECDebitService(struct soap *soap, const char *tag, ns2__ECDebitService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ECDebitService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ECDebitService, sizeof(ns2__ECDebitService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ECDebitService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ECDebitService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__ECDebitService*)a)->run))
		return NULL;
	size_t soap_flag_paymentMode1 = 1;
	size_t soap_flag_referenceNumber1 = 1;
	size_t soap_flag_settlementMethod1 = 1;
	size_t soap_flag_transactionToken1 = 1;
	size_t soap_flag_verificationLevel1 = 1;
	size_t soap_flag_partialPaymentID1 = 1;
	size_t soap_flag_commerceIndicator1 = 1;
	size_t soap_flag_debitRequestID1 = 1;
	size_t soap_flag_effectiveDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_paymentMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:paymentMode", &a->ns2__ECDebitService::paymentMode, "xsd:integer"))
				{	soap_flag_paymentMode1--;
					continue;
				}
			if (soap_flag_referenceNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:referenceNumber", (wchar_t**)&a->ns2__ECDebitService::referenceNumber, "xsd:string"))
				{	soap_flag_referenceNumber1--;
					continue;
				}
			if (soap_flag_settlementMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:settlementMethod", (wchar_t**)&a->ns2__ECDebitService::settlementMethod, "xsd:string"))
				{	soap_flag_settlementMethod1--;
					continue;
				}
			if (soap_flag_transactionToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionToken", (wchar_t**)&a->ns2__ECDebitService::transactionToken, "xsd:string"))
				{	soap_flag_transactionToken1--;
					continue;
				}
			if (soap_flag_verificationLevel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:verificationLevel", &a->ns2__ECDebitService::verificationLevel, "xsd:integer"))
				{	soap_flag_verificationLevel1--;
					continue;
				}
			if (soap_flag_partialPaymentID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:partialPaymentID", (wchar_t**)&a->ns2__ECDebitService::partialPaymentID, "xsd:string"))
				{	soap_flag_partialPaymentID1--;
					continue;
				}
			if (soap_flag_commerceIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:commerceIndicator", (wchar_t**)&a->ns2__ECDebitService::commerceIndicator, "xsd:string"))
				{	soap_flag_commerceIndicator1--;
					continue;
				}
			if (soap_flag_debitRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:debitRequestID", (wchar_t**)&a->ns2__ECDebitService::debitRequestID, "xsd:string"))
				{	soap_flag_debitRequestID1--;
					continue;
				}
			if (soap_flag_effectiveDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:effectiveDate", (wchar_t**)&a->ns2__ECDebitService::effectiveDate, "xsd:string"))
				{	soap_flag_effectiveDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ECDebitService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ECDebitService, SOAP_TYPE_ns2__ECDebitService, sizeof(ns2__ECDebitService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ECDebitService * SOAP_FMAC2 soap_instantiate_ns2__ECDebitService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ECDebitService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ECDebitService *p;
	size_t k = sizeof(ns2__ECDebitService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ECDebitService);
		if (p)
			((ns2__ECDebitService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ECDebitService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ECDebitService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ECDebitService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ECDebitService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ECDebitService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:ECDebitService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ECDebitService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ECDebitService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ECDebitService * SOAP_FMAC4 soap_get_ns2__ECDebitService(struct soap *soap, ns2__ECDebitService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ECDebitService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__ServiceFeeCalculateService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ServiceFeeCalculateService::run = NULL;
	/* transient soap skipped */
}

void ns2__ServiceFeeCalculateService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__ServiceFeeCalculateService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ServiceFeeCalculateService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ServiceFeeCalculateService(struct soap *soap, const char *tag, int id, const ns2__ServiceFeeCalculateService *a, const char *type)
{
	if (((ns2__ServiceFeeCalculateService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__ServiceFeeCalculateService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ServiceFeeCalculateService), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ServiceFeeCalculateService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ServiceFeeCalculateService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ServiceFeeCalculateService * SOAP_FMAC4 soap_in_ns2__ServiceFeeCalculateService(struct soap *soap, const char *tag, ns2__ServiceFeeCalculateService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ServiceFeeCalculateService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ServiceFeeCalculateService, sizeof(ns2__ServiceFeeCalculateService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__ServiceFeeCalculateService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__ServiceFeeCalculateService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__ServiceFeeCalculateService*)a)->run))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ServiceFeeCalculateService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ServiceFeeCalculateService, SOAP_TYPE_ns2__ServiceFeeCalculateService, sizeof(ns2__ServiceFeeCalculateService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__ServiceFeeCalculateService * SOAP_FMAC2 soap_instantiate_ns2__ServiceFeeCalculateService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ServiceFeeCalculateService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__ServiceFeeCalculateService *p;
	size_t k = sizeof(ns2__ServiceFeeCalculateService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__ServiceFeeCalculateService);
		if (p)
			((ns2__ServiceFeeCalculateService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__ServiceFeeCalculateService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__ServiceFeeCalculateService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__ServiceFeeCalculateService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__ServiceFeeCalculateService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__ServiceFeeCalculateService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:ServiceFeeCalculateService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ServiceFeeCalculateService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ServiceFeeCalculateService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ServiceFeeCalculateService * SOAP_FMAC4 soap_get_ns2__ServiceFeeCalculateService(struct soap *soap, ns2__ServiceFeeCalculateService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ServiceFeeCalculateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CCDCCService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CCDCCService::run = NULL;
	/* transient soap skipped */
}

void ns2__CCDCCService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns2__CCDCCService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CCDCCService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CCDCCService(struct soap *soap, const char *tag, int id, const ns2__CCDCCService *a, const char *type)
{
	if (((ns2__CCDCCService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__CCDCCService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CCDCCService), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CCDCCService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CCDCCService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CCDCCService * SOAP_FMAC4 soap_in_ns2__CCDCCService(struct soap *soap, const char *tag, ns2__CCDCCService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CCDCCService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CCDCCService, sizeof(ns2__CCDCCService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CCDCCService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CCDCCService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__CCDCCService*)a)->run))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CCDCCService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CCDCCService, SOAP_TYPE_ns2__CCDCCService, sizeof(ns2__CCDCCService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CCDCCService * SOAP_FMAC2 soap_instantiate_ns2__CCDCCService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CCDCCService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CCDCCService *p;
	size_t k = sizeof(ns2__CCDCCService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CCDCCService);
		if (p)
			((ns2__CCDCCService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CCDCCService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CCDCCService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CCDCCService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CCDCCService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CCDCCService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CCDCCService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CCDCCService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CCDCCService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CCDCCService * SOAP_FMAC4 soap_get_ns2__CCDCCService(struct soap *soap, ns2__CCDCCService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CCDCCService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CCAutoAuthReversalService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CCAutoAuthReversalService::authPaymentServiceData = NULL;
	this->ns2__CCAutoAuthReversalService::reconciliationID = NULL;
	this->ns2__CCAutoAuthReversalService::authAmount = NULL;
	this->ns2__CCAutoAuthReversalService::commerceIndicator = NULL;
	this->ns2__CCAutoAuthReversalService::authRequestID = NULL;
	this->ns2__CCAutoAuthReversalService::billAmount = NULL;
	this->ns2__CCAutoAuthReversalService::authCode = NULL;
	this->ns2__CCAutoAuthReversalService::authType = NULL;
	this->ns2__CCAutoAuthReversalService::billPayment = NULL;
	this->ns2__CCAutoAuthReversalService::dateAdded = NULL;
	this->ns2__CCAutoAuthReversalService::run = NULL;
	/* transient soap skipped */
}

void ns2__CCAutoAuthReversalService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAutoAuthReversalService::authPaymentServiceData);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAutoAuthReversalService::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAutoAuthReversalService::authAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAutoAuthReversalService::commerceIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAutoAuthReversalService::authRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAutoAuthReversalService::billAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAutoAuthReversalService::authCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAutoAuthReversalService::authType);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__CCAutoAuthReversalService::billPayment);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAutoAuthReversalService::dateAdded);
#endif
}

int ns2__CCAutoAuthReversalService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CCAutoAuthReversalService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CCAutoAuthReversalService(struct soap *soap, const char *tag, int id, const ns2__CCAutoAuthReversalService *a, const char *type)
{
	if (((ns2__CCAutoAuthReversalService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__CCAutoAuthReversalService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CCAutoAuthReversalService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authPaymentServiceData", -1, (wchar_t*const*)&a->ns2__CCAutoAuthReversalService::authPaymentServiceData, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__CCAutoAuthReversalService::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authAmount", -1, (wchar_t*const*)&a->ns2__CCAutoAuthReversalService::authAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:commerceIndicator", -1, (wchar_t*const*)&a->ns2__CCAutoAuthReversalService::commerceIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authRequestID", -1, (wchar_t*const*)&a->ns2__CCAutoAuthReversalService::authRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:billAmount", -1, (wchar_t*const*)&a->ns2__CCAutoAuthReversalService::billAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authCode", -1, (wchar_t*const*)&a->ns2__CCAutoAuthReversalService::authCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authType", -1, (wchar_t*const*)&a->ns2__CCAutoAuthReversalService::authType, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:billPayment", -1, &a->ns2__CCAutoAuthReversalService::billPayment, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:dateAdded", -1, (wchar_t*const*)&a->ns2__CCAutoAuthReversalService::dateAdded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CCAutoAuthReversalService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CCAutoAuthReversalService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CCAutoAuthReversalService * SOAP_FMAC4 soap_in_ns2__CCAutoAuthReversalService(struct soap *soap, const char *tag, ns2__CCAutoAuthReversalService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CCAutoAuthReversalService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CCAutoAuthReversalService, sizeof(ns2__CCAutoAuthReversalService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CCAutoAuthReversalService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CCAutoAuthReversalService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__CCAutoAuthReversalService*)a)->run))
		return NULL;
	size_t soap_flag_authPaymentServiceData1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_authAmount1 = 1;
	size_t soap_flag_commerceIndicator1 = 1;
	size_t soap_flag_authRequestID1 = 1;
	size_t soap_flag_billAmount1 = 1;
	size_t soap_flag_authCode1 = 1;
	size_t soap_flag_authType1 = 1;
	size_t soap_flag_billPayment1 = 1;
	size_t soap_flag_dateAdded1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authPaymentServiceData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authPaymentServiceData", (wchar_t**)&a->ns2__CCAutoAuthReversalService::authPaymentServiceData, "xsd:string"))
				{	soap_flag_authPaymentServiceData1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__CCAutoAuthReversalService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_authAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authAmount", (wchar_t**)&a->ns2__CCAutoAuthReversalService::authAmount, "xsd:string"))
				{	soap_flag_authAmount1--;
					continue;
				}
			if (soap_flag_commerceIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:commerceIndicator", (wchar_t**)&a->ns2__CCAutoAuthReversalService::commerceIndicator, "xsd:string"))
				{	soap_flag_commerceIndicator1--;
					continue;
				}
			if (soap_flag_authRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authRequestID", (wchar_t**)&a->ns2__CCAutoAuthReversalService::authRequestID, "xsd:string"))
				{	soap_flag_authRequestID1--;
					continue;
				}
			if (soap_flag_billAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:billAmount", (wchar_t**)&a->ns2__CCAutoAuthReversalService::billAmount, "xsd:string"))
				{	soap_flag_billAmount1--;
					continue;
				}
			if (soap_flag_authCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authCode", (wchar_t**)&a->ns2__CCAutoAuthReversalService::authCode, "xsd:string"))
				{	soap_flag_authCode1--;
					continue;
				}
			if (soap_flag_authType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authType", (wchar_t**)&a->ns2__CCAutoAuthReversalService::authType, "xsd:string"))
				{	soap_flag_authType1--;
					continue;
				}
			if (soap_flag_billPayment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:billPayment", &a->ns2__CCAutoAuthReversalService::billPayment, "ns2:boolean"))
				{	soap_flag_billPayment1--;
					continue;
				}
			if (soap_flag_dateAdded1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:dateAdded", (wchar_t**)&a->ns2__CCAutoAuthReversalService::dateAdded, "xsd:string"))
				{	soap_flag_dateAdded1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CCAutoAuthReversalService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CCAutoAuthReversalService, SOAP_TYPE_ns2__CCAutoAuthReversalService, sizeof(ns2__CCAutoAuthReversalService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CCAutoAuthReversalService * SOAP_FMAC2 soap_instantiate_ns2__CCAutoAuthReversalService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CCAutoAuthReversalService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CCAutoAuthReversalService *p;
	size_t k = sizeof(ns2__CCAutoAuthReversalService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CCAutoAuthReversalService);
		if (p)
			((ns2__CCAutoAuthReversalService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CCAutoAuthReversalService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CCAutoAuthReversalService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CCAutoAuthReversalService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CCAutoAuthReversalService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CCAutoAuthReversalService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CCAutoAuthReversalService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CCAutoAuthReversalService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CCAutoAuthReversalService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CCAutoAuthReversalService * SOAP_FMAC4 soap_get_ns2__CCAutoAuthReversalService(struct soap *soap, ns2__CCAutoAuthReversalService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CCAutoAuthReversalService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CCAuthReversalService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CCAuthReversalService::authRequestID = NULL;
	this->ns2__CCAuthReversalService::authRequestToken = NULL;
	this->ns2__CCAuthReversalService::reversalReason = NULL;
	this->ns2__CCAuthReversalService::run = NULL;
	/* transient soap skipped */
}

void ns2__CCAuthReversalService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReversalService::authRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReversalService::authRequestToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthReversalService::reversalReason);
#endif
}

int ns2__CCAuthReversalService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CCAuthReversalService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CCAuthReversalService(struct soap *soap, const char *tag, int id, const ns2__CCAuthReversalService *a, const char *type)
{
	if (((ns2__CCAuthReversalService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__CCAuthReversalService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CCAuthReversalService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authRequestID", -1, (wchar_t*const*)&a->ns2__CCAuthReversalService::authRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authRequestToken", -1, (wchar_t*const*)&a->ns2__CCAuthReversalService::authRequestToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reversalReason", -1, (wchar_t*const*)&a->ns2__CCAuthReversalService::reversalReason, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CCAuthReversalService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CCAuthReversalService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CCAuthReversalService * SOAP_FMAC4 soap_in_ns2__CCAuthReversalService(struct soap *soap, const char *tag, ns2__CCAuthReversalService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CCAuthReversalService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CCAuthReversalService, sizeof(ns2__CCAuthReversalService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CCAuthReversalService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CCAuthReversalService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__CCAuthReversalService*)a)->run))
		return NULL;
	size_t soap_flag_authRequestID1 = 1;
	size_t soap_flag_authRequestToken1 = 1;
	size_t soap_flag_reversalReason1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authRequestID", (wchar_t**)&a->ns2__CCAuthReversalService::authRequestID, "xsd:string"))
				{	soap_flag_authRequestID1--;
					continue;
				}
			if (soap_flag_authRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authRequestToken", (wchar_t**)&a->ns2__CCAuthReversalService::authRequestToken, "xsd:string"))
				{	soap_flag_authRequestToken1--;
					continue;
				}
			if (soap_flag_reversalReason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reversalReason", (wchar_t**)&a->ns2__CCAuthReversalService::reversalReason, "xsd:string"))
				{	soap_flag_reversalReason1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CCAuthReversalService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CCAuthReversalService, SOAP_TYPE_ns2__CCAuthReversalService, sizeof(ns2__CCAuthReversalService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CCAuthReversalService * SOAP_FMAC2 soap_instantiate_ns2__CCAuthReversalService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CCAuthReversalService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CCAuthReversalService *p;
	size_t k = sizeof(ns2__CCAuthReversalService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CCAuthReversalService);
		if (p)
			((ns2__CCAuthReversalService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CCAuthReversalService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CCAuthReversalService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CCAuthReversalService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CCAuthReversalService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CCAuthReversalService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CCAuthReversalService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CCAuthReversalService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CCAuthReversalService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CCAuthReversalService * SOAP_FMAC4 soap_get_ns2__CCAuthReversalService(struct soap *soap, ns2__CCAuthReversalService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CCAuthReversalService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CCCreditService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CCCreditService::captureRequestID = NULL;
	this->ns2__CCCreditService::reconciliationID = NULL;
	this->ns2__CCCreditService::partialPaymentID = NULL;
	this->ns2__CCCreditService::purchasingLevel = NULL;
	this->ns2__CCCreditService::industryDatatype = NULL;
	this->ns2__CCCreditService::commerceIndicator = NULL;
	this->ns2__CCCreditService::billPayment = NULL;
	this->ns2__CCCreditService::authorizationXID = NULL;
	this->ns2__CCCreditService::occurrenceNumber = NULL;
	this->ns2__CCCreditService::authCode = NULL;
	this->ns2__CCCreditService::captureRequestToken = NULL;
	this->ns2__CCCreditService::merchantReceiptNumber = NULL;
	this->ns2__CCCreditService::checksumKey = NULL;
	this->ns2__CCCreditService::aggregatorID = NULL;
	this->ns2__CCCreditService::aggregatorName = NULL;
	this->ns2__CCCreditService::duration = NULL;
	this->ns2__CCCreditService::dpdeBillingMonth = NULL;
	this->ns2__CCCreditService::reconciliationIDAlternate = NULL;
	this->ns2__CCCreditService::refundReason = NULL;
	this->ns2__CCCreditService::run = NULL;
	/* transient soap skipped */
}

void ns2__CCCreditService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCreditService::captureRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCreditService::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCreditService::partialPaymentID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCreditService::purchasingLevel);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCreditService::industryDatatype);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCreditService::commerceIndicator);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__CCCreditService::billPayment);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCreditService::authorizationXID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCreditService::occurrenceNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCreditService::authCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCreditService::captureRequestToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCreditService::merchantReceiptNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCreditService::checksumKey);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCreditService::aggregatorID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCreditService::aggregatorName);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__CCCreditService::duration);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__CCCreditService::dpdeBillingMonth);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCreditService::reconciliationIDAlternate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCreditService::refundReason);
#endif
}

int ns2__CCCreditService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CCCreditService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CCCreditService(struct soap *soap, const char *tag, int id, const ns2__CCCreditService *a, const char *type)
{
	if (((ns2__CCCreditService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__CCCreditService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CCCreditService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:captureRequestID", -1, (wchar_t*const*)&a->ns2__CCCreditService::captureRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__CCCreditService::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:partialPaymentID", -1, (wchar_t*const*)&a->ns2__CCCreditService::partialPaymentID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:purchasingLevel", -1, (wchar_t*const*)&a->ns2__CCCreditService::purchasingLevel, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:industryDatatype", -1, (wchar_t*const*)&a->ns2__CCCreditService::industryDatatype, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:commerceIndicator", -1, (wchar_t*const*)&a->ns2__CCCreditService::commerceIndicator, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:billPayment", -1, &a->ns2__CCCreditService::billPayment, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authorizationXID", -1, (wchar_t*const*)&a->ns2__CCCreditService::authorizationXID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:occurrenceNumber", -1, (wchar_t*const*)&a->ns2__CCCreditService::occurrenceNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authCode", -1, (wchar_t*const*)&a->ns2__CCCreditService::authCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:captureRequestToken", -1, (wchar_t*const*)&a->ns2__CCCreditService::captureRequestToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantReceiptNumber", -1, (wchar_t*const*)&a->ns2__CCCreditService::merchantReceiptNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:checksumKey", -1, (wchar_t*const*)&a->ns2__CCCreditService::checksumKey, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:aggregatorID", -1, (wchar_t*const*)&a->ns2__CCCreditService::aggregatorID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:aggregatorName", -1, (wchar_t*const*)&a->ns2__CCCreditService::aggregatorName, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:duration", -1, &a->ns2__CCCreditService::duration, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:dpdeBillingMonth", -1, &a->ns2__CCCreditService::dpdeBillingMonth, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationIDAlternate", -1, (wchar_t*const*)&a->ns2__CCCreditService::reconciliationIDAlternate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:refundReason", -1, (wchar_t*const*)&a->ns2__CCCreditService::refundReason, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CCCreditService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CCCreditService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CCCreditService * SOAP_FMAC4 soap_in_ns2__CCCreditService(struct soap *soap, const char *tag, ns2__CCCreditService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CCCreditService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CCCreditService, sizeof(ns2__CCCreditService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CCCreditService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CCCreditService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__CCCreditService*)a)->run))
		return NULL;
	size_t soap_flag_captureRequestID1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_partialPaymentID1 = 1;
	size_t soap_flag_purchasingLevel1 = 1;
	size_t soap_flag_industryDatatype1 = 1;
	size_t soap_flag_commerceIndicator1 = 1;
	size_t soap_flag_billPayment1 = 1;
	size_t soap_flag_authorizationXID1 = 1;
	size_t soap_flag_occurrenceNumber1 = 1;
	size_t soap_flag_authCode1 = 1;
	size_t soap_flag_captureRequestToken1 = 1;
	size_t soap_flag_merchantReceiptNumber1 = 1;
	size_t soap_flag_checksumKey1 = 1;
	size_t soap_flag_aggregatorID1 = 1;
	size_t soap_flag_aggregatorName1 = 1;
	size_t soap_flag_duration1 = 1;
	size_t soap_flag_dpdeBillingMonth1 = 1;
	size_t soap_flag_reconciliationIDAlternate1 = 1;
	size_t soap_flag_refundReason1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_captureRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:captureRequestID", (wchar_t**)&a->ns2__CCCreditService::captureRequestID, "xsd:string"))
				{	soap_flag_captureRequestID1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__CCCreditService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_partialPaymentID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:partialPaymentID", (wchar_t**)&a->ns2__CCCreditService::partialPaymentID, "xsd:string"))
				{	soap_flag_partialPaymentID1--;
					continue;
				}
			if (soap_flag_purchasingLevel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:purchasingLevel", (wchar_t**)&a->ns2__CCCreditService::purchasingLevel, "xsd:string"))
				{	soap_flag_purchasingLevel1--;
					continue;
				}
			if (soap_flag_industryDatatype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:industryDatatype", (wchar_t**)&a->ns2__CCCreditService::industryDatatype, "xsd:string"))
				{	soap_flag_industryDatatype1--;
					continue;
				}
			if (soap_flag_commerceIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:commerceIndicator", (wchar_t**)&a->ns2__CCCreditService::commerceIndicator, "xsd:string"))
				{	soap_flag_commerceIndicator1--;
					continue;
				}
			if (soap_flag_billPayment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:billPayment", &a->ns2__CCCreditService::billPayment, "ns2:boolean"))
				{	soap_flag_billPayment1--;
					continue;
				}
			if (soap_flag_authorizationXID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authorizationXID", (wchar_t**)&a->ns2__CCCreditService::authorizationXID, "xsd:string"))
				{	soap_flag_authorizationXID1--;
					continue;
				}
			if (soap_flag_occurrenceNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:occurrenceNumber", (wchar_t**)&a->ns2__CCCreditService::occurrenceNumber, "xsd:string"))
				{	soap_flag_occurrenceNumber1--;
					continue;
				}
			if (soap_flag_authCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authCode", (wchar_t**)&a->ns2__CCCreditService::authCode, "xsd:string"))
				{	soap_flag_authCode1--;
					continue;
				}
			if (soap_flag_captureRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:captureRequestToken", (wchar_t**)&a->ns2__CCCreditService::captureRequestToken, "xsd:string"))
				{	soap_flag_captureRequestToken1--;
					continue;
				}
			if (soap_flag_merchantReceiptNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantReceiptNumber", (wchar_t**)&a->ns2__CCCreditService::merchantReceiptNumber, "xsd:string"))
				{	soap_flag_merchantReceiptNumber1--;
					continue;
				}
			if (soap_flag_checksumKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:checksumKey", (wchar_t**)&a->ns2__CCCreditService::checksumKey, "xsd:string"))
				{	soap_flag_checksumKey1--;
					continue;
				}
			if (soap_flag_aggregatorID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:aggregatorID", (wchar_t**)&a->ns2__CCCreditService::aggregatorID, "xsd:string"))
				{	soap_flag_aggregatorID1--;
					continue;
				}
			if (soap_flag_aggregatorName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:aggregatorName", (wchar_t**)&a->ns2__CCCreditService::aggregatorName, "xsd:string"))
				{	soap_flag_aggregatorName1--;
					continue;
				}
			if (soap_flag_duration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:duration", &a->ns2__CCCreditService::duration, "xsd:integer"))
				{	soap_flag_duration1--;
					continue;
				}
			if (soap_flag_dpdeBillingMonth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:dpdeBillingMonth", &a->ns2__CCCreditService::dpdeBillingMonth, "xsd:integer"))
				{	soap_flag_dpdeBillingMonth1--;
					continue;
				}
			if (soap_flag_reconciliationIDAlternate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationIDAlternate", (wchar_t**)&a->ns2__CCCreditService::reconciliationIDAlternate, "xsd:string"))
				{	soap_flag_reconciliationIDAlternate1--;
					continue;
				}
			if (soap_flag_refundReason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:refundReason", (wchar_t**)&a->ns2__CCCreditService::refundReason, "xsd:string"))
				{	soap_flag_refundReason1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CCCreditService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CCCreditService, SOAP_TYPE_ns2__CCCreditService, sizeof(ns2__CCCreditService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CCCreditService * SOAP_FMAC2 soap_instantiate_ns2__CCCreditService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CCCreditService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CCCreditService *p;
	size_t k = sizeof(ns2__CCCreditService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CCCreditService);
		if (p)
			((ns2__CCCreditService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CCCreditService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CCCreditService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CCCreditService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CCCreditService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CCCreditService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CCCreditService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CCCreditService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CCCreditService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CCCreditService * SOAP_FMAC4 soap_get_ns2__CCCreditService(struct soap *soap, ns2__CCCreditService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CCCreditService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CCCaptureService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CCCaptureService::authType = NULL;
	this->ns2__CCCaptureService::verbalAuthCode = NULL;
	this->ns2__CCCaptureService::authRequestID = NULL;
	this->ns2__CCCaptureService::reconciliationID = NULL;
	this->ns2__CCCaptureService::partialPaymentID = NULL;
	this->ns2__CCCaptureService::purchasingLevel = NULL;
	this->ns2__CCCaptureService::industryDatatype = NULL;
	this->ns2__CCCaptureService::authRequestToken = NULL;
	this->ns2__CCCaptureService::merchantReceiptNumber = NULL;
	this->ns2__CCCaptureService::posData = NULL;
	this->ns2__CCCaptureService::transactionID = NULL;
	this->ns2__CCCaptureService::checksumKey = NULL;
	this->ns2__CCCaptureService::gratuityAmount = NULL;
	this->ns2__CCCaptureService::duration = NULL;
	this->ns2__CCCaptureService::dpdeBillingMonth = NULL;
	this->ns2__CCCaptureService::sequence = NULL;
	this->ns2__CCCaptureService::totalCount = NULL;
	this->ns2__CCCaptureService::reconciliationIDAlternate = NULL;
	this->ns2__CCCaptureService::aggregatorID = NULL;
	this->ns2__CCCaptureService::aggregatorName = NULL;
	this->ns2__CCCaptureService::run = NULL;
	/* transient soap skipped */
}

void ns2__CCCaptureService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureService::authType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureService::verbalAuthCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureService::authRequestID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureService::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureService::partialPaymentID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureService::purchasingLevel);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureService::industryDatatype);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureService::authRequestToken);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureService::merchantReceiptNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureService::posData);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureService::transactionID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureService::checksumKey);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureService::gratuityAmount);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__CCCaptureService::duration);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__CCCaptureService::dpdeBillingMonth);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureService::sequence);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureService::totalCount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureService::reconciliationIDAlternate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureService::aggregatorID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCCaptureService::aggregatorName);
#endif
}

int ns2__CCCaptureService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CCCaptureService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CCCaptureService(struct soap *soap, const char *tag, int id, const ns2__CCCaptureService *a, const char *type)
{
	if (((ns2__CCCaptureService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__CCCaptureService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CCCaptureService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authType", -1, (wchar_t*const*)&a->ns2__CCCaptureService::authType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:verbalAuthCode", -1, (wchar_t*const*)&a->ns2__CCCaptureService::verbalAuthCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authRequestID", -1, (wchar_t*const*)&a->ns2__CCCaptureService::authRequestID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__CCCaptureService::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:partialPaymentID", -1, (wchar_t*const*)&a->ns2__CCCaptureService::partialPaymentID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:purchasingLevel", -1, (wchar_t*const*)&a->ns2__CCCaptureService::purchasingLevel, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:industryDatatype", -1, (wchar_t*const*)&a->ns2__CCCaptureService::industryDatatype, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authRequestToken", -1, (wchar_t*const*)&a->ns2__CCCaptureService::authRequestToken, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:merchantReceiptNumber", -1, (wchar_t*const*)&a->ns2__CCCaptureService::merchantReceiptNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:posData", -1, (wchar_t*const*)&a->ns2__CCCaptureService::posData, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:transactionID", -1, (wchar_t*const*)&a->ns2__CCCaptureService::transactionID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:checksumKey", -1, (wchar_t*const*)&a->ns2__CCCaptureService::checksumKey, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:gratuityAmount", -1, (wchar_t*const*)&a->ns2__CCCaptureService::gratuityAmount, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:duration", -1, &a->ns2__CCCaptureService::duration, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:dpdeBillingMonth", -1, &a->ns2__CCCaptureService::dpdeBillingMonth, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sequence", -1, (wchar_t*const*)&a->ns2__CCCaptureService::sequence, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:totalCount", -1, (wchar_t*const*)&a->ns2__CCCaptureService::totalCount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationIDAlternate", -1, (wchar_t*const*)&a->ns2__CCCaptureService::reconciliationIDAlternate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:aggregatorID", -1, (wchar_t*const*)&a->ns2__CCCaptureService::aggregatorID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:aggregatorName", -1, (wchar_t*const*)&a->ns2__CCCaptureService::aggregatorName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CCCaptureService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CCCaptureService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CCCaptureService * SOAP_FMAC4 soap_in_ns2__CCCaptureService(struct soap *soap, const char *tag, ns2__CCCaptureService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CCCaptureService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CCCaptureService, sizeof(ns2__CCCaptureService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CCCaptureService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CCCaptureService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__CCCaptureService*)a)->run))
		return NULL;
	size_t soap_flag_authType1 = 1;
	size_t soap_flag_verbalAuthCode1 = 1;
	size_t soap_flag_authRequestID1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_partialPaymentID1 = 1;
	size_t soap_flag_purchasingLevel1 = 1;
	size_t soap_flag_industryDatatype1 = 1;
	size_t soap_flag_authRequestToken1 = 1;
	size_t soap_flag_merchantReceiptNumber1 = 1;
	size_t soap_flag_posData1 = 1;
	size_t soap_flag_transactionID1 = 1;
	size_t soap_flag_checksumKey1 = 1;
	size_t soap_flag_gratuityAmount1 = 1;
	size_t soap_flag_duration1 = 1;
	size_t soap_flag_dpdeBillingMonth1 = 1;
	size_t soap_flag_sequence1 = 1;
	size_t soap_flag_totalCount1 = 1;
	size_t soap_flag_reconciliationIDAlternate1 = 1;
	size_t soap_flag_aggregatorID1 = 1;
	size_t soap_flag_aggregatorName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authType", (wchar_t**)&a->ns2__CCCaptureService::authType, "xsd:string"))
				{	soap_flag_authType1--;
					continue;
				}
			if (soap_flag_verbalAuthCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:verbalAuthCode", (wchar_t**)&a->ns2__CCCaptureService::verbalAuthCode, "xsd:string"))
				{	soap_flag_verbalAuthCode1--;
					continue;
				}
			if (soap_flag_authRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authRequestID", (wchar_t**)&a->ns2__CCCaptureService::authRequestID, "xsd:string"))
				{	soap_flag_authRequestID1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__CCCaptureService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_partialPaymentID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:partialPaymentID", (wchar_t**)&a->ns2__CCCaptureService::partialPaymentID, "xsd:string"))
				{	soap_flag_partialPaymentID1--;
					continue;
				}
			if (soap_flag_purchasingLevel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:purchasingLevel", (wchar_t**)&a->ns2__CCCaptureService::purchasingLevel, "xsd:string"))
				{	soap_flag_purchasingLevel1--;
					continue;
				}
			if (soap_flag_industryDatatype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:industryDatatype", (wchar_t**)&a->ns2__CCCaptureService::industryDatatype, "xsd:string"))
				{	soap_flag_industryDatatype1--;
					continue;
				}
			if (soap_flag_authRequestToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authRequestToken", (wchar_t**)&a->ns2__CCCaptureService::authRequestToken, "xsd:string"))
				{	soap_flag_authRequestToken1--;
					continue;
				}
			if (soap_flag_merchantReceiptNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:merchantReceiptNumber", (wchar_t**)&a->ns2__CCCaptureService::merchantReceiptNumber, "xsd:string"))
				{	soap_flag_merchantReceiptNumber1--;
					continue;
				}
			if (soap_flag_posData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:posData", (wchar_t**)&a->ns2__CCCaptureService::posData, "xsd:string"))
				{	soap_flag_posData1--;
					continue;
				}
			if (soap_flag_transactionID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:transactionID", (wchar_t**)&a->ns2__CCCaptureService::transactionID, "xsd:string"))
				{	soap_flag_transactionID1--;
					continue;
				}
			if (soap_flag_checksumKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:checksumKey", (wchar_t**)&a->ns2__CCCaptureService::checksumKey, "xsd:string"))
				{	soap_flag_checksumKey1--;
					continue;
				}
			if (soap_flag_gratuityAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:gratuityAmount", (wchar_t**)&a->ns2__CCCaptureService::gratuityAmount, "xsd:string"))
				{	soap_flag_gratuityAmount1--;
					continue;
				}
			if (soap_flag_duration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:duration", &a->ns2__CCCaptureService::duration, "xsd:integer"))
				{	soap_flag_duration1--;
					continue;
				}
			if (soap_flag_dpdeBillingMonth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:dpdeBillingMonth", &a->ns2__CCCaptureService::dpdeBillingMonth, "xsd:integer"))
				{	soap_flag_dpdeBillingMonth1--;
					continue;
				}
			if (soap_flag_sequence1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sequence", (wchar_t**)&a->ns2__CCCaptureService::sequence, "xsd:string"))
				{	soap_flag_sequence1--;
					continue;
				}
			if (soap_flag_totalCount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:totalCount", (wchar_t**)&a->ns2__CCCaptureService::totalCount, "xsd:string"))
				{	soap_flag_totalCount1--;
					continue;
				}
			if (soap_flag_reconciliationIDAlternate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationIDAlternate", (wchar_t**)&a->ns2__CCCaptureService::reconciliationIDAlternate, "xsd:string"))
				{	soap_flag_reconciliationIDAlternate1--;
					continue;
				}
			if (soap_flag_aggregatorID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:aggregatorID", (wchar_t**)&a->ns2__CCCaptureService::aggregatorID, "xsd:string"))
				{	soap_flag_aggregatorID1--;
					continue;
				}
			if (soap_flag_aggregatorName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:aggregatorName", (wchar_t**)&a->ns2__CCCaptureService::aggregatorName, "xsd:string"))
				{	soap_flag_aggregatorName1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CCCaptureService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CCCaptureService, SOAP_TYPE_ns2__CCCaptureService, sizeof(ns2__CCCaptureService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CCCaptureService * SOAP_FMAC2 soap_instantiate_ns2__CCCaptureService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CCCaptureService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CCCaptureService *p;
	size_t k = sizeof(ns2__CCCaptureService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CCCaptureService);
		if (p)
			((ns2__CCCaptureService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CCCaptureService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CCCaptureService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CCCaptureService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CCCaptureService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CCCaptureService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CCCaptureService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CCCaptureService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CCCaptureService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CCCaptureService * SOAP_FMAC4 soap_get_ns2__CCCaptureService(struct soap *soap, ns2__CCCaptureService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CCCaptureService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CCIncrementalAuthService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CCIncrementalAuthService::authRequestID = NULL;
	this->ns2__CCIncrementalAuthService::duration = NULL;
	this->ns2__CCIncrementalAuthService::run = NULL;
	/* transient soap skipped */
}

void ns2__CCIncrementalAuthService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCIncrementalAuthService::authRequestID);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__CCIncrementalAuthService::duration);
#endif
}

int ns2__CCIncrementalAuthService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CCIncrementalAuthService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CCIncrementalAuthService(struct soap *soap, const char *tag, int id, const ns2__CCIncrementalAuthService *a, const char *type)
{
	if (((ns2__CCIncrementalAuthService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__CCIncrementalAuthService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CCIncrementalAuthService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authRequestID", -1, (wchar_t*const*)&a->ns2__CCIncrementalAuthService::authRequestID, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:duration", -1, &a->ns2__CCIncrementalAuthService::duration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CCIncrementalAuthService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CCIncrementalAuthService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CCIncrementalAuthService * SOAP_FMAC4 soap_in_ns2__CCIncrementalAuthService(struct soap *soap, const char *tag, ns2__CCIncrementalAuthService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CCIncrementalAuthService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CCIncrementalAuthService, sizeof(ns2__CCIncrementalAuthService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CCIncrementalAuthService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CCIncrementalAuthService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__CCIncrementalAuthService*)a)->run))
		return NULL;
	size_t soap_flag_authRequestID1 = 1;
	size_t soap_flag_duration1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authRequestID", (wchar_t**)&a->ns2__CCIncrementalAuthService::authRequestID, "xsd:string"))
				{	soap_flag_authRequestID1--;
					continue;
				}
			if (soap_flag_duration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:duration", &a->ns2__CCIncrementalAuthService::duration, "xsd:integer"))
				{	soap_flag_duration1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CCIncrementalAuthService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CCIncrementalAuthService, SOAP_TYPE_ns2__CCIncrementalAuthService, sizeof(ns2__CCIncrementalAuthService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CCIncrementalAuthService * SOAP_FMAC2 soap_instantiate_ns2__CCIncrementalAuthService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CCIncrementalAuthService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CCIncrementalAuthService *p;
	size_t k = sizeof(ns2__CCIncrementalAuthService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CCIncrementalAuthService);
		if (p)
			((ns2__CCIncrementalAuthService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CCIncrementalAuthService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CCIncrementalAuthService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CCIncrementalAuthService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CCIncrementalAuthService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CCIncrementalAuthService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CCIncrementalAuthService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CCIncrementalAuthService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CCIncrementalAuthService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CCIncrementalAuthService * SOAP_FMAC4 soap_get_ns2__CCIncrementalAuthService(struct soap *soap, ns2__CCIncrementalAuthService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CCIncrementalAuthService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CCSaleReversalService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CCSaleReversalService::saleRequestID = NULL;
	this->ns2__CCSaleReversalService::run = NULL;
	/* transient soap skipped */
}

void ns2__CCSaleReversalService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleReversalService::saleRequestID);
#endif
}

int ns2__CCSaleReversalService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CCSaleReversalService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CCSaleReversalService(struct soap *soap, const char *tag, int id, const ns2__CCSaleReversalService *a, const char *type)
{
	if (((ns2__CCSaleReversalService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__CCSaleReversalService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CCSaleReversalService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:saleRequestID", -1, (wchar_t*const*)&a->ns2__CCSaleReversalService::saleRequestID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CCSaleReversalService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CCSaleReversalService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CCSaleReversalService * SOAP_FMAC4 soap_in_ns2__CCSaleReversalService(struct soap *soap, const char *tag, ns2__CCSaleReversalService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CCSaleReversalService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CCSaleReversalService, sizeof(ns2__CCSaleReversalService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CCSaleReversalService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CCSaleReversalService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__CCSaleReversalService*)a)->run))
		return NULL;
	size_t soap_flag_saleRequestID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saleRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:saleRequestID", (wchar_t**)&a->ns2__CCSaleReversalService::saleRequestID, "xsd:string"))
				{	soap_flag_saleRequestID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CCSaleReversalService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CCSaleReversalService, SOAP_TYPE_ns2__CCSaleReversalService, sizeof(ns2__CCSaleReversalService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CCSaleReversalService * SOAP_FMAC2 soap_instantiate_ns2__CCSaleReversalService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CCSaleReversalService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CCSaleReversalService *p;
	size_t k = sizeof(ns2__CCSaleReversalService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CCSaleReversalService);
		if (p)
			((ns2__CCSaleReversalService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CCSaleReversalService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CCSaleReversalService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CCSaleReversalService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CCSaleReversalService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CCSaleReversalService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CCSaleReversalService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CCSaleReversalService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CCSaleReversalService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CCSaleReversalService * SOAP_FMAC4 soap_get_ns2__CCSaleReversalService(struct soap *soap, ns2__CCSaleReversalService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CCSaleReversalService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CCSaleCreditService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CCSaleCreditService::overridePaymentMethod = NULL;
	this->ns2__CCSaleCreditService::commerceIndicator = NULL;
	this->ns2__CCSaleCreditService::reconciliationID = NULL;
	this->ns2__CCSaleCreditService::refundReason = NULL;
	this->ns2__CCSaleCreditService::saleRequestID = NULL;
	this->ns2__CCSaleCreditService::run = NULL;
	/* transient soap skipped */
}

void ns2__CCSaleCreditService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleCreditService::overridePaymentMethod);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleCreditService::commerceIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleCreditService::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleCreditService::refundReason);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleCreditService::saleRequestID);
#endif
}

int ns2__CCSaleCreditService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CCSaleCreditService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CCSaleCreditService(struct soap *soap, const char *tag, int id, const ns2__CCSaleCreditService *a, const char *type)
{
	if (((ns2__CCSaleCreditService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__CCSaleCreditService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CCSaleCreditService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:overridePaymentMethod", -1, (wchar_t*const*)&a->ns2__CCSaleCreditService::overridePaymentMethod, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:commerceIndicator", -1, (wchar_t*const*)&a->ns2__CCSaleCreditService::commerceIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__CCSaleCreditService::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:refundReason", -1, (wchar_t*const*)&a->ns2__CCSaleCreditService::refundReason, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:saleRequestID", -1, (wchar_t*const*)&a->ns2__CCSaleCreditService::saleRequestID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CCSaleCreditService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CCSaleCreditService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CCSaleCreditService * SOAP_FMAC4 soap_in_ns2__CCSaleCreditService(struct soap *soap, const char *tag, ns2__CCSaleCreditService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CCSaleCreditService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CCSaleCreditService, sizeof(ns2__CCSaleCreditService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CCSaleCreditService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CCSaleCreditService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__CCSaleCreditService*)a)->run))
		return NULL;
	size_t soap_flag_overridePaymentMethod1 = 1;
	size_t soap_flag_commerceIndicator1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_refundReason1 = 1;
	size_t soap_flag_saleRequestID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_overridePaymentMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:overridePaymentMethod", (wchar_t**)&a->ns2__CCSaleCreditService::overridePaymentMethod, "xsd:string"))
				{	soap_flag_overridePaymentMethod1--;
					continue;
				}
			if (soap_flag_commerceIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:commerceIndicator", (wchar_t**)&a->ns2__CCSaleCreditService::commerceIndicator, "xsd:string"))
				{	soap_flag_commerceIndicator1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__CCSaleCreditService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_refundReason1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:refundReason", (wchar_t**)&a->ns2__CCSaleCreditService::refundReason, "xsd:string"))
				{	soap_flag_refundReason1--;
					continue;
				}
			if (soap_flag_saleRequestID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:saleRequestID", (wchar_t**)&a->ns2__CCSaleCreditService::saleRequestID, "xsd:string"))
				{	soap_flag_saleRequestID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CCSaleCreditService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CCSaleCreditService, SOAP_TYPE_ns2__CCSaleCreditService, sizeof(ns2__CCSaleCreditService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CCSaleCreditService * SOAP_FMAC2 soap_instantiate_ns2__CCSaleCreditService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CCSaleCreditService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CCSaleCreditService *p;
	size_t k = sizeof(ns2__CCSaleCreditService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CCSaleCreditService);
		if (p)
			((ns2__CCSaleCreditService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CCSaleCreditService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CCSaleCreditService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CCSaleCreditService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CCSaleCreditService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CCSaleCreditService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CCSaleCreditService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CCSaleCreditService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CCSaleCreditService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CCSaleCreditService * SOAP_FMAC4 soap_get_ns2__CCSaleCreditService(struct soap *soap, ns2__CCSaleCreditService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CCSaleCreditService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CCSaleService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CCSaleService::overridePaymentMethod = NULL;
	this->ns2__CCSaleService::commerceIndicator = NULL;
	this->ns2__CCSaleService::partialAuthIndicator = NULL;
	this->ns2__CCSaleService::cavv = NULL;
	this->ns2__CCSaleService::xid = NULL;
	this->ns2__CCSaleService::reconciliationID = NULL;
	this->ns2__CCSaleService::industryDatatype = NULL;
	this->ns2__CCSaleService::run = NULL;
	/* transient soap skipped */
}

void ns2__CCSaleService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleService::overridePaymentMethod);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleService::commerceIndicator);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__CCSaleService::partialAuthIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleService::cavv);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleService::xid);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleService::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCSaleService::industryDatatype);
#endif
}

int ns2__CCSaleService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CCSaleService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CCSaleService(struct soap *soap, const char *tag, int id, const ns2__CCSaleService *a, const char *type)
{
	if (((ns2__CCSaleService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__CCSaleService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CCSaleService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:overridePaymentMethod", -1, (wchar_t*const*)&a->ns2__CCSaleService::overridePaymentMethod, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:commerceIndicator", -1, (wchar_t*const*)&a->ns2__CCSaleService::commerceIndicator, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:partialAuthIndicator", -1, &a->ns2__CCSaleService::partialAuthIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cavv", -1, (wchar_t*const*)&a->ns2__CCSaleService::cavv, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:xid", -1, (wchar_t*const*)&a->ns2__CCSaleService::xid, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__CCSaleService::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:industryDatatype", -1, (wchar_t*const*)&a->ns2__CCSaleService::industryDatatype, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CCSaleService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CCSaleService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CCSaleService * SOAP_FMAC4 soap_in_ns2__CCSaleService(struct soap *soap, const char *tag, ns2__CCSaleService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CCSaleService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CCSaleService, sizeof(ns2__CCSaleService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CCSaleService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CCSaleService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__CCSaleService*)a)->run))
		return NULL;
	size_t soap_flag_overridePaymentMethod1 = 1;
	size_t soap_flag_commerceIndicator1 = 1;
	size_t soap_flag_partialAuthIndicator1 = 1;
	size_t soap_flag_cavv1 = 1;
	size_t soap_flag_xid1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_industryDatatype1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_overridePaymentMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:overridePaymentMethod", (wchar_t**)&a->ns2__CCSaleService::overridePaymentMethod, "xsd:string"))
				{	soap_flag_overridePaymentMethod1--;
					continue;
				}
			if (soap_flag_commerceIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:commerceIndicator", (wchar_t**)&a->ns2__CCSaleService::commerceIndicator, "xsd:string"))
				{	soap_flag_commerceIndicator1--;
					continue;
				}
			if (soap_flag_partialAuthIndicator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:partialAuthIndicator", &a->ns2__CCSaleService::partialAuthIndicator, "ns2:boolean"))
				{	soap_flag_partialAuthIndicator1--;
					continue;
				}
			if (soap_flag_cavv1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cavv", (wchar_t**)&a->ns2__CCSaleService::cavv, "xsd:string"))
				{	soap_flag_cavv1--;
					continue;
				}
			if (soap_flag_xid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:xid", (wchar_t**)&a->ns2__CCSaleService::xid, "xsd:string"))
				{	soap_flag_xid1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__CCSaleService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_industryDatatype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:industryDatatype", (wchar_t**)&a->ns2__CCSaleService::industryDatatype, "xsd:string"))
				{	soap_flag_industryDatatype1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CCSaleService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CCSaleService, SOAP_TYPE_ns2__CCSaleService, sizeof(ns2__CCSaleService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CCSaleService * SOAP_FMAC2 soap_instantiate_ns2__CCSaleService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CCSaleService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CCSaleService *p;
	size_t k = sizeof(ns2__CCSaleService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CCSaleService);
		if (p)
			((ns2__CCSaleService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CCSaleService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CCSaleService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CCSaleService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CCSaleService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CCSaleService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CCSaleService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CCSaleService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CCSaleService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CCSaleService * SOAP_FMAC4 soap_get_ns2__CCSaleService(struct soap *soap, ns2__CCSaleService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CCSaleService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__VerificationService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__VerificationService::reconciliationID = NULL;
	this->ns2__VerificationService::run = NULL;
	/* transient soap skipped */
}

void ns2__VerificationService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__VerificationService::reconciliationID);
#endif
}

int ns2__VerificationService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__VerificationService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__VerificationService(struct soap *soap, const char *tag, int id, const ns2__VerificationService *a, const char *type)
{
	if (((ns2__VerificationService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__VerificationService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__VerificationService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__VerificationService::reconciliationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__VerificationService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__VerificationService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__VerificationService * SOAP_FMAC4 soap_in_ns2__VerificationService(struct soap *soap, const char *tag, ns2__VerificationService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__VerificationService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__VerificationService, sizeof(ns2__VerificationService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__VerificationService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__VerificationService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__VerificationService*)a)->run))
		return NULL;
	size_t soap_flag_reconciliationID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__VerificationService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__VerificationService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__VerificationService, SOAP_TYPE_ns2__VerificationService, sizeof(ns2__VerificationService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__VerificationService * SOAP_FMAC2 soap_instantiate_ns2__VerificationService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__VerificationService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__VerificationService *p;
	size_t k = sizeof(ns2__VerificationService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__VerificationService);
		if (p)
			((ns2__VerificationService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__VerificationService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__VerificationService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__VerificationService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__VerificationService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__VerificationService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:VerificationService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__VerificationService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__VerificationService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__VerificationService * SOAP_FMAC4 soap_get_ns2__VerificationService(struct soap *soap, ns2__VerificationService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__VerificationService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__OCTService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__OCTService::commerceIndicator = NULL;
	this->ns2__OCTService::reconciliationID = NULL;
	this->ns2__OCTService::networkOrder = NULL;
	this->ns2__OCTService::run = NULL;
	/* transient soap skipped */
}

void ns2__OCTService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__OCTService::commerceIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__OCTService::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__OCTService::networkOrder);
#endif
}

int ns2__OCTService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__OCTService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OCTService(struct soap *soap, const char *tag, int id, const ns2__OCTService *a, const char *type)
{
	if (((ns2__OCTService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__OCTService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OCTService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:commerceIndicator", -1, (wchar_t*const*)&a->ns2__OCTService::commerceIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__OCTService::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:networkOrder", -1, (wchar_t*const*)&a->ns2__OCTService::networkOrder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__OCTService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__OCTService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__OCTService * SOAP_FMAC4 soap_in_ns2__OCTService(struct soap *soap, const char *tag, ns2__OCTService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__OCTService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OCTService, sizeof(ns2__OCTService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__OCTService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__OCTService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__OCTService*)a)->run))
		return NULL;
	size_t soap_flag_commerceIndicator1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_networkOrder1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_commerceIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:commerceIndicator", (wchar_t**)&a->ns2__OCTService::commerceIndicator, "xsd:string"))
				{	soap_flag_commerceIndicator1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__OCTService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_networkOrder1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:networkOrder", (wchar_t**)&a->ns2__OCTService::networkOrder, "xsd:string"))
				{	soap_flag_networkOrder1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__OCTService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OCTService, SOAP_TYPE_ns2__OCTService, sizeof(ns2__OCTService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__OCTService * SOAP_FMAC2 soap_instantiate_ns2__OCTService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__OCTService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__OCTService *p;
	size_t k = sizeof(ns2__OCTService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__OCTService);
		if (p)
			((ns2__OCTService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__OCTService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__OCTService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__OCTService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__OCTService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__OCTService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:OCTService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__OCTService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__OCTService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__OCTService * SOAP_FMAC4 soap_get_ns2__OCTService(struct soap *soap, ns2__OCTService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OCTService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__CCAuthService::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__CCAuthService::cavv = NULL;
	this->ns2__CCAuthService::cavvAlgorithm = NULL;
	this->ns2__CCAuthService::commerceIndicator = NULL;
	this->ns2__CCAuthService::eciRaw = NULL;
	this->ns2__CCAuthService::xid = NULL;
	this->ns2__CCAuthService::reconciliationID = NULL;
	this->ns2__CCAuthService::avsLevel = NULL;
	this->ns2__CCAuthService::fxQuoteID = NULL;
	this->ns2__CCAuthService::returnAuthRecord = NULL;
	this->ns2__CCAuthService::authType = NULL;
	this->ns2__CCAuthService::verbalAuthCode = NULL;
	this->ns2__CCAuthService::billPayment = NULL;
	this->ns2__CCAuthService::authenticationXID = NULL;
	this->ns2__CCAuthService::authorizationXID = NULL;
	this->ns2__CCAuthService::industryDatatype = NULL;
	this->ns2__CCAuthService::traceNumber = NULL;
	this->ns2__CCAuthService::checksumKey = NULL;
	this->ns2__CCAuthService::aggregatorID = NULL;
	this->ns2__CCAuthService::aggregatorName = NULL;
	this->ns2__CCAuthService::splitTenderIndicator = NULL;
	this->ns2__CCAuthService::veresEnrolled = NULL;
	this->ns2__CCAuthService::paresStatus = NULL;
	this->ns2__CCAuthService::partialAuthIndicator = NULL;
	this->ns2__CCAuthService::captureDate = NULL;
	this->ns2__CCAuthService::firstRecurringPayment = NULL;
	this->ns2__CCAuthService::duration = NULL;
	this->ns2__CCAuthService::overridePaymentMethod = NULL;
	this->ns2__CCAuthService::mobileRemotePaymentType = NULL;
	this->ns2__CCAuthService::cardholderVerificationMethod = NULL;
	this->ns2__CCAuthService::run = NULL;
	/* transient soap skipped */
}

void ns2__CCAuthService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::cavv);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::cavvAlgorithm);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::commerceIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::eciRaw);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::xid);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::reconciliationID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::avsLevel);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::fxQuoteID);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__CCAuthService::returnAuthRecord);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::authType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::verbalAuthCode);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__CCAuthService::billPayment);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::authenticationXID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::authorizationXID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::industryDatatype);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::traceNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::checksumKey);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::aggregatorID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::aggregatorName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::splitTenderIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::veresEnrolled);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::paresStatus);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__CCAuthService::partialAuthIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::captureDate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::firstRecurringPayment);
	soap_serialize_PointerToxsd__integer(soap, &this->ns2__CCAuthService::duration);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::overridePaymentMethod);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::mobileRemotePaymentType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__CCAuthService::cardholderVerificationMethod);
#endif
}

int ns2__CCAuthService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CCAuthService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CCAuthService(struct soap *soap, const char *tag, int id, const ns2__CCAuthService *a, const char *type)
{
	if (((ns2__CCAuthService*)a)->run)
		soap_set_attr(soap, "run", soap_ns2__boolean2s(soap, ((ns2__CCAuthService*)a)->run), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CCAuthService), type))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cavv", -1, (wchar_t*const*)&a->ns2__CCAuthService::cavv, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cavvAlgorithm", -1, (wchar_t*const*)&a->ns2__CCAuthService::cavvAlgorithm, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:commerceIndicator", -1, (wchar_t*const*)&a->ns2__CCAuthService::commerceIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:eciRaw", -1, (wchar_t*const*)&a->ns2__CCAuthService::eciRaw, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:xid", -1, (wchar_t*const*)&a->ns2__CCAuthService::xid, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:reconciliationID", -1, (wchar_t*const*)&a->ns2__CCAuthService::reconciliationID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:avsLevel", -1, (wchar_t*const*)&a->ns2__CCAuthService::avsLevel, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:fxQuoteID", -1, (wchar_t*const*)&a->ns2__CCAuthService::fxQuoteID, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:returnAuthRecord", -1, &a->ns2__CCAuthService::returnAuthRecord, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authType", -1, (wchar_t*const*)&a->ns2__CCAuthService::authType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:verbalAuthCode", -1, (wchar_t*const*)&a->ns2__CCAuthService::verbalAuthCode, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:billPayment", -1, &a->ns2__CCAuthService::billPayment, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authenticationXID", -1, (wchar_t*const*)&a->ns2__CCAuthService::authenticationXID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:authorizationXID", -1, (wchar_t*const*)&a->ns2__CCAuthService::authorizationXID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:industryDatatype", -1, (wchar_t*const*)&a->ns2__CCAuthService::industryDatatype, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:traceNumber", -1, (wchar_t*const*)&a->ns2__CCAuthService::traceNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:checksumKey", -1, (wchar_t*const*)&a->ns2__CCAuthService::checksumKey, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:aggregatorID", -1, (wchar_t*const*)&a->ns2__CCAuthService::aggregatorID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:aggregatorName", -1, (wchar_t*const*)&a->ns2__CCAuthService::aggregatorName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:splitTenderIndicator", -1, (wchar_t*const*)&a->ns2__CCAuthService::splitTenderIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:veresEnrolled", -1, (wchar_t*const*)&a->ns2__CCAuthService::veresEnrolled, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:paresStatus", -1, (wchar_t*const*)&a->ns2__CCAuthService::paresStatus, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:partialAuthIndicator", -1, &a->ns2__CCAuthService::partialAuthIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:captureDate", -1, (wchar_t*const*)&a->ns2__CCAuthService::captureDate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:firstRecurringPayment", -1, (wchar_t*const*)&a->ns2__CCAuthService::firstRecurringPayment, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "ns2:duration", -1, &a->ns2__CCAuthService::duration, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:overridePaymentMethod", -1, (wchar_t*const*)&a->ns2__CCAuthService::overridePaymentMethod, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:mobileRemotePaymentType", -1, (wchar_t*const*)&a->ns2__CCAuthService::mobileRemotePaymentType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:cardholderVerificationMethod", -1, (wchar_t*const*)&a->ns2__CCAuthService::cardholderVerificationMethod, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CCAuthService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CCAuthService(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CCAuthService * SOAP_FMAC4 soap_in_ns2__CCAuthService(struct soap *soap, const char *tag, ns2__CCAuthService *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CCAuthService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CCAuthService, sizeof(ns2__CCAuthService), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__CCAuthService)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__CCAuthService *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2ns2__boolean(soap, soap_attr_value(soap, "run", 1), &((ns2__CCAuthService*)a)->run))
		return NULL;
	size_t soap_flag_cavv1 = 1;
	size_t soap_flag_cavvAlgorithm1 = 1;
	size_t soap_flag_commerceIndicator1 = 1;
	size_t soap_flag_eciRaw1 = 1;
	size_t soap_flag_xid1 = 1;
	size_t soap_flag_reconciliationID1 = 1;
	size_t soap_flag_avsLevel1 = 1;
	size_t soap_flag_fxQuoteID1 = 1;
	size_t soap_flag_returnAuthRecord1 = 1;
	size_t soap_flag_authType1 = 1;
	size_t soap_flag_verbalAuthCode1 = 1;
	size_t soap_flag_billPayment1 = 1;
	size_t soap_flag_authenticationXID1 = 1;
	size_t soap_flag_authorizationXID1 = 1;
	size_t soap_flag_industryDatatype1 = 1;
	size_t soap_flag_traceNumber1 = 1;
	size_t soap_flag_checksumKey1 = 1;
	size_t soap_flag_aggregatorID1 = 1;
	size_t soap_flag_aggregatorName1 = 1;
	size_t soap_flag_splitTenderIndicator1 = 1;
	size_t soap_flag_veresEnrolled1 = 1;
	size_t soap_flag_paresStatus1 = 1;
	size_t soap_flag_partialAuthIndicator1 = 1;
	size_t soap_flag_captureDate1 = 1;
	size_t soap_flag_firstRecurringPayment1 = 1;
	size_t soap_flag_duration1 = 1;
	size_t soap_flag_overridePaymentMethod1 = 1;
	size_t soap_flag_mobileRemotePaymentType1 = 1;
	size_t soap_flag_cardholderVerificationMethod1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cavv1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cavv", (wchar_t**)&a->ns2__CCAuthService::cavv, "xsd:string"))
				{	soap_flag_cavv1--;
					continue;
				}
			if (soap_flag_cavvAlgorithm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cavvAlgorithm", (wchar_t**)&a->ns2__CCAuthService::cavvAlgorithm, "xsd:string"))
				{	soap_flag_cavvAlgorithm1--;
					continue;
				}
			if (soap_flag_commerceIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:commerceIndicator", (wchar_t**)&a->ns2__CCAuthService::commerceIndicator, "xsd:string"))
				{	soap_flag_commerceIndicator1--;
					continue;
				}
			if (soap_flag_eciRaw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:eciRaw", (wchar_t**)&a->ns2__CCAuthService::eciRaw, "xsd:string"))
				{	soap_flag_eciRaw1--;
					continue;
				}
			if (soap_flag_xid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:xid", (wchar_t**)&a->ns2__CCAuthService::xid, "xsd:string"))
				{	soap_flag_xid1--;
					continue;
				}
			if (soap_flag_reconciliationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:reconciliationID", (wchar_t**)&a->ns2__CCAuthService::reconciliationID, "xsd:string"))
				{	soap_flag_reconciliationID1--;
					continue;
				}
			if (soap_flag_avsLevel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:avsLevel", (wchar_t**)&a->ns2__CCAuthService::avsLevel, "xsd:string"))
				{	soap_flag_avsLevel1--;
					continue;
				}
			if (soap_flag_fxQuoteID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:fxQuoteID", (wchar_t**)&a->ns2__CCAuthService::fxQuoteID, "xsd:string"))
				{	soap_flag_fxQuoteID1--;
					continue;
				}
			if (soap_flag_returnAuthRecord1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:returnAuthRecord", &a->ns2__CCAuthService::returnAuthRecord, "ns2:boolean"))
				{	soap_flag_returnAuthRecord1--;
					continue;
				}
			if (soap_flag_authType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authType", (wchar_t**)&a->ns2__CCAuthService::authType, "xsd:string"))
				{	soap_flag_authType1--;
					continue;
				}
			if (soap_flag_verbalAuthCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:verbalAuthCode", (wchar_t**)&a->ns2__CCAuthService::verbalAuthCode, "xsd:string"))
				{	soap_flag_verbalAuthCode1--;
					continue;
				}
			if (soap_flag_billPayment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:billPayment", &a->ns2__CCAuthService::billPayment, "ns2:boolean"))
				{	soap_flag_billPayment1--;
					continue;
				}
			if (soap_flag_authenticationXID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authenticationXID", (wchar_t**)&a->ns2__CCAuthService::authenticationXID, "xsd:string"))
				{	soap_flag_authenticationXID1--;
					continue;
				}
			if (soap_flag_authorizationXID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:authorizationXID", (wchar_t**)&a->ns2__CCAuthService::authorizationXID, "xsd:string"))
				{	soap_flag_authorizationXID1--;
					continue;
				}
			if (soap_flag_industryDatatype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:industryDatatype", (wchar_t**)&a->ns2__CCAuthService::industryDatatype, "xsd:string"))
				{	soap_flag_industryDatatype1--;
					continue;
				}
			if (soap_flag_traceNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:traceNumber", (wchar_t**)&a->ns2__CCAuthService::traceNumber, "xsd:string"))
				{	soap_flag_traceNumber1--;
					continue;
				}
			if (soap_flag_checksumKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:checksumKey", (wchar_t**)&a->ns2__CCAuthService::checksumKey, "xsd:string"))
				{	soap_flag_checksumKey1--;
					continue;
				}
			if (soap_flag_aggregatorID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:aggregatorID", (wchar_t**)&a->ns2__CCAuthService::aggregatorID, "xsd:string"))
				{	soap_flag_aggregatorID1--;
					continue;
				}
			if (soap_flag_aggregatorName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:aggregatorName", (wchar_t**)&a->ns2__CCAuthService::aggregatorName, "xsd:string"))
				{	soap_flag_aggregatorName1--;
					continue;
				}
			if (soap_flag_splitTenderIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:splitTenderIndicator", (wchar_t**)&a->ns2__CCAuthService::splitTenderIndicator, "xsd:string"))
				{	soap_flag_splitTenderIndicator1--;
					continue;
				}
			if (soap_flag_veresEnrolled1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:veresEnrolled", (wchar_t**)&a->ns2__CCAuthService::veresEnrolled, "xsd:string"))
				{	soap_flag_veresEnrolled1--;
					continue;
				}
			if (soap_flag_paresStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:paresStatus", (wchar_t**)&a->ns2__CCAuthService::paresStatus, "xsd:string"))
				{	soap_flag_paresStatus1--;
					continue;
				}
			if (soap_flag_partialAuthIndicator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:partialAuthIndicator", &a->ns2__CCAuthService::partialAuthIndicator, "ns2:boolean"))
				{	soap_flag_partialAuthIndicator1--;
					continue;
				}
			if (soap_flag_captureDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:captureDate", (wchar_t**)&a->ns2__CCAuthService::captureDate, "xsd:string"))
				{	soap_flag_captureDate1--;
					continue;
				}
			if (soap_flag_firstRecurringPayment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:firstRecurringPayment", (wchar_t**)&a->ns2__CCAuthService::firstRecurringPayment, "xsd:string"))
				{	soap_flag_firstRecurringPayment1--;
					continue;
				}
			if (soap_flag_duration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__integer(soap, "ns2:duration", &a->ns2__CCAuthService::duration, "xsd:integer"))
				{	soap_flag_duration1--;
					continue;
				}
			if (soap_flag_overridePaymentMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:overridePaymentMethod", (wchar_t**)&a->ns2__CCAuthService::overridePaymentMethod, "xsd:string"))
				{	soap_flag_overridePaymentMethod1--;
					continue;
				}
			if (soap_flag_mobileRemotePaymentType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:mobileRemotePaymentType", (wchar_t**)&a->ns2__CCAuthService::mobileRemotePaymentType, "xsd:string"))
				{	soap_flag_mobileRemotePaymentType1--;
					continue;
				}
			if (soap_flag_cardholderVerificationMethod1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:cardholderVerificationMethod", (wchar_t**)&a->ns2__CCAuthService::cardholderVerificationMethod, "xsd:string"))
				{	soap_flag_cardholderVerificationMethod1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CCAuthService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CCAuthService, SOAP_TYPE_ns2__CCAuthService, sizeof(ns2__CCAuthService), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__CCAuthService * SOAP_FMAC2 soap_instantiate_ns2__CCAuthService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CCAuthService(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__CCAuthService *p;
	size_t k = sizeof(ns2__CCAuthService);
	if (n < 0)
	{	p = SOAP_NEW(ns2__CCAuthService);
		if (p)
			((ns2__CCAuthService*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__CCAuthService, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__CCAuthService*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__CCAuthService location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__CCAuthService, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__CCAuthService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:CCAuthService", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CCAuthService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CCAuthService(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CCAuthService * SOAP_FMAC4 soap_get_ns2__CCAuthService(struct soap *soap, ns2__CCAuthService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CCAuthService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__Item::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Item::unitPrice = NULL;
	this->ns2__Item::quantity = NULL;
	this->ns2__Item::productCode = NULL;
	this->ns2__Item::productName = NULL;
	this->ns2__Item::productSKU = NULL;
	this->ns2__Item::productRisk = NULL;
	this->ns2__Item::taxAmount = NULL;
	this->ns2__Item::cityOverrideAmount = NULL;
	this->ns2__Item::cityOverrideRate = NULL;
	this->ns2__Item::countyOverrideAmount = NULL;
	this->ns2__Item::countyOverrideRate = NULL;
	this->ns2__Item::districtOverrideAmount = NULL;
	this->ns2__Item::districtOverrideRate = NULL;
	this->ns2__Item::stateOverrideAmount = NULL;
	this->ns2__Item::stateOverrideRate = NULL;
	this->ns2__Item::countryOverrideAmount = NULL;
	this->ns2__Item::countryOverrideRate = NULL;
	this->ns2__Item::orderAcceptanceCity = NULL;
	this->ns2__Item::orderAcceptanceCounty = NULL;
	this->ns2__Item::orderAcceptanceCountry = NULL;
	this->ns2__Item::orderAcceptanceState = NULL;
	this->ns2__Item::orderAcceptancePostalCode = NULL;
	this->ns2__Item::orderOriginCity = NULL;
	this->ns2__Item::orderOriginCounty = NULL;
	this->ns2__Item::orderOriginCountry = NULL;
	this->ns2__Item::orderOriginState = NULL;
	this->ns2__Item::orderOriginPostalCode = NULL;
	this->ns2__Item::shipFromCity = NULL;
	this->ns2__Item::shipFromCounty = NULL;
	this->ns2__Item::shipFromCountry = NULL;
	this->ns2__Item::shipFromState = NULL;
	this->ns2__Item::shipFromPostalCode = NULL;
	this->ns2__Item::export_ = NULL;
	this->ns2__Item::noExport = NULL;
	this->ns2__Item::nationalTax = NULL;
	this->ns2__Item::vatRate = NULL;
	this->ns2__Item::sellerRegistration = NULL;
	this->ns2__Item::sellerRegistration0 = NULL;
	this->ns2__Item::sellerRegistration1 = NULL;
	this->ns2__Item::sellerRegistration2 = NULL;
	this->ns2__Item::sellerRegistration3 = NULL;
	this->ns2__Item::sellerRegistration4 = NULL;
	this->ns2__Item::sellerRegistration5 = NULL;
	this->ns2__Item::sellerRegistration6 = NULL;
	this->ns2__Item::sellerRegistration7 = NULL;
	this->ns2__Item::sellerRegistration8 = NULL;
	this->ns2__Item::sellerRegistration9 = NULL;
	this->ns2__Item::buyerRegistration = NULL;
	this->ns2__Item::middlemanRegistration = NULL;
	this->ns2__Item::pointOfTitleTransfer = NULL;
	this->ns2__Item::giftCategory = NULL;
	this->ns2__Item::timeCategory = NULL;
	this->ns2__Item::hostHedge = NULL;
	this->ns2__Item::timeHedge = NULL;
	this->ns2__Item::velocityHedge = NULL;
	this->ns2__Item::nonsensicalHedge = NULL;
	this->ns2__Item::phoneHedge = NULL;
	this->ns2__Item::obscenitiesHedge = NULL;
	this->ns2__Item::unitOfMeasure = NULL;
	this->ns2__Item::taxRate = NULL;
	this->ns2__Item::totalAmount = NULL;
	this->ns2__Item::discountAmount = NULL;
	this->ns2__Item::discountRate = NULL;
	this->ns2__Item::commodityCode = NULL;
	this->ns2__Item::grossNetIndicator = NULL;
	this->ns2__Item::taxTypeApplied = NULL;
	this->ns2__Item::discountIndicator = NULL;
	this->ns2__Item::alternateTaxID = NULL;
	this->ns2__Item::alternateTaxAmount = NULL;
	this->ns2__Item::alternateTaxTypeApplied = NULL;
	this->ns2__Item::alternateTaxRate = NULL;
	this->ns2__Item::alternateTaxType = NULL;
	this->ns2__Item::localTax = NULL;
	this->ns2__Item::zeroCostToCustomerIndicator = NULL;
	this->ns2__Item::passengerFirstName = NULL;
	this->ns2__Item::passengerLastName = NULL;
	this->ns2__Item::passengerID = NULL;
	this->ns2__Item::passengerStatus = NULL;
	this->ns2__Item::passengerType = NULL;
	this->ns2__Item::passengerEmail = NULL;
	this->ns2__Item::passengerPhone = NULL;
	this->ns2__Item::invoiceNumber = NULL;
	this->ns2__Item::productDescription = NULL;
	this->ns2__Item::taxStatusIndicator = NULL;
	this->ns2__Item::discountManagementIndicator = NULL;
	this->ns2__Item::typeOfSupply = NULL;
	this->ns2__Item::sign = NULL;
	this->ns2__Item::id = NULL;
	/* transient soap skipped */
}

void ns2__Item::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Item::unitPrice);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Item::quantity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::productCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::productName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::productSKU);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::productRisk);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Item::taxAmount);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Item::cityOverrideAmount);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Item::cityOverrideRate);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Item::countyOverrideAmount);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Item::countyOverrideRate);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Item::districtOverrideAmount);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Item::districtOverrideRate);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Item::stateOverrideAmount);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Item::stateOverrideRate);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Item::countryOverrideAmount);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Item::countryOverrideRate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::orderAcceptanceCity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::orderAcceptanceCounty);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::orderAcceptanceCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::orderAcceptanceState);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::orderAcceptancePostalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::orderOriginCity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::orderOriginCounty);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::orderOriginCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::orderOriginState);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::orderOriginPostalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::shipFromCity);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::shipFromCounty);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::shipFromCountry);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::shipFromState);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::shipFromPostalCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::export_);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::noExport);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Item::nationalTax);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Item::vatRate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::sellerRegistration);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::sellerRegistration0);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::sellerRegistration1);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::sellerRegistration2);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::sellerRegistration3);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::sellerRegistration4);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::sellerRegistration5);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::sellerRegistration6);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::sellerRegistration7);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::sellerRegistration8);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::sellerRegistration9);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::buyerRegistration);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::middlemanRegistration);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::pointOfTitleTransfer);
	soap_serialize_PointerTons2__boolean(soap, &this->ns2__Item::giftCategory);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::timeCategory);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::hostHedge);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::timeHedge);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::velocityHedge);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::nonsensicalHedge);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::phoneHedge);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::obscenitiesHedge);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::unitOfMeasure);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Item::taxRate);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Item::totalAmount);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Item::discountAmount);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Item::discountRate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::commodityCode);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::grossNetIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::taxTypeApplied);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::discountIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::alternateTaxID);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Item::alternateTaxAmount);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::alternateTaxTypeApplied);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Item::alternateTaxRate);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::alternateTaxType);
	soap_serialize_PointerTons2__amount(soap, &this->ns2__Item::localTax);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::zeroCostToCustomerIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::passengerFirstName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::passengerLastName);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::passengerID);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::passengerStatus);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::passengerType);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::passengerEmail);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::passengerPhone);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::invoiceNumber);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::productDescription);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::taxStatusIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::discountManagementIndicator);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::typeOfSupply);
	soap_serialize_wstring(soap, (wchar_t*const*)&this->ns2__Item::sign);
#endif
}

int ns2__Item::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Item(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Item(struct soap *soap, const char *tag, int id, const ns2__Item *a, const char *type)
{
	if (((ns2__Item*)a)->id)
		if (*((ns2__Item*)a)->id)
			soap_set_attr(soap, "id", soap_xsd__integer2s(soap, *((ns2__Item*)a)->id), 2);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Item), type))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:unitPrice", -1, &a->ns2__Item::unitPrice, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:quantity", -1, &a->ns2__Item::quantity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:productCode", -1, (wchar_t*const*)&a->ns2__Item::productCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:productName", -1, (wchar_t*const*)&a->ns2__Item::productName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:productSKU", -1, (wchar_t*const*)&a->ns2__Item::productSKU, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:productRisk", -1, (wchar_t*const*)&a->ns2__Item::productRisk, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:taxAmount", -1, &a->ns2__Item::taxAmount, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:cityOverrideAmount", -1, &a->ns2__Item::cityOverrideAmount, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:cityOverrideRate", -1, &a->ns2__Item::cityOverrideRate, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:countyOverrideAmount", -1, &a->ns2__Item::countyOverrideAmount, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:countyOverrideRate", -1, &a->ns2__Item::countyOverrideRate, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:districtOverrideAmount", -1, &a->ns2__Item::districtOverrideAmount, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:districtOverrideRate", -1, &a->ns2__Item::districtOverrideRate, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:stateOverrideAmount", -1, &a->ns2__Item::stateOverrideAmount, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:stateOverrideRate", -1, &a->ns2__Item::stateOverrideRate, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:countryOverrideAmount", -1, &a->ns2__Item::countryOverrideAmount, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:countryOverrideRate", -1, &a->ns2__Item::countryOverrideRate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderAcceptanceCity", -1, (wchar_t*const*)&a->ns2__Item::orderAcceptanceCity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderAcceptanceCounty", -1, (wchar_t*const*)&a->ns2__Item::orderAcceptanceCounty, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderAcceptanceCountry", -1, (wchar_t*const*)&a->ns2__Item::orderAcceptanceCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderAcceptanceState", -1, (wchar_t*const*)&a->ns2__Item::orderAcceptanceState, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderAcceptancePostalCode", -1, (wchar_t*const*)&a->ns2__Item::orderAcceptancePostalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderOriginCity", -1, (wchar_t*const*)&a->ns2__Item::orderOriginCity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderOriginCounty", -1, (wchar_t*const*)&a->ns2__Item::orderOriginCounty, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderOriginCountry", -1, (wchar_t*const*)&a->ns2__Item::orderOriginCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderOriginState", -1, (wchar_t*const*)&a->ns2__Item::orderOriginState, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:orderOriginPostalCode", -1, (wchar_t*const*)&a->ns2__Item::orderOriginPostalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipFromCity", -1, (wchar_t*const*)&a->ns2__Item::shipFromCity, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipFromCounty", -1, (wchar_t*const*)&a->ns2__Item::shipFromCounty, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipFromCountry", -1, (wchar_t*const*)&a->ns2__Item::shipFromCountry, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipFromState", -1, (wchar_t*const*)&a->ns2__Item::shipFromState, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:shipFromPostalCode", -1, (wchar_t*const*)&a->ns2__Item::shipFromPostalCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:export", -1, (wchar_t*const*)&a->ns2__Item::export_, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:noExport", -1, (wchar_t*const*)&a->ns2__Item::noExport, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:nationalTax", -1, &a->ns2__Item::nationalTax, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:vatRate", -1, &a->ns2__Item::vatRate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sellerRegistration", -1, (wchar_t*const*)&a->ns2__Item::sellerRegistration, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sellerRegistration0", -1, (wchar_t*const*)&a->ns2__Item::sellerRegistration0, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sellerRegistration1", -1, (wchar_t*const*)&a->ns2__Item::sellerRegistration1, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sellerRegistration2", -1, (wchar_t*const*)&a->ns2__Item::sellerRegistration2, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sellerRegistration3", -1, (wchar_t*const*)&a->ns2__Item::sellerRegistration3, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sellerRegistration4", -1, (wchar_t*const*)&a->ns2__Item::sellerRegistration4, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sellerRegistration5", -1, (wchar_t*const*)&a->ns2__Item::sellerRegistration5, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sellerRegistration6", -1, (wchar_t*const*)&a->ns2__Item::sellerRegistration6, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sellerRegistration7", -1, (wchar_t*const*)&a->ns2__Item::sellerRegistration7, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sellerRegistration8", -1, (wchar_t*const*)&a->ns2__Item::sellerRegistration8, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sellerRegistration9", -1, (wchar_t*const*)&a->ns2__Item::sellerRegistration9, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:buyerRegistration", -1, (wchar_t*const*)&a->ns2__Item::buyerRegistration, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:middlemanRegistration", -1, (wchar_t*const*)&a->ns2__Item::middlemanRegistration, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:pointOfTitleTransfer", -1, (wchar_t*const*)&a->ns2__Item::pointOfTitleTransfer, ""))
		return soap->error;
	if (soap_out_PointerTons2__boolean(soap, "ns2:giftCategory", -1, &a->ns2__Item::giftCategory, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:timeCategory", -1, (wchar_t*const*)&a->ns2__Item::timeCategory, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:hostHedge", -1, (wchar_t*const*)&a->ns2__Item::hostHedge, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:timeHedge", -1, (wchar_t*const*)&a->ns2__Item::timeHedge, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:velocityHedge", -1, (wchar_t*const*)&a->ns2__Item::velocityHedge, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:nonsensicalHedge", -1, (wchar_t*const*)&a->ns2__Item::nonsensicalHedge, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:phoneHedge", -1, (wchar_t*const*)&a->ns2__Item::phoneHedge, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:obscenitiesHedge", -1, (wchar_t*const*)&a->ns2__Item::obscenitiesHedge, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:unitOfMeasure", -1, (wchar_t*const*)&a->ns2__Item::unitOfMeasure, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:taxRate", -1, &a->ns2__Item::taxRate, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:totalAmount", -1, &a->ns2__Item::totalAmount, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:discountAmount", -1, &a->ns2__Item::discountAmount, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:discountRate", -1, &a->ns2__Item::discountRate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:commodityCode", -1, (wchar_t*const*)&a->ns2__Item::commodityCode, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:grossNetIndicator", -1, (wchar_t*const*)&a->ns2__Item::grossNetIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:taxTypeApplied", -1, (wchar_t*const*)&a->ns2__Item::taxTypeApplied, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:discountIndicator", -1, (wchar_t*const*)&a->ns2__Item::discountIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:alternateTaxID", -1, (wchar_t*const*)&a->ns2__Item::alternateTaxID, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:alternateTaxAmount", -1, &a->ns2__Item::alternateTaxAmount, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:alternateTaxTypeApplied", -1, (wchar_t*const*)&a->ns2__Item::alternateTaxTypeApplied, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:alternateTaxRate", -1, &a->ns2__Item::alternateTaxRate, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:alternateTaxType", -1, (wchar_t*const*)&a->ns2__Item::alternateTaxType, ""))
		return soap->error;
	if (soap_out_PointerTons2__amount(soap, "ns2:localTax", -1, &a->ns2__Item::localTax, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:zeroCostToCustomerIndicator", -1, (wchar_t*const*)&a->ns2__Item::zeroCostToCustomerIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:passengerFirstName", -1, (wchar_t*const*)&a->ns2__Item::passengerFirstName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:passengerLastName", -1, (wchar_t*const*)&a->ns2__Item::passengerLastName, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:passengerID", -1, (wchar_t*const*)&a->ns2__Item::passengerID, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:passengerStatus", -1, (wchar_t*const*)&a->ns2__Item::passengerStatus, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:passengerType", -1, (wchar_t*const*)&a->ns2__Item::passengerType, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:passengerEmail", -1, (wchar_t*const*)&a->ns2__Item::passengerEmail, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:passengerPhone", -1, (wchar_t*const*)&a->ns2__Item::passengerPhone, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:invoiceNumber", -1, (wchar_t*const*)&a->ns2__Item::invoiceNumber, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:productDescription", -1, (wchar_t*const*)&a->ns2__Item::productDescription, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:taxStatusIndicator", -1, (wchar_t*const*)&a->ns2__Item::taxStatusIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:discountManagementIndicator", -1, (wchar_t*const*)&a->ns2__Item::discountManagementIndicator, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:typeOfSupply", -1, (wchar_t*const*)&a->ns2__Item::typeOfSupply, ""))
		return soap->error;
	if (soap_out_wstring(soap, "ns2:sign", -1, (wchar_t*const*)&a->ns2__Item::sign, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Item::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Item(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Item * SOAP_FMAC4 soap_in_ns2__Item(struct soap *soap, const char *tag, ns2__Item *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Item *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Item, sizeof(ns2__Item), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns2__Item)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns2__Item *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{	const char *t = soap_attr_value(soap, "id", 0);
		if (t)
		{
			if (!(((ns2__Item*)a)->id = (wchar_t **)soap_malloc(soap, sizeof(wchar_t *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__integer(soap, t, ((ns2__Item*)a)->id))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_unitPrice1 = 1;
	size_t soap_flag_quantity1 = 1;
	size_t soap_flag_productCode1 = 1;
	size_t soap_flag_productName1 = 1;
	size_t soap_flag_productSKU1 = 1;
	size_t soap_flag_productRisk1 = 1;
	size_t soap_flag_taxAmount1 = 1;
	size_t soap_flag_cityOverrideAmount1 = 1;
	size_t soap_flag_cityOverrideRate1 = 1;
	size_t soap_flag_countyOverrideAmount1 = 1;
	size_t soap_flag_countyOverrideRate1 = 1;
	size_t soap_flag_districtOverrideAmount1 = 1;
	size_t soap_flag_districtOverrideRate1 = 1;
	size_t soap_flag_stateOverrideAmount1 = 1;
	size_t soap_flag_stateOverrideRate1 = 1;
	size_t soap_flag_countryOverrideAmount1 = 1;
	size_t soap_flag_countryOverrideRate1 = 1;
	size_t soap_flag_orderAcceptanceCity1 = 1;
	size_t soap_flag_orderAcceptanceCounty1 = 1;
	size_t soap_flag_orderAcceptanceCountry1 = 1;
	size_t soap_flag_orderAcceptanceState1 = 1;
	size_t soap_flag_orderAcceptancePostalCode1 = 1;
	size_t soap_flag_orderOriginCity1 = 1;
	size_t soap_flag_orderOriginCounty1 = 1;
	size_t soap_flag_orderOriginCountry1 = 1;
	size_t soap_flag_orderOriginState1 = 1;
	size_t soap_flag_orderOriginPostalCode1 = 1;
	size_t soap_flag_shipFromCity1 = 1;
	size_t soap_flag_shipFromCounty1 = 1;
	size_t soap_flag_shipFromCountry1 = 1;
	size_t soap_flag_shipFromState1 = 1;
	size_t soap_flag_shipFromPostalCode1 = 1;
	size_t soap_flag_export_1 = 1;
	size_t soap_flag_noExport1 = 1;
	size_t soap_flag_nationalTax1 = 1;
	size_t soap_flag_vatRate1 = 1;
	size_t soap_flag_sellerRegistration1 = 1;
	size_t soap_flag_sellerRegistration01 = 1;
	size_t soap_flag_sellerRegistration11 = 1;
	size_t soap_flag_sellerRegistration21 = 1;
	size_t soap_flag_sellerRegistration31 = 1;
	size_t soap_flag_sellerRegistration41 = 1;
	size_t soap_flag_sellerRegistration51 = 1;
	size_t soap_flag_sellerRegistration61 = 1;
	size_t soap_flag_sellerRegistration71 = 1;
	size_t soap_flag_sellerRegistration81 = 1;
	size_t soap_flag_sellerRegistration91 = 1;
	size_t soap_flag_buyerRegistration1 = 1;
	size_t soap_flag_middlemanRegistration1 = 1;
	size_t soap_flag_pointOfTitleTransfer1 = 1;
	size_t soap_flag_giftCategory1 = 1;
	size_t soap_flag_timeCategory1 = 1;
	size_t soap_flag_hostHedge1 = 1;
	size_t soap_flag_timeHedge1 = 1;
	size_t soap_flag_velocityHedge1 = 1;
	size_t soap_flag_nonsensicalHedge1 = 1;
	size_t soap_flag_phoneHedge1 = 1;
	size_t soap_flag_obscenitiesHedge1 = 1;
	size_t soap_flag_unitOfMeasure1 = 1;
	size_t soap_flag_taxRate1 = 1;
	size_t soap_flag_totalAmount1 = 1;
	size_t soap_flag_discountAmount1 = 1;
	size_t soap_flag_discountRate1 = 1;
	size_t soap_flag_commodityCode1 = 1;
	size_t soap_flag_grossNetIndicator1 = 1;
	size_t soap_flag_taxTypeApplied1 = 1;
	size_t soap_flag_discountIndicator1 = 1;
	size_t soap_flag_alternateTaxID1 = 1;
	size_t soap_flag_alternateTaxAmount1 = 1;
	size_t soap_flag_alternateTaxTypeApplied1 = 1;
	size_t soap_flag_alternateTaxRate1 = 1;
	size_t soap_flag_alternateTaxType1 = 1;
	size_t soap_flag_localTax1 = 1;
	size_t soap_flag_zeroCostToCustomerIndicator1 = 1;
	size_t soap_flag_passengerFirstName1 = 1;
	size_t soap_flag_passengerLastName1 = 1;
	size_t soap_flag_passengerID1 = 1;
	size_t soap_flag_passengerStatus1 = 1;
	size_t soap_flag_passengerType1 = 1;
	size_t soap_flag_passengerEmail1 = 1;
	size_t soap_flag_passengerPhone1 = 1;
	size_t soap_flag_invoiceNumber1 = 1;
	size_t soap_flag_productDescription1 = 1;
	size_t soap_flag_taxStatusIndicator1 = 1;
	size_t soap_flag_discountManagementIndicator1 = 1;
	size_t soap_flag_typeOfSupply1 = 1;
	size_t soap_flag_sign1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_unitPrice1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:unitPrice", &a->ns2__Item::unitPrice, "ns2:amount"))
				{	soap_flag_unitPrice1--;
					continue;
				}
			if (soap_flag_quantity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:quantity", &a->ns2__Item::quantity, "ns2:amount"))
				{	soap_flag_quantity1--;
					continue;
				}
			if (soap_flag_productCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:productCode", (wchar_t**)&a->ns2__Item::productCode, "xsd:string"))
				{	soap_flag_productCode1--;
					continue;
				}
			if (soap_flag_productName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:productName", (wchar_t**)&a->ns2__Item::productName, "xsd:string"))
				{	soap_flag_productName1--;
					continue;
				}
			if (soap_flag_productSKU1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:productSKU", (wchar_t**)&a->ns2__Item::productSKU, "xsd:string"))
				{	soap_flag_productSKU1--;
					continue;
				}
			if (soap_flag_productRisk1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:productRisk", (wchar_t**)&a->ns2__Item::productRisk, "xsd:string"))
				{	soap_flag_productRisk1--;
					continue;
				}
			if (soap_flag_taxAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:taxAmount", &a->ns2__Item::taxAmount, "ns2:amount"))
				{	soap_flag_taxAmount1--;
					continue;
				}
			if (soap_flag_cityOverrideAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:cityOverrideAmount", &a->ns2__Item::cityOverrideAmount, "ns2:amount"))
				{	soap_flag_cityOverrideAmount1--;
					continue;
				}
			if (soap_flag_cityOverrideRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:cityOverrideRate", &a->ns2__Item::cityOverrideRate, "ns2:amount"))
				{	soap_flag_cityOverrideRate1--;
					continue;
				}
			if (soap_flag_countyOverrideAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:countyOverrideAmount", &a->ns2__Item::countyOverrideAmount, "ns2:amount"))
				{	soap_flag_countyOverrideAmount1--;
					continue;
				}
			if (soap_flag_countyOverrideRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:countyOverrideRate", &a->ns2__Item::countyOverrideRate, "ns2:amount"))
				{	soap_flag_countyOverrideRate1--;
					continue;
				}
			if (soap_flag_districtOverrideAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:districtOverrideAmount", &a->ns2__Item::districtOverrideAmount, "ns2:amount"))
				{	soap_flag_districtOverrideAmount1--;
					continue;
				}
			if (soap_flag_districtOverrideRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:districtOverrideRate", &a->ns2__Item::districtOverrideRate, "ns2:amount"))
				{	soap_flag_districtOverrideRate1--;
					continue;
				}
			if (soap_flag_stateOverrideAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:stateOverrideAmount", &a->ns2__Item::stateOverrideAmount, "ns2:amount"))
				{	soap_flag_stateOverrideAmount1--;
					continue;
				}
			if (soap_flag_stateOverrideRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:stateOverrideRate", &a->ns2__Item::stateOverrideRate, "ns2:amount"))
				{	soap_flag_stateOverrideRate1--;
					continue;
				}
			if (soap_flag_countryOverrideAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:countryOverrideAmount", &a->ns2__Item::countryOverrideAmount, "ns2:amount"))
				{	soap_flag_countryOverrideAmount1--;
					continue;
				}
			if (soap_flag_countryOverrideRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:countryOverrideRate", &a->ns2__Item::countryOverrideRate, "ns2:amount"))
				{	soap_flag_countryOverrideRate1--;
					continue;
				}
			if (soap_flag_orderAcceptanceCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderAcceptanceCity", (wchar_t**)&a->ns2__Item::orderAcceptanceCity, "xsd:string"))
				{	soap_flag_orderAcceptanceCity1--;
					continue;
				}
			if (soap_flag_orderAcceptanceCounty1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderAcceptanceCounty", (wchar_t**)&a->ns2__Item::orderAcceptanceCounty, "xsd:string"))
				{	soap_flag_orderAcceptanceCounty1--;
					continue;
				}
			if (soap_flag_orderAcceptanceCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderAcceptanceCountry", (wchar_t**)&a->ns2__Item::orderAcceptanceCountry, "xsd:string"))
				{	soap_flag_orderAcceptanceCountry1--;
					continue;
				}
			if (soap_flag_orderAcceptanceState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderAcceptanceState", (wchar_t**)&a->ns2__Item::orderAcceptanceState, "xsd:string"))
				{	soap_flag_orderAcceptanceState1--;
					continue;
				}
			if (soap_flag_orderAcceptancePostalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderAcceptancePostalCode", (wchar_t**)&a->ns2__Item::orderAcceptancePostalCode, "xsd:string"))
				{	soap_flag_orderAcceptancePostalCode1--;
					continue;
				}
			if (soap_flag_orderOriginCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderOriginCity", (wchar_t**)&a->ns2__Item::orderOriginCity, "xsd:string"))
				{	soap_flag_orderOriginCity1--;
					continue;
				}
			if (soap_flag_orderOriginCounty1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderOriginCounty", (wchar_t**)&a->ns2__Item::orderOriginCounty, "xsd:string"))
				{	soap_flag_orderOriginCounty1--;
					continue;
				}
			if (soap_flag_orderOriginCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderOriginCountry", (wchar_t**)&a->ns2__Item::orderOriginCountry, "xsd:string"))
				{	soap_flag_orderOriginCountry1--;
					continue;
				}
			if (soap_flag_orderOriginState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderOriginState", (wchar_t**)&a->ns2__Item::orderOriginState, "xsd:string"))
				{	soap_flag_orderOriginState1--;
					continue;
				}
			if (soap_flag_orderOriginPostalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:orderOriginPostalCode", (wchar_t**)&a->ns2__Item::orderOriginPostalCode, "xsd:string"))
				{	soap_flag_orderOriginPostalCode1--;
					continue;
				}
			if (soap_flag_shipFromCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipFromCity", (wchar_t**)&a->ns2__Item::shipFromCity, "xsd:string"))
				{	soap_flag_shipFromCity1--;
					continue;
				}
			if (soap_flag_shipFromCounty1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipFromCounty", (wchar_t**)&a->ns2__Item::shipFromCounty, "xsd:string"))
				{	soap_flag_shipFromCounty1--;
					continue;
				}
			if (soap_flag_shipFromCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipFromCountry", (wchar_t**)&a->ns2__Item::shipFromCountry, "xsd:string"))
				{	soap_flag_shipFromCountry1--;
					continue;
				}
			if (soap_flag_shipFromState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipFromState", (wchar_t**)&a->ns2__Item::shipFromState, "xsd:string"))
				{	soap_flag_shipFromState1--;
					continue;
				}
			if (soap_flag_shipFromPostalCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:shipFromPostalCode", (wchar_t**)&a->ns2__Item::shipFromPostalCode, "xsd:string"))
				{	soap_flag_shipFromPostalCode1--;
					continue;
				}
			if (soap_flag_export_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:export", (wchar_t**)&a->ns2__Item::export_, "xsd:string"))
				{	soap_flag_export_1--;
					continue;
				}
			if (soap_flag_noExport1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:noExport", (wchar_t**)&a->ns2__Item::noExport, "xsd:string"))
				{	soap_flag_noExport1--;
					continue;
				}
			if (soap_flag_nationalTax1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:nationalTax", &a->ns2__Item::nationalTax, "ns2:amount"))
				{	soap_flag_nationalTax1--;
					continue;
				}
			if (soap_flag_vatRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:vatRate", &a->ns2__Item::vatRate, "ns2:amount"))
				{	soap_flag_vatRate1--;
					continue;
				}
			if (soap_flag_sellerRegistration1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sellerRegistration", (wchar_t**)&a->ns2__Item::sellerRegistration, "xsd:string"))
				{	soap_flag_sellerRegistration1--;
					continue;
				}
			if (soap_flag_sellerRegistration01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sellerRegistration0", (wchar_t**)&a->ns2__Item::sellerRegistration0, "xsd:string"))
				{	soap_flag_sellerRegistration01--;
					continue;
				}
			if (soap_flag_sellerRegistration11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sellerRegistration1", (wchar_t**)&a->ns2__Item::sellerRegistration1, "xsd:string"))
				{	soap_flag_sellerRegistration11--;
					continue;
				}
			if (soap_flag_sellerRegistration21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sellerRegistration2", (wchar_t**)&a->ns2__Item::sellerRegistration2, "xsd:string"))
				{	soap_flag_sellerRegistration21--;
					continue;
				}
			if (soap_flag_sellerRegistration31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sellerRegistration3", (wchar_t**)&a->ns2__Item::sellerRegistration3, "xsd:string"))
				{	soap_flag_sellerRegistration31--;
					continue;
				}
			if (soap_flag_sellerRegistration41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sellerRegistration4", (wchar_t**)&a->ns2__Item::sellerRegistration4, "xsd:string"))
				{	soap_flag_sellerRegistration41--;
					continue;
				}
			if (soap_flag_sellerRegistration51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sellerRegistration5", (wchar_t**)&a->ns2__Item::sellerRegistration5, "xsd:string"))
				{	soap_flag_sellerRegistration51--;
					continue;
				}
			if (soap_flag_sellerRegistration61 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sellerRegistration6", (wchar_t**)&a->ns2__Item::sellerRegistration6, "xsd:string"))
				{	soap_flag_sellerRegistration61--;
					continue;
				}
			if (soap_flag_sellerRegistration71 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sellerRegistration7", (wchar_t**)&a->ns2__Item::sellerRegistration7, "xsd:string"))
				{	soap_flag_sellerRegistration71--;
					continue;
				}
			if (soap_flag_sellerRegistration81 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sellerRegistration8", (wchar_t**)&a->ns2__Item::sellerRegistration8, "xsd:string"))
				{	soap_flag_sellerRegistration81--;
					continue;
				}
			if (soap_flag_sellerRegistration91 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sellerRegistration9", (wchar_t**)&a->ns2__Item::sellerRegistration9, "xsd:string"))
				{	soap_flag_sellerRegistration91--;
					continue;
				}
			if (soap_flag_buyerRegistration1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:buyerRegistration", (wchar_t**)&a->ns2__Item::buyerRegistration, "xsd:string"))
				{	soap_flag_buyerRegistration1--;
					continue;
				}
			if (soap_flag_middlemanRegistration1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:middlemanRegistration", (wchar_t**)&a->ns2__Item::middlemanRegistration, "xsd:string"))
				{	soap_flag_middlemanRegistration1--;
					continue;
				}
			if (soap_flag_pointOfTitleTransfer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:pointOfTitleTransfer", (wchar_t**)&a->ns2__Item::pointOfTitleTransfer, "xsd:string"))
				{	soap_flag_pointOfTitleTransfer1--;
					continue;
				}
			if (soap_flag_giftCategory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__boolean(soap, "ns2:giftCategory", &a->ns2__Item::giftCategory, "ns2:boolean"))
				{	soap_flag_giftCategory1--;
					continue;
				}
			if (soap_flag_timeCategory1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:timeCategory", (wchar_t**)&a->ns2__Item::timeCategory, "xsd:string"))
				{	soap_flag_timeCategory1--;
					continue;
				}
			if (soap_flag_hostHedge1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:hostHedge", (wchar_t**)&a->ns2__Item::hostHedge, "xsd:string"))
				{	soap_flag_hostHedge1--;
					continue;
				}
			if (soap_flag_timeHedge1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:timeHedge", (wchar_t**)&a->ns2__Item::timeHedge, "xsd:string"))
				{	soap_flag_timeHedge1--;
					continue;
				}
			if (soap_flag_velocityHedge1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:velocityHedge", (wchar_t**)&a->ns2__Item::velocityHedge, "xsd:string"))
				{	soap_flag_velocityHedge1--;
					continue;
				}
			if (soap_flag_nonsensicalHedge1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:nonsensicalHedge", (wchar_t**)&a->ns2__Item::nonsensicalHedge, "xsd:string"))
				{	soap_flag_nonsensicalHedge1--;
					continue;
				}
			if (soap_flag_phoneHedge1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:phoneHedge", (wchar_t**)&a->ns2__Item::phoneHedge, "xsd:string"))
				{	soap_flag_phoneHedge1--;
					continue;
				}
			if (soap_flag_obscenitiesHedge1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:obscenitiesHedge", (wchar_t**)&a->ns2__Item::obscenitiesHedge, "xsd:string"))
				{	soap_flag_obscenitiesHedge1--;
					continue;
				}
			if (soap_flag_unitOfMeasure1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:unitOfMeasure", (wchar_t**)&a->ns2__Item::unitOfMeasure, "xsd:string"))
				{	soap_flag_unitOfMeasure1--;
					continue;
				}
			if (soap_flag_taxRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:taxRate", &a->ns2__Item::taxRate, "ns2:amount"))
				{	soap_flag_taxRate1--;
					continue;
				}
			if (soap_flag_totalAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:totalAmount", &a->ns2__Item::totalAmount, "ns2:amount"))
				{	soap_flag_totalAmount1--;
					continue;
				}
			if (soap_flag_discountAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:discountAmount", &a->ns2__Item::discountAmount, "ns2:amount"))
				{	soap_flag_discountAmount1--;
					continue;
				}
			if (soap_flag_discountRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:discountRate", &a->ns2__Item::discountRate, "ns2:amount"))
				{	soap_flag_discountRate1--;
					continue;
				}
			if (soap_flag_commodityCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:commodityCode", (wchar_t**)&a->ns2__Item::commodityCode, "xsd:string"))
				{	soap_flag_commodityCode1--;
					continue;
				}
			if (soap_flag_grossNetIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:grossNetIndicator", (wchar_t**)&a->ns2__Item::grossNetIndicator, "xsd:string"))
				{	soap_flag_grossNetIndicator1--;
					continue;
				}
			if (soap_flag_taxTypeApplied1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:taxTypeApplied", (wchar_t**)&a->ns2__Item::taxTypeApplied, "xsd:string"))
				{	soap_flag_taxTypeApplied1--;
					continue;
				}
			if (soap_flag_discountIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:discountIndicator", (wchar_t**)&a->ns2__Item::discountIndicator, "xsd:string"))
				{	soap_flag_discountIndicator1--;
					continue;
				}
			if (soap_flag_alternateTaxID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:alternateTaxID", (wchar_t**)&a->ns2__Item::alternateTaxID, "xsd:string"))
				{	soap_flag_alternateTaxID1--;
					continue;
				}
			if (soap_flag_alternateTaxAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:alternateTaxAmount", &a->ns2__Item::alternateTaxAmount, "ns2:amount"))
				{	soap_flag_alternateTaxAmount1--;
					continue;
				}
			if (soap_flag_alternateTaxTypeApplied1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:alternateTaxTypeApplied", (wchar_t**)&a->ns2__Item::alternateTaxTypeApplied, "xsd:string"))
				{	soap_flag_alternateTaxTypeApplied1--;
					continue;
				}
			if (soap_flag_alternateTaxRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:alternateTaxRate", &a->ns2__Item::alternateTaxRate, "ns2:amount"))
				{	soap_flag_alternateTaxRate1--;
					continue;
				}
			if (soap_flag_alternateTaxType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:alternateTaxType", (wchar_t**)&a->ns2__Item::alternateTaxType, "xsd:string"))
				{	soap_flag_alternateTaxType1--;
					continue;
				}
			if (soap_flag_localTax1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__amount(soap, "ns2:localTax", &a->ns2__Item::localTax, "ns2:amount"))
				{	soap_flag_localTax1--;
					continue;
				}
			if (soap_flag_zeroCostToCustomerIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:zeroCostToCustomerIndicator", (wchar_t**)&a->ns2__Item::zeroCostToCustomerIndicator, "xsd:string"))
				{	soap_flag_zeroCostToCustomerIndicator1--;
					continue;
				}
			if (soap_flag_passengerFirstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:passengerFirstName", (wchar_t**)&a->ns2__Item::passengerFirstName, "xsd:string"))
				{	soap_flag_passengerFirstName1--;
					continue;
				}
			if (soap_flag_passengerLastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:passengerLastName", (wchar_t**)&a->ns2__Item::passengerLastName, "xsd:string"))
				{	soap_flag_passengerLastName1--;
					continue;
				}
			if (soap_flag_passengerID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:passengerID", (wchar_t**)&a->ns2__Item::passengerID, "xsd:string"))
				{	soap_flag_passengerID1--;
					continue;
				}
			if (soap_flag_passengerStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:passengerStatus", (wchar_t**)&a->ns2__Item::passengerStatus, "xsd:string"))
				{	soap_flag_passengerStatus1--;
					continue;
				}
			if (soap_flag_passengerType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:passengerType", (wchar_t**)&a->ns2__Item::passengerType, "xsd:string"))
				{	soap_flag_passengerType1--;
					continue;
				}
			if (soap_flag_passengerEmail1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:passengerEmail", (wchar_t**)&a->ns2__Item::passengerEmail, "xsd:string"))
				{	soap_flag_passengerEmail1--;
					continue;
				}
			if (soap_flag_passengerPhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:passengerPhone", (wchar_t**)&a->ns2__Item::passengerPhone, "xsd:string"))
				{	soap_flag_passengerPhone1--;
					continue;
				}
			if (soap_flag_invoiceNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:invoiceNumber", (wchar_t**)&a->ns2__Item::invoiceNumber, "xsd:string"))
				{	soap_flag_invoiceNumber1--;
					continue;
				}
			if (soap_flag_productDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:productDescription", (wchar_t**)&a->ns2__Item::productDescription, "xsd:string"))
				{	soap_flag_productDescription1--;
					continue;
				}
			if (soap_flag_taxStatusIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:taxStatusIndicator", (wchar_t**)&a->ns2__Item::taxStatusIndicator, "xsd:string"))
				{	soap_flag_taxStatusIndicator1--;
					continue;
				}
			if (soap_flag_discountManagementIndicator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:discountManagementIndicator", (wchar_t**)&a->ns2__Item::discountManagementIndicator, "xsd:string"))
				{	soap_flag_discountManagementIndicator1--;
					continue;
				}
			if (soap_flag_typeOfSupply1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:typeOfSupply", (wchar_t**)&a->ns2__Item::typeOfSupply, "xsd:string"))
				{	soap_flag_typeOfSupply1--;
					continue;
				}
			if (soap_flag_sign1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:sign", (wchar_t**)&a->ns2__Item::sign, "xsd:string"))
				{	soap_flag_sign1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Item *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Item, SOAP_TYPE_ns2__Item, sizeof(ns2__Item), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns2__Item * SOAP_FMAC2 soap_instantiate_ns2__Item(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Item(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns2__Item *p;
	size_t k = sizeof(ns2__Item);
	if (n < 0)
	{	p = SOAP_NEW(ns2__Item);
		if (p)
			((ns2__Item*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns2__Item, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns2__Item*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns2__Item location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns2__Item, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns2__Item::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (this->soap_out(soap, tag?tag:"ns2:Item", -2, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Item::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Item(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Item * SOAP_FMAC4 soap_get_ns2__Item(struct soap *soap, ns2__Item *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Item(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__runTransaction(struct soap *soap, struct __ns1__runTransaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__nvpRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__runTransaction(struct soap *soap, const struct __ns1__runTransaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&a->ns2__nvpRequest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__runTransaction(struct soap *soap, const char *tag, int id, const struct __ns1__runTransaction *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_wstring(soap, "ns2:nvpRequest", -1, (wchar_t*const*)&a->ns2__nvpRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__runTransaction * SOAP_FMAC4 soap_in___ns1__runTransaction(struct soap *soap, const char *tag, struct __ns1__runTransaction *a, const char *type)
{
	size_t soap_flag_ns2__nvpRequest = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__runTransaction *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__runTransaction, sizeof(struct __ns1__runTransaction), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__runTransaction(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__nvpRequest && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:nvpRequest", (wchar_t**)&a->ns2__nvpRequest, "xsd:string"))
				{	soap_flag_ns2__nvpRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__runTransaction * SOAP_FMAC2 soap_instantiate___ns1__runTransaction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__runTransaction(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__runTransaction *p;
	size_t k = sizeof(struct __ns1__runTransaction);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__runTransaction);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__runTransaction, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__runTransaction location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__runTransaction, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__runTransaction(struct soap *soap, const struct __ns1__runTransaction *a, const char *tag, const char *type)
{
	if (soap_out___ns1__runTransaction(soap, tag?tag:"-ns1:runTransaction", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__runTransaction * SOAP_FMAC4 soap_get___ns1__runTransaction(struct soap *soap, struct __ns1__runTransaction *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__runTransaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__runTransactionResponse(struct soap *soap, struct __ns1__runTransactionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__nvpReply = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__runTransactionResponse(struct soap *soap, const struct __ns1__runTransactionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wstring(soap, (wchar_t*const*)&a->ns2__nvpReply);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__runTransactionResponse(struct soap *soap, const char *tag, int id, const struct __ns1__runTransactionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (a->ns2__nvpReply)
		soap_element_result(soap, "ns2:nvpReply");
	if (!a->ns2__nvpReply)
	{	if (soap_element_nil(soap, "ns2:nvpReply"))
			return soap->error;
	}
	else
	if (soap_out_wstring(soap, "ns2:nvpReply", -1, (wchar_t*const*)&a->ns2__nvpReply, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__runTransactionResponse * SOAP_FMAC4 soap_in___ns1__runTransactionResponse(struct soap *soap, const char *tag, struct __ns1__runTransactionResponse *a, const char *type)
{
	size_t soap_flag_ns2__nvpReply = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__runTransactionResponse *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__runTransactionResponse, sizeof(struct __ns1__runTransactionResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__runTransactionResponse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__nvpReply && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "ns2:nvpReply", (wchar_t**)&a->ns2__nvpReply, "xsd:string"))
				{	soap_flag_ns2__nvpReply--;
					continue;
				}
			soap_check_result(soap, "ns2:nvpReply");
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ns2__nvpReply > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__runTransactionResponse * SOAP_FMAC2 soap_instantiate___ns1__runTransactionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__runTransactionResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__runTransactionResponse *p;
	size_t k = sizeof(struct __ns1__runTransactionResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__runTransactionResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__runTransactionResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__runTransactionResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__runTransactionResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__runTransactionResponse(struct soap *soap, const struct __ns1__runTransactionResponse *a, const char *tag, const char *type)
{
	if (soap_out___ns1__runTransactionResponse(soap, tag?tag:"-ns1:runTransactionResponse", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__runTransactionResponse * SOAP_FMAC4 soap_get___ns1__runTransactionResponse(struct soap *soap, struct __ns1__runTransactionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__runTransactionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsse__Security = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsse__Security(soap, &a->wsse__Security);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsse__Security(soap, "wsse:Security", -1, &a->wsse__Security, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsse__Security = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsse__Security && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Security(soap, "wsse:Security", &a->wsse__Security, ""))
				{	soap_flag_wsse__Security--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Security(struct soap *soap, struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsu__Timestamp = NULL;
	a->UsernameToken = NULL;
	a->BinarySecurityToken = NULL;
	a->xenc__EncryptedKey = NULL;
	a->xenc__ReferenceList = NULL;
	a->wsc__SecurityContextToken = NULL;
	a->ds__Signature = NULL;
	soap_default_string(soap, &a->SOAP_ENV__actor);
	soap_default_string(soap, &a->SOAP_ENV__role);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Security(struct soap *soap, const struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsu__Timestamp(soap, &a->wsu__Timestamp);
	soap_serialize_PointerTo_wsse__UsernameToken(soap, &a->UsernameToken);
	soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, &a->BinarySecurityToken);
	soap_serialize_PointerToxenc__EncryptedKeyType(soap, &a->xenc__EncryptedKey);
	soap_serialize_PointerTo_xenc__ReferenceList(soap, &a->xenc__ReferenceList);
	soap_serialize_PointerTowsc__SecurityContextTokenType(soap, &a->wsc__SecurityContextToken);
	soap_serialize_PointerTods__SignatureType(soap, &a->ds__Signature);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Security(struct soap *soap, const char *tag, int id, const struct _wsse__Security *a, const char *type)
{
	if (a->SOAP_ENV__actor)
		soap_set_attr(soap, "SOAP-ENV:actor", soap_string2s(soap, a->SOAP_ENV__actor), 1);
	if (a->SOAP_ENV__role)
		soap_set_attr(soap, "SOAP-ENV:role", soap_string2s(soap, a->SOAP_ENV__role), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Security), type))
		return soap->error;
	if (soap_out_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", -1, &a->wsu__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", -1, &a->UsernameToken, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", -1, &a->BinarySecurityToken, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", -1, &a->xenc__EncryptedKey, ""))
		return soap->error;
	if (soap_out_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", -1, &a->xenc__ReferenceList, ""))
		return soap->error;
	if (soap_out_PointerTowsc__SecurityContextTokenType(soap, "wsc:SecurityContextToken", -1, &a->wsc__SecurityContextToken, ""))
		return soap->error;
	if (soap_out_PointerTods__SignatureType(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_in__wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security *a, const char *type)
{
	size_t soap_flag_wsu__Timestamp = 1;
	size_t soap_flag_UsernameToken = 1;
	size_t soap_flag_BinarySecurityToken = 1;
	size_t soap_flag_xenc__EncryptedKey = 1;
	size_t soap_flag_xenc__ReferenceList = 1;
	size_t soap_flag_wsc__SecurityContextToken = 1;
	size_t soap_flag_ds__Signature = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Security *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Security(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:actor", 0), &a->SOAP_ENV__actor))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:role", 0), &a->SOAP_ENV__role))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsu__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", &a->wsu__Timestamp, ""))
				{	soap_flag_wsu__Timestamp--;
					continue;
				}
			if (soap_flag_UsernameToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", &a->UsernameToken, ""))
				{	soap_flag_UsernameToken--;
					continue;
				}
			if (soap_flag_BinarySecurityToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", &a->BinarySecurityToken, ""))
				{	soap_flag_BinarySecurityToken--;
					continue;
				}
			if (soap_flag_xenc__EncryptedKey && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", &a->xenc__EncryptedKey, "xenc:EncryptedKeyType"))
				{	soap_flag_xenc__EncryptedKey--;
					continue;
				}
			if (soap_flag_xenc__ReferenceList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", &a->xenc__ReferenceList, ""))
				{	soap_flag_xenc__ReferenceList--;
					continue;
				}
			if (soap_flag_wsc__SecurityContextToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsc__SecurityContextTokenType(soap, "wsc:SecurityContextToken", &a->wsc__SecurityContextToken, "wsc:SecurityContextTokenType"))
				{	soap_flag_wsc__SecurityContextToken--;
					continue;
				}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureType(soap, "ds:Signature", &a->ds__Signature, "ds:SignatureType"))
				{	soap_flag_ds__Signature--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Security, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsse__Security * SOAP_FMAC2 soap_instantiate__wsse__Security(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Security(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__Security *p;
	size_t k = sizeof(struct _wsse__Security);
	if (n < 0)
	{	p = SOAP_NEW(struct _wsse__Security);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct _wsse__Security, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__Security location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__wsse__Security, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Security(struct soap *soap, const struct _wsse__Security *a, const char *tag, const char *type)
{
	if (soap_out__wsse__Security(soap, tag?tag:"wsse:Security", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_get__wsse__Security(struct soap *soap, struct _wsse__Security *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_DerivedKeyTokenType = -1;
	a->Length = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const struct __wsc__DerivedKeyTokenType_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsc__union_DerivedKeyTokenType(soap, a->__union_DerivedKeyTokenType, &a->union_DerivedKeyTokenType);
	soap_serialize_PointerToULONG64(soap, &a->Length);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, int id, const struct __wsc__DerivedKeyTokenType_sequence *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out__wsc__union_DerivedKeyTokenType(soap, a->__union_DerivedKeyTokenType, &a->union_DerivedKeyTokenType))
		return soap->error;
	if (soap_out_PointerToULONG64(soap, "wsc:Length", -1, &a->Length, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC4 soap_in___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, struct __wsc__DerivedKeyTokenType_sequence *a, const char *type)
{
	size_t soap_flag_union_DerivedKeyTokenType = 1;
	size_t soap_flag_Length = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsc__DerivedKeyTokenType_sequence *)soap_id_enter(soap, "", a, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence, sizeof(struct __wsc__DerivedKeyTokenType_sequence), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsc__DerivedKeyTokenType_sequence(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_union_DerivedKeyTokenType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsc__union_DerivedKeyTokenType(soap, &a->__union_DerivedKeyTokenType, &a->union_DerivedKeyTokenType))
				{	soap_flag_union_DerivedKeyTokenType = 0;
					continue;
				}
			if (soap_flag_Length && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToULONG64(soap, "wsc:Length", &a->Length, "xsd:unsignedLong"))
				{	soap_flag_Length--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_DerivedKeyTokenType))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC2 soap_instantiate___wsc__DerivedKeyTokenType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsc__DerivedKeyTokenType_sequence(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __wsc__DerivedKeyTokenType_sequence *p;
	size_t k = sizeof(struct __wsc__DerivedKeyTokenType_sequence);
	if (n < 0)
	{	p = SOAP_NEW(struct __wsc__DerivedKeyTokenType_sequence);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __wsc__DerivedKeyTokenType_sequence, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __wsc__DerivedKeyTokenType_sequence location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const struct __wsc__DerivedKeyTokenType_sequence *a, const char *tag, const char *type)
{
	if (soap_out___wsc__DerivedKeyTokenType_sequence(soap, tag?tag:"-wsc:DerivedKeyTokenType-sequence", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC4 soap_get___wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsc__DerivedKeyTokenType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__PropertiesType(struct soap *soap, const struct wsc__PropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__PropertiesType(struct soap *soap, const char *tag, int id, const struct wsc__PropertiesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__PropertiesType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsc__PropertiesType * SOAP_FMAC4 soap_in_wsc__PropertiesType(struct soap *soap, const char *tag, struct wsc__PropertiesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsc__PropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__PropertiesType, sizeof(struct wsc__PropertiesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsc__PropertiesType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsc__PropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__PropertiesType, SOAP_TYPE_wsc__PropertiesType, sizeof(struct wsc__PropertiesType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsc__PropertiesType * SOAP_FMAC2 soap_instantiate_wsc__PropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsc__PropertiesType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsc__PropertiesType *p;
	size_t k = sizeof(struct wsc__PropertiesType);
	if (n < 0)
	{	p = SOAP_NEW(struct wsc__PropertiesType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct wsc__PropertiesType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsc__PropertiesType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_wsc__PropertiesType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__PropertiesType(struct soap *soap, const struct wsc__PropertiesType *a, const char *tag, const char *type)
{
	if (soap_out_wsc__PropertiesType(soap, tag?tag:"wsc:PropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__PropertiesType * SOAP_FMAC4 soap_get_wsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__PropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__DerivedKeyTokenType(struct soap *soap, struct wsc__DerivedKeyTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsse__SecurityTokenReference = NULL;
	a->Properties = NULL;
	a->__DerivedKeyTokenType_sequence = NULL;
	soap_default_string(soap, &a->Label);
	soap_default_string(soap, &a->Nonce);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__DerivedKeyTokenType(struct soap *soap, const struct wsc__DerivedKeyTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
	soap_serialize_PointerTowsc__PropertiesType(soap, &a->Properties);
	soap_serialize_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, &a->__DerivedKeyTokenType_sequence);
	soap_serialize_string(soap, (char*const*)&a->Label);
	soap_serialize_string(soap, (char*const*)&a->Nonce);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__DerivedKeyTokenType(struct soap *soap, const char *tag, int id, const struct wsc__DerivedKeyTokenType *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", soap_string2s(soap, a->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__DerivedKeyTokenType), type))
		return soap->error;
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	if (soap_out_PointerTowsc__PropertiesType(soap, "wsc:Properties", -1, &a->Properties, ""))
		return soap->error;
	if (soap_out_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, "-DerivedKeyTokenType-sequence", -1, &a->__DerivedKeyTokenType_sequence, ""))
		return soap->error;
	if (soap_out_string(soap, "wsc:Label", -1, (char*const*)&a->Label, ""))
		return soap->error;
	if (soap_out_string(soap, "wsc:Nonce", -1, (char*const*)&a->Nonce, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsc__DerivedKeyTokenType * SOAP_FMAC4 soap_in_wsc__DerivedKeyTokenType(struct soap *soap, const char *tag, struct wsc__DerivedKeyTokenType *a, const char *type)
{
	size_t soap_flag_wsse__SecurityTokenReference = 1;
	size_t soap_flag_Properties = 1;
	size_t soap_flag___DerivedKeyTokenType_sequence = 1;
	size_t soap_flag_Label = 1;
	size_t soap_flag_Nonce = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsc__DerivedKeyTokenType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__DerivedKeyTokenType, sizeof(struct wsc__DerivedKeyTokenType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsc__DerivedKeyTokenType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 0), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
				{	soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			if (soap_flag_Properties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsc__PropertiesType(soap, "wsc:Properties", &a->Properties, "wsc:PropertiesType"))
				{	soap_flag_Properties--;
					continue;
				}
			if (soap_flag_Label && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsc:Label", (char**)&a->Label, "xsd:string"))
				{	soap_flag_Label--;
					continue;
				}
			if (soap_flag_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsc:Nonce", (char**)&a->Nonce, "xsd:string"))
				{	soap_flag_Nonce--;
					continue;
				}
			if (soap_flag___DerivedKeyTokenType_sequence && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, "-DerivedKeyTokenType-sequence", &a->__DerivedKeyTokenType_sequence, "-wsc:DerivedKeyTokenType-sequence"))
				{	soap_flag___DerivedKeyTokenType_sequence--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsc__DerivedKeyTokenType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__DerivedKeyTokenType, SOAP_TYPE_wsc__DerivedKeyTokenType, sizeof(struct wsc__DerivedKeyTokenType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsc__DerivedKeyTokenType * SOAP_FMAC2 soap_instantiate_wsc__DerivedKeyTokenType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsc__DerivedKeyTokenType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsc__DerivedKeyTokenType *p;
	size_t k = sizeof(struct wsc__DerivedKeyTokenType);
	if (n < 0)
	{	p = SOAP_NEW(struct wsc__DerivedKeyTokenType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct wsc__DerivedKeyTokenType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsc__DerivedKeyTokenType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_wsc__DerivedKeyTokenType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__DerivedKeyTokenType(struct soap *soap, const struct wsc__DerivedKeyTokenType *a, const char *tag, const char *type)
{
	if (soap_out_wsc__DerivedKeyTokenType(soap, tag?tag:"wsc:DerivedKeyTokenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__DerivedKeyTokenType * SOAP_FMAC4 soap_get_wsc__DerivedKeyTokenType(struct soap *soap, struct wsc__DerivedKeyTokenType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__DerivedKeyTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Identifier);
	soap_default_string(soap, &a->Instance);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__SecurityContextTokenType(struct soap *soap, const struct wsc__SecurityContextTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Identifier);
	soap_serialize_string(soap, (char*const*)&a->Instance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__SecurityContextTokenType(struct soap *soap, const char *tag, int id, const struct wsc__SecurityContextTokenType *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__SecurityContextTokenType), type))
		return soap->error;
	if (soap_out_string(soap, "wsc:Identifier", -1, (char*const*)&a->Identifier, ""))
		return soap->error;
	if (soap_out_string(soap, "wsc:Instance", -1, (char*const*)&a->Instance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType * SOAP_FMAC4 soap_in_wsc__SecurityContextTokenType(struct soap *soap, const char *tag, struct wsc__SecurityContextTokenType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	size_t soap_flag_Instance = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsc__SecurityContextTokenType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__SecurityContextTokenType, sizeof(struct wsc__SecurityContextTokenType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsc__SecurityContextTokenType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsc:Identifier", (char**)&a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			if (soap_flag_Instance && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsc:Instance", (char**)&a->Instance, "xsd:string"))
				{	soap_flag_Instance--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsc__SecurityContextTokenType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__SecurityContextTokenType, SOAP_TYPE_wsc__SecurityContextTokenType, sizeof(struct wsc__SecurityContextTokenType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsc__SecurityContextTokenType * SOAP_FMAC2 soap_instantiate_wsc__SecurityContextTokenType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsc__SecurityContextTokenType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsc__SecurityContextTokenType *p;
	size_t k = sizeof(struct wsc__SecurityContextTokenType);
	if (n < 0)
	{	p = SOAP_NEW(struct wsc__SecurityContextTokenType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct wsc__SecurityContextTokenType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsc__SecurityContextTokenType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_wsc__SecurityContextTokenType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__SecurityContextTokenType(struct soap *soap, const struct wsc__SecurityContextTokenType *a, const char *tag, const char *type)
{
	if (soap_out_wsc__SecurityContextTokenType(soap, tag?tag:"wsc:SecurityContextTokenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType * SOAP_FMAC4 soap_get_wsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__SecurityContextTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DataReference = NULL;
	a->KeyReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___xenc__union_ReferenceList(struct soap *soap, const struct __xenc__union_ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__ReferenceType(soap, &a->DataReference);
	soap_serialize_PointerToxenc__ReferenceType(soap, &a->KeyReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___xenc__union_ReferenceList(struct soap *soap, const char *tag, int id, const struct __xenc__union_ReferenceList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerToxenc__ReferenceType(soap, "xenc:DataReference", -1, &a->DataReference, ""))
		return soap->error;
	if (soap_out_PointerToxenc__ReferenceType(soap, "xenc:KeyReference", -1, &a->KeyReference, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_in___xenc__union_ReferenceList(struct soap *soap, const char *tag, struct __xenc__union_ReferenceList *a, const char *type)
{
	size_t soap_flag_DataReference = 1;
	size_t soap_flag_KeyReference = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __xenc__union_ReferenceList *)soap_id_enter(soap, "", a, SOAP_TYPE___xenc__union_ReferenceList, sizeof(struct __xenc__union_ReferenceList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___xenc__union_ReferenceList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DataReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__ReferenceType(soap, "xenc:DataReference", &a->DataReference, "xenc:ReferenceType"))
				{	soap_flag_DataReference--;
					continue;
				}
			if (soap_flag_KeyReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__ReferenceType(soap, "xenc:KeyReference", &a->KeyReference, "xenc:ReferenceType"))
				{	soap_flag_KeyReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __xenc__union_ReferenceList * SOAP_FMAC2 soap_instantiate___xenc__union_ReferenceList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___xenc__union_ReferenceList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __xenc__union_ReferenceList *p;
	size_t k = sizeof(struct __xenc__union_ReferenceList);
	if (n < 0)
	{	p = SOAP_NEW(struct __xenc__union_ReferenceList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __xenc__union_ReferenceList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __xenc__union_ReferenceList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE___xenc__union_ReferenceList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___xenc__union_ReferenceList(struct soap *soap, const struct __xenc__union_ReferenceList *a, const char *tag, const char *type)
{
	if (soap_out___xenc__union_ReferenceList(soap, tag?tag:"-xenc:union-ReferenceList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_get___xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *p, const char *tag, const char *type)
{
	if ((p = soap_in___xenc__union_ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_ReferenceList = 0;
	a->__union_ReferenceList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xenc__ReferenceList(struct soap *soap, const struct _xenc__ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_ReferenceList)
	{	int i;
		for (i = 0; i < (int)a->__size_ReferenceList; i++)
		{
			soap_serialize___xenc__union_ReferenceList(soap, a->__union_ReferenceList + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xenc__ReferenceList(struct soap *soap, const char *tag, int id, const struct _xenc__ReferenceList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__xenc__ReferenceList), type))
		return soap->error;
	if (a->__union_ReferenceList)
	{	int i;
		for (i = 0; i < (int)a->__size_ReferenceList; i++)
			if (soap_out___xenc__union_ReferenceList(soap, "-union-ReferenceList", -1, a->__union_ReferenceList + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_in__xenc__ReferenceList(struct soap *soap, const char *tag, struct _xenc__ReferenceList *a, const char *type)
{
	struct soap_blist *soap_blist___union_ReferenceList = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _xenc__ReferenceList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__xenc__ReferenceList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_ReferenceList == NULL)
				{	if (soap_blist___union_ReferenceList == NULL)
						soap_blist___union_ReferenceList = soap_new_block(soap);
					a->__union_ReferenceList = soap_block<struct __xenc__union_ReferenceList>::push(soap, soap_blist___union_ReferenceList);
					if (a->__union_ReferenceList == NULL)
						return NULL;
					soap_default___xenc__union_ReferenceList(soap, a->__union_ReferenceList);
				}
				if (soap_in___xenc__union_ReferenceList(soap, "-union-ReferenceList", a->__union_ReferenceList, "-xenc:union-ReferenceList"))
				{	a->__size_ReferenceList++;
					a->__union_ReferenceList = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_ReferenceList)
			soap_block<struct __xenc__union_ReferenceList>::pop(soap, soap_blist___union_ReferenceList);
		if (a->__size_ReferenceList)
		{	a->__union_ReferenceList = soap_new___xenc__union_ReferenceList(soap, a->__size_ReferenceList);
			if (!a->__union_ReferenceList)
				return NULL;
			soap_block<struct __xenc__union_ReferenceList>::save(soap, soap_blist___union_ReferenceList, a->__union_ReferenceList);
		}
		else
		{	a->__union_ReferenceList = NULL;
			if (soap_blist___union_ReferenceList)
				soap_block<struct __xenc__union_ReferenceList>::end(soap, soap_blist___union_ReferenceList);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__size_ReferenceList < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _xenc__ReferenceList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xenc__ReferenceList, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _xenc__ReferenceList * SOAP_FMAC2 soap_instantiate__xenc__ReferenceList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__xenc__ReferenceList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _xenc__ReferenceList *p;
	size_t k = sizeof(struct _xenc__ReferenceList);
	if (n < 0)
	{	p = SOAP_NEW(struct _xenc__ReferenceList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct _xenc__ReferenceList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _xenc__ReferenceList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__xenc__ReferenceList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xenc__ReferenceList(struct soap *soap, const struct _xenc__ReferenceList *a, const char *tag, const char *type)
{
	if (soap_out__xenc__ReferenceList(soap, tag?tag:"xenc:ReferenceList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_get__xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *p, const char *tag, const char *type)
{
	if ((p = soap_in__xenc__ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Target);
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionPropertyType(struct soap *soap, const struct xenc__EncryptionPropertyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionPropertyType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionPropertyType *a, const char *type)
{
	if (a->Target)
		soap_set_attr(soap, "Target", soap_string2s(soap, a->Target), 1);
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionPropertyType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_in_xenc__EncryptionPropertyType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptionPropertyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionPropertyType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Target", 0), &a->Target))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertyType, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__EncryptionPropertyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptionPropertyType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__EncryptionPropertyType *p;
	size_t k = sizeof(struct xenc__EncryptionPropertyType);
	if (n < 0)
	{	p = SOAP_NEW(struct xenc__EncryptionPropertyType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct xenc__EncryptionPropertyType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__EncryptionPropertyType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_xenc__EncryptionPropertyType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionPropertyType(struct soap *soap, const struct xenc__EncryptionPropertyType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptionPropertyType(soap, tag?tag:"xenc:EncryptionPropertyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_get_xenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionPropertyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeEncryptionProperty = 0;
	a->EncryptionProperty = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionPropertiesType(struct soap *soap, const struct xenc__EncryptionPropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->EncryptionProperty)
	{	int i;
		for (i = 0; i < (int)a->__sizeEncryptionProperty; i++)
		{
			soap_embedded(soap, a->EncryptionProperty + i, SOAP_TYPE_xenc__EncryptionPropertyType);
			soap_serialize_xenc__EncryptionPropertyType(soap, a->EncryptionProperty + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionPropertiesType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionPropertiesType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionPropertiesType), type))
		return soap->error;
	if (a->EncryptionProperty)
	{	int i;
		for (i = 0; i < (int)a->__sizeEncryptionProperty; i++)
			if (soap_out_xenc__EncryptionPropertyType(soap, "xenc:EncryptionProperty", -1, a->EncryptionProperty + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_in_xenc__EncryptionPropertiesType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertiesType *a, const char *type)
{
	struct soap_blist *soap_blist_EncryptionProperty = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptionPropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionPropertiesType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "xenc:EncryptionProperty", 1, NULL))
			{	if (a->EncryptionProperty == NULL)
				{	if (soap_blist_EncryptionProperty == NULL)
						soap_blist_EncryptionProperty = soap_new_block(soap);
					a->EncryptionProperty = soap_block<struct xenc__EncryptionPropertyType>::push(soap, soap_blist_EncryptionProperty);
					if (a->EncryptionProperty == NULL)
						return NULL;
					soap_default_xenc__EncryptionPropertyType(soap, a->EncryptionProperty);
				}
				soap_revert(soap);
				if (soap_in_xenc__EncryptionPropertyType(soap, "xenc:EncryptionProperty", a->EncryptionProperty, "xenc:EncryptionPropertyType"))
				{	a->__sizeEncryptionProperty++;
					a->EncryptionProperty = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->EncryptionProperty)
			soap_block<struct xenc__EncryptionPropertyType>::pop(soap, soap_blist_EncryptionProperty);
		if (a->__sizeEncryptionProperty)
		{	a->EncryptionProperty = soap_new_xenc__EncryptionPropertyType(soap, a->__sizeEncryptionProperty);
			if (!a->EncryptionProperty)
				return NULL;
			soap_block<struct xenc__EncryptionPropertyType>::save(soap, soap_blist_EncryptionProperty, a->EncryptionProperty);
		}
		else
		{	a->EncryptionProperty = NULL;
			if (soap_blist_EncryptionProperty)
				soap_block<struct xenc__EncryptionPropertyType>::end(soap, soap_blist_EncryptionProperty);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeEncryptionProperty < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertiesType, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__EncryptionPropertiesType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptionPropertiesType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__EncryptionPropertiesType *p;
	size_t k = sizeof(struct xenc__EncryptionPropertiesType);
	if (n < 0)
	{	p = SOAP_NEW(struct xenc__EncryptionPropertiesType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct xenc__EncryptionPropertiesType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__EncryptionPropertiesType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_xenc__EncryptionPropertiesType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionPropertiesType(struct soap *soap, const struct xenc__EncryptionPropertiesType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptionPropertiesType(soap, tag?tag:"xenc:EncryptionPropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_get_xenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__ReferenceType(struct soap *soap, const struct xenc__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__ReferenceType(struct soap *soap, const char *tag, int id, const struct xenc__ReferenceType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", soap_string2s(soap, a->URI), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__ReferenceType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_in_xenc__ReferenceType(struct soap *soap, const char *tag, struct xenc__ReferenceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1), &a->URI))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__ReferenceType, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__ReferenceType * SOAP_FMAC2 soap_instantiate_xenc__ReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__ReferenceType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__ReferenceType *p;
	size_t k = sizeof(struct xenc__ReferenceType);
	if (n < 0)
	{	p = SOAP_NEW(struct xenc__ReferenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct xenc__ReferenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__ReferenceType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_xenc__ReferenceType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__ReferenceType(struct soap *soap, const struct xenc__ReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__ReferenceType(soap, tag?tag:"xenc:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_get_xenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__AgreementMethodType(struct soap *soap, struct xenc__AgreementMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->KA_Nonce);
	a->OriginatorKeyInfo = NULL;
	a->RecipientKeyInfo = NULL;
	soap_default_string(soap, &a->Algorithm);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__AgreementMethodType(struct soap *soap, const struct xenc__AgreementMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->KA_Nonce);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->OriginatorKeyInfo);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->RecipientKeyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__AgreementMethodType(struct soap *soap, const char *tag, int id, const struct xenc__AgreementMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", soap_string2s(soap, a->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__AgreementMethodType), type))
		return soap->error;
	if (soap_out_string(soap, "xenc:KA-Nonce", -1, (char*const*)&a->KA_Nonce, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "xenc:OriginatorKeyInfo", -1, &a->OriginatorKeyInfo, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "xenc:RecipientKeyInfo", -1, &a->RecipientKeyInfo, ""))
		return soap->error;
	soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__AgreementMethodType * SOAP_FMAC4 soap_in_xenc__AgreementMethodType(struct soap *soap, const char *tag, struct xenc__AgreementMethodType *a, const char *type)
{
	size_t soap_flag_KA_Nonce = 1;
	size_t soap_flag_OriginatorKeyInfo = 1;
	size_t soap_flag_RecipientKeyInfo = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__AgreementMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__AgreementMethodType, sizeof(struct xenc__AgreementMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__AgreementMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KA_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:KA-Nonce", (char**)&a->KA_Nonce, "xsd:string"))
				{	soap_flag_KA_Nonce--;
					continue;
				}
			if (soap_flag_OriginatorKeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "xenc:OriginatorKeyInfo", &a->OriginatorKeyInfo, "ds:KeyInfoType"))
				{	soap_flag_OriginatorKeyInfo--;
					continue;
				}
			if (soap_flag_RecipientKeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "xenc:RecipientKeyInfo", &a->RecipientKeyInfo, "ds:KeyInfoType"))
				{	soap_flag_RecipientKeyInfo--;
					continue;
				}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__AgreementMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__AgreementMethodType, SOAP_TYPE_xenc__AgreementMethodType, sizeof(struct xenc__AgreementMethodType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__AgreementMethodType * SOAP_FMAC2 soap_instantiate_xenc__AgreementMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__AgreementMethodType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__AgreementMethodType *p;
	size_t k = sizeof(struct xenc__AgreementMethodType);
	if (n < 0)
	{	p = SOAP_NEW(struct xenc__AgreementMethodType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct xenc__AgreementMethodType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__AgreementMethodType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_xenc__AgreementMethodType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__AgreementMethodType(struct soap *soap, const struct xenc__AgreementMethodType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__AgreementMethodType(soap, tag?tag:"xenc:AgreementMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__AgreementMethodType * SOAP_FMAC4 soap_get_xenc__AgreementMethodType(struct soap *soap, struct xenc__AgreementMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__AgreementMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
	a->ReferenceList = NULL;
	soap_default_string(soap, &a->CarriedKeyName);
	soap_default_string(soap, &a->Recipient);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedKeyType(struct soap *soap, const struct xenc__EncryptedKeyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
	soap_serialize_PointerTo_xenc__ReferenceList(soap, &a->ReferenceList);
	soap_serialize_string(soap, (char*const*)&a->CarriedKeyName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedKeyType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", soap_string2s(soap, a->MimeType), 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", soap_string2s(soap, a->Encoding), 1);
	if (a->Recipient)
		soap_set_attr(soap, "Recipient", soap_string2s(soap, a->Recipient), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedKeyType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (!a->CipherData)
	{	if (soap_element_nil(soap, "xenc:CipherData"))
			return soap->error;
	}
	else
	if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	if (soap_out_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", -1, &a->ReferenceList, ""))
		return soap->error;
	if (soap_out_string(soap, "xenc:CarriedKeyName", -1, (char*const*)&a->CarriedKeyName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_in_xenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	size_t soap_flag_ReferenceList = 1;
	size_t soap_flag_CarriedKeyName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptedKeyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedKeyType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 0), &a->MimeType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Recipient", 0), &a->Recipient))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			if (soap_flag_ReferenceList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", &a->ReferenceList, ""))
				{	soap_flag_ReferenceList--;
					continue;
				}
			if (soap_flag_CarriedKeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:CarriedKeyName", (char**)&a->CarriedKeyName, "xsd:string"))
				{	soap_flag_CarriedKeyName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CipherData > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptedKeyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedKeyType, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__EncryptedKeyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedKeyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptedKeyType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__EncryptedKeyType *p;
	size_t k = sizeof(struct xenc__EncryptedKeyType);
	if (n < 0)
	{	p = SOAP_NEW(struct xenc__EncryptedKeyType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct xenc__EncryptedKeyType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__EncryptedKeyType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_xenc__EncryptedKeyType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedKeyType(struct soap *soap, const struct xenc__EncryptedKeyType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptedKeyType(soap, tag?tag:"xenc:EncryptedKeyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_get_xenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedDataType(struct soap *soap, struct xenc__EncryptedDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedDataType(struct soap *soap, const struct xenc__EncryptedDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedDataType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedDataType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", soap_string2s(soap, a->MimeType), 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", soap_string2s(soap, a->Encoding), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedDataType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (!a->CipherData)
	{	if (soap_element_nil(soap, "xenc:CipherData"))
			return soap->error;
	}
	else
	if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedDataType * SOAP_FMAC4 soap_in_xenc__EncryptedDataType(struct soap *soap, const char *tag, struct xenc__EncryptedDataType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptedDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedDataType, sizeof(struct xenc__EncryptedDataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedDataType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 0), &a->MimeType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CipherData > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptedDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedDataType, SOAP_TYPE_xenc__EncryptedDataType, sizeof(struct xenc__EncryptedDataType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__EncryptedDataType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedDataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptedDataType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__EncryptedDataType *p;
	size_t k = sizeof(struct xenc__EncryptedDataType);
	if (n < 0)
	{	p = SOAP_NEW(struct xenc__EncryptedDataType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct xenc__EncryptedDataType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__EncryptedDataType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_xenc__EncryptedDataType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedDataType(struct soap *soap, const struct xenc__EncryptedDataType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptedDataType(soap, tag?tag:"xenc:EncryptedDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedDataType * SOAP_FMAC4 soap_get_xenc__EncryptedDataType(struct soap *soap, struct xenc__EncryptedDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__TransformsType(struct soap *soap, struct xenc__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__ds__Transform(soap, &a->ds__Transform);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__TransformsType(struct soap *soap, const struct xenc__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ds__Transform(soap, &a->ds__Transform);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__TransformsType(struct soap *soap, const char *tag, int id, const struct xenc__TransformsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__TransformsType), type))
		return soap->error;
	if (soap_out__ds__Transform(soap, "ds:Transform", -1, &a->ds__Transform, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_in_xenc__TransformsType(struct soap *soap, const char *tag, struct xenc__TransformsType *a, const char *type)
{
	size_t soap_flag_ds__Transform = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__TransformsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ds__Transform && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ds__Transform(soap, "ds:Transform", &a->ds__Transform, ""))
				{	soap_flag_ds__Transform--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ds__Transform > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__TransformsType, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__TransformsType * SOAP_FMAC2 soap_instantiate_xenc__TransformsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__TransformsType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__TransformsType *p;
	size_t k = sizeof(struct xenc__TransformsType);
	if (n < 0)
	{	p = SOAP_NEW(struct xenc__TransformsType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct xenc__TransformsType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__TransformsType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_xenc__TransformsType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__TransformsType(struct soap *soap, const struct xenc__TransformsType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__TransformsType(soap, tag?tag:"xenc:TransformsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_get_xenc__TransformsType(struct soap *soap, struct xenc__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__CipherReferenceType(struct soap *soap, const struct xenc__CipherReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__TransformsType(soap, &a->Transforms);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__CipherReferenceType(struct soap *soap, const char *tag, int id, const struct xenc__CipherReferenceType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", soap_string2s(soap, a->URI), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__CipherReferenceType), type))
		return soap->error;
	if (soap_out_PointerToxenc__TransformsType(soap, "xenc:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_in_xenc__CipherReferenceType(struct soap *soap, const char *tag, struct xenc__CipherReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__CipherReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__CipherReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1), &a->URI))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__TransformsType(soap, "xenc:Transforms", &a->Transforms, "xenc:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherReferenceType, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__CipherReferenceType * SOAP_FMAC2 soap_instantiate_xenc__CipherReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__CipherReferenceType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__CipherReferenceType *p;
	size_t k = sizeof(struct xenc__CipherReferenceType);
	if (n < 0)
	{	p = SOAP_NEW(struct xenc__CipherReferenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct xenc__CipherReferenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__CipherReferenceType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_xenc__CipherReferenceType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__CipherReferenceType(struct soap *soap, const struct xenc__CipherReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__CipherReferenceType(soap, tag?tag:"xenc:CipherReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_get_xenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__CipherReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->CipherValue);
	a->CipherReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__CipherDataType(struct soap *soap, const struct xenc__CipherDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->CipherValue);
	soap_serialize_PointerToxenc__CipherReferenceType(soap, &a->CipherReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__CipherDataType(struct soap *soap, const char *tag, int id, const struct xenc__CipherDataType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__CipherDataType), type))
		return soap->error;
	if (soap_out_string(soap, "xenc:CipherValue", -1, (char*const*)&a->CipherValue, ""))
		return soap->error;
	if (soap_out_PointerToxenc__CipherReferenceType(soap, "xenc:CipherReference", -1, &a->CipherReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_in_xenc__CipherDataType(struct soap *soap, const char *tag, struct xenc__CipherDataType *a, const char *type)
{
	size_t soap_flag_CipherValue = 1;
	size_t soap_flag_CipherReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__CipherDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__CipherDataType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CipherValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:CipherValue", (char**)&a->CipherValue, "xsd:string"))
				{	soap_flag_CipherValue--;
					continue;
				}
			if (soap_flag_CipherReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherReferenceType(soap, "xenc:CipherReference", &a->CipherReference, "xenc:CipherReferenceType"))
				{	soap_flag_CipherReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherDataType, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__CipherDataType * SOAP_FMAC2 soap_instantiate_xenc__CipherDataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__CipherDataType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__CipherDataType *p;
	size_t k = sizeof(struct xenc__CipherDataType);
	if (n < 0)
	{	p = SOAP_NEW(struct xenc__CipherDataType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct xenc__CipherDataType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__CipherDataType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_xenc__CipherDataType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__CipherDataType(struct soap *soap, const struct xenc__CipherDataType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__CipherDataType(soap, tag?tag:"xenc:CipherDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_get_xenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__CipherDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->KeySize = NULL;
	soap_default_string(soap, &a->OAEPparams);
	soap_default_string(soap, &a->Algorithm);
	a->ds__DigestMethod = NULL;
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionMethodType(struct soap *soap, const struct xenc__EncryptionMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->KeySize);
	soap_serialize_string(soap, (char*const*)&a->OAEPparams);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->ds__DigestMethod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionMethodType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", soap_string2s(soap, a->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "xenc:KeySize", -1, &a->KeySize, ""))
		return soap->error;
	if (soap_out_string(soap, "xenc:OAEPparams", -1, (char*const*)&a->OAEPparams, ""))
		return soap->error;
	if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->ds__DigestMethod, ""))
		return soap->error;
	soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_in_xenc__EncryptionMethodType(struct soap *soap, const char *tag, struct xenc__EncryptionMethodType *a, const char *type)
{
	size_t soap_flag_KeySize = 1;
	size_t soap_flag_OAEPparams = 1;
	size_t soap_flag_ds__DigestMethod = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptionMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeySize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "xenc:KeySize", &a->KeySize, "xsd:int"))
				{	soap_flag_KeySize--;
					continue;
				}
			if (soap_flag_OAEPparams && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:OAEPparams", (char**)&a->OAEPparams, "xsd:string"))
				{	soap_flag_OAEPparams--;
					continue;
				}
			if (soap_flag_ds__DigestMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->ds__DigestMethod, "ds:DigestMethodType"))
				{	soap_flag_ds__DigestMethod--;
					continue;
				}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionMethodType, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__EncryptionMethodType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptionMethodType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__EncryptionMethodType *p;
	size_t k = sizeof(struct xenc__EncryptionMethodType);
	if (n < 0)
	{	p = SOAP_NEW(struct xenc__EncryptionMethodType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct xenc__EncryptionMethodType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__EncryptionMethodType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_xenc__EncryptionMethodType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionMethodType(struct soap *soap, const struct xenc__EncryptionMethodType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptionMethodType(soap, tag?tag:"xenc:EncryptionMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_get_xenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedType(struct soap *soap, struct xenc__EncryptedType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedType(struct soap *soap, const struct xenc__EncryptedType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", soap_string2s(soap, a->MimeType), 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", soap_string2s(soap, a->Encoding), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (!a->CipherData)
	{	if (soap_element_nil(soap, "xenc:CipherData"))
			return soap->error;
	}
	else
	if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedType * SOAP_FMAC4 soap_in_xenc__EncryptedType(struct soap *soap, const char *tag, struct xenc__EncryptedType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptedType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedType, sizeof(struct xenc__EncryptedType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 0), &a->MimeType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CipherData > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptedType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedType, SOAP_TYPE_xenc__EncryptedType, sizeof(struct xenc__EncryptedType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct xenc__EncryptedType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptedType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct xenc__EncryptedType *p;
	size_t k = sizeof(struct xenc__EncryptedType);
	if (n < 0)
	{	p = SOAP_NEW(struct xenc__EncryptedType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct xenc__EncryptedType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct xenc__EncryptedType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_xenc__EncryptedType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedType(struct soap *soap, const struct xenc__EncryptedType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptedType(soap, tag?tag:"xenc:EncryptedType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedType * SOAP_FMAC4 soap_get_xenc__EncryptedType(struct soap *soap, struct xenc__EncryptedType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Modulus);
	soap_default_string(soap, &a->Exponent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Modulus);
	soap_serialize_string(soap, (char*const*)&a->Exponent);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__RSAKeyValueType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RSAKeyValueType), type))
		return soap->error;
	if (!a->Modulus)
	{	if (soap_element_nil(soap, "ds:Modulus"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ds:Modulus", -1, (char*const*)&a->Modulus, ""))
		return soap->error;
	if (!a->Exponent)
	{	if (soap_element_nil(soap, "ds:Exponent"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ds:Exponent", -1, (char*const*)&a->Exponent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_in_ds__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType *a, const char *type)
{
	size_t soap_flag_Modulus = 1;
	size_t soap_flag_Exponent = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Modulus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Modulus", (char**)&a->Modulus, "xsd:string"))
				{	soap_flag_Modulus--;
					continue;
				}
			if (soap_flag_Exponent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Exponent", (char**)&a->Exponent, "xsd:string"))
				{	soap_flag_Exponent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Modulus > 0 || soap_flag_Exponent > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RSAKeyValueType, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__RSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__RSAKeyValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__RSAKeyValueType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__RSAKeyValueType *p;
	size_t k = sizeof(struct ds__RSAKeyValueType);
	if (n < 0)
	{	p = SOAP_NEW(struct ds__RSAKeyValueType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ds__RSAKeyValueType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__RSAKeyValueType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ds__RSAKeyValueType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a, const char *tag, const char *type)
{
	if (soap_out_ds__RSAKeyValueType(soap, tag?tag:"ds:RSAKeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_get_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->G);
	soap_default_string(soap, &a->Y);
	soap_default_string(soap, &a->J);
	soap_default_string(soap, &a->P);
	soap_default_string(soap, &a->Q);
	soap_default_string(soap, &a->Seed);
	soap_default_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->G);
	soap_serialize_string(soap, (char*const*)&a->Y);
	soap_serialize_string(soap, (char*const*)&a->J);
	soap_serialize_string(soap, (char*const*)&a->P);
	soap_serialize_string(soap, (char*const*)&a->Q);
	soap_serialize_string(soap, (char*const*)&a->Seed);
	soap_serialize_string(soap, (char*const*)&a->PgenCounter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__DSAKeyValueType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DSAKeyValueType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:G", -1, (char*const*)&a->G, ""))
		return soap->error;
	if (!a->Y)
	{	if (soap_element_nil(soap, "ds:Y"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ds:Y", -1, (char*const*)&a->Y, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:J", -1, (char*const*)&a->J, ""))
		return soap->error;
	if (!a->P)
	{	if (soap_element_nil(soap, "ds:P"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ds:P", -1, (char*const*)&a->P, ""))
		return soap->error;
	if (!a->Q)
	{	if (soap_element_nil(soap, "ds:Q"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ds:Q", -1, (char*const*)&a->Q, ""))
		return soap->error;
	if (!a->Seed)
	{	if (soap_element_nil(soap, "ds:Seed"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ds:Seed", -1, (char*const*)&a->Seed, ""))
		return soap->error;
	if (!a->PgenCounter)
	{	if (soap_element_nil(soap, "ds:PgenCounter"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ds:PgenCounter", -1, (char*const*)&a->PgenCounter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_in_ds__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType *a, const char *type)
{
	size_t soap_flag_G = 1;
	size_t soap_flag_Y = 1;
	size_t soap_flag_J = 1;
	size_t soap_flag_P = 1;
	size_t soap_flag_Q = 1;
	size_t soap_flag_Seed = 1;
	size_t soap_flag_PgenCounter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_G && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:G", (char**)&a->G, "xsd:string"))
				{	soap_flag_G--;
					continue;
				}
			if (soap_flag_Y && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Y", (char**)&a->Y, "xsd:string"))
				{	soap_flag_Y--;
					continue;
				}
			if (soap_flag_J && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:J", (char**)&a->J, "xsd:string"))
				{	soap_flag_J--;
					continue;
				}
			if (soap_flag_P && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:P", (char**)&a->P, "xsd:string"))
				{	soap_flag_P--;
					continue;
				}
			if (soap_flag_Q && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Q", (char**)&a->Q, "xsd:string"))
				{	soap_flag_Q--;
					continue;
				}
			if (soap_flag_Seed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Seed", (char**)&a->Seed, "xsd:string"))
				{	soap_flag_Seed--;
					continue;
				}
			if (soap_flag_PgenCounter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:PgenCounter", (char**)&a->PgenCounter, "xsd:string"))
				{	soap_flag_PgenCounter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Y > 0 || soap_flag_P > 0 || soap_flag_Q > 0 || soap_flag_Seed > 0 || soap_flag_PgenCounter > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DSAKeyValueType, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__DSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__DSAKeyValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__DSAKeyValueType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__DSAKeyValueType *p;
	size_t k = sizeof(struct ds__DSAKeyValueType);
	if (n < 0)
	{	p = SOAP_NEW(struct ds__DSAKeyValueType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ds__DSAKeyValueType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__DSAKeyValueType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ds__DSAKeyValueType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a, const char *tag, const char *type)
{
	if (soap_out_ds__DSAKeyValueType(soap, tag?tag:"ds:DSAKeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_get_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->X509IssuerName);
	soap_default_string(soap, &a->X509SerialNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->X509IssuerName);
	soap_serialize_string(soap, (char*const*)&a->X509SerialNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509IssuerSerialType(struct soap *soap, const char *tag, int id, const struct ds__X509IssuerSerialType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509IssuerSerialType), type))
		return soap->error;
	if (!a->X509IssuerName)
	{	if (soap_element_nil(soap, "ds:X509IssuerName"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ds:X509IssuerName", -1, (char*const*)&a->X509IssuerName, ""))
		return soap->error;
	if (!a->X509SerialNumber)
	{	if (soap_element_nil(soap, "ds:X509SerialNumber"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ds:X509SerialNumber", -1, (char*const*)&a->X509SerialNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_in_ds__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType *a, const char *type)
{
	size_t soap_flag_X509IssuerName = 1;
	size_t soap_flag_X509SerialNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509IssuerSerialType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509IssuerSerialType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509IssuerName", (char**)&a->X509IssuerName, "xsd:string"))
				{	soap_flag_X509IssuerName--;
					continue;
				}
			if (soap_flag_X509SerialNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SerialNumber", (char**)&a->X509SerialNumber, "xsd:string"))
				{	soap_flag_X509SerialNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X509IssuerName > 0 || soap_flag_X509SerialNumber > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509IssuerSerialType, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__X509IssuerSerialType * SOAP_FMAC2 soap_instantiate_ds__X509IssuerSerialType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__X509IssuerSerialType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__X509IssuerSerialType *p;
	size_t k = sizeof(struct ds__X509IssuerSerialType);
	if (n < 0)
	{	p = SOAP_NEW(struct ds__X509IssuerSerialType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ds__X509IssuerSerialType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__X509IssuerSerialType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ds__X509IssuerSerialType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a, const char *tag, const char *type)
{
	if (soap_out_ds__X509IssuerSerialType(soap, tag?tag:"ds:X509IssuerSerialType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_get_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RetrievalMethodType(struct soap *soap, const char *tag, int id, const struct ds__RetrievalMethodType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", soap_string2s(soap, a->URI), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RetrievalMethodType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_in_ds__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RetrievalMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RetrievalMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RetrievalMethodType, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__RetrievalMethodType * SOAP_FMAC2 soap_instantiate_ds__RetrievalMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__RetrievalMethodType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__RetrievalMethodType *p;
	size_t k = sizeof(struct ds__RetrievalMethodType);
	if (n < 0)
	{	p = SOAP_NEW(struct ds__RetrievalMethodType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ds__RetrievalMethodType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__RetrievalMethodType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ds__RetrievalMethodType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a, const char *tag, const char *type)
{
	if (soap_out_ds__RetrievalMethodType(soap, tag?tag:"ds:RetrievalMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_get_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DSAKeyValue = NULL;
	a->RSAKeyValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__DSAKeyValueType(soap, &a->DSAKeyValue);
	soap_serialize_PointerTods__RSAKeyValueType(soap, &a->RSAKeyValue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyValueType(struct soap *soap, const char *tag, int id, const struct ds__KeyValueType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyValueType), type))
		return soap->error;
	if (soap_out_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", -1, &a->DSAKeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", -1, &a->RSAKeyValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_in_ds__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType *a, const char *type)
{
	size_t soap_flag_DSAKeyValue = 1;
	size_t soap_flag_RSAKeyValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", &a->DSAKeyValue, "ds:DSAKeyValueType"))
				{	soap_flag_DSAKeyValue--;
					continue;
				}
			if (soap_flag_RSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", &a->RSAKeyValue, "ds:RSAKeyValueType"))
				{	soap_flag_RSAKeyValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyValueType, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__KeyValueType * SOAP_FMAC2 soap_instantiate_ds__KeyValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__KeyValueType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__KeyValueType *p;
	size_t k = sizeof(struct ds__KeyValueType);
	if (n < 0)
	{	p = SOAP_NEW(struct ds__KeyValueType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ds__KeyValueType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__KeyValueType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ds__KeyValueType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a, const char *tag, const char *type)
{
	if (soap_out_ds__KeyValueType(soap, tag?tag:"ds:KeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_get_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DigestMethodType(struct soap *soap, const char *tag, int id, const struct ds__DigestMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", soap_string2s(soap, a->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DigestMethodType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_in_ds__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DigestMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DigestMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DigestMethodType, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__DigestMethodType * SOAP_FMAC2 soap_instantiate_ds__DigestMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__DigestMethodType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__DigestMethodType *p;
	size_t k = sizeof(struct ds__DigestMethodType);
	if (n < 0)
	{	p = SOAP_NEW(struct ds__DigestMethodType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ds__DigestMethodType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__DigestMethodType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ds__DigestMethodType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a, const char *tag, const char *type)
{
	if (soap_out_ds__DigestMethodType(soap, tag?tag:"ds:DigestMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_get_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformType(struct soap *soap, struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->c14n__InclusiveNamespaces = NULL;
	a->__any = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformType(struct soap *soap, const struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformType(struct soap *soap, const char *tag, int id, const struct ds__TransformType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", soap_string2s(soap, a->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_in_ds__TransformType(struct soap *soap, const char *tag, struct ds__TransformType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 0), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformType, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__TransformType * SOAP_FMAC2 soap_instantiate_ds__TransformType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__TransformType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__TransformType *p;
	size_t k = sizeof(struct ds__TransformType);
	if (n < 0)
	{	p = SOAP_NEW(struct ds__TransformType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ds__TransformType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__TransformType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ds__TransformType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformType(struct soap *soap, const struct ds__TransformType *a, const char *tag, const char *type)
{
	if (soap_out_ds__TransformType(soap, tag?tag:"ds:TransformType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_get_ds__TransformType(struct soap *soap, struct ds__TransformType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->PrefixList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, const struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (a->PrefixList)
		soap_set_attr(soap, "PrefixList", soap_string2s(soap, a->PrefixList), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__c14n__InclusiveNamespaces), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_in__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _c14n__InclusiveNamespaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__c14n__InclusiveNamespaces(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PrefixList", 0), &a->PrefixList))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__c14n__InclusiveNamespaces, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _c14n__InclusiveNamespaces * SOAP_FMAC2 soap_instantiate__c14n__InclusiveNamespaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__c14n__InclusiveNamespaces(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _c14n__InclusiveNamespaces *p;
	size_t k = sizeof(struct _c14n__InclusiveNamespaces);
	if (n < 0)
	{	p = SOAP_NEW(struct _c14n__InclusiveNamespaces);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct _c14n__InclusiveNamespaces, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _c14n__InclusiveNamespaces location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__c14n__InclusiveNamespaces, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a, const char *tag, const char *type)
{
	if (soap_out__c14n__InclusiveNamespaces(soap, tag?tag:"c14n:InclusiveNamespaces", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_get__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformsType(struct soap *soap, struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTransform = 0;
	a->Transform = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Transform)
	{	int i;
		for (i = 0; i < (int)a->__sizeTransform; i++)
		{
			soap_embedded(soap, a->Transform + i, SOAP_TYPE_ds__TransformType);
			soap_serialize_ds__TransformType(soap, a->Transform + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformsType(struct soap *soap, const char *tag, int id, const struct ds__TransformsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformsType), type))
		return soap->error;
	if (a->Transform)
	{	int i;
		for (i = 0; i < (int)a->__sizeTransform; i++)
			if (soap_out_ds__TransformType(soap, "ds:Transform", -1, a->Transform + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_in_ds__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType *a, const char *type)
{
	struct soap_blist *soap_blist_Transform = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Transform", 1, NULL))
			{	if (a->Transform == NULL)
				{	if (soap_blist_Transform == NULL)
						soap_blist_Transform = soap_new_block(soap);
					a->Transform = soap_block<struct ds__TransformType>::push(soap, soap_blist_Transform);
					if (a->Transform == NULL)
						return NULL;
					soap_default_ds__TransformType(soap, a->Transform);
				}
				soap_revert(soap);
				if (soap_in_ds__TransformType(soap, "ds:Transform", a->Transform, "ds:TransformType"))
				{	a->__sizeTransform++;
					a->Transform = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Transform)
			soap_block<struct ds__TransformType>::pop(soap, soap_blist_Transform);
		if (a->__sizeTransform)
		{	a->Transform = soap_new_ds__TransformType(soap, a->__sizeTransform);
			if (!a->Transform)
				return NULL;
			soap_block<struct ds__TransformType>::save(soap, soap_blist_Transform, a->Transform);
		}
		else
		{	a->Transform = NULL;
			if (soap_blist_Transform)
				soap_block<struct ds__TransformType>::end(soap, soap_blist_Transform);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformsType, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__TransformsType * SOAP_FMAC2 soap_instantiate_ds__TransformsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__TransformsType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__TransformsType *p;
	size_t k = sizeof(struct ds__TransformsType);
	if (n < 0)
	{	p = SOAP_NEW(struct ds__TransformsType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ds__TransformsType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__TransformsType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ds__TransformsType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a, const char *tag, const char *type)
{
	if (soap_out_ds__TransformsType(soap, tag?tag:"ds:TransformsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_get_ds__TransformsType(struct soap *soap, struct ds__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	a->DigestMethod = NULL;
	soap_default_string(soap, &a->DigestValue);
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->DigestMethod);
	soap_serialize_string(soap, (char*const*)&a->DigestValue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__ReferenceType(struct soap *soap, const char *tag, int id, const struct ds__ReferenceType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	if (a->URI)
		soap_set_attr(soap, "URI", soap_string2s(soap, a->URI), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__ReferenceType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	if (!a->DigestMethod)
	{	if (soap_element_nil(soap, "ds:DigestMethod"))
			return soap->error;
	}
	else
	if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->DigestMethod, ""))
		return soap->error;
	if (!a->DigestValue)
	{	if (soap_element_nil(soap, "ds:DigestValue"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ds:DigestValue", -1, (char*const*)&a->DigestValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_in_ds__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	size_t soap_flag_DigestMethod = 1;
	size_t soap_flag_DigestValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap_flag_DigestMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->DigestMethod, "ds:DigestMethodType"))
				{	soap_flag_DigestMethod--;
					continue;
				}
			if (soap_flag_DigestValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:DigestValue", (char**)&a->DigestValue, "xsd:string"))
				{	soap_flag_DigestValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DigestMethod > 0 || soap_flag_DigestValue > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__ReferenceType, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__ReferenceType * SOAP_FMAC2 soap_instantiate_ds__ReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__ReferenceType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__ReferenceType *p;
	size_t k = sizeof(struct ds__ReferenceType);
	if (n < 0)
	{	p = SOAP_NEW(struct ds__ReferenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ds__ReferenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__ReferenceType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ds__ReferenceType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_ds__ReferenceType(soap, tag?tag:"ds:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_get_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HMACOutputLength = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->HMACOutputLength);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureMethodType(struct soap *soap, const char *tag, int id, const struct ds__SignatureMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", soap_string2s(soap, a->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ds:HMACOutputLength", -1, &a->HMACOutputLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_in_ds__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType *a, const char *type)
{
	size_t soap_flag_HMACOutputLength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HMACOutputLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ds:HMACOutputLength", &a->HMACOutputLength, "xsd:int"))
				{	soap_flag_HMACOutputLength--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureMethodType, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__SignatureMethodType * SOAP_FMAC2 soap_instantiate_ds__SignatureMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__SignatureMethodType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__SignatureMethodType *p;
	size_t k = sizeof(struct ds__SignatureMethodType);
	if (n < 0)
	{	p = SOAP_NEW(struct ds__SignatureMethodType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ds__SignatureMethodType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__SignatureMethodType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ds__SignatureMethodType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a, const char *tag, const char *type)
{
	if (soap_out_ds__SignatureMethodType(soap, tag?tag:"ds:SignatureMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_get_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
	a->c14n__InclusiveNamespaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, const struct ds__CanonicalizationMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", soap_string2s(soap, a->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__CanonicalizationMethodType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_in_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__CanonicalizationMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__CanonicalizationMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__CanonicalizationMethodType, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__CanonicalizationMethodType * SOAP_FMAC2 soap_instantiate_ds__CanonicalizationMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__CanonicalizationMethodType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__CanonicalizationMethodType *p;
	size_t k = sizeof(struct ds__CanonicalizationMethodType);
	if (n < 0)
	{	p = SOAP_NEW(struct ds__CanonicalizationMethodType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ds__CanonicalizationMethodType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__CanonicalizationMethodType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ds__CanonicalizationMethodType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a, const char *tag, const char *type)
{
	if (soap_out_ds__CanonicalizationMethodType(soap, tag?tag:"ds:CanonicalizationMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_get_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->KeyName);
	a->KeyValue = NULL;
	a->RetrievalMethod = NULL;
	a->X509Data = NULL;
	a->wsse__SecurityTokenReference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->KeyName);
	soap_serialize_PointerTods__KeyValueType(soap, &a->KeyValue);
	soap_serialize_PointerTods__RetrievalMethodType(soap, &a->RetrievalMethod);
	soap_serialize_PointerTods__X509DataType(soap, &a->X509Data);
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyInfoType(struct soap *soap, const char *tag, int id, const struct ds__KeyInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyInfoType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:KeyName", -1, (char*const*)&a->KeyName, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyValueType(soap, "ds:KeyValue", -1, &a->KeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", -1, &a->RetrievalMethod, ""))
		return soap->error;
	if (soap_out_PointerTods__X509DataType(soap, "ds:X509Data", -1, &a->X509Data, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_in_ds__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType *a, const char *type)
{
	size_t soap_flag_KeyName = 1;
	size_t soap_flag_KeyValue = 1;
	size_t soap_flag_RetrievalMethod = 1;
	size_t soap_flag_X509Data = 1;
	size_t soap_flag_wsse__SecurityTokenReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:KeyName", (char**)&a->KeyName, "xsd:string"))
				{	soap_flag_KeyName--;
					continue;
				}
			if (soap_flag_KeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyValueType(soap, "ds:KeyValue", &a->KeyValue, "ds:KeyValueType"))
				{	soap_flag_KeyValue--;
					continue;
				}
			if (soap_flag_RetrievalMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", &a->RetrievalMethod, "ds:RetrievalMethodType"))
				{	soap_flag_RetrievalMethod--;
					continue;
				}
			if (soap_flag_X509Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509DataType(soap, "ds:X509Data", &a->X509Data, "ds:X509DataType"))
				{	soap_flag_X509Data--;
					continue;
				}
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
				{	soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyInfoType, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__KeyInfoType * SOAP_FMAC2 soap_instantiate_ds__KeyInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__KeyInfoType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__KeyInfoType *p;
	size_t k = sizeof(struct ds__KeyInfoType);
	if (n < 0)
	{	p = SOAP_NEW(struct ds__KeyInfoType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ds__KeyInfoType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__KeyInfoType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ds__KeyInfoType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a, const char *tag, const char *type)
{
	if (soap_out_ds__KeyInfoType(soap, tag?tag:"ds:KeyInfoType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_get_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CanonicalizationMethod = NULL;
	a->SignatureMethod = NULL;
	a->__sizeReference = 0;
	a->Reference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__CanonicalizationMethodType(soap, &a->CanonicalizationMethod);
	soap_serialize_PointerTods__SignatureMethodType(soap, &a->SignatureMethod);
	if (a->Reference)
	{	int i;
		for (i = 0; i < (int)a->__sizeReference; i++)
		{
			soap_serialize_PointerTods__ReferenceType(soap, a->Reference + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignedInfoType(struct soap *soap, const char *tag, int id, const struct ds__SignedInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignedInfoType), type))
		return soap->error;
	if (!a->CanonicalizationMethod)
	{	if (soap_element_nil(soap, "ds:CanonicalizationMethod"))
			return soap->error;
	}
	else
	if (soap_out_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", -1, &a->CanonicalizationMethod, ""))
		return soap->error;
	if (!a->SignatureMethod)
	{	if (soap_element_nil(soap, "ds:SignatureMethod"))
			return soap->error;
	}
	else
	if (soap_out_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", -1, &a->SignatureMethod, ""))
		return soap->error;
	if (a->Reference)
	{	int i;
		for (i = 0; i < (int)a->__sizeReference; i++)
			if (soap_out_PointerTods__ReferenceType(soap, "ds:Reference", -1, a->Reference + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_in_ds__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType *a, const char *type)
{
	size_t soap_flag_CanonicalizationMethod = 1;
	size_t soap_flag_SignatureMethod = 1;
	struct soap_blist *soap_blist_Reference = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignedInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignedInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CanonicalizationMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", &a->CanonicalizationMethod, "ds:CanonicalizationMethodType"))
				{	soap_flag_CanonicalizationMethod--;
					continue;
				}
			if (soap_flag_SignatureMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", &a->SignatureMethod, "ds:SignatureMethodType"))
				{	soap_flag_SignatureMethod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Reference", 1, NULL))
			{	if (a->Reference == NULL)
				{	if (soap_blist_Reference == NULL)
						soap_blist_Reference = soap_new_block(soap);
					a->Reference = (struct ds__ReferenceType **)soap_push_block_max(soap, soap_blist_Reference, sizeof(struct ds__ReferenceType *));
					if (a->Reference == NULL)
						return NULL;
					*a->Reference = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTods__ReferenceType(soap, "ds:Reference", a->Reference, "ds:ReferenceType"))
				{	a->__sizeReference++;
					a->Reference = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Reference)
			soap_pop_block(soap, soap_blist_Reference);
		if (a->__sizeReference)
		{	a->Reference = (struct ds__ReferenceType **)soap_save_block(soap, soap_blist_Reference, NULL, 1);
		}
		else
		{	a->Reference = NULL;
			if (soap_blist_Reference)
				soap_end_block(soap, soap_blist_Reference);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CanonicalizationMethod > 0 || soap_flag_SignatureMethod > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignedInfoType, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__SignedInfoType * SOAP_FMAC2 soap_instantiate_ds__SignedInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__SignedInfoType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__SignedInfoType *p;
	size_t k = sizeof(struct ds__SignedInfoType);
	if (n < 0)
	{	p = SOAP_NEW(struct ds__SignedInfoType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ds__SignedInfoType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__SignedInfoType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ds__SignedInfoType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a, const char *tag, const char *type)
{
	if (soap_out_ds__SignedInfoType(soap, tag?tag:"ds:SignedInfoType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_get_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureType(struct soap *soap, struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SignedInfo = NULL;
	soap_default__ds__SignatureValue(soap, &a->SignatureValue);
	a->KeyInfo = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__SignedInfoType(soap, &a->SignedInfo);
	soap_serialize__ds__SignatureValue(soap, (char*const*)&a->SignatureValue);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->KeyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureType(struct soap *soap, const char *tag, int id, const struct ds__SignatureType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureType), type))
		return soap->error;
	if (soap_out_PointerTods__SignedInfoType(soap, "ds:SignedInfo", -1, &a->SignedInfo, ""))
		return soap->error;
	if (soap_out__ds__SignatureValue(soap, "ds:SignatureValue", -1, (char*const*)&a->SignatureValue, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "ds:KeyInfo", -1, &a->KeyInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_in_ds__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType *a, const char *type)
{
	size_t soap_flag_SignedInfo = 1;
	size_t soap_flag_SignatureValue = 1;
	size_t soap_flag_KeyInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SignedInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignedInfoType(soap, "ds:SignedInfo", &a->SignedInfo, "ds:SignedInfoType"))
				{	soap_flag_SignedInfo--;
					continue;
				}
			if (soap_flag_SignatureValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__ds__SignatureValue(soap, "ds:SignatureValue", (char**)&a->SignatureValue, ""))
				{	soap_flag_SignatureValue--;
					continue;
				}
			if (soap_flag_KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "ds:KeyInfo", &a->KeyInfo, "ds:KeyInfoType"))
				{	soap_flag_KeyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureType, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__SignatureType * SOAP_FMAC2 soap_instantiate_ds__SignatureType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__SignatureType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__SignatureType *p;
	size_t k = sizeof(struct ds__SignatureType);
	if (n < 0)
	{	p = SOAP_NEW(struct ds__SignatureType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ds__SignatureType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__SignatureType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ds__SignatureType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a, const char *tag, const char *type)
{
	if (soap_out_ds__SignatureType(soap, tag?tag:"ds:SignatureType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_get_ds__SignatureType(struct soap *soap, struct ds__SignatureType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509DataType(struct soap *soap, struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->X509IssuerSerial = NULL;
	soap_default_string(soap, &a->X509SKI);
	soap_default_string(soap, &a->X509SubjectName);
	soap_default_string(soap, &a->X509Certificate);
	soap_default_string(soap, &a->X509CRL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__X509IssuerSerialType(soap, &a->X509IssuerSerial);
	soap_serialize_string(soap, (char*const*)&a->X509SKI);
	soap_serialize_string(soap, (char*const*)&a->X509SubjectName);
	soap_serialize_string(soap, (char*const*)&a->X509Certificate);
	soap_serialize_string(soap, (char*const*)&a->X509CRL);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509DataType(struct soap *soap, const char *tag, int id, const struct ds__X509DataType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509DataType), type))
		return soap->error;
	if (soap_out_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", -1, &a->X509IssuerSerial, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509SKI", -1, (char*const*)&a->X509SKI, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509SubjectName", -1, (char*const*)&a->X509SubjectName, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509Certificate", -1, (char*const*)&a->X509Certificate, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509CRL", -1, (char*const*)&a->X509CRL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_in_ds__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType *a, const char *type)
{
	size_t soap_flag_X509IssuerSerial = 1;
	size_t soap_flag_X509SKI = 1;
	size_t soap_flag_X509SubjectName = 1;
	size_t soap_flag_X509Certificate = 1;
	size_t soap_flag_X509CRL = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509DataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509DataType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerSerial && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", &a->X509IssuerSerial, "ds:X509IssuerSerialType"))
				{	soap_flag_X509IssuerSerial--;
					continue;
				}
			if (soap_flag_X509SKI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SKI", (char**)&a->X509SKI, "xsd:string"))
				{	soap_flag_X509SKI--;
					continue;
				}
			if (soap_flag_X509SubjectName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SubjectName", (char**)&a->X509SubjectName, "xsd:string"))
				{	soap_flag_X509SubjectName--;
					continue;
				}
			if (soap_flag_X509Certificate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509Certificate", (char**)&a->X509Certificate, "xsd:string"))
				{	soap_flag_X509Certificate--;
					continue;
				}
			if (soap_flag_X509CRL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509CRL", (char**)&a->X509CRL, "xsd:string"))
				{	soap_flag_X509CRL--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509DataType, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ds__X509DataType * SOAP_FMAC2 soap_instantiate_ds__X509DataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__X509DataType(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ds__X509DataType *p;
	size_t k = sizeof(struct ds__X509DataType);
	if (n < 0)
	{	p = SOAP_NEW(struct ds__X509DataType);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ds__X509DataType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ds__X509DataType location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ds__X509DataType, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a, const char *tag, const char *type)
{
	if (soap_out_ds__X509DataType(soap, tag?tag:"ds:X509DataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_get_ds__X509DataType(struct soap *soap, struct ds__X509DataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Reference = NULL;
	a->KeyIdentifier = NULL;
	a->Embedded = NULL;
	a->ds__X509Data = NULL;
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->wsc__Instance);
	soap_default_string(soap, &a->Usage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsse__Reference(soap, &a->Reference);
	soap_serialize_PointerTo_wsse__KeyIdentifier(soap, &a->KeyIdentifier);
	soap_serialize_PointerTo_wsse__Embedded(soap, &a->Embedded);
	soap_serialize_PointerTods__X509DataType(soap, &a->ds__X509Data);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, const struct _wsse__SecurityTokenReference *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	if (a->wsc__Instance)
		soap_set_attr(soap, "wsc:Instance", soap_string2s(soap, a->wsc__Instance), 1);
	if (a->Usage)
		soap_set_attr(soap, "Usage", soap_string2s(soap, a->Usage), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__SecurityTokenReference), type))
		return soap->error;
	if (soap_out_PointerTo_wsse__Reference(soap, "wsse:Reference", -1, &a->Reference, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", -1, &a->KeyIdentifier, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Embedded(soap, "wsse:Embedded", -1, &a->Embedded, ""))
		return soap->error;
	if (soap_out_PointerTods__X509DataType(soap, "ds:X509Data", -1, &a->ds__X509Data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_in__wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference *a, const char *type)
{
	size_t soap_flag_Reference = 1;
	size_t soap_flag_KeyIdentifier = 1;
	size_t soap_flag_Embedded = 1;
	size_t soap_flag_ds__X509Data = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__SecurityTokenReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__SecurityTokenReference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "wsc:Instance", 0), &a->wsc__Instance))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Usage", 0), &a->Usage))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Reference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Reference(soap, "wsse:Reference", &a->Reference, ""))
				{	soap_flag_Reference--;
					continue;
				}
			if (soap_flag_KeyIdentifier && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", &a->KeyIdentifier, ""))
				{	soap_flag_KeyIdentifier--;
					continue;
				}
			if (soap_flag_Embedded && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Embedded(soap, "wsse:Embedded", &a->Embedded, ""))
				{	soap_flag_Embedded--;
					continue;
				}
			if (soap_flag_ds__X509Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509DataType(soap, "ds:X509Data", &a->ds__X509Data, "ds:X509DataType"))
				{	soap_flag_ds__X509Data--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__SecurityTokenReference, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsse__SecurityTokenReference * SOAP_FMAC2 soap_instantiate__wsse__SecurityTokenReference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__SecurityTokenReference(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__SecurityTokenReference *p;
	size_t k = sizeof(struct _wsse__SecurityTokenReference);
	if (n < 0)
	{	p = SOAP_NEW(struct _wsse__SecurityTokenReference);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct _wsse__SecurityTokenReference, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__SecurityTokenReference location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__wsse__SecurityTokenReference, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a, const char *tag, const char *type)
{
	if (soap_out__wsse__SecurityTokenReference(soap, tag?tag:"wsse:SecurityTokenReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_get__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, const struct _wsse__KeyIdentifier *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", soap_string2s(soap, a->ValueType), 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", soap_string2s(soap, a->EncodingType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_in__wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__KeyIdentifier *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__KeyIdentifier(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC1 struct _wsse__KeyIdentifier * SOAP_FMAC2 soap_instantiate__wsse__KeyIdentifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__KeyIdentifier(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__KeyIdentifier *p;
	size_t k = sizeof(struct _wsse__KeyIdentifier);
	if (n < 0)
	{	p = SOAP_NEW(struct _wsse__KeyIdentifier);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct _wsse__KeyIdentifier, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__KeyIdentifier location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__wsse__KeyIdentifier, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a, const char *tag, const char *type)
{
	if (soap_out__wsse__KeyIdentifier(soap, tag?tag:"wsse:KeyIdentifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_get__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Embedded(struct soap *soap, const char *tag, int id, const struct _wsse__Embedded *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", soap_string2s(soap, a->ValueType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Embedded), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_in__wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Embedded *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Embedded(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Embedded, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsse__Embedded * SOAP_FMAC2 soap_instantiate__wsse__Embedded(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Embedded(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__Embedded *p;
	size_t k = sizeof(struct _wsse__Embedded);
	if (n < 0)
	{	p = SOAP_NEW(struct _wsse__Embedded);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct _wsse__Embedded, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__Embedded location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__wsse__Embedded, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a, const char *tag, const char *type)
{
	if (soap_out__wsse__Embedded(soap, tag?tag:"wsse:Embedded", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_get__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Reference(struct soap *soap, struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Reference(struct soap *soap, const char *tag, int id, const struct _wsse__Reference *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", soap_string2s(soap, a->URI), 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", soap_string2s(soap, a->ValueType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Reference), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_in__wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Reference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Reference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Reference, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsse__Reference * SOAP_FMAC2 soap_instantiate__wsse__Reference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Reference(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__Reference *p;
	size_t k = sizeof(struct _wsse__Reference);
	if (n < 0)
	{	p = SOAP_NEW(struct _wsse__Reference);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct _wsse__Reference, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__Reference location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__wsse__Reference, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a, const char *tag, const char *type)
{
	if (soap_out__wsse__Reference(soap, tag?tag:"wsse:Reference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_get__wsse__Reference(struct soap *soap, struct _wsse__Reference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, const struct _wsse__BinarySecurityToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", soap_string2s(soap, a->ValueType), 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", soap_string2s(soap, a->EncodingType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_in__wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__BinarySecurityToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__BinarySecurityToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC1 struct _wsse__BinarySecurityToken * SOAP_FMAC2 soap_instantiate__wsse__BinarySecurityToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__BinarySecurityToken(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__BinarySecurityToken *p;
	size_t k = sizeof(struct _wsse__BinarySecurityToken);
	if (n < 0)
	{	p = SOAP_NEW(struct _wsse__BinarySecurityToken);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct _wsse__BinarySecurityToken, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__BinarySecurityToken location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__wsse__BinarySecurityToken, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a, const char *tag, const char *type)
{
	if (soap_out__wsse__BinarySecurityToken(soap, tag?tag:"wsse:BinarySecurityToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_get__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Password(struct soap *soap, struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Password(struct soap *soap, const struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Password(struct soap *soap, const char *tag, int id, const struct _wsse__Password *a, const char *type)
{
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_in__wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__Password *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__Password(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC1 struct _wsse__Password * SOAP_FMAC2 soap_instantiate__wsse__Password(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Password(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__Password *p;
	size_t k = sizeof(struct _wsse__Password);
	if (n < 0)
	{	p = SOAP_NEW(struct _wsse__Password);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct _wsse__Password, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__Password location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__wsse__Password, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Password(struct soap *soap, const struct _wsse__Password *a, const char *tag, const char *type)
{
	if (soap_out__wsse__Password(soap, tag?tag:"wsse:Password", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_get__wsse__Password(struct soap *soap, struct _wsse__Password *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	a->Password = NULL;
	a->Nonce = NULL;
	soap_default_string(soap, &a->wsu__Created);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Username);
	soap_serialize_PointerTo_wsse__Password(soap, &a->Password);
	soap_serialize_PointerTowsse__EncodedString(soap, &a->Nonce);
	soap_serialize_string(soap, (char*const*)&a->wsu__Created);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__UsernameToken(struct soap *soap, const char *tag, int id, const struct _wsse__UsernameToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__UsernameToken), type))
		return soap->error;
	if (soap_out_string(soap, "wsse:Username", -1, (char*const*)&a->Username, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Password(soap, "wsse:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_PointerTowsse__EncodedString(soap, "wsse:Nonce", -1, &a->Nonce, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, (char*const*)&a->wsu__Created, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_in__wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Nonce = 1;
	size_t soap_flag_wsu__Created = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__UsernameToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__UsernameToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsse:Username", (char**)&a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Password(soap, "wsse:Password", &a->Password, ""))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_Nonce && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsse__EncodedString(soap, "wsse:Nonce", &a->Nonce, "wsse:EncodedString"))
				{	soap_flag_Nonce--;
					continue;
				}
			if (soap_flag_wsu__Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Created", (char**)&a->wsu__Created, "xsd:string"))
				{	soap_flag_wsu__Created--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__UsernameToken, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsse__UsernameToken * SOAP_FMAC2 soap_instantiate__wsse__UsernameToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__UsernameToken(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsse__UsernameToken *p;
	size_t k = sizeof(struct _wsse__UsernameToken);
	if (n < 0)
	{	p = SOAP_NEW(struct _wsse__UsernameToken);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct _wsse__UsernameToken, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsse__UsernameToken location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__wsse__UsernameToken, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a, const char *tag, const char *type)
{
	if (soap_out__wsse__UsernameToken(soap, tag?tag:"wsse:UsernameToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_get__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsse__EncodedString(struct soap *soap, struct wsse__EncodedString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->EncodingType);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsse__EncodedString(struct soap *soap, const struct wsse__EncodedString *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsse__EncodedString(struct soap *soap, const char *tag, int id, const struct wsse__EncodedString *a, const char *type)
{
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", soap_string2s(soap, a->EncodingType), 1);
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsse__EncodedString * SOAP_FMAC4 soap_in_wsse__EncodedString(struct soap *soap, const char *tag, struct wsse__EncodedString *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsse__EncodedString *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsse__EncodedString, sizeof(struct wsse__EncodedString), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsse__EncodedString(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "wsse:EncodedString"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct wsse__EncodedString * SOAP_FMAC2 soap_instantiate_wsse__EncodedString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsse__EncodedString(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsse__EncodedString *p;
	size_t k = sizeof(struct wsse__EncodedString);
	if (n < 0)
	{	p = SOAP_NEW(struct wsse__EncodedString);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct wsse__EncodedString, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsse__EncodedString location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_wsse__EncodedString, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsse__EncodedString(struct soap *soap, const struct wsse__EncodedString *a, const char *tag, const char *type)
{
	if (soap_out_wsse__EncodedString(soap, tag?tag:"wsse:EncodedString", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsse__EncodedString * SOAP_FMAC4 soap_get_wsse__EncodedString(struct soap *soap, struct wsse__EncodedString *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsse__EncodedString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Created);
	soap_default_string(soap, &a->Expires);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Created);
	soap_serialize_string(soap, (char*const*)&a->Expires);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsu__Timestamp(struct soap *soap, const char *tag, int id, const struct _wsu__Timestamp *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsu__Timestamp), type))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, (char*const*)&a->Created, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Expires", -1, (char*const*)&a->Expires, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_in__wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp *a, const char *type)
{
	size_t soap_flag_Created = 1;
	size_t soap_flag_Expires = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsu__Timestamp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsu__Timestamp(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Created", (char**)&a->Created, "xsd:string"))
				{	soap_flag_Created--;
					continue;
				}
			if (soap_flag_Expires && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Expires", (char**)&a->Expires, "xsd:string"))
				{	soap_flag_Expires--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsu__Timestamp, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _wsu__Timestamp * SOAP_FMAC2 soap_instantiate__wsu__Timestamp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsu__Timestamp(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _wsu__Timestamp *p;
	size_t k = sizeof(struct _wsu__Timestamp);
	if (n < 0)
	{	p = SOAP_NEW(struct _wsu__Timestamp);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct _wsu__Timestamp, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _wsu__Timestamp location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE__wsu__Timestamp, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a, const char *tag, const char *type)
{
	if (soap_out__wsu__Timestamp(soap, tag?tag:"wsu:Timestamp", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_get__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsc__union_DerivedKeyTokenType(struct soap *soap, int choice, const union _wsc__union_DerivedKeyTokenType *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation:
		soap_embedded(soap, &a->Generation, SOAP_TYPE_ULONG64);
		break;
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset:
		soap_embedded(soap, &a->Offset, SOAP_TYPE_ULONG64);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsc__union_DerivedKeyTokenType(struct soap *soap, int choice, const union _wsc__union_DerivedKeyTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation:
		return soap_out_ULONG64(soap, "wsc:Generation", -1, &a->Generation, "");
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset:
		return soap_out_ULONG64(soap, "wsc:Offset", -1, &a->Offset, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _wsc__union_DerivedKeyTokenType * SOAP_FMAC4 soap_in__wsc__union_DerivedKeyTokenType(struct soap *soap, int *choice, union _wsc__union_DerivedKeyTokenType *a)
{
	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ULONG64(soap, "wsc:Generation", &a->Generation, "xsd:unsignedLong"))
	{	*choice = SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ULONG64(soap, "wsc:Offset", &a->Offset, "xsd:unsignedLong"))
	{	*choice = SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VCCustomData(struct soap *soap, ns2__VCCustomData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VCCustomData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VCCustomData(struct soap *soap, const char *tag, int id, ns2__VCCustomData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VCCustomData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__VCCustomData ** SOAP_FMAC4 soap_in_PointerTons2__VCCustomData(struct soap *soap, const char *tag, ns2__VCCustomData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__VCCustomData **)soap_malloc(soap, sizeof(ns2__VCCustomData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__VCCustomData *)soap_instantiate_ns2__VCCustomData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__VCCustomData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VCCustomData, sizeof(ns2__VCCustomData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VCCustomData(struct soap *soap, ns2__VCCustomData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__VCCustomData(soap, tag?tag:"ns2:VCCustomData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__VCCustomData ** SOAP_FMAC4 soap_get_PointerTons2__VCCustomData(struct soap *soap, ns2__VCCustomData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VCCustomData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VCCardArt(struct soap *soap, ns2__VCCardArt *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VCCardArt))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VCCardArt(struct soap *soap, const char *tag, int id, ns2__VCCardArt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VCCardArt, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__VCCardArt ** SOAP_FMAC4 soap_in_PointerTons2__VCCardArt(struct soap *soap, const char *tag, ns2__VCCardArt **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__VCCardArt **)soap_malloc(soap, sizeof(ns2__VCCardArt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__VCCardArt *)soap_instantiate_ns2__VCCardArt(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__VCCardArt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VCCardArt, sizeof(ns2__VCCardArt), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VCCardArt(struct soap *soap, ns2__VCCardArt *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__VCCardArt(soap, tag?tag:"ns2:VCCardArt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__VCCardArt ** SOAP_FMAC4 soap_get_PointerTons2__VCCardArt(struct soap *soap, ns2__VCCardArt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VCCardArt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PaypalTransaction(struct soap *soap, ns2__PaypalTransaction *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PaypalTransaction))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PaypalTransaction(struct soap *soap, const char *tag, int id, ns2__PaypalTransaction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PaypalTransaction, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PaypalTransaction ** SOAP_FMAC4 soap_in_PointerTons2__PaypalTransaction(struct soap *soap, const char *tag, ns2__PaypalTransaction **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PaypalTransaction **)soap_malloc(soap, sizeof(ns2__PaypalTransaction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PaypalTransaction *)soap_instantiate_ns2__PaypalTransaction(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PaypalTransaction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PaypalTransaction, sizeof(ns2__PaypalTransaction), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PaypalTransaction(struct soap *soap, ns2__PaypalTransaction *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PaypalTransaction(soap, tag?tag:"ns2:PaypalTransaction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PaypalTransaction ** SOAP_FMAC4 soap_get_PointerTons2__PaypalTransaction(struct soap *soap, ns2__PaypalTransaction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PaypalTransaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MDDField(struct soap *soap, ns2__MDDField *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MDDField))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MDDField(struct soap *soap, const char *tag, int id, ns2__MDDField *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MDDField, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MDDField ** SOAP_FMAC4 soap_in_PointerTons2__MDDField(struct soap *soap, const char *tag, ns2__MDDField **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MDDField **)soap_malloc(soap, sizeof(ns2__MDDField *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MDDField *)soap_instantiate_ns2__MDDField(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__MDDField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MDDField, sizeof(ns2__MDDField), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MDDField(struct soap *soap, ns2__MDDField *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__MDDField(soap, tag?tag:"ns2:MDDField", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MDDField ** SOAP_FMAC4 soap_get_PointerTons2__MDDField(struct soap *soap, ns2__MDDField **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MDDField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Service(struct soap *soap, ns2__Service *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Service))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Service(struct soap *soap, const char *tag, int id, ns2__Service *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Service, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Service ** SOAP_FMAC4 soap_in_PointerTons2__Service(struct soap *soap, const char *tag, ns2__Service **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Service **)soap_malloc(soap, sizeof(ns2__Service *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Service *)soap_instantiate_ns2__Service(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Service **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Service, sizeof(ns2__Service), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Service(struct soap *soap, ns2__Service *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Service(soap, tag?tag:"ns2:Service", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Service ** SOAP_FMAC4 soap_get_PointerTons2__Service(struct soap *soap, ns2__Service **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Service(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Leg(struct soap *soap, ns2__Leg *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Leg))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Leg(struct soap *soap, const char *tag, int id, ns2__Leg *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Leg, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Leg ** SOAP_FMAC4 soap_in_PointerTons2__Leg(struct soap *soap, const char *tag, ns2__Leg **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Leg **)soap_malloc(soap, sizeof(ns2__Leg *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Leg *)soap_instantiate_ns2__Leg(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Leg **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Leg, sizeof(ns2__Leg), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Leg(struct soap *soap, ns2__Leg *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Leg(soap, tag?tag:"ns2:Leg", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Leg ** SOAP_FMAC4 soap_get_PointerTons2__Leg(struct soap *soap, ns2__Leg **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Leg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ReplyReserved(struct soap *soap, ns2__ReplyReserved *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ReplyReserved))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ReplyReserved(struct soap *soap, const char *tag, int id, ns2__ReplyReserved *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ReplyReserved, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ReplyReserved ** SOAP_FMAC4 soap_in_PointerTons2__ReplyReserved(struct soap *soap, const char *tag, ns2__ReplyReserved **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ReplyReserved **)soap_malloc(soap, sizeof(ns2__ReplyReserved *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ReplyReserved *)soap_instantiate_ns2__ReplyReserved(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ReplyReserved **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ReplyReserved, sizeof(ns2__ReplyReserved), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ReplyReserved(struct soap *soap, ns2__ReplyReserved *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ReplyReserved(soap, tag?tag:"ns2:ReplyReserved", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ReplyReserved ** SOAP_FMAC4 soap_get_PointerTons2__ReplyReserved(struct soap *soap, ns2__ReplyReserved **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ReplyReserved(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Token(struct soap *soap, ns2__Token *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Token))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Token(struct soap *soap, const char *tag, int id, ns2__Token *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Token, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Token ** SOAP_FMAC4 soap_in_PointerTons2__Token(struct soap *soap, const char *tag, ns2__Token **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Token **)soap_malloc(soap, sizeof(ns2__Token *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Token *)soap_instantiate_ns2__Token(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Token **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Token, sizeof(ns2__Token), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Token(struct soap *soap, ns2__Token *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Token(soap, tag?tag:"ns2:Token", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Token ** SOAP_FMAC4 soap_get_PointerTons2__Token(struct soap *soap, ns2__Token **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BinLookupReply(struct soap *soap, ns2__BinLookupReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BinLookupReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BinLookupReply(struct soap *soap, const char *tag, int id, ns2__BinLookupReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BinLookupReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__BinLookupReply ** SOAP_FMAC4 soap_in_PointerTons2__BinLookupReply(struct soap *soap, const char *tag, ns2__BinLookupReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__BinLookupReply **)soap_malloc(soap, sizeof(ns2__BinLookupReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__BinLookupReply *)soap_instantiate_ns2__BinLookupReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__BinLookupReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BinLookupReply, sizeof(ns2__BinLookupReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BinLookupReply(struct soap *soap, ns2__BinLookupReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__BinLookupReply(soap, tag?tag:"ns2:BinLookupReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__BinLookupReply ** SOAP_FMAC4 soap_get_PointerTons2__BinLookupReply(struct soap *soap, ns2__BinLookupReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BinLookupReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DecryptVisaCheckoutDataReply(struct soap *soap, ns2__DecryptVisaCheckoutDataReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DecryptVisaCheckoutDataReply(struct soap *soap, const char *tag, int id, ns2__DecryptVisaCheckoutDataReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DecryptVisaCheckoutDataReply ** SOAP_FMAC4 soap_in_PointerTons2__DecryptVisaCheckoutDataReply(struct soap *soap, const char *tag, ns2__DecryptVisaCheckoutDataReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DecryptVisaCheckoutDataReply **)soap_malloc(soap, sizeof(ns2__DecryptVisaCheckoutDataReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DecryptVisaCheckoutDataReply *)soap_instantiate_ns2__DecryptVisaCheckoutDataReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DecryptVisaCheckoutDataReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply, sizeof(ns2__DecryptVisaCheckoutDataReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DecryptVisaCheckoutDataReply(struct soap *soap, ns2__DecryptVisaCheckoutDataReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DecryptVisaCheckoutDataReply(soap, tag?tag:"ns2:DecryptVisaCheckoutDataReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DecryptVisaCheckoutDataReply ** SOAP_FMAC4 soap_get_PointerTons2__DecryptVisaCheckoutDataReply(struct soap *soap, ns2__DecryptVisaCheckoutDataReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DecryptVisaCheckoutDataReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VCReply(struct soap *soap, ns2__VCReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VCReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VCReply(struct soap *soap, const char *tag, int id, ns2__VCReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VCReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__VCReply ** SOAP_FMAC4 soap_in_PointerTons2__VCReply(struct soap *soap, const char *tag, ns2__VCReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__VCReply **)soap_malloc(soap, sizeof(ns2__VCReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__VCReply *)soap_instantiate_ns2__VCReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__VCReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VCReply, sizeof(ns2__VCReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VCReply(struct soap *soap, ns2__VCReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__VCReply(soap, tag?tag:"ns2:VCReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__VCReply ** SOAP_FMAC4 soap_get_PointerTons2__VCReply(struct soap *soap, ns2__VCReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VCReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__HostedDataRetrieveReply(struct soap *soap, ns2__HostedDataRetrieveReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__HostedDataRetrieveReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__HostedDataRetrieveReply(struct soap *soap, const char *tag, int id, ns2__HostedDataRetrieveReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__HostedDataRetrieveReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__HostedDataRetrieveReply ** SOAP_FMAC4 soap_in_PointerTons2__HostedDataRetrieveReply(struct soap *soap, const char *tag, ns2__HostedDataRetrieveReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__HostedDataRetrieveReply **)soap_malloc(soap, sizeof(ns2__HostedDataRetrieveReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__HostedDataRetrieveReply *)soap_instantiate_ns2__HostedDataRetrieveReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__HostedDataRetrieveReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__HostedDataRetrieveReply, sizeof(ns2__HostedDataRetrieveReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__HostedDataRetrieveReply(struct soap *soap, ns2__HostedDataRetrieveReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__HostedDataRetrieveReply(soap, tag?tag:"ns2:HostedDataRetrieveReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__HostedDataRetrieveReply ** SOAP_FMAC4 soap_get_PointerTons2__HostedDataRetrieveReply(struct soap *soap, ns2__HostedDataRetrieveReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__HostedDataRetrieveReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__HostedDataCreateReply(struct soap *soap, ns2__HostedDataCreateReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__HostedDataCreateReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__HostedDataCreateReply(struct soap *soap, const char *tag, int id, ns2__HostedDataCreateReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__HostedDataCreateReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__HostedDataCreateReply ** SOAP_FMAC4 soap_in_PointerTons2__HostedDataCreateReply(struct soap *soap, const char *tag, ns2__HostedDataCreateReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__HostedDataCreateReply **)soap_malloc(soap, sizeof(ns2__HostedDataCreateReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__HostedDataCreateReply *)soap_instantiate_ns2__HostedDataCreateReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__HostedDataCreateReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__HostedDataCreateReply, sizeof(ns2__HostedDataCreateReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__HostedDataCreateReply(struct soap *soap, ns2__HostedDataCreateReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__HostedDataCreateReply(soap, tag?tag:"ns2:HostedDataCreateReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__HostedDataCreateReply ** SOAP_FMAC4 soap_get_PointerTons2__HostedDataCreateReply(struct soap *soap, ns2__HostedDataCreateReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__HostedDataCreateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OriginalTransaction(struct soap *soap, ns2__OriginalTransaction *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OriginalTransaction))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OriginalTransaction(struct soap *soap, const char *tag, int id, ns2__OriginalTransaction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OriginalTransaction, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__OriginalTransaction ** SOAP_FMAC4 soap_in_PointerTons2__OriginalTransaction(struct soap *soap, const char *tag, ns2__OriginalTransaction **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__OriginalTransaction **)soap_malloc(soap, sizeof(ns2__OriginalTransaction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__OriginalTransaction *)soap_instantiate_ns2__OriginalTransaction(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__OriginalTransaction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OriginalTransaction, sizeof(ns2__OriginalTransaction), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OriginalTransaction(struct soap *soap, ns2__OriginalTransaction *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__OriginalTransaction(soap, tag?tag:"ns2:OriginalTransaction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__OriginalTransaction ** SOAP_FMAC4 soap_get_PointerTons2__OriginalTransaction(struct soap *soap, ns2__OriginalTransaction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OriginalTransaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__EmvReply(struct soap *soap, ns2__EmvReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__EmvReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__EmvReply(struct soap *soap, const char *tag, int id, ns2__EmvReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__EmvReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__EmvReply ** SOAP_FMAC4 soap_in_PointerTons2__EmvReply(struct soap *soap, const char *tag, ns2__EmvReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__EmvReply **)soap_malloc(soap, sizeof(ns2__EmvReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__EmvReply *)soap_instantiate_ns2__EmvReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__EmvReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__EmvReply, sizeof(ns2__EmvReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__EmvReply(struct soap *soap, ns2__EmvReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__EmvReply(soap, tag?tag:"ns2:EmvReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__EmvReply ** SOAP_FMAC4 soap_get_PointerTons2__EmvReply(struct soap *soap, ns2__EmvReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__EmvReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalTransactionSearchReply(struct soap *soap, ns2__PayPalTransactionSearchReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalTransactionSearchReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalTransactionSearchReply(struct soap *soap, const char *tag, int id, ns2__PayPalTransactionSearchReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalTransactionSearchReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalTransactionSearchReply ** SOAP_FMAC4 soap_in_PointerTons2__PayPalTransactionSearchReply(struct soap *soap, const char *tag, ns2__PayPalTransactionSearchReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalTransactionSearchReply **)soap_malloc(soap, sizeof(ns2__PayPalTransactionSearchReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalTransactionSearchReply *)soap_instantiate_ns2__PayPalTransactionSearchReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalTransactionSearchReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalTransactionSearchReply, sizeof(ns2__PayPalTransactionSearchReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalTransactionSearchReply(struct soap *soap, ns2__PayPalTransactionSearchReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalTransactionSearchReply(soap, tag?tag:"ns2:PayPalTransactionSearchReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalTransactionSearchReply ** SOAP_FMAC4 soap_get_PointerTons2__PayPalTransactionSearchReply(struct soap *soap, ns2__PayPalTransactionSearchReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalTransactionSearchReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalGetTxnDetailsReply(struct soap *soap, ns2__PayPalGetTxnDetailsReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalGetTxnDetailsReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalGetTxnDetailsReply(struct soap *soap, const char *tag, int id, ns2__PayPalGetTxnDetailsReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalGetTxnDetailsReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalGetTxnDetailsReply ** SOAP_FMAC4 soap_in_PointerTons2__PayPalGetTxnDetailsReply(struct soap *soap, const char *tag, ns2__PayPalGetTxnDetailsReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalGetTxnDetailsReply **)soap_malloc(soap, sizeof(ns2__PayPalGetTxnDetailsReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalGetTxnDetailsReply *)soap_instantiate_ns2__PayPalGetTxnDetailsReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalGetTxnDetailsReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalGetTxnDetailsReply, sizeof(ns2__PayPalGetTxnDetailsReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalGetTxnDetailsReply(struct soap *soap, ns2__PayPalGetTxnDetailsReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalGetTxnDetailsReply(soap, tag?tag:"ns2:PayPalGetTxnDetailsReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalGetTxnDetailsReply ** SOAP_FMAC4 soap_get_PointerTons2__PayPalGetTxnDetailsReply(struct soap *soap, ns2__PayPalGetTxnDetailsReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalGetTxnDetailsReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PromotionGroupReply(struct soap *soap, ns2__PromotionGroupReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PromotionGroupReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PromotionGroupReply(struct soap *soap, const char *tag, int id, ns2__PromotionGroupReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PromotionGroupReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PromotionGroupReply ** SOAP_FMAC4 soap_in_PointerTons2__PromotionGroupReply(struct soap *soap, const char *tag, ns2__PromotionGroupReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PromotionGroupReply **)soap_malloc(soap, sizeof(ns2__PromotionGroupReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PromotionGroupReply *)soap_instantiate_ns2__PromotionGroupReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PromotionGroupReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PromotionGroupReply, sizeof(ns2__PromotionGroupReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PromotionGroupReply(struct soap *soap, ns2__PromotionGroupReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PromotionGroupReply(soap, tag?tag:"ns2:PromotionGroupReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PromotionGroupReply ** SOAP_FMAC4 soap_get_PointerTons2__PromotionGroupReply(struct soap *soap, ns2__PromotionGroupReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PromotionGroupReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Promotion(struct soap *soap, ns2__Promotion *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Promotion))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Promotion(struct soap *soap, const char *tag, int id, ns2__Promotion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Promotion, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Promotion ** SOAP_FMAC4 soap_in_PointerTons2__Promotion(struct soap *soap, const char *tag, ns2__Promotion **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Promotion **)soap_malloc(soap, sizeof(ns2__Promotion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Promotion *)soap_instantiate_ns2__Promotion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Promotion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Promotion, sizeof(ns2__Promotion), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Promotion(struct soap *soap, ns2__Promotion *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Promotion(soap, tag?tag:"ns2:Promotion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Promotion ** SOAP_FMAC4 soap_get_PointerTons2__Promotion(struct soap *soap, ns2__Promotion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Promotion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APConfirmPurchaseReply(struct soap *soap, ns2__APConfirmPurchaseReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APConfirmPurchaseReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APConfirmPurchaseReply(struct soap *soap, const char *tag, int id, ns2__APConfirmPurchaseReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APConfirmPurchaseReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APConfirmPurchaseReply ** SOAP_FMAC4 soap_in_PointerTons2__APConfirmPurchaseReply(struct soap *soap, const char *tag, ns2__APConfirmPurchaseReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APConfirmPurchaseReply **)soap_malloc(soap, sizeof(ns2__APConfirmPurchaseReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APConfirmPurchaseReply *)soap_instantiate_ns2__APConfirmPurchaseReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APConfirmPurchaseReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APConfirmPurchaseReply, sizeof(ns2__APConfirmPurchaseReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APConfirmPurchaseReply(struct soap *soap, ns2__APConfirmPurchaseReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APConfirmPurchaseReply(soap, tag?tag:"ns2:APConfirmPurchaseReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APConfirmPurchaseReply ** SOAP_FMAC4 soap_get_PointerTons2__APConfirmPurchaseReply(struct soap *soap, ns2__APConfirmPurchaseReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APConfirmPurchaseReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APTransactionDetailsReply(struct soap *soap, ns2__APTransactionDetailsReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APTransactionDetailsReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APTransactionDetailsReply(struct soap *soap, const char *tag, int id, ns2__APTransactionDetailsReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APTransactionDetailsReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APTransactionDetailsReply ** SOAP_FMAC4 soap_in_PointerTons2__APTransactionDetailsReply(struct soap *soap, const char *tag, ns2__APTransactionDetailsReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APTransactionDetailsReply **)soap_malloc(soap, sizeof(ns2__APTransactionDetailsReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APTransactionDetailsReply *)soap_instantiate_ns2__APTransactionDetailsReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APTransactionDetailsReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APTransactionDetailsReply, sizeof(ns2__APTransactionDetailsReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APTransactionDetailsReply(struct soap *soap, ns2__APTransactionDetailsReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APTransactionDetailsReply(soap, tag?tag:"ns2:APTransactionDetailsReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APTransactionDetailsReply ** SOAP_FMAC4 soap_get_PointerTons2__APTransactionDetailsReply(struct soap *soap, ns2__APTransactionDetailsReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APTransactionDetailsReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APCheckOutDetailsReply(struct soap *soap, ns2__APCheckOutDetailsReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APCheckOutDetailsReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APCheckOutDetailsReply(struct soap *soap, const char *tag, int id, ns2__APCheckOutDetailsReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APCheckOutDetailsReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APCheckOutDetailsReply ** SOAP_FMAC4 soap_in_PointerTons2__APCheckOutDetailsReply(struct soap *soap, const char *tag, ns2__APCheckOutDetailsReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APCheckOutDetailsReply **)soap_malloc(soap, sizeof(ns2__APCheckOutDetailsReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APCheckOutDetailsReply *)soap_instantiate_ns2__APCheckOutDetailsReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APCheckOutDetailsReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APCheckOutDetailsReply, sizeof(ns2__APCheckOutDetailsReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APCheckOutDetailsReply(struct soap *soap, ns2__APCheckOutDetailsReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APCheckOutDetailsReply(soap, tag?tag:"ns2:APCheckOutDetailsReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APCheckOutDetailsReply ** SOAP_FMAC4 soap_get_PointerTons2__APCheckOutDetailsReply(struct soap *soap, ns2__APCheckOutDetailsReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APCheckOutDetailsReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APSaleReply(struct soap *soap, ns2__APSaleReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APSaleReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APSaleReply(struct soap *soap, const char *tag, int id, ns2__APSaleReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APSaleReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APSaleReply ** SOAP_FMAC4 soap_in_PointerTons2__APSaleReply(struct soap *soap, const char *tag, ns2__APSaleReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APSaleReply **)soap_malloc(soap, sizeof(ns2__APSaleReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APSaleReply *)soap_instantiate_ns2__APSaleReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APSaleReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APSaleReply, sizeof(ns2__APSaleReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APSaleReply(struct soap *soap, ns2__APSaleReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APSaleReply(soap, tag?tag:"ns2:APSaleReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APSaleReply ** SOAP_FMAC4 soap_get_PointerTons2__APSaleReply(struct soap *soap, ns2__APSaleReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APSaleReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APRefundReply(struct soap *soap, ns2__APRefundReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APRefundReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APRefundReply(struct soap *soap, const char *tag, int id, ns2__APRefundReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APRefundReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APRefundReply ** SOAP_FMAC4 soap_in_PointerTons2__APRefundReply(struct soap *soap, const char *tag, ns2__APRefundReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APRefundReply **)soap_malloc(soap, sizeof(ns2__APRefundReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APRefundReply *)soap_instantiate_ns2__APRefundReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APRefundReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APRefundReply, sizeof(ns2__APRefundReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APRefundReply(struct soap *soap, ns2__APRefundReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APRefundReply(soap, tag?tag:"ns2:APRefundReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APRefundReply ** SOAP_FMAC4 soap_get_PointerTons2__APRefundReply(struct soap *soap, ns2__APRefundReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APRefundReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APOptionsReply(struct soap *soap, ns2__APOptionsReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APOptionsReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APOptionsReply(struct soap *soap, const char *tag, int id, ns2__APOptionsReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APOptionsReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APOptionsReply ** SOAP_FMAC4 soap_in_PointerTons2__APOptionsReply(struct soap *soap, const char *tag, ns2__APOptionsReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APOptionsReply **)soap_malloc(soap, sizeof(ns2__APOptionsReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APOptionsReply *)soap_instantiate_ns2__APOptionsReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APOptionsReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APOptionsReply, sizeof(ns2__APOptionsReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APOptionsReply(struct soap *soap, ns2__APOptionsReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APOptionsReply(soap, tag?tag:"ns2:APOptionsReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APOptionsReply ** SOAP_FMAC4 soap_get_PointerTons2__APOptionsReply(struct soap *soap, ns2__APOptionsReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APOptionsReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APCaptureReply(struct soap *soap, ns2__APCaptureReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APCaptureReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APCaptureReply(struct soap *soap, const char *tag, int id, ns2__APCaptureReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APCaptureReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APCaptureReply ** SOAP_FMAC4 soap_in_PointerTons2__APCaptureReply(struct soap *soap, const char *tag, ns2__APCaptureReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APCaptureReply **)soap_malloc(soap, sizeof(ns2__APCaptureReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APCaptureReply *)soap_instantiate_ns2__APCaptureReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APCaptureReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APCaptureReply, sizeof(ns2__APCaptureReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APCaptureReply(struct soap *soap, ns2__APCaptureReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APCaptureReply(soap, tag?tag:"ns2:APCaptureReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APCaptureReply ** SOAP_FMAC4 soap_get_PointerTons2__APCaptureReply(struct soap *soap, ns2__APCaptureReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APCaptureReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APAuthReversalReply(struct soap *soap, ns2__APAuthReversalReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APAuthReversalReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APAuthReversalReply(struct soap *soap, const char *tag, int id, ns2__APAuthReversalReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APAuthReversalReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APAuthReversalReply ** SOAP_FMAC4 soap_in_PointerTons2__APAuthReversalReply(struct soap *soap, const char *tag, ns2__APAuthReversalReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APAuthReversalReply **)soap_malloc(soap, sizeof(ns2__APAuthReversalReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APAuthReversalReply *)soap_instantiate_ns2__APAuthReversalReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APAuthReversalReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APAuthReversalReply, sizeof(ns2__APAuthReversalReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APAuthReversalReply(struct soap *soap, ns2__APAuthReversalReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APAuthReversalReply(soap, tag?tag:"ns2:APAuthReversalReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APAuthReversalReply ** SOAP_FMAC4 soap_get_PointerTons2__APAuthReversalReply(struct soap *soap, ns2__APAuthReversalReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APAuthReversalReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APAuthReply(struct soap *soap, ns2__APAuthReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APAuthReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APAuthReply(struct soap *soap, const char *tag, int id, ns2__APAuthReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APAuthReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APAuthReply ** SOAP_FMAC4 soap_in_PointerTons2__APAuthReply(struct soap *soap, const char *tag, ns2__APAuthReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APAuthReply **)soap_malloc(soap, sizeof(ns2__APAuthReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APAuthReply *)soap_instantiate_ns2__APAuthReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APAuthReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APAuthReply, sizeof(ns2__APAuthReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APAuthReply(struct soap *soap, ns2__APAuthReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APAuthReply(soap, tag?tag:"ns2:APAuthReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APAuthReply ** SOAP_FMAC4 soap_get_PointerTons2__APAuthReply(struct soap *soap, ns2__APAuthReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APAuthReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APReply(struct soap *soap, ns2__APReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APReply(struct soap *soap, const char *tag, int id, ns2__APReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APReply ** SOAP_FMAC4 soap_in_PointerTons2__APReply(struct soap *soap, const char *tag, ns2__APReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APReply **)soap_malloc(soap, sizeof(ns2__APReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APReply *)soap_instantiate_ns2__APReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APReply, sizeof(ns2__APReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APReply(struct soap *soap, ns2__APReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APReply(soap, tag?tag:"ns2:APReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APReply ** SOAP_FMAC4 soap_get_PointerTons2__APReply(struct soap *soap, ns2__APReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APCheckStatusReply(struct soap *soap, ns2__APCheckStatusReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APCheckStatusReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APCheckStatusReply(struct soap *soap, const char *tag, int id, ns2__APCheckStatusReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APCheckStatusReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APCheckStatusReply ** SOAP_FMAC4 soap_in_PointerTons2__APCheckStatusReply(struct soap *soap, const char *tag, ns2__APCheckStatusReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APCheckStatusReply **)soap_malloc(soap, sizeof(ns2__APCheckStatusReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APCheckStatusReply *)soap_instantiate_ns2__APCheckStatusReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APCheckStatusReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APCheckStatusReply, sizeof(ns2__APCheckStatusReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APCheckStatusReply(struct soap *soap, ns2__APCheckStatusReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APCheckStatusReply(soap, tag?tag:"ns2:APCheckStatusReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APCheckStatusReply ** SOAP_FMAC4 soap_get_PointerTons2__APCheckStatusReply(struct soap *soap, ns2__APCheckStatusReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APCheckStatusReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APInitiateReply(struct soap *soap, ns2__APInitiateReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APInitiateReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APInitiateReply(struct soap *soap, const char *tag, int id, ns2__APInitiateReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APInitiateReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APInitiateReply ** SOAP_FMAC4 soap_in_PointerTons2__APInitiateReply(struct soap *soap, const char *tag, ns2__APInitiateReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APInitiateReply **)soap_malloc(soap, sizeof(ns2__APInitiateReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APInitiateReply *)soap_instantiate_ns2__APInitiateReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APInitiateReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APInitiateReply, sizeof(ns2__APInitiateReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APInitiateReply(struct soap *soap, ns2__APInitiateReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APInitiateReply(soap, tag?tag:"ns2:APInitiateReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APInitiateReply ** SOAP_FMAC4 soap_get_PointerTons2__APInitiateReply(struct soap *soap, ns2__APInitiateReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APInitiateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PinDebitReversalReply(struct soap *soap, ns2__PinDebitReversalReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PinDebitReversalReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PinDebitReversalReply(struct soap *soap, const char *tag, int id, ns2__PinDebitReversalReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PinDebitReversalReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PinDebitReversalReply ** SOAP_FMAC4 soap_in_PointerTons2__PinDebitReversalReply(struct soap *soap, const char *tag, ns2__PinDebitReversalReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PinDebitReversalReply **)soap_malloc(soap, sizeof(ns2__PinDebitReversalReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PinDebitReversalReply *)soap_instantiate_ns2__PinDebitReversalReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PinDebitReversalReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PinDebitReversalReply, sizeof(ns2__PinDebitReversalReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PinDebitReversalReply(struct soap *soap, ns2__PinDebitReversalReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PinDebitReversalReply(soap, tag?tag:"ns2:PinDebitReversalReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PinDebitReversalReply ** SOAP_FMAC4 soap_get_PointerTons2__PinDebitReversalReply(struct soap *soap, ns2__PinDebitReversalReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PinDebitReversalReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PinDebitCreditReply(struct soap *soap, ns2__PinDebitCreditReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PinDebitCreditReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PinDebitCreditReply(struct soap *soap, const char *tag, int id, ns2__PinDebitCreditReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PinDebitCreditReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PinDebitCreditReply ** SOAP_FMAC4 soap_in_PointerTons2__PinDebitCreditReply(struct soap *soap, const char *tag, ns2__PinDebitCreditReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PinDebitCreditReply **)soap_malloc(soap, sizeof(ns2__PinDebitCreditReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PinDebitCreditReply *)soap_instantiate_ns2__PinDebitCreditReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PinDebitCreditReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PinDebitCreditReply, sizeof(ns2__PinDebitCreditReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PinDebitCreditReply(struct soap *soap, ns2__PinDebitCreditReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PinDebitCreditReply(soap, tag?tag:"ns2:PinDebitCreditReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PinDebitCreditReply ** SOAP_FMAC4 soap_get_PointerTons2__PinDebitCreditReply(struct soap *soap, ns2__PinDebitCreditReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PinDebitCreditReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PinDebitPurchaseReply(struct soap *soap, ns2__PinDebitPurchaseReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PinDebitPurchaseReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PinDebitPurchaseReply(struct soap *soap, const char *tag, int id, ns2__PinDebitPurchaseReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PinDebitPurchaseReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PinDebitPurchaseReply ** SOAP_FMAC4 soap_in_PointerTons2__PinDebitPurchaseReply(struct soap *soap, const char *tag, ns2__PinDebitPurchaseReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PinDebitPurchaseReply **)soap_malloc(soap, sizeof(ns2__PinDebitPurchaseReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PinDebitPurchaseReply *)soap_instantiate_ns2__PinDebitPurchaseReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PinDebitPurchaseReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PinDebitPurchaseReply, sizeof(ns2__PinDebitPurchaseReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PinDebitPurchaseReply(struct soap *soap, ns2__PinDebitPurchaseReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PinDebitPurchaseReply(soap, tag?tag:"ns2:PinDebitPurchaseReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PinDebitPurchaseReply ** SOAP_FMAC4 soap_get_PointerTons2__PinDebitPurchaseReply(struct soap *soap, ns2__PinDebitPurchaseReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PinDebitPurchaseReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BoletoPaymentReply(struct soap *soap, ns2__BoletoPaymentReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BoletoPaymentReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BoletoPaymentReply(struct soap *soap, const char *tag, int id, ns2__BoletoPaymentReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BoletoPaymentReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__BoletoPaymentReply ** SOAP_FMAC4 soap_in_PointerTons2__BoletoPaymentReply(struct soap *soap, const char *tag, ns2__BoletoPaymentReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__BoletoPaymentReply **)soap_malloc(soap, sizeof(ns2__BoletoPaymentReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__BoletoPaymentReply *)soap_instantiate_ns2__BoletoPaymentReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__BoletoPaymentReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BoletoPaymentReply, sizeof(ns2__BoletoPaymentReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BoletoPaymentReply(struct soap *soap, ns2__BoletoPaymentReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__BoletoPaymentReply(soap, tag?tag:"ns2:BoletoPaymentReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__BoletoPaymentReply ** SOAP_FMAC4 soap_get_PointerTons2__BoletoPaymentReply(struct soap *soap, ns2__BoletoPaymentReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BoletoPaymentReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ChinaRefundReply(struct soap *soap, ns2__ChinaRefundReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ChinaRefundReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ChinaRefundReply(struct soap *soap, const char *tag, int id, ns2__ChinaRefundReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ChinaRefundReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ChinaRefundReply ** SOAP_FMAC4 soap_in_PointerTons2__ChinaRefundReply(struct soap *soap, const char *tag, ns2__ChinaRefundReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ChinaRefundReply **)soap_malloc(soap, sizeof(ns2__ChinaRefundReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ChinaRefundReply *)soap_instantiate_ns2__ChinaRefundReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ChinaRefundReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ChinaRefundReply, sizeof(ns2__ChinaRefundReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ChinaRefundReply(struct soap *soap, ns2__ChinaRefundReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ChinaRefundReply(soap, tag?tag:"ns2:ChinaRefundReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ChinaRefundReply ** SOAP_FMAC4 soap_get_PointerTons2__ChinaRefundReply(struct soap *soap, ns2__ChinaRefundReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ChinaRefundReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ChinaPaymentReply(struct soap *soap, ns2__ChinaPaymentReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ChinaPaymentReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ChinaPaymentReply(struct soap *soap, const char *tag, int id, ns2__ChinaPaymentReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ChinaPaymentReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ChinaPaymentReply ** SOAP_FMAC4 soap_in_PointerTons2__ChinaPaymentReply(struct soap *soap, const char *tag, ns2__ChinaPaymentReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ChinaPaymentReply **)soap_malloc(soap, sizeof(ns2__ChinaPaymentReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ChinaPaymentReply *)soap_instantiate_ns2__ChinaPaymentReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ChinaPaymentReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ChinaPaymentReply, sizeof(ns2__ChinaPaymentReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ChinaPaymentReply(struct soap *soap, ns2__ChinaPaymentReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ChinaPaymentReply(soap, tag?tag:"ns2:ChinaPaymentReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ChinaPaymentReply ** SOAP_FMAC4 soap_get_PointerTons2__ChinaPaymentReply(struct soap *soap, ns2__ChinaPaymentReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ChinaPaymentReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalDoRefTransactionReply(struct soap *soap, ns2__PayPalDoRefTransactionReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalDoRefTransactionReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalDoRefTransactionReply(struct soap *soap, const char *tag, int id, ns2__PayPalDoRefTransactionReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalDoRefTransactionReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalDoRefTransactionReply ** SOAP_FMAC4 soap_in_PointerTons2__PayPalDoRefTransactionReply(struct soap *soap, const char *tag, ns2__PayPalDoRefTransactionReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalDoRefTransactionReply **)soap_malloc(soap, sizeof(ns2__PayPalDoRefTransactionReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalDoRefTransactionReply *)soap_instantiate_ns2__PayPalDoRefTransactionReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalDoRefTransactionReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalDoRefTransactionReply, sizeof(ns2__PayPalDoRefTransactionReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalDoRefTransactionReply(struct soap *soap, ns2__PayPalDoRefTransactionReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalDoRefTransactionReply(soap, tag?tag:"ns2:PayPalDoRefTransactionReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalDoRefTransactionReply ** SOAP_FMAC4 soap_get_PointerTons2__PayPalDoRefTransactionReply(struct soap *soap, ns2__PayPalDoRefTransactionReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalDoRefTransactionReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalCreateAgreementReply(struct soap *soap, ns2__PayPalCreateAgreementReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalCreateAgreementReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalCreateAgreementReply(struct soap *soap, const char *tag, int id, ns2__PayPalCreateAgreementReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalCreateAgreementReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalCreateAgreementReply ** SOAP_FMAC4 soap_in_PointerTons2__PayPalCreateAgreementReply(struct soap *soap, const char *tag, ns2__PayPalCreateAgreementReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalCreateAgreementReply **)soap_malloc(soap, sizeof(ns2__PayPalCreateAgreementReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalCreateAgreementReply *)soap_instantiate_ns2__PayPalCreateAgreementReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalCreateAgreementReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalCreateAgreementReply, sizeof(ns2__PayPalCreateAgreementReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalCreateAgreementReply(struct soap *soap, ns2__PayPalCreateAgreementReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalCreateAgreementReply(soap, tag?tag:"ns2:PayPalCreateAgreementReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalCreateAgreementReply ** SOAP_FMAC4 soap_get_PointerTons2__PayPalCreateAgreementReply(struct soap *soap, ns2__PayPalCreateAgreementReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalCreateAgreementReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalUpdateAgreementReply(struct soap *soap, ns2__PayPalUpdateAgreementReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalUpdateAgreementReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalUpdateAgreementReply(struct soap *soap, const char *tag, int id, ns2__PayPalUpdateAgreementReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalUpdateAgreementReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalUpdateAgreementReply ** SOAP_FMAC4 soap_in_PointerTons2__PayPalUpdateAgreementReply(struct soap *soap, const char *tag, ns2__PayPalUpdateAgreementReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalUpdateAgreementReply **)soap_malloc(soap, sizeof(ns2__PayPalUpdateAgreementReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalUpdateAgreementReply *)soap_instantiate_ns2__PayPalUpdateAgreementReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalUpdateAgreementReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalUpdateAgreementReply, sizeof(ns2__PayPalUpdateAgreementReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalUpdateAgreementReply(struct soap *soap, ns2__PayPalUpdateAgreementReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalUpdateAgreementReply(soap, tag?tag:"ns2:PayPalUpdateAgreementReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalUpdateAgreementReply ** SOAP_FMAC4 soap_get_PointerTons2__PayPalUpdateAgreementReply(struct soap *soap, ns2__PayPalUpdateAgreementReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalUpdateAgreementReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalEcOrderSetupReply(struct soap *soap, ns2__PayPalEcOrderSetupReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalEcOrderSetupReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalEcOrderSetupReply(struct soap *soap, const char *tag, int id, ns2__PayPalEcOrderSetupReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalEcOrderSetupReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalEcOrderSetupReply ** SOAP_FMAC4 soap_in_PointerTons2__PayPalEcOrderSetupReply(struct soap *soap, const char *tag, ns2__PayPalEcOrderSetupReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalEcOrderSetupReply **)soap_malloc(soap, sizeof(ns2__PayPalEcOrderSetupReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalEcOrderSetupReply *)soap_instantiate_ns2__PayPalEcOrderSetupReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalEcOrderSetupReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalEcOrderSetupReply, sizeof(ns2__PayPalEcOrderSetupReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalEcOrderSetupReply(struct soap *soap, ns2__PayPalEcOrderSetupReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalEcOrderSetupReply(soap, tag?tag:"ns2:PayPalEcOrderSetupReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalEcOrderSetupReply ** SOAP_FMAC4 soap_get_PointerTons2__PayPalEcOrderSetupReply(struct soap *soap, ns2__PayPalEcOrderSetupReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalEcOrderSetupReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalAuthorizationReply(struct soap *soap, ns2__PayPalAuthorizationReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalAuthorizationReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalAuthorizationReply(struct soap *soap, const char *tag, int id, ns2__PayPalAuthorizationReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalAuthorizationReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalAuthorizationReply ** SOAP_FMAC4 soap_in_PointerTons2__PayPalAuthorizationReply(struct soap *soap, const char *tag, ns2__PayPalAuthorizationReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalAuthorizationReply **)soap_malloc(soap, sizeof(ns2__PayPalAuthorizationReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalAuthorizationReply *)soap_instantiate_ns2__PayPalAuthorizationReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalAuthorizationReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalAuthorizationReply, sizeof(ns2__PayPalAuthorizationReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalAuthorizationReply(struct soap *soap, ns2__PayPalAuthorizationReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalAuthorizationReply(soap, tag?tag:"ns2:PayPalAuthorizationReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalAuthorizationReply ** SOAP_FMAC4 soap_get_PointerTons2__PayPalAuthorizationReply(struct soap *soap, ns2__PayPalAuthorizationReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalAuthorizationReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalEcSetReply(struct soap *soap, ns2__PayPalEcSetReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalEcSetReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalEcSetReply(struct soap *soap, const char *tag, int id, ns2__PayPalEcSetReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalEcSetReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalEcSetReply ** SOAP_FMAC4 soap_in_PointerTons2__PayPalEcSetReply(struct soap *soap, const char *tag, ns2__PayPalEcSetReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalEcSetReply **)soap_malloc(soap, sizeof(ns2__PayPalEcSetReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalEcSetReply *)soap_instantiate_ns2__PayPalEcSetReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalEcSetReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalEcSetReply, sizeof(ns2__PayPalEcSetReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalEcSetReply(struct soap *soap, ns2__PayPalEcSetReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalEcSetReply(soap, tag?tag:"ns2:PayPalEcSetReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalEcSetReply ** SOAP_FMAC4 soap_get_PointerTons2__PayPalEcSetReply(struct soap *soap, ns2__PayPalEcSetReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalEcSetReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalEcGetDetailsReply(struct soap *soap, ns2__PayPalEcGetDetailsReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalEcGetDetailsReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalEcGetDetailsReply(struct soap *soap, const char *tag, int id, ns2__PayPalEcGetDetailsReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalEcGetDetailsReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalEcGetDetailsReply ** SOAP_FMAC4 soap_in_PointerTons2__PayPalEcGetDetailsReply(struct soap *soap, const char *tag, ns2__PayPalEcGetDetailsReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalEcGetDetailsReply **)soap_malloc(soap, sizeof(ns2__PayPalEcGetDetailsReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalEcGetDetailsReply *)soap_instantiate_ns2__PayPalEcGetDetailsReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalEcGetDetailsReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalEcGetDetailsReply, sizeof(ns2__PayPalEcGetDetailsReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalEcGetDetailsReply(struct soap *soap, ns2__PayPalEcGetDetailsReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalEcGetDetailsReply(soap, tag?tag:"ns2:PayPalEcGetDetailsReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalEcGetDetailsReply ** SOAP_FMAC4 soap_get_PointerTons2__PayPalEcGetDetailsReply(struct soap *soap, ns2__PayPalEcGetDetailsReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalEcGetDetailsReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalEcDoPaymentReply(struct soap *soap, ns2__PayPalEcDoPaymentReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalEcDoPaymentReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalEcDoPaymentReply(struct soap *soap, const char *tag, int id, ns2__PayPalEcDoPaymentReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalEcDoPaymentReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalEcDoPaymentReply ** SOAP_FMAC4 soap_in_PointerTons2__PayPalEcDoPaymentReply(struct soap *soap, const char *tag, ns2__PayPalEcDoPaymentReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalEcDoPaymentReply **)soap_malloc(soap, sizeof(ns2__PayPalEcDoPaymentReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalEcDoPaymentReply *)soap_instantiate_ns2__PayPalEcDoPaymentReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalEcDoPaymentReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalEcDoPaymentReply, sizeof(ns2__PayPalEcDoPaymentReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalEcDoPaymentReply(struct soap *soap, ns2__PayPalEcDoPaymentReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalEcDoPaymentReply(soap, tag?tag:"ns2:PayPalEcDoPaymentReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalEcDoPaymentReply ** SOAP_FMAC4 soap_get_PointerTons2__PayPalEcDoPaymentReply(struct soap *soap, ns2__PayPalEcDoPaymentReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalEcDoPaymentReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalDoCaptureReply(struct soap *soap, ns2__PayPalDoCaptureReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalDoCaptureReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalDoCaptureReply(struct soap *soap, const char *tag, int id, ns2__PayPalDoCaptureReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalDoCaptureReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalDoCaptureReply ** SOAP_FMAC4 soap_in_PointerTons2__PayPalDoCaptureReply(struct soap *soap, const char *tag, ns2__PayPalDoCaptureReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalDoCaptureReply **)soap_malloc(soap, sizeof(ns2__PayPalDoCaptureReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalDoCaptureReply *)soap_instantiate_ns2__PayPalDoCaptureReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalDoCaptureReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalDoCaptureReply, sizeof(ns2__PayPalDoCaptureReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalDoCaptureReply(struct soap *soap, ns2__PayPalDoCaptureReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalDoCaptureReply(soap, tag?tag:"ns2:PayPalDoCaptureReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalDoCaptureReply ** SOAP_FMAC4 soap_get_PointerTons2__PayPalDoCaptureReply(struct soap *soap, ns2__PayPalDoCaptureReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalDoCaptureReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalAuthReversalReply(struct soap *soap, ns2__PayPalAuthReversalReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalAuthReversalReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalAuthReversalReply(struct soap *soap, const char *tag, int id, ns2__PayPalAuthReversalReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalAuthReversalReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalAuthReversalReply ** SOAP_FMAC4 soap_in_PointerTons2__PayPalAuthReversalReply(struct soap *soap, const char *tag, ns2__PayPalAuthReversalReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalAuthReversalReply **)soap_malloc(soap, sizeof(ns2__PayPalAuthReversalReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalAuthReversalReply *)soap_instantiate_ns2__PayPalAuthReversalReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalAuthReversalReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalAuthReversalReply, sizeof(ns2__PayPalAuthReversalReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalAuthReversalReply(struct soap *soap, ns2__PayPalAuthReversalReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalAuthReversalReply(soap, tag?tag:"ns2:PayPalAuthReversalReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalAuthReversalReply ** SOAP_FMAC4 soap_get_PointerTons2__PayPalAuthReversalReply(struct soap *soap, ns2__PayPalAuthReversalReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalAuthReversalReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalRefundReply(struct soap *soap, ns2__PayPalRefundReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalRefundReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalRefundReply(struct soap *soap, const char *tag, int id, ns2__PayPalRefundReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalRefundReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalRefundReply ** SOAP_FMAC4 soap_in_PointerTons2__PayPalRefundReply(struct soap *soap, const char *tag, ns2__PayPalRefundReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalRefundReply **)soap_malloc(soap, sizeof(ns2__PayPalRefundReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalRefundReply *)soap_instantiate_ns2__PayPalRefundReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalRefundReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalRefundReply, sizeof(ns2__PayPalRefundReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalRefundReply(struct soap *soap, ns2__PayPalRefundReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalRefundReply(soap, tag?tag:"ns2:PayPalRefundReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalRefundReply ** SOAP_FMAC4 soap_get_PointerTons2__PayPalRefundReply(struct soap *soap, ns2__PayPalRefundReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalRefundReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DecisionReply(struct soap *soap, ns2__DecisionReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DecisionReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DecisionReply(struct soap *soap, const char *tag, int id, ns2__DecisionReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DecisionReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DecisionReply ** SOAP_FMAC4 soap_in_PointerTons2__DecisionReply(struct soap *soap, const char *tag, ns2__DecisionReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DecisionReply **)soap_malloc(soap, sizeof(ns2__DecisionReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DecisionReply *)soap_instantiate_ns2__DecisionReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DecisionReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DecisionReply, sizeof(ns2__DecisionReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DecisionReply(struct soap *soap, ns2__DecisionReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DecisionReply(soap, tag?tag:"ns2:DecisionReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DecisionReply ** SOAP_FMAC4 soap_get_PointerTons2__DecisionReply(struct soap *soap, ns2__DecisionReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DecisionReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CaseManagementActionReply(struct soap *soap, ns2__CaseManagementActionReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CaseManagementActionReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CaseManagementActionReply(struct soap *soap, const char *tag, int id, ns2__CaseManagementActionReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CaseManagementActionReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CaseManagementActionReply ** SOAP_FMAC4 soap_in_PointerTons2__CaseManagementActionReply(struct soap *soap, const char *tag, ns2__CaseManagementActionReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CaseManagementActionReply **)soap_malloc(soap, sizeof(ns2__CaseManagementActionReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CaseManagementActionReply *)soap_instantiate_ns2__CaseManagementActionReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CaseManagementActionReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CaseManagementActionReply, sizeof(ns2__CaseManagementActionReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CaseManagementActionReply(struct soap *soap, ns2__CaseManagementActionReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CaseManagementActionReply(soap, tag?tag:"ns2:CaseManagementActionReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CaseManagementActionReply ** SOAP_FMAC4 soap_get_PointerTons2__CaseManagementActionReply(struct soap *soap, ns2__CaseManagementActionReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CaseManagementActionReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FraudUpdateReply(struct soap *soap, ns2__FraudUpdateReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FraudUpdateReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FraudUpdateReply(struct soap *soap, const char *tag, int id, ns2__FraudUpdateReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FraudUpdateReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__FraudUpdateReply ** SOAP_FMAC4 soap_in_PointerTons2__FraudUpdateReply(struct soap *soap, const char *tag, ns2__FraudUpdateReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__FraudUpdateReply **)soap_malloc(soap, sizeof(ns2__FraudUpdateReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__FraudUpdateReply *)soap_instantiate_ns2__FraudUpdateReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__FraudUpdateReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FraudUpdateReply, sizeof(ns2__FraudUpdateReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FraudUpdateReply(struct soap *soap, ns2__FraudUpdateReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__FraudUpdateReply(soap, tag?tag:"ns2:FraudUpdateReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__FraudUpdateReply ** SOAP_FMAC4 soap_get_PointerTons2__FraudUpdateReply(struct soap *soap, ns2__FraudUpdateReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FraudUpdateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RiskUpdateReply(struct soap *soap, ns2__RiskUpdateReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RiskUpdateReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RiskUpdateReply(struct soap *soap, const char *tag, int id, ns2__RiskUpdateReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RiskUpdateReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RiskUpdateReply ** SOAP_FMAC4 soap_in_PointerTons2__RiskUpdateReply(struct soap *soap, const char *tag, ns2__RiskUpdateReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RiskUpdateReply **)soap_malloc(soap, sizeof(ns2__RiskUpdateReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RiskUpdateReply *)soap_instantiate_ns2__RiskUpdateReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__RiskUpdateReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RiskUpdateReply, sizeof(ns2__RiskUpdateReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RiskUpdateReply(struct soap *soap, ns2__RiskUpdateReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__RiskUpdateReply(soap, tag?tag:"ns2:RiskUpdateReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RiskUpdateReply ** SOAP_FMAC4 soap_get_PointerTons2__RiskUpdateReply(struct soap *soap, ns2__RiskUpdateReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RiskUpdateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalPreapprovedUpdateReply(struct soap *soap, ns2__PayPalPreapprovedUpdateReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalPreapprovedUpdateReply(struct soap *soap, const char *tag, int id, ns2__PayPalPreapprovedUpdateReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalPreapprovedUpdateReply ** SOAP_FMAC4 soap_in_PointerTons2__PayPalPreapprovedUpdateReply(struct soap *soap, const char *tag, ns2__PayPalPreapprovedUpdateReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalPreapprovedUpdateReply **)soap_malloc(soap, sizeof(ns2__PayPalPreapprovedUpdateReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalPreapprovedUpdateReply *)soap_instantiate_ns2__PayPalPreapprovedUpdateReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalPreapprovedUpdateReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply, sizeof(ns2__PayPalPreapprovedUpdateReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalPreapprovedUpdateReply(struct soap *soap, ns2__PayPalPreapprovedUpdateReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalPreapprovedUpdateReply(soap, tag?tag:"ns2:PayPalPreapprovedUpdateReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalPreapprovedUpdateReply ** SOAP_FMAC4 soap_get_PointerTons2__PayPalPreapprovedUpdateReply(struct soap *soap, ns2__PayPalPreapprovedUpdateReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalPreapprovedUpdateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalPreapprovedPaymentReply(struct soap *soap, ns2__PayPalPreapprovedPaymentReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalPreapprovedPaymentReply(struct soap *soap, const char *tag, int id, ns2__PayPalPreapprovedPaymentReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalPreapprovedPaymentReply ** SOAP_FMAC4 soap_in_PointerTons2__PayPalPreapprovedPaymentReply(struct soap *soap, const char *tag, ns2__PayPalPreapprovedPaymentReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalPreapprovedPaymentReply **)soap_malloc(soap, sizeof(ns2__PayPalPreapprovedPaymentReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalPreapprovedPaymentReply *)soap_instantiate_ns2__PayPalPreapprovedPaymentReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalPreapprovedPaymentReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply, sizeof(ns2__PayPalPreapprovedPaymentReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalPreapprovedPaymentReply(struct soap *soap, ns2__PayPalPreapprovedPaymentReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalPreapprovedPaymentReply(soap, tag?tag:"ns2:PayPalPreapprovedPaymentReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalPreapprovedPaymentReply ** SOAP_FMAC4 soap_get_PointerTons2__PayPalPreapprovedPaymentReply(struct soap *soap, ns2__PayPalPreapprovedPaymentReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalPreapprovedPaymentReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalButtonCreateReply(struct soap *soap, ns2__PayPalButtonCreateReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalButtonCreateReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalButtonCreateReply(struct soap *soap, const char *tag, int id, ns2__PayPalButtonCreateReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalButtonCreateReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalButtonCreateReply ** SOAP_FMAC4 soap_in_PointerTons2__PayPalButtonCreateReply(struct soap *soap, const char *tag, ns2__PayPalButtonCreateReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalButtonCreateReply **)soap_malloc(soap, sizeof(ns2__PayPalButtonCreateReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalButtonCreateReply *)soap_instantiate_ns2__PayPalButtonCreateReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalButtonCreateReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalButtonCreateReply, sizeof(ns2__PayPalButtonCreateReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalButtonCreateReply(struct soap *soap, ns2__PayPalButtonCreateReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalButtonCreateReply(soap, tag?tag:"ns2:PayPalButtonCreateReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalButtonCreateReply ** SOAP_FMAC4 soap_get_PointerTons2__PayPalButtonCreateReply(struct soap *soap, ns2__PayPalButtonCreateReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalButtonCreateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PinlessDebitReversalReply(struct soap *soap, ns2__PinlessDebitReversalReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PinlessDebitReversalReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PinlessDebitReversalReply(struct soap *soap, const char *tag, int id, ns2__PinlessDebitReversalReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PinlessDebitReversalReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PinlessDebitReversalReply ** SOAP_FMAC4 soap_in_PointerTons2__PinlessDebitReversalReply(struct soap *soap, const char *tag, ns2__PinlessDebitReversalReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PinlessDebitReversalReply **)soap_malloc(soap, sizeof(ns2__PinlessDebitReversalReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PinlessDebitReversalReply *)soap_instantiate_ns2__PinlessDebitReversalReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PinlessDebitReversalReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PinlessDebitReversalReply, sizeof(ns2__PinlessDebitReversalReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PinlessDebitReversalReply(struct soap *soap, ns2__PinlessDebitReversalReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PinlessDebitReversalReply(soap, tag?tag:"ns2:PinlessDebitReversalReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PinlessDebitReversalReply ** SOAP_FMAC4 soap_get_PointerTons2__PinlessDebitReversalReply(struct soap *soap, ns2__PinlessDebitReversalReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PinlessDebitReversalReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PinlessDebitValidateReply(struct soap *soap, ns2__PinlessDebitValidateReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PinlessDebitValidateReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PinlessDebitValidateReply(struct soap *soap, const char *tag, int id, ns2__PinlessDebitValidateReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PinlessDebitValidateReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PinlessDebitValidateReply ** SOAP_FMAC4 soap_in_PointerTons2__PinlessDebitValidateReply(struct soap *soap, const char *tag, ns2__PinlessDebitValidateReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PinlessDebitValidateReply **)soap_malloc(soap, sizeof(ns2__PinlessDebitValidateReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PinlessDebitValidateReply *)soap_instantiate_ns2__PinlessDebitValidateReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PinlessDebitValidateReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PinlessDebitValidateReply, sizeof(ns2__PinlessDebitValidateReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PinlessDebitValidateReply(struct soap *soap, ns2__PinlessDebitValidateReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PinlessDebitValidateReply(soap, tag?tag:"ns2:PinlessDebitValidateReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PinlessDebitValidateReply ** SOAP_FMAC4 soap_get_PointerTons2__PinlessDebitValidateReply(struct soap *soap, ns2__PinlessDebitValidateReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PinlessDebitValidateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PinlessDebitReply(struct soap *soap, ns2__PinlessDebitReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PinlessDebitReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PinlessDebitReply(struct soap *soap, const char *tag, int id, ns2__PinlessDebitReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PinlessDebitReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PinlessDebitReply ** SOAP_FMAC4 soap_in_PointerTons2__PinlessDebitReply(struct soap *soap, const char *tag, ns2__PinlessDebitReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PinlessDebitReply **)soap_malloc(soap, sizeof(ns2__PinlessDebitReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PinlessDebitReply *)soap_instantiate_ns2__PinlessDebitReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PinlessDebitReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PinlessDebitReply, sizeof(ns2__PinlessDebitReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PinlessDebitReply(struct soap *soap, ns2__PinlessDebitReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PinlessDebitReply(soap, tag?tag:"ns2:PinlessDebitReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PinlessDebitReply ** SOAP_FMAC4 soap_get_PointerTons2__PinlessDebitReply(struct soap *soap, ns2__PinlessDebitReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PinlessDebitReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VoidReply(struct soap *soap, ns2__VoidReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VoidReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VoidReply(struct soap *soap, const char *tag, int id, ns2__VoidReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VoidReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__VoidReply ** SOAP_FMAC4 soap_in_PointerTons2__VoidReply(struct soap *soap, const char *tag, ns2__VoidReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__VoidReply **)soap_malloc(soap, sizeof(ns2__VoidReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__VoidReply *)soap_instantiate_ns2__VoidReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__VoidReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VoidReply, sizeof(ns2__VoidReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VoidReply(struct soap *soap, ns2__VoidReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__VoidReply(soap, tag?tag:"ns2:VoidReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__VoidReply ** SOAP_FMAC4 soap_get_PointerTons2__VoidReply(struct soap *soap, ns2__VoidReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VoidReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalCreditReply(struct soap *soap, ns2__PayPalCreditReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalCreditReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalCreditReply(struct soap *soap, const char *tag, int id, ns2__PayPalCreditReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalCreditReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalCreditReply ** SOAP_FMAC4 soap_in_PointerTons2__PayPalCreditReply(struct soap *soap, const char *tag, ns2__PayPalCreditReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalCreditReply **)soap_malloc(soap, sizeof(ns2__PayPalCreditReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalCreditReply *)soap_instantiate_ns2__PayPalCreditReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalCreditReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalCreditReply, sizeof(ns2__PayPalCreditReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalCreditReply(struct soap *soap, ns2__PayPalCreditReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalCreditReply(soap, tag?tag:"ns2:PayPalCreditReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalCreditReply ** SOAP_FMAC4 soap_get_PointerTons2__PayPalCreditReply(struct soap *soap, ns2__PayPalCreditReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalCreditReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalPaymentReply(struct soap *soap, ns2__PayPalPaymentReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalPaymentReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalPaymentReply(struct soap *soap, const char *tag, int id, ns2__PayPalPaymentReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalPaymentReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalPaymentReply ** SOAP_FMAC4 soap_in_PointerTons2__PayPalPaymentReply(struct soap *soap, const char *tag, ns2__PayPalPaymentReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalPaymentReply **)soap_malloc(soap, sizeof(ns2__PayPalPaymentReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalPaymentReply *)soap_instantiate_ns2__PayPalPaymentReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalPaymentReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalPaymentReply, sizeof(ns2__PayPalPaymentReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalPaymentReply(struct soap *soap, ns2__PayPalPaymentReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalPaymentReply(soap, tag?tag:"ns2:PayPalPaymentReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalPaymentReply ** SOAP_FMAC4 soap_get_PointerTons2__PayPalPaymentReply(struct soap *soap, ns2__PayPalPaymentReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalPaymentReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PaySubscriptionDeleteReply(struct soap *soap, ns2__PaySubscriptionDeleteReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PaySubscriptionDeleteReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PaySubscriptionDeleteReply(struct soap *soap, const char *tag, int id, ns2__PaySubscriptionDeleteReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PaySubscriptionDeleteReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PaySubscriptionDeleteReply ** SOAP_FMAC4 soap_in_PointerTons2__PaySubscriptionDeleteReply(struct soap *soap, const char *tag, ns2__PaySubscriptionDeleteReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PaySubscriptionDeleteReply **)soap_malloc(soap, sizeof(ns2__PaySubscriptionDeleteReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PaySubscriptionDeleteReply *)soap_instantiate_ns2__PaySubscriptionDeleteReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PaySubscriptionDeleteReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PaySubscriptionDeleteReply, sizeof(ns2__PaySubscriptionDeleteReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PaySubscriptionDeleteReply(struct soap *soap, ns2__PaySubscriptionDeleteReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PaySubscriptionDeleteReply(soap, tag?tag:"ns2:PaySubscriptionDeleteReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PaySubscriptionDeleteReply ** SOAP_FMAC4 soap_get_PointerTons2__PaySubscriptionDeleteReply(struct soap *soap, ns2__PaySubscriptionDeleteReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PaySubscriptionDeleteReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PaySubscriptionRetrieveReply(struct soap *soap, ns2__PaySubscriptionRetrieveReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PaySubscriptionRetrieveReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PaySubscriptionRetrieveReply(struct soap *soap, const char *tag, int id, ns2__PaySubscriptionRetrieveReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PaySubscriptionRetrieveReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PaySubscriptionRetrieveReply ** SOAP_FMAC4 soap_in_PointerTons2__PaySubscriptionRetrieveReply(struct soap *soap, const char *tag, ns2__PaySubscriptionRetrieveReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PaySubscriptionRetrieveReply **)soap_malloc(soap, sizeof(ns2__PaySubscriptionRetrieveReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PaySubscriptionRetrieveReply *)soap_instantiate_ns2__PaySubscriptionRetrieveReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PaySubscriptionRetrieveReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PaySubscriptionRetrieveReply, sizeof(ns2__PaySubscriptionRetrieveReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PaySubscriptionRetrieveReply(struct soap *soap, ns2__PaySubscriptionRetrieveReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PaySubscriptionRetrieveReply(soap, tag?tag:"ns2:PaySubscriptionRetrieveReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PaySubscriptionRetrieveReply ** SOAP_FMAC4 soap_get_PointerTons2__PaySubscriptionRetrieveReply(struct soap *soap, ns2__PaySubscriptionRetrieveReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PaySubscriptionRetrieveReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PaySubscriptionEventUpdateReply(struct soap *soap, ns2__PaySubscriptionEventUpdateReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PaySubscriptionEventUpdateReply(struct soap *soap, const char *tag, int id, ns2__PaySubscriptionEventUpdateReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PaySubscriptionEventUpdateReply ** SOAP_FMAC4 soap_in_PointerTons2__PaySubscriptionEventUpdateReply(struct soap *soap, const char *tag, ns2__PaySubscriptionEventUpdateReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PaySubscriptionEventUpdateReply **)soap_malloc(soap, sizeof(ns2__PaySubscriptionEventUpdateReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PaySubscriptionEventUpdateReply *)soap_instantiate_ns2__PaySubscriptionEventUpdateReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PaySubscriptionEventUpdateReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply, sizeof(ns2__PaySubscriptionEventUpdateReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PaySubscriptionEventUpdateReply(struct soap *soap, ns2__PaySubscriptionEventUpdateReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PaySubscriptionEventUpdateReply(soap, tag?tag:"ns2:PaySubscriptionEventUpdateReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PaySubscriptionEventUpdateReply ** SOAP_FMAC4 soap_get_PointerTons2__PaySubscriptionEventUpdateReply(struct soap *soap, ns2__PaySubscriptionEventUpdateReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PaySubscriptionEventUpdateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PaySubscriptionUpdateReply(struct soap *soap, ns2__PaySubscriptionUpdateReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PaySubscriptionUpdateReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PaySubscriptionUpdateReply(struct soap *soap, const char *tag, int id, ns2__PaySubscriptionUpdateReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PaySubscriptionUpdateReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PaySubscriptionUpdateReply ** SOAP_FMAC4 soap_in_PointerTons2__PaySubscriptionUpdateReply(struct soap *soap, const char *tag, ns2__PaySubscriptionUpdateReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PaySubscriptionUpdateReply **)soap_malloc(soap, sizeof(ns2__PaySubscriptionUpdateReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PaySubscriptionUpdateReply *)soap_instantiate_ns2__PaySubscriptionUpdateReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PaySubscriptionUpdateReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PaySubscriptionUpdateReply, sizeof(ns2__PaySubscriptionUpdateReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PaySubscriptionUpdateReply(struct soap *soap, ns2__PaySubscriptionUpdateReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PaySubscriptionUpdateReply(soap, tag?tag:"ns2:PaySubscriptionUpdateReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PaySubscriptionUpdateReply ** SOAP_FMAC4 soap_get_PointerTons2__PaySubscriptionUpdateReply(struct soap *soap, ns2__PaySubscriptionUpdateReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PaySubscriptionUpdateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PaySubscriptionCreateReply(struct soap *soap, ns2__PaySubscriptionCreateReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PaySubscriptionCreateReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PaySubscriptionCreateReply(struct soap *soap, const char *tag, int id, ns2__PaySubscriptionCreateReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PaySubscriptionCreateReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PaySubscriptionCreateReply ** SOAP_FMAC4 soap_in_PointerTons2__PaySubscriptionCreateReply(struct soap *soap, const char *tag, ns2__PaySubscriptionCreateReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PaySubscriptionCreateReply **)soap_malloc(soap, sizeof(ns2__PaySubscriptionCreateReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PaySubscriptionCreateReply *)soap_instantiate_ns2__PaySubscriptionCreateReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PaySubscriptionCreateReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PaySubscriptionCreateReply, sizeof(ns2__PaySubscriptionCreateReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PaySubscriptionCreateReply(struct soap *soap, ns2__PaySubscriptionCreateReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PaySubscriptionCreateReply(soap, tag?tag:"ns2:PaySubscriptionCreateReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PaySubscriptionCreateReply ** SOAP_FMAC4 soap_get_PointerTons2__PaySubscriptionCreateReply(struct soap *soap, ns2__PaySubscriptionCreateReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PaySubscriptionCreateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DirectDebitRefundReply(struct soap *soap, ns2__DirectDebitRefundReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DirectDebitRefundReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DirectDebitRefundReply(struct soap *soap, const char *tag, int id, ns2__DirectDebitRefundReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DirectDebitRefundReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DirectDebitRefundReply ** SOAP_FMAC4 soap_in_PointerTons2__DirectDebitRefundReply(struct soap *soap, const char *tag, ns2__DirectDebitRefundReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DirectDebitRefundReply **)soap_malloc(soap, sizeof(ns2__DirectDebitRefundReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DirectDebitRefundReply *)soap_instantiate_ns2__DirectDebitRefundReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DirectDebitRefundReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DirectDebitRefundReply, sizeof(ns2__DirectDebitRefundReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DirectDebitRefundReply(struct soap *soap, ns2__DirectDebitRefundReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DirectDebitRefundReply(soap, tag?tag:"ns2:DirectDebitRefundReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DirectDebitRefundReply ** SOAP_FMAC4 soap_get_PointerTons2__DirectDebitRefundReply(struct soap *soap, ns2__DirectDebitRefundReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DirectDebitRefundReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DirectDebitValidateReply(struct soap *soap, ns2__DirectDebitValidateReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DirectDebitValidateReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DirectDebitValidateReply(struct soap *soap, const char *tag, int id, ns2__DirectDebitValidateReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DirectDebitValidateReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DirectDebitValidateReply ** SOAP_FMAC4 soap_in_PointerTons2__DirectDebitValidateReply(struct soap *soap, const char *tag, ns2__DirectDebitValidateReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DirectDebitValidateReply **)soap_malloc(soap, sizeof(ns2__DirectDebitValidateReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DirectDebitValidateReply *)soap_instantiate_ns2__DirectDebitValidateReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DirectDebitValidateReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DirectDebitValidateReply, sizeof(ns2__DirectDebitValidateReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DirectDebitValidateReply(struct soap *soap, ns2__DirectDebitValidateReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DirectDebitValidateReply(soap, tag?tag:"ns2:DirectDebitValidateReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DirectDebitValidateReply ** SOAP_FMAC4 soap_get_PointerTons2__DirectDebitValidateReply(struct soap *soap, ns2__DirectDebitValidateReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DirectDebitValidateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DirectDebitReply(struct soap *soap, ns2__DirectDebitReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DirectDebitReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DirectDebitReply(struct soap *soap, const char *tag, int id, ns2__DirectDebitReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DirectDebitReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DirectDebitReply ** SOAP_FMAC4 soap_in_PointerTons2__DirectDebitReply(struct soap *soap, const char *tag, ns2__DirectDebitReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DirectDebitReply **)soap_malloc(soap, sizeof(ns2__DirectDebitReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DirectDebitReply *)soap_instantiate_ns2__DirectDebitReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DirectDebitReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DirectDebitReply, sizeof(ns2__DirectDebitReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DirectDebitReply(struct soap *soap, ns2__DirectDebitReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DirectDebitReply(soap, tag?tag:"ns2:DirectDebitReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DirectDebitReply ** SOAP_FMAC4 soap_get_PointerTons2__DirectDebitReply(struct soap *soap, ns2__DirectDebitReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DirectDebitReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DirectDebitMandateReply(struct soap *soap, ns2__DirectDebitMandateReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DirectDebitMandateReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DirectDebitMandateReply(struct soap *soap, const char *tag, int id, ns2__DirectDebitMandateReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DirectDebitMandateReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DirectDebitMandateReply ** SOAP_FMAC4 soap_in_PointerTons2__DirectDebitMandateReply(struct soap *soap, const char *tag, ns2__DirectDebitMandateReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DirectDebitMandateReply **)soap_malloc(soap, sizeof(ns2__DirectDebitMandateReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DirectDebitMandateReply *)soap_instantiate_ns2__DirectDebitMandateReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DirectDebitMandateReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DirectDebitMandateReply, sizeof(ns2__DirectDebitMandateReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DirectDebitMandateReply(struct soap *soap, ns2__DirectDebitMandateReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DirectDebitMandateReply(soap, tag?tag:"ns2:DirectDebitMandateReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DirectDebitMandateReply ** SOAP_FMAC4 soap_get_PointerTons2__DirectDebitMandateReply(struct soap *soap, ns2__DirectDebitMandateReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DirectDebitMandateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BankTransferRealTimeReply(struct soap *soap, ns2__BankTransferRealTimeReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BankTransferRealTimeReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BankTransferRealTimeReply(struct soap *soap, const char *tag, int id, ns2__BankTransferRealTimeReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BankTransferRealTimeReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__BankTransferRealTimeReply ** SOAP_FMAC4 soap_in_PointerTons2__BankTransferRealTimeReply(struct soap *soap, const char *tag, ns2__BankTransferRealTimeReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__BankTransferRealTimeReply **)soap_malloc(soap, sizeof(ns2__BankTransferRealTimeReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__BankTransferRealTimeReply *)soap_instantiate_ns2__BankTransferRealTimeReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__BankTransferRealTimeReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BankTransferRealTimeReply, sizeof(ns2__BankTransferRealTimeReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BankTransferRealTimeReply(struct soap *soap, ns2__BankTransferRealTimeReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__BankTransferRealTimeReply(soap, tag?tag:"ns2:BankTransferRealTimeReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__BankTransferRealTimeReply ** SOAP_FMAC4 soap_get_PointerTons2__BankTransferRealTimeReply(struct soap *soap, ns2__BankTransferRealTimeReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BankTransferRealTimeReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BankTransferRefundReply(struct soap *soap, ns2__BankTransferRefundReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BankTransferRefundReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BankTransferRefundReply(struct soap *soap, const char *tag, int id, ns2__BankTransferRefundReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BankTransferRefundReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__BankTransferRefundReply ** SOAP_FMAC4 soap_in_PointerTons2__BankTransferRefundReply(struct soap *soap, const char *tag, ns2__BankTransferRefundReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__BankTransferRefundReply **)soap_malloc(soap, sizeof(ns2__BankTransferRefundReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__BankTransferRefundReply *)soap_instantiate_ns2__BankTransferRefundReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__BankTransferRefundReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BankTransferRefundReply, sizeof(ns2__BankTransferRefundReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BankTransferRefundReply(struct soap *soap, ns2__BankTransferRefundReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__BankTransferRefundReply(soap, tag?tag:"ns2:BankTransferRefundReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__BankTransferRefundReply ** SOAP_FMAC4 soap_get_PointerTons2__BankTransferRefundReply(struct soap *soap, ns2__BankTransferRefundReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BankTransferRefundReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BankTransferReply(struct soap *soap, ns2__BankTransferReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BankTransferReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BankTransferReply(struct soap *soap, const char *tag, int id, ns2__BankTransferReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BankTransferReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__BankTransferReply ** SOAP_FMAC4 soap_in_PointerTons2__BankTransferReply(struct soap *soap, const char *tag, ns2__BankTransferReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__BankTransferReply **)soap_malloc(soap, sizeof(ns2__BankTransferReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__BankTransferReply *)soap_instantiate_ns2__BankTransferReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__BankTransferReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BankTransferReply, sizeof(ns2__BankTransferReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BankTransferReply(struct soap *soap, ns2__BankTransferReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__BankTransferReply(soap, tag?tag:"ns2:BankTransferReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__BankTransferReply ** SOAP_FMAC4 soap_get_PointerTons2__BankTransferReply(struct soap *soap, ns2__BankTransferReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BankTransferReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FXRatesReply(struct soap *soap, ns2__FXRatesReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FXRatesReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FXRatesReply(struct soap *soap, const char *tag, int id, ns2__FXRatesReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FXRatesReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__FXRatesReply ** SOAP_FMAC4 soap_in_PointerTons2__FXRatesReply(struct soap *soap, const char *tag, ns2__FXRatesReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__FXRatesReply **)soap_malloc(soap, sizeof(ns2__FXRatesReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__FXRatesReply *)soap_instantiate_ns2__FXRatesReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__FXRatesReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FXRatesReply, sizeof(ns2__FXRatesReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FXRatesReply(struct soap *soap, ns2__FXRatesReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__FXRatesReply(soap, tag?tag:"ns2:FXRatesReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__FXRatesReply ** SOAP_FMAC4 soap_get_PointerTons2__FXRatesReply(struct soap *soap, ns2__FXRatesReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FXRatesReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ExportReply(struct soap *soap, ns2__ExportReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ExportReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ExportReply(struct soap *soap, const char *tag, int id, ns2__ExportReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ExportReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ExportReply ** SOAP_FMAC4 soap_in_PointerTons2__ExportReply(struct soap *soap, const char *tag, ns2__ExportReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ExportReply **)soap_malloc(soap, sizeof(ns2__ExportReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ExportReply *)soap_instantiate_ns2__ExportReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ExportReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ExportReply, sizeof(ns2__ExportReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ExportReply(struct soap *soap, ns2__ExportReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ExportReply(soap, tag?tag:"ns2:ExportReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ExportReply ** SOAP_FMAC4 soap_get_PointerTons2__ExportReply(struct soap *soap, ns2__ExportReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ExportReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DAVReply(struct soap *soap, ns2__DAVReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DAVReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DAVReply(struct soap *soap, const char *tag, int id, ns2__DAVReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DAVReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DAVReply ** SOAP_FMAC4 soap_in_PointerTons2__DAVReply(struct soap *soap, const char *tag, ns2__DAVReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DAVReply **)soap_malloc(soap, sizeof(ns2__DAVReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DAVReply *)soap_instantiate_ns2__DAVReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DAVReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DAVReply, sizeof(ns2__DAVReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DAVReply(struct soap *soap, ns2__DAVReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DAVReply(soap, tag?tag:"ns2:DAVReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DAVReply ** SOAP_FMAC4 soap_get_PointerTons2__DAVReply(struct soap *soap, ns2__DAVReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DAVReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AFSReply(struct soap *soap, ns2__AFSReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AFSReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AFSReply(struct soap *soap, const char *tag, int id, ns2__AFSReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AFSReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AFSReply ** SOAP_FMAC4 soap_in_PointerTons2__AFSReply(struct soap *soap, const char *tag, ns2__AFSReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AFSReply **)soap_malloc(soap, sizeof(ns2__AFSReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AFSReply *)soap_instantiate_ns2__AFSReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__AFSReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AFSReply, sizeof(ns2__AFSReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AFSReply(struct soap *soap, ns2__AFSReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__AFSReply(soap, tag?tag:"ns2:AFSReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AFSReply ** SOAP_FMAC4 soap_get_PointerTons2__AFSReply(struct soap *soap, ns2__AFSReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AFSReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DMEReply(struct soap *soap, ns2__DMEReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DMEReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DMEReply(struct soap *soap, const char *tag, int id, ns2__DMEReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DMEReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DMEReply ** SOAP_FMAC4 soap_in_PointerTons2__DMEReply(struct soap *soap, const char *tag, ns2__DMEReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DMEReply **)soap_malloc(soap, sizeof(ns2__DMEReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DMEReply *)soap_instantiate_ns2__DMEReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DMEReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DMEReply, sizeof(ns2__DMEReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DMEReply(struct soap *soap, ns2__DMEReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DMEReply(soap, tag?tag:"ns2:DMEReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DMEReply ** SOAP_FMAC4 soap_get_PointerTons2__DMEReply(struct soap *soap, ns2__DMEReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DMEReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__EncryptPaymentDataReply(struct soap *soap, ns2__EncryptPaymentDataReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__EncryptPaymentDataReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__EncryptPaymentDataReply(struct soap *soap, const char *tag, int id, ns2__EncryptPaymentDataReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__EncryptPaymentDataReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__EncryptPaymentDataReply ** SOAP_FMAC4 soap_in_PointerTons2__EncryptPaymentDataReply(struct soap *soap, const char *tag, ns2__EncryptPaymentDataReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__EncryptPaymentDataReply **)soap_malloc(soap, sizeof(ns2__EncryptPaymentDataReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__EncryptPaymentDataReply *)soap_instantiate_ns2__EncryptPaymentDataReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__EncryptPaymentDataReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__EncryptPaymentDataReply, sizeof(ns2__EncryptPaymentDataReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__EncryptPaymentDataReply(struct soap *soap, ns2__EncryptPaymentDataReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__EncryptPaymentDataReply(soap, tag?tag:"ns2:EncryptPaymentDataReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__EncryptPaymentDataReply ** SOAP_FMAC4 soap_get_PointerTons2__EncryptPaymentDataReply(struct soap *soap, ns2__EncryptPaymentDataReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__EncryptPaymentDataReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaxReply(struct soap *soap, ns2__TaxReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaxReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaxReply(struct soap *soap, const char *tag, int id, ns2__TaxReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaxReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__TaxReply ** SOAP_FMAC4 soap_in_PointerTons2__TaxReply(struct soap *soap, const char *tag, ns2__TaxReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaxReply **)soap_malloc(soap, sizeof(ns2__TaxReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaxReply *)soap_instantiate_ns2__TaxReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaxReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaxReply, sizeof(ns2__TaxReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaxReply(struct soap *soap, ns2__TaxReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaxReply(soap, tag?tag:"ns2:TaxReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaxReply ** SOAP_FMAC4 soap_get_PointerTons2__TaxReply(struct soap *soap, ns2__TaxReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaxReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayerAuthValidateReply(struct soap *soap, ns2__PayerAuthValidateReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayerAuthValidateReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayerAuthValidateReply(struct soap *soap, const char *tag, int id, ns2__PayerAuthValidateReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayerAuthValidateReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayerAuthValidateReply ** SOAP_FMAC4 soap_in_PointerTons2__PayerAuthValidateReply(struct soap *soap, const char *tag, ns2__PayerAuthValidateReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayerAuthValidateReply **)soap_malloc(soap, sizeof(ns2__PayerAuthValidateReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayerAuthValidateReply *)soap_instantiate_ns2__PayerAuthValidateReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayerAuthValidateReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayerAuthValidateReply, sizeof(ns2__PayerAuthValidateReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayerAuthValidateReply(struct soap *soap, ns2__PayerAuthValidateReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayerAuthValidateReply(soap, tag?tag:"ns2:PayerAuthValidateReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayerAuthValidateReply ** SOAP_FMAC4 soap_get_PointerTons2__PayerAuthValidateReply(struct soap *soap, ns2__PayerAuthValidateReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayerAuthValidateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayerAuthEnrollReply(struct soap *soap, ns2__PayerAuthEnrollReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayerAuthEnrollReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayerAuthEnrollReply(struct soap *soap, const char *tag, int id, ns2__PayerAuthEnrollReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayerAuthEnrollReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayerAuthEnrollReply ** SOAP_FMAC4 soap_in_PointerTons2__PayerAuthEnrollReply(struct soap *soap, const char *tag, ns2__PayerAuthEnrollReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayerAuthEnrollReply **)soap_malloc(soap, sizeof(ns2__PayerAuthEnrollReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayerAuthEnrollReply *)soap_instantiate_ns2__PayerAuthEnrollReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayerAuthEnrollReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayerAuthEnrollReply, sizeof(ns2__PayerAuthEnrollReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayerAuthEnrollReply(struct soap *soap, ns2__PayerAuthEnrollReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayerAuthEnrollReply(soap, tag?tag:"ns2:PayerAuthEnrollReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayerAuthEnrollReply ** SOAP_FMAC4 soap_get_PointerTons2__PayerAuthEnrollReply(struct soap *soap, ns2__PayerAuthEnrollReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayerAuthEnrollReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ECAuthenticateReply(struct soap *soap, ns2__ECAuthenticateReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ECAuthenticateReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ECAuthenticateReply(struct soap *soap, const char *tag, int id, ns2__ECAuthenticateReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ECAuthenticateReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ECAuthenticateReply ** SOAP_FMAC4 soap_in_PointerTons2__ECAuthenticateReply(struct soap *soap, const char *tag, ns2__ECAuthenticateReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ECAuthenticateReply **)soap_malloc(soap, sizeof(ns2__ECAuthenticateReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ECAuthenticateReply *)soap_instantiate_ns2__ECAuthenticateReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ECAuthenticateReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ECAuthenticateReply, sizeof(ns2__ECAuthenticateReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ECAuthenticateReply(struct soap *soap, ns2__ECAuthenticateReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ECAuthenticateReply(soap, tag?tag:"ns2:ECAuthenticateReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ECAuthenticateReply ** SOAP_FMAC4 soap_get_PointerTons2__ECAuthenticateReply(struct soap *soap, ns2__ECAuthenticateReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ECAuthenticateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ECCreditReply(struct soap *soap, ns2__ECCreditReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ECCreditReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ECCreditReply(struct soap *soap, const char *tag, int id, ns2__ECCreditReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ECCreditReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ECCreditReply ** SOAP_FMAC4 soap_in_PointerTons2__ECCreditReply(struct soap *soap, const char *tag, ns2__ECCreditReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ECCreditReply **)soap_malloc(soap, sizeof(ns2__ECCreditReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ECCreditReply *)soap_instantiate_ns2__ECCreditReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ECCreditReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ECCreditReply, sizeof(ns2__ECCreditReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ECCreditReply(struct soap *soap, ns2__ECCreditReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ECCreditReply(soap, tag?tag:"ns2:ECCreditReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ECCreditReply ** SOAP_FMAC4 soap_get_PointerTons2__ECCreditReply(struct soap *soap, ns2__ECCreditReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ECCreditReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ECDebitReply(struct soap *soap, ns2__ECDebitReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ECDebitReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ECDebitReply(struct soap *soap, const char *tag, int id, ns2__ECDebitReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ECDebitReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ECDebitReply ** SOAP_FMAC4 soap_in_PointerTons2__ECDebitReply(struct soap *soap, const char *tag, ns2__ECDebitReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ECDebitReply **)soap_malloc(soap, sizeof(ns2__ECDebitReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ECDebitReply *)soap_instantiate_ns2__ECDebitReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ECDebitReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ECDebitReply, sizeof(ns2__ECDebitReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ECDebitReply(struct soap *soap, ns2__ECDebitReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ECDebitReply(soap, tag?tag:"ns2:ECDebitReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ECDebitReply ** SOAP_FMAC4 soap_get_PointerTons2__ECDebitReply(struct soap *soap, ns2__ECDebitReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ECDebitReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CCDCCUpdateReply(struct soap *soap, ns2__CCDCCUpdateReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CCDCCUpdateReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CCDCCUpdateReply(struct soap *soap, const char *tag, int id, ns2__CCDCCUpdateReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CCDCCUpdateReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CCDCCUpdateReply ** SOAP_FMAC4 soap_in_PointerTons2__CCDCCUpdateReply(struct soap *soap, const char *tag, ns2__CCDCCUpdateReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CCDCCUpdateReply **)soap_malloc(soap, sizeof(ns2__CCDCCUpdateReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CCDCCUpdateReply *)soap_instantiate_ns2__CCDCCUpdateReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CCDCCUpdateReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CCDCCUpdateReply, sizeof(ns2__CCDCCUpdateReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CCDCCUpdateReply(struct soap *soap, ns2__CCDCCUpdateReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CCDCCUpdateReply(soap, tag?tag:"ns2:CCDCCUpdateReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CCDCCUpdateReply ** SOAP_FMAC4 soap_get_PointerTons2__CCDCCUpdateReply(struct soap *soap, ns2__CCDCCUpdateReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CCDCCUpdateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CCDCCReply(struct soap *soap, ns2__CCDCCReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CCDCCReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CCDCCReply(struct soap *soap, const char *tag, int id, ns2__CCDCCReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CCDCCReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CCDCCReply ** SOAP_FMAC4 soap_in_PointerTons2__CCDCCReply(struct soap *soap, const char *tag, ns2__CCDCCReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CCDCCReply **)soap_malloc(soap, sizeof(ns2__CCDCCReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CCDCCReply *)soap_instantiate_ns2__CCDCCReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CCDCCReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CCDCCReply, sizeof(ns2__CCDCCReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CCDCCReply(struct soap *soap, ns2__CCDCCReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CCDCCReply(soap, tag?tag:"ns2:CCDCCReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CCDCCReply ** SOAP_FMAC4 soap_get_PointerTons2__CCDCCReply(struct soap *soap, ns2__CCDCCReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CCDCCReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CCAutoAuthReversalReply(struct soap *soap, ns2__CCAutoAuthReversalReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CCAutoAuthReversalReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CCAutoAuthReversalReply(struct soap *soap, const char *tag, int id, ns2__CCAutoAuthReversalReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CCAutoAuthReversalReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CCAutoAuthReversalReply ** SOAP_FMAC4 soap_in_PointerTons2__CCAutoAuthReversalReply(struct soap *soap, const char *tag, ns2__CCAutoAuthReversalReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CCAutoAuthReversalReply **)soap_malloc(soap, sizeof(ns2__CCAutoAuthReversalReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CCAutoAuthReversalReply *)soap_instantiate_ns2__CCAutoAuthReversalReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CCAutoAuthReversalReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CCAutoAuthReversalReply, sizeof(ns2__CCAutoAuthReversalReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CCAutoAuthReversalReply(struct soap *soap, ns2__CCAutoAuthReversalReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CCAutoAuthReversalReply(soap, tag?tag:"ns2:CCAutoAuthReversalReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CCAutoAuthReversalReply ** SOAP_FMAC4 soap_get_PointerTons2__CCAutoAuthReversalReply(struct soap *soap, ns2__CCAutoAuthReversalReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CCAutoAuthReversalReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CCAuthReversalReply(struct soap *soap, ns2__CCAuthReversalReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CCAuthReversalReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CCAuthReversalReply(struct soap *soap, const char *tag, int id, ns2__CCAuthReversalReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CCAuthReversalReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CCAuthReversalReply ** SOAP_FMAC4 soap_in_PointerTons2__CCAuthReversalReply(struct soap *soap, const char *tag, ns2__CCAuthReversalReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CCAuthReversalReply **)soap_malloc(soap, sizeof(ns2__CCAuthReversalReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CCAuthReversalReply *)soap_instantiate_ns2__CCAuthReversalReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CCAuthReversalReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CCAuthReversalReply, sizeof(ns2__CCAuthReversalReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CCAuthReversalReply(struct soap *soap, ns2__CCAuthReversalReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CCAuthReversalReply(soap, tag?tag:"ns2:CCAuthReversalReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CCAuthReversalReply ** SOAP_FMAC4 soap_get_PointerTons2__CCAuthReversalReply(struct soap *soap, ns2__CCAuthReversalReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CCAuthReversalReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CCCreditReply(struct soap *soap, ns2__CCCreditReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CCCreditReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CCCreditReply(struct soap *soap, const char *tag, int id, ns2__CCCreditReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CCCreditReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CCCreditReply ** SOAP_FMAC4 soap_in_PointerTons2__CCCreditReply(struct soap *soap, const char *tag, ns2__CCCreditReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CCCreditReply **)soap_malloc(soap, sizeof(ns2__CCCreditReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CCCreditReply *)soap_instantiate_ns2__CCCreditReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CCCreditReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CCCreditReply, sizeof(ns2__CCCreditReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CCCreditReply(struct soap *soap, ns2__CCCreditReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CCCreditReply(soap, tag?tag:"ns2:CCCreditReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CCCreditReply ** SOAP_FMAC4 soap_get_PointerTons2__CCCreditReply(struct soap *soap, ns2__CCCreditReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CCCreditReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CCCaptureReply(struct soap *soap, ns2__CCCaptureReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CCCaptureReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CCCaptureReply(struct soap *soap, const char *tag, int id, ns2__CCCaptureReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CCCaptureReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CCCaptureReply ** SOAP_FMAC4 soap_in_PointerTons2__CCCaptureReply(struct soap *soap, const char *tag, ns2__CCCaptureReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CCCaptureReply **)soap_malloc(soap, sizeof(ns2__CCCaptureReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CCCaptureReply *)soap_instantiate_ns2__CCCaptureReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CCCaptureReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CCCaptureReply, sizeof(ns2__CCCaptureReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CCCaptureReply(struct soap *soap, ns2__CCCaptureReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CCCaptureReply(soap, tag?tag:"ns2:CCCaptureReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CCCaptureReply ** SOAP_FMAC4 soap_get_PointerTons2__CCCaptureReply(struct soap *soap, ns2__CCCaptureReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CCCaptureReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ServiceFeeCalculateReply(struct soap *soap, ns2__ServiceFeeCalculateReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ServiceFeeCalculateReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ServiceFeeCalculateReply(struct soap *soap, const char *tag, int id, ns2__ServiceFeeCalculateReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ServiceFeeCalculateReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ServiceFeeCalculateReply ** SOAP_FMAC4 soap_in_PointerTons2__ServiceFeeCalculateReply(struct soap *soap, const char *tag, ns2__ServiceFeeCalculateReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ServiceFeeCalculateReply **)soap_malloc(soap, sizeof(ns2__ServiceFeeCalculateReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ServiceFeeCalculateReply *)soap_instantiate_ns2__ServiceFeeCalculateReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ServiceFeeCalculateReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ServiceFeeCalculateReply, sizeof(ns2__ServiceFeeCalculateReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ServiceFeeCalculateReply(struct soap *soap, ns2__ServiceFeeCalculateReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ServiceFeeCalculateReply(soap, tag?tag:"ns2:ServiceFeeCalculateReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ServiceFeeCalculateReply ** SOAP_FMAC4 soap_get_PointerTons2__ServiceFeeCalculateReply(struct soap *soap, ns2__ServiceFeeCalculateReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ServiceFeeCalculateReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CCIncrementalAuthReply(struct soap *soap, ns2__CCIncrementalAuthReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CCIncrementalAuthReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CCIncrementalAuthReply(struct soap *soap, const char *tag, int id, ns2__CCIncrementalAuthReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CCIncrementalAuthReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CCIncrementalAuthReply ** SOAP_FMAC4 soap_in_PointerTons2__CCIncrementalAuthReply(struct soap *soap, const char *tag, ns2__CCIncrementalAuthReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CCIncrementalAuthReply **)soap_malloc(soap, sizeof(ns2__CCIncrementalAuthReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CCIncrementalAuthReply *)soap_instantiate_ns2__CCIncrementalAuthReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CCIncrementalAuthReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CCIncrementalAuthReply, sizeof(ns2__CCIncrementalAuthReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CCIncrementalAuthReply(struct soap *soap, ns2__CCIncrementalAuthReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CCIncrementalAuthReply(soap, tag?tag:"ns2:CCIncrementalAuthReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CCIncrementalAuthReply ** SOAP_FMAC4 soap_get_PointerTons2__CCIncrementalAuthReply(struct soap *soap, ns2__CCIncrementalAuthReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CCIncrementalAuthReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CCSaleReversalReply(struct soap *soap, ns2__CCSaleReversalReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CCSaleReversalReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CCSaleReversalReply(struct soap *soap, const char *tag, int id, ns2__CCSaleReversalReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CCSaleReversalReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CCSaleReversalReply ** SOAP_FMAC4 soap_in_PointerTons2__CCSaleReversalReply(struct soap *soap, const char *tag, ns2__CCSaleReversalReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CCSaleReversalReply **)soap_malloc(soap, sizeof(ns2__CCSaleReversalReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CCSaleReversalReply *)soap_instantiate_ns2__CCSaleReversalReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CCSaleReversalReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CCSaleReversalReply, sizeof(ns2__CCSaleReversalReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CCSaleReversalReply(struct soap *soap, ns2__CCSaleReversalReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CCSaleReversalReply(soap, tag?tag:"ns2:CCSaleReversalReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CCSaleReversalReply ** SOAP_FMAC4 soap_get_PointerTons2__CCSaleReversalReply(struct soap *soap, ns2__CCSaleReversalReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CCSaleReversalReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CCSaleCreditReply(struct soap *soap, ns2__CCSaleCreditReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CCSaleCreditReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CCSaleCreditReply(struct soap *soap, const char *tag, int id, ns2__CCSaleCreditReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CCSaleCreditReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CCSaleCreditReply ** SOAP_FMAC4 soap_in_PointerTons2__CCSaleCreditReply(struct soap *soap, const char *tag, ns2__CCSaleCreditReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CCSaleCreditReply **)soap_malloc(soap, sizeof(ns2__CCSaleCreditReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CCSaleCreditReply *)soap_instantiate_ns2__CCSaleCreditReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CCSaleCreditReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CCSaleCreditReply, sizeof(ns2__CCSaleCreditReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CCSaleCreditReply(struct soap *soap, ns2__CCSaleCreditReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CCSaleCreditReply(soap, tag?tag:"ns2:CCSaleCreditReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CCSaleCreditReply ** SOAP_FMAC4 soap_get_PointerTons2__CCSaleCreditReply(struct soap *soap, ns2__CCSaleCreditReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CCSaleCreditReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CCSaleReply(struct soap *soap, ns2__CCSaleReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CCSaleReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CCSaleReply(struct soap *soap, const char *tag, int id, ns2__CCSaleReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CCSaleReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CCSaleReply ** SOAP_FMAC4 soap_in_PointerTons2__CCSaleReply(struct soap *soap, const char *tag, ns2__CCSaleReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CCSaleReply **)soap_malloc(soap, sizeof(ns2__CCSaleReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CCSaleReply *)soap_instantiate_ns2__CCSaleReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CCSaleReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CCSaleReply, sizeof(ns2__CCSaleReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CCSaleReply(struct soap *soap, ns2__CCSaleReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CCSaleReply(soap, tag?tag:"ns2:CCSaleReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CCSaleReply ** SOAP_FMAC4 soap_get_PointerTons2__CCSaleReply(struct soap *soap, ns2__CCSaleReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CCSaleReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VerificationReply(struct soap *soap, ns2__VerificationReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VerificationReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VerificationReply(struct soap *soap, const char *tag, int id, ns2__VerificationReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VerificationReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__VerificationReply ** SOAP_FMAC4 soap_in_PointerTons2__VerificationReply(struct soap *soap, const char *tag, ns2__VerificationReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__VerificationReply **)soap_malloc(soap, sizeof(ns2__VerificationReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__VerificationReply *)soap_instantiate_ns2__VerificationReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__VerificationReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VerificationReply, sizeof(ns2__VerificationReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VerificationReply(struct soap *soap, ns2__VerificationReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__VerificationReply(soap, tag?tag:"ns2:VerificationReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__VerificationReply ** SOAP_FMAC4 soap_get_PointerTons2__VerificationReply(struct soap *soap, ns2__VerificationReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VerificationReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OCTReply(struct soap *soap, ns2__OCTReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OCTReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OCTReply(struct soap *soap, const char *tag, int id, ns2__OCTReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OCTReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__OCTReply ** SOAP_FMAC4 soap_in_PointerTons2__OCTReply(struct soap *soap, const char *tag, ns2__OCTReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__OCTReply **)soap_malloc(soap, sizeof(ns2__OCTReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__OCTReply *)soap_instantiate_ns2__OCTReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__OCTReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OCTReply, sizeof(ns2__OCTReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OCTReply(struct soap *soap, ns2__OCTReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__OCTReply(soap, tag?tag:"ns2:OCTReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__OCTReply ** SOAP_FMAC4 soap_get_PointerTons2__OCTReply(struct soap *soap, ns2__OCTReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OCTReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CCAuthReply(struct soap *soap, ns2__CCAuthReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CCAuthReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CCAuthReply(struct soap *soap, const char *tag, int id, ns2__CCAuthReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CCAuthReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CCAuthReply ** SOAP_FMAC4 soap_in_PointerTons2__CCAuthReply(struct soap *soap, const char *tag, ns2__CCAuthReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CCAuthReply **)soap_malloc(soap, sizeof(ns2__CCAuthReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CCAuthReply *)soap_instantiate_ns2__CCAuthReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CCAuthReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CCAuthReply, sizeof(ns2__CCAuthReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CCAuthReply(struct soap *soap, ns2__CCAuthReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CCAuthReply(soap, tag?tag:"ns2:CCAuthReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CCAuthReply ** SOAP_FMAC4 soap_get_PointerTons2__CCAuthReply(struct soap *soap, ns2__CCAuthReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CCAuthReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DeniedPartiesMatch(struct soap *soap, ns2__DeniedPartiesMatch *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DeniedPartiesMatch))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DeniedPartiesMatch(struct soap *soap, const char *tag, int id, ns2__DeniedPartiesMatch *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DeniedPartiesMatch, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DeniedPartiesMatch ** SOAP_FMAC4 soap_in_PointerTons2__DeniedPartiesMatch(struct soap *soap, const char *tag, ns2__DeniedPartiesMatch **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DeniedPartiesMatch **)soap_malloc(soap, sizeof(ns2__DeniedPartiesMatch *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DeniedPartiesMatch *)soap_instantiate_ns2__DeniedPartiesMatch(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DeniedPartiesMatch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DeniedPartiesMatch, sizeof(ns2__DeniedPartiesMatch), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DeniedPartiesMatch(struct soap *soap, ns2__DeniedPartiesMatch *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DeniedPartiesMatch(soap, tag?tag:"ns2:DeniedPartiesMatch", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DeniedPartiesMatch ** SOAP_FMAC4 soap_get_PointerTons2__DeniedPartiesMatch(struct soap *soap, ns2__DeniedPartiesMatch **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DeniedPartiesMatch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APOptionsOption(struct soap *soap, ns2__APOptionsOption *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APOptionsOption))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APOptionsOption(struct soap *soap, const char *tag, int id, ns2__APOptionsOption *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APOptionsOption, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APOptionsOption ** SOAP_FMAC4 soap_in_PointerTons2__APOptionsOption(struct soap *soap, const char *tag, ns2__APOptionsOption **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APOptionsOption **)soap_malloc(soap, sizeof(ns2__APOptionsOption *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APOptionsOption *)soap_instantiate_ns2__APOptionsOption(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APOptionsOption **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APOptionsOption, sizeof(ns2__APOptionsOption), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APOptionsOption(struct soap *soap, ns2__APOptionsOption *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APOptionsOption(soap, tag?tag:"ns2:APOptionsOption", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APOptionsOption ** SOAP_FMAC4 soap_get_PointerTons2__APOptionsOption(struct soap *soap, ns2__APOptionsOption **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APOptionsOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RuleResultItems(struct soap *soap, ns2__RuleResultItems *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RuleResultItems))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RuleResultItems(struct soap *soap, const char *tag, int id, ns2__RuleResultItems *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RuleResultItems, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RuleResultItems ** SOAP_FMAC4 soap_in_PointerTons2__RuleResultItems(struct soap *soap, const char *tag, ns2__RuleResultItems **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RuleResultItems **)soap_malloc(soap, sizeof(ns2__RuleResultItems *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RuleResultItems *)soap_instantiate_ns2__RuleResultItems(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__RuleResultItems **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RuleResultItems, sizeof(ns2__RuleResultItems), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RuleResultItems(struct soap *soap, ns2__RuleResultItems *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__RuleResultItems(soap, tag?tag:"ns2:RuleResultItems", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RuleResultItems ** SOAP_FMAC4 soap_get_PointerTons2__RuleResultItems(struct soap *soap, ns2__RuleResultItems **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RuleResultItems(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Field(struct soap *soap, ns2__Field *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Field))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Field(struct soap *soap, const char *tag, int id, ns2__Field *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Field, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Field ** SOAP_FMAC4 soap_in_PointerTons2__Field(struct soap *soap, const char *tag, ns2__Field **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Field **)soap_malloc(soap, sizeof(ns2__Field *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Field *)soap_instantiate_ns2__Field(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Field **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Field, sizeof(ns2__Field), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Field(struct soap *soap, ns2__Field *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Field(soap, tag?tag:"ns2:Field", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Field ** SOAP_FMAC4 soap_get_PointerTons2__Field(struct soap *soap, ns2__Field **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Field(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AdditionalFields(struct soap *soap, ns2__AdditionalFields *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AdditionalFields))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AdditionalFields(struct soap *soap, const char *tag, int id, ns2__AdditionalFields *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AdditionalFields, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AdditionalFields ** SOAP_FMAC4 soap_in_PointerTons2__AdditionalFields(struct soap *soap, const char *tag, ns2__AdditionalFields **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AdditionalFields **)soap_malloc(soap, sizeof(ns2__AdditionalFields *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AdditionalFields *)soap_instantiate_ns2__AdditionalFields(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__AdditionalFields **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AdditionalFields, sizeof(ns2__AdditionalFields), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AdditionalFields(struct soap *soap, ns2__AdditionalFields *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__AdditionalFields(soap, tag?tag:"ns2:AdditionalFields", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AdditionalFields ** SOAP_FMAC4 soap_get_PointerTons2__AdditionalFields(struct soap *soap, ns2__AdditionalFields **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AdditionalFields(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ProfileReply(struct soap *soap, ns2__ProfileReply *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ProfileReply))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ProfileReply(struct soap *soap, const char *tag, int id, ns2__ProfileReply *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ProfileReply, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ProfileReply ** SOAP_FMAC4 soap_in_PointerTons2__ProfileReply(struct soap *soap, const char *tag, ns2__ProfileReply **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ProfileReply **)soap_malloc(soap, sizeof(ns2__ProfileReply *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ProfileReply *)soap_instantiate_ns2__ProfileReply(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ProfileReply **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ProfileReply, sizeof(ns2__ProfileReply), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ProfileReply(struct soap *soap, ns2__ProfileReply *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ProfileReply(soap, tag?tag:"ns2:ProfileReply", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ProfileReply ** SOAP_FMAC4 soap_get_PointerTons2__ProfileReply(struct soap *soap, ns2__ProfileReply **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ProfileReply(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RuleResultItem(struct soap *soap, ns2__RuleResultItem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RuleResultItem))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RuleResultItem(struct soap *soap, const char *tag, int id, ns2__RuleResultItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RuleResultItem, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RuleResultItem ** SOAP_FMAC4 soap_in_PointerTons2__RuleResultItem(struct soap *soap, const char *tag, ns2__RuleResultItem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RuleResultItem **)soap_malloc(soap, sizeof(ns2__RuleResultItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RuleResultItem *)soap_instantiate_ns2__RuleResultItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__RuleResultItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RuleResultItem, sizeof(ns2__RuleResultItem), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RuleResultItem(struct soap *soap, ns2__RuleResultItem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__RuleResultItem(soap, tag?tag:"ns2:RuleResultItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RuleResultItem ** SOAP_FMAC4 soap_get_PointerTons2__RuleResultItem(struct soap *soap, ns2__RuleResultItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RuleResultItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FXQuote(struct soap *soap, ns2__FXQuote *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FXQuote))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FXQuote(struct soap *soap, const char *tag, int id, ns2__FXQuote *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FXQuote, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__FXQuote ** SOAP_FMAC4 soap_in_PointerTons2__FXQuote(struct soap *soap, const char *tag, ns2__FXQuote **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__FXQuote **)soap_malloc(soap, sizeof(ns2__FXQuote *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__FXQuote *)soap_instantiate_ns2__FXQuote(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__FXQuote **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FXQuote, sizeof(ns2__FXQuote), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FXQuote(struct soap *soap, ns2__FXQuote *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__FXQuote(soap, tag?tag:"ns2:FXQuote", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__FXQuote ** SOAP_FMAC4 soap_get_PointerTons2__FXQuote(struct soap *soap, ns2__FXQuote **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FXQuote(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DeviceFingerprint(struct soap *soap, ns2__DeviceFingerprint *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DeviceFingerprint))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DeviceFingerprint(struct soap *soap, const char *tag, int id, ns2__DeviceFingerprint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DeviceFingerprint, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DeviceFingerprint ** SOAP_FMAC4 soap_in_PointerTons2__DeviceFingerprint(struct soap *soap, const char *tag, ns2__DeviceFingerprint **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DeviceFingerprint **)soap_malloc(soap, sizeof(ns2__DeviceFingerprint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DeviceFingerprint *)soap_instantiate_ns2__DeviceFingerprint(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DeviceFingerprint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DeviceFingerprint, sizeof(ns2__DeviceFingerprint), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DeviceFingerprint(struct soap *soap, ns2__DeviceFingerprint *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DeviceFingerprint(soap, tag?tag:"ns2:DeviceFingerprint", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DeviceFingerprint ** SOAP_FMAC4 soap_get_PointerTons2__DeviceFingerprint(struct soap *soap, ns2__DeviceFingerprint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DeviceFingerprint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaxReplyItem(struct soap *soap, ns2__TaxReplyItem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaxReplyItem))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaxReplyItem(struct soap *soap, const char *tag, int id, ns2__TaxReplyItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaxReplyItem, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__TaxReplyItem ** SOAP_FMAC4 soap_in_PointerTons2__TaxReplyItem(struct soap *soap, const char *tag, ns2__TaxReplyItem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaxReplyItem **)soap_malloc(soap, sizeof(ns2__TaxReplyItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaxReplyItem *)soap_instantiate_ns2__TaxReplyItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaxReplyItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaxReplyItem, sizeof(ns2__TaxReplyItem), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaxReplyItem(struct soap *soap, ns2__TaxReplyItem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaxReplyItem(soap, tag?tag:"ns2:TaxReplyItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaxReplyItem ** SOAP_FMAC4 soap_get_PointerTons2__TaxReplyItem(struct soap *soap, ns2__TaxReplyItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaxReplyItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__issuer(struct soap *soap, ns2__issuer *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__issuer))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__issuer(struct soap *soap, const char *tag, int id, ns2__issuer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__issuer, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__issuer ** SOAP_FMAC4 soap_in_PointerTons2__issuer(struct soap *soap, const char *tag, ns2__issuer **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__issuer **)soap_malloc(soap, sizeof(ns2__issuer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__issuer *)soap_instantiate_ns2__issuer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__issuer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__issuer, sizeof(ns2__issuer), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__issuer(struct soap *soap, ns2__issuer *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__issuer(soap, tag?tag:"ns2:issuer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__issuer ** SOAP_FMAC4 soap_get_PointerTons2__issuer(struct soap *soap, ns2__issuer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__issuer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BinLookupService(struct soap *soap, ns2__BinLookupService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BinLookupService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BinLookupService(struct soap *soap, const char *tag, int id, ns2__BinLookupService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BinLookupService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__BinLookupService ** SOAP_FMAC4 soap_in_PointerTons2__BinLookupService(struct soap *soap, const char *tag, ns2__BinLookupService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__BinLookupService **)soap_malloc(soap, sizeof(ns2__BinLookupService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__BinLookupService *)soap_instantiate_ns2__BinLookupService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__BinLookupService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BinLookupService, sizeof(ns2__BinLookupService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BinLookupService(struct soap *soap, ns2__BinLookupService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__BinLookupService(soap, tag?tag:"ns2:BinLookupService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__BinLookupService ** SOAP_FMAC4 soap_get_PointerTons2__BinLookupService(struct soap *soap, ns2__BinLookupService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BinLookupService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__EncryptPaymentDataService(struct soap *soap, ns2__EncryptPaymentDataService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__EncryptPaymentDataService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__EncryptPaymentDataService(struct soap *soap, const char *tag, int id, ns2__EncryptPaymentDataService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__EncryptPaymentDataService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__EncryptPaymentDataService ** SOAP_FMAC4 soap_in_PointerTons2__EncryptPaymentDataService(struct soap *soap, const char *tag, ns2__EncryptPaymentDataService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__EncryptPaymentDataService **)soap_malloc(soap, sizeof(ns2__EncryptPaymentDataService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__EncryptPaymentDataService *)soap_instantiate_ns2__EncryptPaymentDataService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__EncryptPaymentDataService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__EncryptPaymentDataService, sizeof(ns2__EncryptPaymentDataService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__EncryptPaymentDataService(struct soap *soap, ns2__EncryptPaymentDataService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__EncryptPaymentDataService(soap, tag?tag:"ns2:EncryptPaymentDataService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__EncryptPaymentDataService ** SOAP_FMAC4 soap_get_PointerTons2__EncryptPaymentDataService(struct soap *soap, ns2__EncryptPaymentDataService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__EncryptPaymentDataService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Aft(struct soap *soap, ns2__Aft *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Aft))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Aft(struct soap *soap, const char *tag, int id, ns2__Aft *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Aft, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Aft ** SOAP_FMAC4 soap_in_PointerTons2__Aft(struct soap *soap, const char *tag, ns2__Aft **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Aft **)soap_malloc(soap, sizeof(ns2__Aft *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Aft *)soap_instantiate_ns2__Aft(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Aft **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Aft, sizeof(ns2__Aft), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Aft(struct soap *soap, ns2__Aft *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Aft(soap, tag?tag:"ns2:Aft", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Aft ** SOAP_FMAC4 soap_get_PointerTons2__Aft(struct soap *soap, ns2__Aft **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Aft(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Wallet(struct soap *soap, ns2__Wallet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Wallet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Wallet(struct soap *soap, const char *tag, int id, ns2__Wallet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Wallet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Wallet ** SOAP_FMAC4 soap_in_PointerTons2__Wallet(struct soap *soap, const char *tag, ns2__Wallet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Wallet **)soap_malloc(soap, sizeof(ns2__Wallet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Wallet *)soap_instantiate_ns2__Wallet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Wallet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Wallet, sizeof(ns2__Wallet), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Wallet(struct soap *soap, ns2__Wallet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Wallet(soap, tag?tag:"ns2:Wallet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Wallet ** SOAP_FMAC4 soap_get_PointerTons2__Wallet(struct soap *soap, ns2__Wallet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Wallet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PromotionGroup(struct soap *soap, ns2__PromotionGroup *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PromotionGroup))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PromotionGroup(struct soap *soap, const char *tag, int id, ns2__PromotionGroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PromotionGroup, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PromotionGroup ** SOAP_FMAC4 soap_in_PointerTons2__PromotionGroup(struct soap *soap, const char *tag, ns2__PromotionGroup **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PromotionGroup **)soap_malloc(soap, sizeof(ns2__PromotionGroup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PromotionGroup *)soap_instantiate_ns2__PromotionGroup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PromotionGroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PromotionGroup, sizeof(ns2__PromotionGroup), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PromotionGroup(struct soap *soap, ns2__PromotionGroup *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PromotionGroup(soap, tag?tag:"ns2:PromotionGroup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PromotionGroup ** SOAP_FMAC4 soap_get_PointerTons2__PromotionGroup(struct soap *soap, ns2__PromotionGroup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PromotionGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DecryptVisaCheckoutDataService(struct soap *soap, ns2__DecryptVisaCheckoutDataService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DecryptVisaCheckoutDataService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DecryptVisaCheckoutDataService(struct soap *soap, const char *tag, int id, ns2__DecryptVisaCheckoutDataService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DecryptVisaCheckoutDataService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DecryptVisaCheckoutDataService ** SOAP_FMAC4 soap_in_PointerTons2__DecryptVisaCheckoutDataService(struct soap *soap, const char *tag, ns2__DecryptVisaCheckoutDataService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DecryptVisaCheckoutDataService **)soap_malloc(soap, sizeof(ns2__DecryptVisaCheckoutDataService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DecryptVisaCheckoutDataService *)soap_instantiate_ns2__DecryptVisaCheckoutDataService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DecryptVisaCheckoutDataService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DecryptVisaCheckoutDataService, sizeof(ns2__DecryptVisaCheckoutDataService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DecryptVisaCheckoutDataService(struct soap *soap, ns2__DecryptVisaCheckoutDataService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DecryptVisaCheckoutDataService(soap, tag?tag:"ns2:DecryptVisaCheckoutDataService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DecryptVisaCheckoutDataService ** SOAP_FMAC4 soap_get_PointerTons2__DecryptVisaCheckoutDataService(struct soap *soap, ns2__DecryptVisaCheckoutDataService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DecryptVisaCheckoutDataService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VC(struct soap *soap, ns2__VC *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VC(struct soap *soap, const char *tag, int id, ns2__VC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VC, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__VC ** SOAP_FMAC4 soap_in_PointerTons2__VC(struct soap *soap, const char *tag, ns2__VC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__VC **)soap_malloc(soap, sizeof(ns2__VC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__VC *)soap_instantiate_ns2__VC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__VC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VC, sizeof(ns2__VC), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VC(struct soap *soap, ns2__VC *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__VC(soap, tag?tag:"ns2:VC", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__VC ** SOAP_FMAC4 soap_get_PointerTons2__VC(struct soap *soap, ns2__VC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AutoRentalData(struct soap *soap, ns2__AutoRentalData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AutoRentalData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AutoRentalData(struct soap *soap, const char *tag, int id, ns2__AutoRentalData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AutoRentalData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AutoRentalData ** SOAP_FMAC4 soap_in_PointerTons2__AutoRentalData(struct soap *soap, const char *tag, ns2__AutoRentalData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AutoRentalData **)soap_malloc(soap, sizeof(ns2__AutoRentalData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AutoRentalData *)soap_instantiate_ns2__AutoRentalData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__AutoRentalData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AutoRentalData, sizeof(ns2__AutoRentalData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AutoRentalData(struct soap *soap, ns2__AutoRentalData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__AutoRentalData(soap, tag?tag:"ns2:AutoRentalData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AutoRentalData ** SOAP_FMAC4 soap_get_PointerTons2__AutoRentalData(struct soap *soap, ns2__AutoRentalData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AutoRentalData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Sender(struct soap *soap, ns2__Sender *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Sender))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Sender(struct soap *soap, const char *tag, int id, ns2__Sender *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Sender, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Sender ** SOAP_FMAC4 soap_in_PointerTons2__Sender(struct soap *soap, const char *tag, ns2__Sender **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Sender **)soap_malloc(soap, sizeof(ns2__Sender *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Sender *)soap_instantiate_ns2__Sender(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Sender **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Sender, sizeof(ns2__Sender), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Sender(struct soap *soap, ns2__Sender *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Sender(soap, tag?tag:"ns2:Sender", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Sender ** SOAP_FMAC4 soap_get_PointerTons2__Sender(struct soap *soap, ns2__Sender **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Sender(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Recipient(struct soap *soap, ns2__Recipient *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Recipient))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Recipient(struct soap *soap, const char *tag, int id, ns2__Recipient *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Recipient, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Recipient ** SOAP_FMAC4 soap_in_PointerTons2__Recipient(struct soap *soap, const char *tag, ns2__Recipient **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Recipient **)soap_malloc(soap, sizeof(ns2__Recipient *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Recipient *)soap_instantiate_ns2__Recipient(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Recipient **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Recipient, sizeof(ns2__Recipient), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Recipient(struct soap *soap, ns2__Recipient *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Recipient(soap, tag?tag:"ns2:Recipient", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Recipient ** SOAP_FMAC4 soap_get_PointerTons2__Recipient(struct soap *soap, ns2__Recipient **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Recipient(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PaymentNetworkToken(struct soap *soap, ns2__PaymentNetworkToken *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PaymentNetworkToken))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PaymentNetworkToken(struct soap *soap, const char *tag, int id, ns2__PaymentNetworkToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PaymentNetworkToken, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PaymentNetworkToken ** SOAP_FMAC4 soap_in_PointerTons2__PaymentNetworkToken(struct soap *soap, const char *tag, ns2__PaymentNetworkToken **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PaymentNetworkToken **)soap_malloc(soap, sizeof(ns2__PaymentNetworkToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PaymentNetworkToken *)soap_instantiate_ns2__PaymentNetworkToken(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PaymentNetworkToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PaymentNetworkToken, sizeof(ns2__PaymentNetworkToken), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PaymentNetworkToken(struct soap *soap, ns2__PaymentNetworkToken *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PaymentNetworkToken(soap, tag?tag:"ns2:PaymentNetworkToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PaymentNetworkToken ** SOAP_FMAC4 soap_get_PointerTons2__PaymentNetworkToken(struct soap *soap, ns2__PaymentNetworkToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PaymentNetworkToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__HostedDataRetrieveService(struct soap *soap, ns2__HostedDataRetrieveService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__HostedDataRetrieveService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__HostedDataRetrieveService(struct soap *soap, const char *tag, int id, ns2__HostedDataRetrieveService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__HostedDataRetrieveService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__HostedDataRetrieveService ** SOAP_FMAC4 soap_in_PointerTons2__HostedDataRetrieveService(struct soap *soap, const char *tag, ns2__HostedDataRetrieveService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__HostedDataRetrieveService **)soap_malloc(soap, sizeof(ns2__HostedDataRetrieveService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__HostedDataRetrieveService *)soap_instantiate_ns2__HostedDataRetrieveService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__HostedDataRetrieveService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__HostedDataRetrieveService, sizeof(ns2__HostedDataRetrieveService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__HostedDataRetrieveService(struct soap *soap, ns2__HostedDataRetrieveService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__HostedDataRetrieveService(soap, tag?tag:"ns2:HostedDataRetrieveService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__HostedDataRetrieveService ** SOAP_FMAC4 soap_get_PointerTons2__HostedDataRetrieveService(struct soap *soap, ns2__HostedDataRetrieveService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__HostedDataRetrieveService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__HostedDataCreateService(struct soap *soap, ns2__HostedDataCreateService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__HostedDataCreateService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__HostedDataCreateService(struct soap *soap, const char *tag, int id, ns2__HostedDataCreateService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__HostedDataCreateService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__HostedDataCreateService ** SOAP_FMAC4 soap_in_PointerTons2__HostedDataCreateService(struct soap *soap, const char *tag, ns2__HostedDataCreateService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__HostedDataCreateService **)soap_malloc(soap, sizeof(ns2__HostedDataCreateService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__HostedDataCreateService *)soap_instantiate_ns2__HostedDataCreateService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__HostedDataCreateService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__HostedDataCreateService, sizeof(ns2__HostedDataCreateService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__HostedDataCreateService(struct soap *soap, ns2__HostedDataCreateService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__HostedDataCreateService(soap, tag?tag:"ns2:HostedDataCreateService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__HostedDataCreateService ** SOAP_FMAC4 soap_get_PointerTons2__HostedDataCreateService(struct soap *soap, ns2__HostedDataCreateService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__HostedDataCreateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__EmvRequest(struct soap *soap, ns2__EmvRequest *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__EmvRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__EmvRequest(struct soap *soap, const char *tag, int id, ns2__EmvRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__EmvRequest, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__EmvRequest ** SOAP_FMAC4 soap_in_PointerTons2__EmvRequest(struct soap *soap, const char *tag, ns2__EmvRequest **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__EmvRequest **)soap_malloc(soap, sizeof(ns2__EmvRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__EmvRequest *)soap_instantiate_ns2__EmvRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__EmvRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__EmvRequest, sizeof(ns2__EmvRequest), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__EmvRequest(struct soap *soap, ns2__EmvRequest *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__EmvRequest(soap, tag?tag:"ns2:EmvRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__EmvRequest ** SOAP_FMAC4 soap_get_PointerTons2__EmvRequest(struct soap *soap, ns2__EmvRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__EmvRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CCDCCUpdateService(struct soap *soap, ns2__CCDCCUpdateService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CCDCCUpdateService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CCDCCUpdateService(struct soap *soap, const char *tag, int id, ns2__CCDCCUpdateService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CCDCCUpdateService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CCDCCUpdateService ** SOAP_FMAC4 soap_in_PointerTons2__CCDCCUpdateService(struct soap *soap, const char *tag, ns2__CCDCCUpdateService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CCDCCUpdateService **)soap_malloc(soap, sizeof(ns2__CCDCCUpdateService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CCDCCUpdateService *)soap_instantiate_ns2__CCDCCUpdateService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CCDCCUpdateService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CCDCCUpdateService, sizeof(ns2__CCDCCUpdateService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CCDCCUpdateService(struct soap *soap, ns2__CCDCCUpdateService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CCDCCUpdateService(soap, tag?tag:"ns2:CCDCCUpdateService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CCDCCUpdateService ** SOAP_FMAC4 soap_get_PointerTons2__CCDCCUpdateService(struct soap *soap, ns2__CCDCCUpdateService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CCDCCUpdateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalTransactionSearchService(struct soap *soap, ns2__PayPalTransactionSearchService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalTransactionSearchService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalTransactionSearchService(struct soap *soap, const char *tag, int id, ns2__PayPalTransactionSearchService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalTransactionSearchService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalTransactionSearchService ** SOAP_FMAC4 soap_in_PointerTons2__PayPalTransactionSearchService(struct soap *soap, const char *tag, ns2__PayPalTransactionSearchService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalTransactionSearchService **)soap_malloc(soap, sizeof(ns2__PayPalTransactionSearchService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalTransactionSearchService *)soap_instantiate_ns2__PayPalTransactionSearchService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalTransactionSearchService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalTransactionSearchService, sizeof(ns2__PayPalTransactionSearchService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalTransactionSearchService(struct soap *soap, ns2__PayPalTransactionSearchService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalTransactionSearchService(soap, tag?tag:"ns2:PayPalTransactionSearchService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalTransactionSearchService ** SOAP_FMAC4 soap_get_PointerTons2__PayPalTransactionSearchService(struct soap *soap, ns2__PayPalTransactionSearchService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalTransactionSearchService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalGetTxnDetailsService(struct soap *soap, ns2__PayPalGetTxnDetailsService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalGetTxnDetailsService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalGetTxnDetailsService(struct soap *soap, const char *tag, int id, ns2__PayPalGetTxnDetailsService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalGetTxnDetailsService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalGetTxnDetailsService ** SOAP_FMAC4 soap_in_PointerTons2__PayPalGetTxnDetailsService(struct soap *soap, const char *tag, ns2__PayPalGetTxnDetailsService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalGetTxnDetailsService **)soap_malloc(soap, sizeof(ns2__PayPalGetTxnDetailsService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalGetTxnDetailsService *)soap_instantiate_ns2__PayPalGetTxnDetailsService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalGetTxnDetailsService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalGetTxnDetailsService, sizeof(ns2__PayPalGetTxnDetailsService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalGetTxnDetailsService(struct soap *soap, ns2__PayPalGetTxnDetailsService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalGetTxnDetailsService(soap, tag?tag:"ns2:PayPalGetTxnDetailsService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalGetTxnDetailsService ** SOAP_FMAC4 soap_get_PointerTons2__PayPalGetTxnDetailsService(struct soap *soap, ns2__PayPalGetTxnDetailsService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalGetTxnDetailsService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APConfirmPurchaseService(struct soap *soap, ns2__APConfirmPurchaseService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APConfirmPurchaseService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APConfirmPurchaseService(struct soap *soap, const char *tag, int id, ns2__APConfirmPurchaseService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APConfirmPurchaseService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APConfirmPurchaseService ** SOAP_FMAC4 soap_in_PointerTons2__APConfirmPurchaseService(struct soap *soap, const char *tag, ns2__APConfirmPurchaseService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APConfirmPurchaseService **)soap_malloc(soap, sizeof(ns2__APConfirmPurchaseService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APConfirmPurchaseService *)soap_instantiate_ns2__APConfirmPurchaseService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APConfirmPurchaseService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APConfirmPurchaseService, sizeof(ns2__APConfirmPurchaseService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APConfirmPurchaseService(struct soap *soap, ns2__APConfirmPurchaseService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APConfirmPurchaseService(soap, tag?tag:"ns2:APConfirmPurchaseService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APConfirmPurchaseService ** SOAP_FMAC4 soap_get_PointerTons2__APConfirmPurchaseService(struct soap *soap, ns2__APConfirmPurchaseService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APConfirmPurchaseService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APTransactionDetailsService(struct soap *soap, ns2__APTransactionDetailsService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APTransactionDetailsService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APTransactionDetailsService(struct soap *soap, const char *tag, int id, ns2__APTransactionDetailsService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APTransactionDetailsService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APTransactionDetailsService ** SOAP_FMAC4 soap_in_PointerTons2__APTransactionDetailsService(struct soap *soap, const char *tag, ns2__APTransactionDetailsService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APTransactionDetailsService **)soap_malloc(soap, sizeof(ns2__APTransactionDetailsService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APTransactionDetailsService *)soap_instantiate_ns2__APTransactionDetailsService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APTransactionDetailsService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APTransactionDetailsService, sizeof(ns2__APTransactionDetailsService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APTransactionDetailsService(struct soap *soap, ns2__APTransactionDetailsService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APTransactionDetailsService(soap, tag?tag:"ns2:APTransactionDetailsService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APTransactionDetailsService ** SOAP_FMAC4 soap_get_PointerTons2__APTransactionDetailsService(struct soap *soap, ns2__APTransactionDetailsService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APTransactionDetailsService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APCheckOutDetailsService(struct soap *soap, ns2__APCheckOutDetailsService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APCheckOutDetailsService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APCheckOutDetailsService(struct soap *soap, const char *tag, int id, ns2__APCheckOutDetailsService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APCheckOutDetailsService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APCheckOutDetailsService ** SOAP_FMAC4 soap_in_PointerTons2__APCheckOutDetailsService(struct soap *soap, const char *tag, ns2__APCheckOutDetailsService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APCheckOutDetailsService **)soap_malloc(soap, sizeof(ns2__APCheckOutDetailsService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APCheckOutDetailsService *)soap_instantiate_ns2__APCheckOutDetailsService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APCheckOutDetailsService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APCheckOutDetailsService, sizeof(ns2__APCheckOutDetailsService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APCheckOutDetailsService(struct soap *soap, ns2__APCheckOutDetailsService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APCheckOutDetailsService(soap, tag?tag:"ns2:APCheckOutDetailsService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APCheckOutDetailsService ** SOAP_FMAC4 soap_get_PointerTons2__APCheckOutDetailsService(struct soap *soap, ns2__APCheckOutDetailsService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APCheckOutDetailsService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APSaleService(struct soap *soap, ns2__APSaleService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APSaleService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APSaleService(struct soap *soap, const char *tag, int id, ns2__APSaleService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APSaleService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APSaleService ** SOAP_FMAC4 soap_in_PointerTons2__APSaleService(struct soap *soap, const char *tag, ns2__APSaleService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APSaleService **)soap_malloc(soap, sizeof(ns2__APSaleService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APSaleService *)soap_instantiate_ns2__APSaleService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APSaleService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APSaleService, sizeof(ns2__APSaleService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APSaleService(struct soap *soap, ns2__APSaleService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APSaleService(soap, tag?tag:"ns2:APSaleService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APSaleService ** SOAP_FMAC4 soap_get_PointerTons2__APSaleService(struct soap *soap, ns2__APSaleService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APSaleService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APRefundService(struct soap *soap, ns2__APRefundService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APRefundService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APRefundService(struct soap *soap, const char *tag, int id, ns2__APRefundService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APRefundService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APRefundService ** SOAP_FMAC4 soap_in_PointerTons2__APRefundService(struct soap *soap, const char *tag, ns2__APRefundService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APRefundService **)soap_malloc(soap, sizeof(ns2__APRefundService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APRefundService *)soap_instantiate_ns2__APRefundService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APRefundService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APRefundService, sizeof(ns2__APRefundService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APRefundService(struct soap *soap, ns2__APRefundService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APRefundService(soap, tag?tag:"ns2:APRefundService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APRefundService ** SOAP_FMAC4 soap_get_PointerTons2__APRefundService(struct soap *soap, ns2__APRefundService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APRefundService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APOptionsService(struct soap *soap, ns2__APOptionsService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APOptionsService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APOptionsService(struct soap *soap, const char *tag, int id, ns2__APOptionsService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APOptionsService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APOptionsService ** SOAP_FMAC4 soap_in_PointerTons2__APOptionsService(struct soap *soap, const char *tag, ns2__APOptionsService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APOptionsService **)soap_malloc(soap, sizeof(ns2__APOptionsService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APOptionsService *)soap_instantiate_ns2__APOptionsService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APOptionsService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APOptionsService, sizeof(ns2__APOptionsService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APOptionsService(struct soap *soap, ns2__APOptionsService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APOptionsService(soap, tag?tag:"ns2:APOptionsService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APOptionsService ** SOAP_FMAC4 soap_get_PointerTons2__APOptionsService(struct soap *soap, ns2__APOptionsService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APOptionsService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APCaptureService(struct soap *soap, ns2__APCaptureService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APCaptureService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APCaptureService(struct soap *soap, const char *tag, int id, ns2__APCaptureService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APCaptureService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APCaptureService ** SOAP_FMAC4 soap_in_PointerTons2__APCaptureService(struct soap *soap, const char *tag, ns2__APCaptureService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APCaptureService **)soap_malloc(soap, sizeof(ns2__APCaptureService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APCaptureService *)soap_instantiate_ns2__APCaptureService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APCaptureService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APCaptureService, sizeof(ns2__APCaptureService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APCaptureService(struct soap *soap, ns2__APCaptureService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APCaptureService(soap, tag?tag:"ns2:APCaptureService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APCaptureService ** SOAP_FMAC4 soap_get_PointerTons2__APCaptureService(struct soap *soap, ns2__APCaptureService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APCaptureService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APAuthReversalService(struct soap *soap, ns2__APAuthReversalService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APAuthReversalService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APAuthReversalService(struct soap *soap, const char *tag, int id, ns2__APAuthReversalService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APAuthReversalService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APAuthReversalService ** SOAP_FMAC4 soap_in_PointerTons2__APAuthReversalService(struct soap *soap, const char *tag, ns2__APAuthReversalService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APAuthReversalService **)soap_malloc(soap, sizeof(ns2__APAuthReversalService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APAuthReversalService *)soap_instantiate_ns2__APAuthReversalService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APAuthReversalService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APAuthReversalService, sizeof(ns2__APAuthReversalService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APAuthReversalService(struct soap *soap, ns2__APAuthReversalService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APAuthReversalService(soap, tag?tag:"ns2:APAuthReversalService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APAuthReversalService ** SOAP_FMAC4 soap_get_PointerTons2__APAuthReversalService(struct soap *soap, ns2__APAuthReversalService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APAuthReversalService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APAuthService(struct soap *soap, ns2__APAuthService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APAuthService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APAuthService(struct soap *soap, const char *tag, int id, ns2__APAuthService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APAuthService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APAuthService ** SOAP_FMAC4 soap_in_PointerTons2__APAuthService(struct soap *soap, const char *tag, ns2__APAuthService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APAuthService **)soap_malloc(soap, sizeof(ns2__APAuthService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APAuthService *)soap_instantiate_ns2__APAuthService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APAuthService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APAuthService, sizeof(ns2__APAuthService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APAuthService(struct soap *soap, ns2__APAuthService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APAuthService(soap, tag?tag:"ns2:APAuthService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APAuthService ** SOAP_FMAC4 soap_get_PointerTons2__APAuthService(struct soap *soap, ns2__APAuthService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APAuthService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AP(struct soap *soap, ns2__AP *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AP))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AP(struct soap *soap, const char *tag, int id, ns2__AP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AP, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AP ** SOAP_FMAC4 soap_in_PointerTons2__AP(struct soap *soap, const char *tag, ns2__AP **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AP **)soap_malloc(soap, sizeof(ns2__AP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AP *)soap_instantiate_ns2__AP(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__AP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AP, sizeof(ns2__AP), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AP(struct soap *soap, ns2__AP *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__AP(soap, tag?tag:"ns2:AP", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AP ** SOAP_FMAC4 soap_get_PointerTons2__AP(struct soap *soap, ns2__AP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PinDebitReversalService(struct soap *soap, ns2__PinDebitReversalService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PinDebitReversalService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PinDebitReversalService(struct soap *soap, const char *tag, int id, ns2__PinDebitReversalService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PinDebitReversalService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PinDebitReversalService ** SOAP_FMAC4 soap_in_PointerTons2__PinDebitReversalService(struct soap *soap, const char *tag, ns2__PinDebitReversalService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PinDebitReversalService **)soap_malloc(soap, sizeof(ns2__PinDebitReversalService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PinDebitReversalService *)soap_instantiate_ns2__PinDebitReversalService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PinDebitReversalService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PinDebitReversalService, sizeof(ns2__PinDebitReversalService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PinDebitReversalService(struct soap *soap, ns2__PinDebitReversalService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PinDebitReversalService(soap, tag?tag:"ns2:PinDebitReversalService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PinDebitReversalService ** SOAP_FMAC4 soap_get_PointerTons2__PinDebitReversalService(struct soap *soap, ns2__PinDebitReversalService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PinDebitReversalService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PinDebitCreditService(struct soap *soap, ns2__PinDebitCreditService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PinDebitCreditService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PinDebitCreditService(struct soap *soap, const char *tag, int id, ns2__PinDebitCreditService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PinDebitCreditService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PinDebitCreditService ** SOAP_FMAC4 soap_in_PointerTons2__PinDebitCreditService(struct soap *soap, const char *tag, ns2__PinDebitCreditService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PinDebitCreditService **)soap_malloc(soap, sizeof(ns2__PinDebitCreditService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PinDebitCreditService *)soap_instantiate_ns2__PinDebitCreditService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PinDebitCreditService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PinDebitCreditService, sizeof(ns2__PinDebitCreditService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PinDebitCreditService(struct soap *soap, ns2__PinDebitCreditService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PinDebitCreditService(soap, tag?tag:"ns2:PinDebitCreditService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PinDebitCreditService ** SOAP_FMAC4 soap_get_PointerTons2__PinDebitCreditService(struct soap *soap, ns2__PinDebitCreditService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PinDebitCreditService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PinDebitPurchaseService(struct soap *soap, ns2__PinDebitPurchaseService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PinDebitPurchaseService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PinDebitPurchaseService(struct soap *soap, const char *tag, int id, ns2__PinDebitPurchaseService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PinDebitPurchaseService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PinDebitPurchaseService ** SOAP_FMAC4 soap_in_PointerTons2__PinDebitPurchaseService(struct soap *soap, const char *tag, ns2__PinDebitPurchaseService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PinDebitPurchaseService **)soap_malloc(soap, sizeof(ns2__PinDebitPurchaseService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PinDebitPurchaseService *)soap_instantiate_ns2__PinDebitPurchaseService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PinDebitPurchaseService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PinDebitPurchaseService, sizeof(ns2__PinDebitPurchaseService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PinDebitPurchaseService(struct soap *soap, ns2__PinDebitPurchaseService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PinDebitPurchaseService(soap, tag?tag:"ns2:PinDebitPurchaseService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PinDebitPurchaseService ** SOAP_FMAC4 soap_get_PointerTons2__PinDebitPurchaseService(struct soap *soap, ns2__PinDebitPurchaseService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PinDebitPurchaseService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APCheckStatusService(struct soap *soap, ns2__APCheckStatusService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APCheckStatusService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APCheckStatusService(struct soap *soap, const char *tag, int id, ns2__APCheckStatusService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APCheckStatusService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APCheckStatusService ** SOAP_FMAC4 soap_in_PointerTons2__APCheckStatusService(struct soap *soap, const char *tag, ns2__APCheckStatusService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APCheckStatusService **)soap_malloc(soap, sizeof(ns2__APCheckStatusService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APCheckStatusService *)soap_instantiate_ns2__APCheckStatusService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APCheckStatusService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APCheckStatusService, sizeof(ns2__APCheckStatusService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APCheckStatusService(struct soap *soap, ns2__APCheckStatusService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APCheckStatusService(soap, tag?tag:"ns2:APCheckStatusService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APCheckStatusService ** SOAP_FMAC4 soap_get_PointerTons2__APCheckStatusService(struct soap *soap, ns2__APCheckStatusService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APCheckStatusService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APInitiateService(struct soap *soap, ns2__APInitiateService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APInitiateService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APInitiateService(struct soap *soap, const char *tag, int id, ns2__APInitiateService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APInitiateService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APInitiateService ** SOAP_FMAC4 soap_in_PointerTons2__APInitiateService(struct soap *soap, const char *tag, ns2__APInitiateService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APInitiateService **)soap_malloc(soap, sizeof(ns2__APInitiateService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APInitiateService *)soap_instantiate_ns2__APInitiateService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APInitiateService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APInitiateService, sizeof(ns2__APInitiateService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APInitiateService(struct soap *soap, ns2__APInitiateService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APInitiateService(soap, tag?tag:"ns2:APInitiateService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APInitiateService ** SOAP_FMAC4 soap_get_PointerTons2__APInitiateService(struct soap *soap, ns2__APInitiateService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APInitiateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BoletoPaymentService(struct soap *soap, ns2__BoletoPaymentService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BoletoPaymentService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BoletoPaymentService(struct soap *soap, const char *tag, int id, ns2__BoletoPaymentService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BoletoPaymentService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__BoletoPaymentService ** SOAP_FMAC4 soap_in_PointerTons2__BoletoPaymentService(struct soap *soap, const char *tag, ns2__BoletoPaymentService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__BoletoPaymentService **)soap_malloc(soap, sizeof(ns2__BoletoPaymentService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__BoletoPaymentService *)soap_instantiate_ns2__BoletoPaymentService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__BoletoPaymentService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BoletoPaymentService, sizeof(ns2__BoletoPaymentService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BoletoPaymentService(struct soap *soap, ns2__BoletoPaymentService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__BoletoPaymentService(soap, tag?tag:"ns2:BoletoPaymentService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__BoletoPaymentService ** SOAP_FMAC4 soap_get_PointerTons2__BoletoPaymentService(struct soap *soap, ns2__BoletoPaymentService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BoletoPaymentService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ChinaRefundService(struct soap *soap, ns2__ChinaRefundService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ChinaRefundService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ChinaRefundService(struct soap *soap, const char *tag, int id, ns2__ChinaRefundService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ChinaRefundService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ChinaRefundService ** SOAP_FMAC4 soap_in_PointerTons2__ChinaRefundService(struct soap *soap, const char *tag, ns2__ChinaRefundService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ChinaRefundService **)soap_malloc(soap, sizeof(ns2__ChinaRefundService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ChinaRefundService *)soap_instantiate_ns2__ChinaRefundService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ChinaRefundService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ChinaRefundService, sizeof(ns2__ChinaRefundService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ChinaRefundService(struct soap *soap, ns2__ChinaRefundService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ChinaRefundService(soap, tag?tag:"ns2:ChinaRefundService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ChinaRefundService ** SOAP_FMAC4 soap_get_PointerTons2__ChinaRefundService(struct soap *soap, ns2__ChinaRefundService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ChinaRefundService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ChinaPaymentService(struct soap *soap, ns2__ChinaPaymentService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ChinaPaymentService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ChinaPaymentService(struct soap *soap, const char *tag, int id, ns2__ChinaPaymentService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ChinaPaymentService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ChinaPaymentService ** SOAP_FMAC4 soap_in_PointerTons2__ChinaPaymentService(struct soap *soap, const char *tag, ns2__ChinaPaymentService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ChinaPaymentService **)soap_malloc(soap, sizeof(ns2__ChinaPaymentService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ChinaPaymentService *)soap_instantiate_ns2__ChinaPaymentService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ChinaPaymentService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ChinaPaymentService, sizeof(ns2__ChinaPaymentService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ChinaPaymentService(struct soap *soap, ns2__ChinaPaymentService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ChinaPaymentService(soap, tag?tag:"ns2:ChinaPaymentService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ChinaPaymentService ** SOAP_FMAC4 soap_get_PointerTons2__ChinaPaymentService(struct soap *soap, ns2__ChinaPaymentService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ChinaPaymentService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalDoRefTransactionService(struct soap *soap, ns2__PayPalDoRefTransactionService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalDoRefTransactionService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalDoRefTransactionService(struct soap *soap, const char *tag, int id, ns2__PayPalDoRefTransactionService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalDoRefTransactionService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalDoRefTransactionService ** SOAP_FMAC4 soap_in_PointerTons2__PayPalDoRefTransactionService(struct soap *soap, const char *tag, ns2__PayPalDoRefTransactionService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalDoRefTransactionService **)soap_malloc(soap, sizeof(ns2__PayPalDoRefTransactionService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalDoRefTransactionService *)soap_instantiate_ns2__PayPalDoRefTransactionService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalDoRefTransactionService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalDoRefTransactionService, sizeof(ns2__PayPalDoRefTransactionService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalDoRefTransactionService(struct soap *soap, ns2__PayPalDoRefTransactionService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalDoRefTransactionService(soap, tag?tag:"ns2:PayPalDoRefTransactionService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalDoRefTransactionService ** SOAP_FMAC4 soap_get_PointerTons2__PayPalDoRefTransactionService(struct soap *soap, ns2__PayPalDoRefTransactionService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalDoRefTransactionService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalCreateAgreementService(struct soap *soap, ns2__PayPalCreateAgreementService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalCreateAgreementService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalCreateAgreementService(struct soap *soap, const char *tag, int id, ns2__PayPalCreateAgreementService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalCreateAgreementService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalCreateAgreementService ** SOAP_FMAC4 soap_in_PointerTons2__PayPalCreateAgreementService(struct soap *soap, const char *tag, ns2__PayPalCreateAgreementService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalCreateAgreementService **)soap_malloc(soap, sizeof(ns2__PayPalCreateAgreementService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalCreateAgreementService *)soap_instantiate_ns2__PayPalCreateAgreementService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalCreateAgreementService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalCreateAgreementService, sizeof(ns2__PayPalCreateAgreementService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalCreateAgreementService(struct soap *soap, ns2__PayPalCreateAgreementService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalCreateAgreementService(soap, tag?tag:"ns2:PayPalCreateAgreementService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalCreateAgreementService ** SOAP_FMAC4 soap_get_PointerTons2__PayPalCreateAgreementService(struct soap *soap, ns2__PayPalCreateAgreementService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalCreateAgreementService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalUpdateAgreementService(struct soap *soap, ns2__PayPalUpdateAgreementService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalUpdateAgreementService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalUpdateAgreementService(struct soap *soap, const char *tag, int id, ns2__PayPalUpdateAgreementService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalUpdateAgreementService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalUpdateAgreementService ** SOAP_FMAC4 soap_in_PointerTons2__PayPalUpdateAgreementService(struct soap *soap, const char *tag, ns2__PayPalUpdateAgreementService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalUpdateAgreementService **)soap_malloc(soap, sizeof(ns2__PayPalUpdateAgreementService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalUpdateAgreementService *)soap_instantiate_ns2__PayPalUpdateAgreementService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalUpdateAgreementService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalUpdateAgreementService, sizeof(ns2__PayPalUpdateAgreementService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalUpdateAgreementService(struct soap *soap, ns2__PayPalUpdateAgreementService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalUpdateAgreementService(soap, tag?tag:"ns2:PayPalUpdateAgreementService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalUpdateAgreementService ** SOAP_FMAC4 soap_get_PointerTons2__PayPalUpdateAgreementService(struct soap *soap, ns2__PayPalUpdateAgreementService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalUpdateAgreementService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalAuthorizationService(struct soap *soap, ns2__PayPalAuthorizationService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalAuthorizationService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalAuthorizationService(struct soap *soap, const char *tag, int id, ns2__PayPalAuthorizationService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalAuthorizationService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalAuthorizationService ** SOAP_FMAC4 soap_in_PointerTons2__PayPalAuthorizationService(struct soap *soap, const char *tag, ns2__PayPalAuthorizationService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalAuthorizationService **)soap_malloc(soap, sizeof(ns2__PayPalAuthorizationService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalAuthorizationService *)soap_instantiate_ns2__PayPalAuthorizationService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalAuthorizationService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalAuthorizationService, sizeof(ns2__PayPalAuthorizationService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalAuthorizationService(struct soap *soap, ns2__PayPalAuthorizationService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalAuthorizationService(soap, tag?tag:"ns2:PayPalAuthorizationService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalAuthorizationService ** SOAP_FMAC4 soap_get_PointerTons2__PayPalAuthorizationService(struct soap *soap, ns2__PayPalAuthorizationService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalAuthorizationService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalEcOrderSetupService(struct soap *soap, ns2__PayPalEcOrderSetupService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalEcOrderSetupService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalEcOrderSetupService(struct soap *soap, const char *tag, int id, ns2__PayPalEcOrderSetupService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalEcOrderSetupService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalEcOrderSetupService ** SOAP_FMAC4 soap_in_PointerTons2__PayPalEcOrderSetupService(struct soap *soap, const char *tag, ns2__PayPalEcOrderSetupService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalEcOrderSetupService **)soap_malloc(soap, sizeof(ns2__PayPalEcOrderSetupService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalEcOrderSetupService *)soap_instantiate_ns2__PayPalEcOrderSetupService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalEcOrderSetupService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalEcOrderSetupService, sizeof(ns2__PayPalEcOrderSetupService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalEcOrderSetupService(struct soap *soap, ns2__PayPalEcOrderSetupService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalEcOrderSetupService(soap, tag?tag:"ns2:PayPalEcOrderSetupService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalEcOrderSetupService ** SOAP_FMAC4 soap_get_PointerTons2__PayPalEcOrderSetupService(struct soap *soap, ns2__PayPalEcOrderSetupService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalEcOrderSetupService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalEcSetService(struct soap *soap, ns2__PayPalEcSetService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalEcSetService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalEcSetService(struct soap *soap, const char *tag, int id, ns2__PayPalEcSetService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalEcSetService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalEcSetService ** SOAP_FMAC4 soap_in_PointerTons2__PayPalEcSetService(struct soap *soap, const char *tag, ns2__PayPalEcSetService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalEcSetService **)soap_malloc(soap, sizeof(ns2__PayPalEcSetService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalEcSetService *)soap_instantiate_ns2__PayPalEcSetService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalEcSetService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalEcSetService, sizeof(ns2__PayPalEcSetService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalEcSetService(struct soap *soap, ns2__PayPalEcSetService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalEcSetService(soap, tag?tag:"ns2:PayPalEcSetService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalEcSetService ** SOAP_FMAC4 soap_get_PointerTons2__PayPalEcSetService(struct soap *soap, ns2__PayPalEcSetService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalEcSetService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalEcGetDetailsService(struct soap *soap, ns2__PayPalEcGetDetailsService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalEcGetDetailsService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalEcGetDetailsService(struct soap *soap, const char *tag, int id, ns2__PayPalEcGetDetailsService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalEcGetDetailsService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalEcGetDetailsService ** SOAP_FMAC4 soap_in_PointerTons2__PayPalEcGetDetailsService(struct soap *soap, const char *tag, ns2__PayPalEcGetDetailsService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalEcGetDetailsService **)soap_malloc(soap, sizeof(ns2__PayPalEcGetDetailsService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalEcGetDetailsService *)soap_instantiate_ns2__PayPalEcGetDetailsService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalEcGetDetailsService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalEcGetDetailsService, sizeof(ns2__PayPalEcGetDetailsService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalEcGetDetailsService(struct soap *soap, ns2__PayPalEcGetDetailsService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalEcGetDetailsService(soap, tag?tag:"ns2:PayPalEcGetDetailsService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalEcGetDetailsService ** SOAP_FMAC4 soap_get_PointerTons2__PayPalEcGetDetailsService(struct soap *soap, ns2__PayPalEcGetDetailsService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalEcGetDetailsService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalEcDoPaymentService(struct soap *soap, ns2__PayPalEcDoPaymentService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalEcDoPaymentService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalEcDoPaymentService(struct soap *soap, const char *tag, int id, ns2__PayPalEcDoPaymentService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalEcDoPaymentService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalEcDoPaymentService ** SOAP_FMAC4 soap_in_PointerTons2__PayPalEcDoPaymentService(struct soap *soap, const char *tag, ns2__PayPalEcDoPaymentService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalEcDoPaymentService **)soap_malloc(soap, sizeof(ns2__PayPalEcDoPaymentService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalEcDoPaymentService *)soap_instantiate_ns2__PayPalEcDoPaymentService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalEcDoPaymentService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalEcDoPaymentService, sizeof(ns2__PayPalEcDoPaymentService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalEcDoPaymentService(struct soap *soap, ns2__PayPalEcDoPaymentService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalEcDoPaymentService(soap, tag?tag:"ns2:PayPalEcDoPaymentService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalEcDoPaymentService ** SOAP_FMAC4 soap_get_PointerTons2__PayPalEcDoPaymentService(struct soap *soap, ns2__PayPalEcDoPaymentService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalEcDoPaymentService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalDoCaptureService(struct soap *soap, ns2__PayPalDoCaptureService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalDoCaptureService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalDoCaptureService(struct soap *soap, const char *tag, int id, ns2__PayPalDoCaptureService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalDoCaptureService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalDoCaptureService ** SOAP_FMAC4 soap_in_PointerTons2__PayPalDoCaptureService(struct soap *soap, const char *tag, ns2__PayPalDoCaptureService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalDoCaptureService **)soap_malloc(soap, sizeof(ns2__PayPalDoCaptureService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalDoCaptureService *)soap_instantiate_ns2__PayPalDoCaptureService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalDoCaptureService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalDoCaptureService, sizeof(ns2__PayPalDoCaptureService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalDoCaptureService(struct soap *soap, ns2__PayPalDoCaptureService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalDoCaptureService(soap, tag?tag:"ns2:PayPalDoCaptureService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalDoCaptureService ** SOAP_FMAC4 soap_get_PointerTons2__PayPalDoCaptureService(struct soap *soap, ns2__PayPalDoCaptureService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalDoCaptureService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalAuthReversalService(struct soap *soap, ns2__PayPalAuthReversalService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalAuthReversalService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalAuthReversalService(struct soap *soap, const char *tag, int id, ns2__PayPalAuthReversalService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalAuthReversalService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalAuthReversalService ** SOAP_FMAC4 soap_in_PointerTons2__PayPalAuthReversalService(struct soap *soap, const char *tag, ns2__PayPalAuthReversalService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalAuthReversalService **)soap_malloc(soap, sizeof(ns2__PayPalAuthReversalService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalAuthReversalService *)soap_instantiate_ns2__PayPalAuthReversalService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalAuthReversalService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalAuthReversalService, sizeof(ns2__PayPalAuthReversalService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalAuthReversalService(struct soap *soap, ns2__PayPalAuthReversalService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalAuthReversalService(soap, tag?tag:"ns2:PayPalAuthReversalService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalAuthReversalService ** SOAP_FMAC4 soap_get_PointerTons2__PayPalAuthReversalService(struct soap *soap, ns2__PayPalAuthReversalService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalAuthReversalService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalRefundService(struct soap *soap, ns2__PayPalRefundService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalRefundService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalRefundService(struct soap *soap, const char *tag, int id, ns2__PayPalRefundService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalRefundService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalRefundService ** SOAP_FMAC4 soap_in_PointerTons2__PayPalRefundService(struct soap *soap, const char *tag, ns2__PayPalRefundService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalRefundService **)soap_malloc(soap, sizeof(ns2__PayPalRefundService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalRefundService *)soap_instantiate_ns2__PayPalRefundService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalRefundService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalRefundService, sizeof(ns2__PayPalRefundService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalRefundService(struct soap *soap, ns2__PayPalRefundService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalRefundService(soap, tag?tag:"ns2:PayPalRefundService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalRefundService ** SOAP_FMAC4 soap_get_PointerTons2__PayPalRefundService(struct soap *soap, ns2__PayPalRefundService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalRefundService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RequestReserved(struct soap *soap, ns2__RequestReserved *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RequestReserved))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RequestReserved(struct soap *soap, const char *tag, int id, ns2__RequestReserved *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RequestReserved, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RequestReserved ** SOAP_FMAC4 soap_in_PointerTons2__RequestReserved(struct soap *soap, const char *tag, ns2__RequestReserved **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RequestReserved **)soap_malloc(soap, sizeof(ns2__RequestReserved *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RequestReserved *)soap_instantiate_ns2__RequestReserved(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__RequestReserved **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RequestReserved, sizeof(ns2__RequestReserved), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RequestReserved(struct soap *soap, ns2__RequestReserved *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__RequestReserved(soap, tag?tag:"ns2:RequestReserved", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RequestReserved ** SOAP_FMAC4 soap_get_PointerTons2__RequestReserved(struct soap *soap, ns2__RequestReserved **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RequestReserved(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CaseManagementActionService(struct soap *soap, ns2__CaseManagementActionService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CaseManagementActionService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CaseManagementActionService(struct soap *soap, const char *tag, int id, ns2__CaseManagementActionService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CaseManagementActionService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CaseManagementActionService ** SOAP_FMAC4 soap_in_PointerTons2__CaseManagementActionService(struct soap *soap, const char *tag, ns2__CaseManagementActionService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CaseManagementActionService **)soap_malloc(soap, sizeof(ns2__CaseManagementActionService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CaseManagementActionService *)soap_instantiate_ns2__CaseManagementActionService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CaseManagementActionService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CaseManagementActionService, sizeof(ns2__CaseManagementActionService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CaseManagementActionService(struct soap *soap, ns2__CaseManagementActionService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CaseManagementActionService(soap, tag?tag:"ns2:CaseManagementActionService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CaseManagementActionService ** SOAP_FMAC4 soap_get_PointerTons2__CaseManagementActionService(struct soap *soap, ns2__CaseManagementActionService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CaseManagementActionService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FraudUpdateService(struct soap *soap, ns2__FraudUpdateService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FraudUpdateService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FraudUpdateService(struct soap *soap, const char *tag, int id, ns2__FraudUpdateService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FraudUpdateService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__FraudUpdateService ** SOAP_FMAC4 soap_in_PointerTons2__FraudUpdateService(struct soap *soap, const char *tag, ns2__FraudUpdateService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__FraudUpdateService **)soap_malloc(soap, sizeof(ns2__FraudUpdateService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__FraudUpdateService *)soap_instantiate_ns2__FraudUpdateService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__FraudUpdateService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FraudUpdateService, sizeof(ns2__FraudUpdateService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FraudUpdateService(struct soap *soap, ns2__FraudUpdateService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__FraudUpdateService(soap, tag?tag:"ns2:FraudUpdateService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__FraudUpdateService ** SOAP_FMAC4 soap_get_PointerTons2__FraudUpdateService(struct soap *soap, ns2__FraudUpdateService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FraudUpdateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RiskUpdateService(struct soap *soap, ns2__RiskUpdateService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RiskUpdateService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RiskUpdateService(struct soap *soap, const char *tag, int id, ns2__RiskUpdateService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RiskUpdateService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RiskUpdateService ** SOAP_FMAC4 soap_in_PointerTons2__RiskUpdateService(struct soap *soap, const char *tag, ns2__RiskUpdateService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RiskUpdateService **)soap_malloc(soap, sizeof(ns2__RiskUpdateService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RiskUpdateService *)soap_instantiate_ns2__RiskUpdateService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__RiskUpdateService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RiskUpdateService, sizeof(ns2__RiskUpdateService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RiskUpdateService(struct soap *soap, ns2__RiskUpdateService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__RiskUpdateService(soap, tag?tag:"ns2:RiskUpdateService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RiskUpdateService ** SOAP_FMAC4 soap_get_PointerTons2__RiskUpdateService(struct soap *soap, ns2__RiskUpdateService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RiskUpdateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalPreapprovedUpdateService(struct soap *soap, ns2__PayPalPreapprovedUpdateService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalPreapprovedUpdateService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalPreapprovedUpdateService(struct soap *soap, const char *tag, int id, ns2__PayPalPreapprovedUpdateService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalPreapprovedUpdateService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalPreapprovedUpdateService ** SOAP_FMAC4 soap_in_PointerTons2__PayPalPreapprovedUpdateService(struct soap *soap, const char *tag, ns2__PayPalPreapprovedUpdateService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalPreapprovedUpdateService **)soap_malloc(soap, sizeof(ns2__PayPalPreapprovedUpdateService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalPreapprovedUpdateService *)soap_instantiate_ns2__PayPalPreapprovedUpdateService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalPreapprovedUpdateService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalPreapprovedUpdateService, sizeof(ns2__PayPalPreapprovedUpdateService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalPreapprovedUpdateService(struct soap *soap, ns2__PayPalPreapprovedUpdateService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalPreapprovedUpdateService(soap, tag?tag:"ns2:PayPalPreapprovedUpdateService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalPreapprovedUpdateService ** SOAP_FMAC4 soap_get_PointerTons2__PayPalPreapprovedUpdateService(struct soap *soap, ns2__PayPalPreapprovedUpdateService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalPreapprovedUpdateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalPreapprovedPaymentService(struct soap *soap, ns2__PayPalPreapprovedPaymentService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalPreapprovedPaymentService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalPreapprovedPaymentService(struct soap *soap, const char *tag, int id, ns2__PayPalPreapprovedPaymentService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalPreapprovedPaymentService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalPreapprovedPaymentService ** SOAP_FMAC4 soap_in_PointerTons2__PayPalPreapprovedPaymentService(struct soap *soap, const char *tag, ns2__PayPalPreapprovedPaymentService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalPreapprovedPaymentService **)soap_malloc(soap, sizeof(ns2__PayPalPreapprovedPaymentService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalPreapprovedPaymentService *)soap_instantiate_ns2__PayPalPreapprovedPaymentService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalPreapprovedPaymentService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalPreapprovedPaymentService, sizeof(ns2__PayPalPreapprovedPaymentService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalPreapprovedPaymentService(struct soap *soap, ns2__PayPalPreapprovedPaymentService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalPreapprovedPaymentService(soap, tag?tag:"ns2:PayPalPreapprovedPaymentService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalPreapprovedPaymentService ** SOAP_FMAC4 soap_get_PointerTons2__PayPalPreapprovedPaymentService(struct soap *soap, ns2__PayPalPreapprovedPaymentService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalPreapprovedPaymentService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalButtonCreateService(struct soap *soap, ns2__PayPalButtonCreateService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalButtonCreateService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalButtonCreateService(struct soap *soap, const char *tag, int id, ns2__PayPalButtonCreateService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalButtonCreateService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalButtonCreateService ** SOAP_FMAC4 soap_in_PointerTons2__PayPalButtonCreateService(struct soap *soap, const char *tag, ns2__PayPalButtonCreateService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalButtonCreateService **)soap_malloc(soap, sizeof(ns2__PayPalButtonCreateService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalButtonCreateService *)soap_instantiate_ns2__PayPalButtonCreateService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalButtonCreateService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalButtonCreateService, sizeof(ns2__PayPalButtonCreateService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalButtonCreateService(struct soap *soap, ns2__PayPalButtonCreateService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalButtonCreateService(soap, tag?tag:"ns2:PayPalButtonCreateService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalButtonCreateService ** SOAP_FMAC4 soap_get_PointerTons2__PayPalButtonCreateService(struct soap *soap, ns2__PayPalButtonCreateService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalButtonCreateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__LodgingData(struct soap *soap, ns2__LodgingData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__LodgingData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__LodgingData(struct soap *soap, const char *tag, int id, ns2__LodgingData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__LodgingData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__LodgingData ** SOAP_FMAC4 soap_in_PointerTons2__LodgingData(struct soap *soap, const char *tag, ns2__LodgingData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__LodgingData **)soap_malloc(soap, sizeof(ns2__LodgingData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__LodgingData *)soap_instantiate_ns2__LodgingData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__LodgingData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__LodgingData, sizeof(ns2__LodgingData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__LodgingData(struct soap *soap, ns2__LodgingData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__LodgingData(soap, tag?tag:"ns2:LodgingData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__LodgingData ** SOAP_FMAC4 soap_get_PointerTons2__LodgingData(struct soap *soap, ns2__LodgingData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__LodgingData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AncillaryData(struct soap *soap, ns2__AncillaryData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AncillaryData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AncillaryData(struct soap *soap, const char *tag, int id, ns2__AncillaryData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AncillaryData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AncillaryData ** SOAP_FMAC4 soap_in_PointerTons2__AncillaryData(struct soap *soap, const char *tag, ns2__AncillaryData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AncillaryData **)soap_malloc(soap, sizeof(ns2__AncillaryData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AncillaryData *)soap_instantiate_ns2__AncillaryData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__AncillaryData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AncillaryData, sizeof(ns2__AncillaryData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AncillaryData(struct soap *soap, ns2__AncillaryData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__AncillaryData(soap, tag?tag:"ns2:AncillaryData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AncillaryData ** SOAP_FMAC4 soap_get_PointerTons2__AncillaryData(struct soap *soap, ns2__AncillaryData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AncillaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AirlineData(struct soap *soap, ns2__AirlineData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AirlineData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AirlineData(struct soap *soap, const char *tag, int id, ns2__AirlineData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AirlineData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AirlineData ** SOAP_FMAC4 soap_in_PointerTons2__AirlineData(struct soap *soap, const char *tag, ns2__AirlineData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AirlineData **)soap_malloc(soap, sizeof(ns2__AirlineData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AirlineData *)soap_instantiate_ns2__AirlineData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__AirlineData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AirlineData, sizeof(ns2__AirlineData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AirlineData(struct soap *soap, ns2__AirlineData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__AirlineData(soap, tag?tag:"ns2:AirlineData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AirlineData ** SOAP_FMAC4 soap_get_PointerTons2__AirlineData(struct soap *soap, ns2__AirlineData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AirlineData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Batch(struct soap *soap, ns2__Batch *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Batch))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Batch(struct soap *soap, const char *tag, int id, ns2__Batch *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Batch, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Batch ** SOAP_FMAC4 soap_in_PointerTons2__Batch(struct soap *soap, const char *tag, ns2__Batch **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Batch **)soap_malloc(soap, sizeof(ns2__Batch *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Batch *)soap_instantiate_ns2__Batch(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Batch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Batch, sizeof(ns2__Batch), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Batch(struct soap *soap, ns2__Batch *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Batch(soap, tag?tag:"ns2:Batch", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Batch ** SOAP_FMAC4 soap_get_PointerTons2__Batch(struct soap *soap, ns2__Batch **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Batch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PinlessDebitReversalService(struct soap *soap, ns2__PinlessDebitReversalService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PinlessDebitReversalService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PinlessDebitReversalService(struct soap *soap, const char *tag, int id, ns2__PinlessDebitReversalService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PinlessDebitReversalService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PinlessDebitReversalService ** SOAP_FMAC4 soap_in_PointerTons2__PinlessDebitReversalService(struct soap *soap, const char *tag, ns2__PinlessDebitReversalService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PinlessDebitReversalService **)soap_malloc(soap, sizeof(ns2__PinlessDebitReversalService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PinlessDebitReversalService *)soap_instantiate_ns2__PinlessDebitReversalService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PinlessDebitReversalService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PinlessDebitReversalService, sizeof(ns2__PinlessDebitReversalService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PinlessDebitReversalService(struct soap *soap, ns2__PinlessDebitReversalService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PinlessDebitReversalService(soap, tag?tag:"ns2:PinlessDebitReversalService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PinlessDebitReversalService ** SOAP_FMAC4 soap_get_PointerTons2__PinlessDebitReversalService(struct soap *soap, ns2__PinlessDebitReversalService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PinlessDebitReversalService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PinlessDebitValidateService(struct soap *soap, ns2__PinlessDebitValidateService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PinlessDebitValidateService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PinlessDebitValidateService(struct soap *soap, const char *tag, int id, ns2__PinlessDebitValidateService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PinlessDebitValidateService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PinlessDebitValidateService ** SOAP_FMAC4 soap_in_PointerTons2__PinlessDebitValidateService(struct soap *soap, const char *tag, ns2__PinlessDebitValidateService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PinlessDebitValidateService **)soap_malloc(soap, sizeof(ns2__PinlessDebitValidateService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PinlessDebitValidateService *)soap_instantiate_ns2__PinlessDebitValidateService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PinlessDebitValidateService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PinlessDebitValidateService, sizeof(ns2__PinlessDebitValidateService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PinlessDebitValidateService(struct soap *soap, ns2__PinlessDebitValidateService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PinlessDebitValidateService(soap, tag?tag:"ns2:PinlessDebitValidateService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PinlessDebitValidateService ** SOAP_FMAC4 soap_get_PointerTons2__PinlessDebitValidateService(struct soap *soap, ns2__PinlessDebitValidateService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PinlessDebitValidateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PinlessDebitService(struct soap *soap, ns2__PinlessDebitService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PinlessDebitService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PinlessDebitService(struct soap *soap, const char *tag, int id, ns2__PinlessDebitService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PinlessDebitService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PinlessDebitService ** SOAP_FMAC4 soap_in_PointerTons2__PinlessDebitService(struct soap *soap, const char *tag, ns2__PinlessDebitService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PinlessDebitService **)soap_malloc(soap, sizeof(ns2__PinlessDebitService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PinlessDebitService *)soap_instantiate_ns2__PinlessDebitService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PinlessDebitService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PinlessDebitService, sizeof(ns2__PinlessDebitService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PinlessDebitService(struct soap *soap, ns2__PinlessDebitService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PinlessDebitService(soap, tag?tag:"ns2:PinlessDebitService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PinlessDebitService ** SOAP_FMAC4 soap_get_PointerTons2__PinlessDebitService(struct soap *soap, ns2__PinlessDebitService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PinlessDebitService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BusinessRules(struct soap *soap, ns2__BusinessRules *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BusinessRules))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BusinessRules(struct soap *soap, const char *tag, int id, ns2__BusinessRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BusinessRules, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__BusinessRules ** SOAP_FMAC4 soap_in_PointerTons2__BusinessRules(struct soap *soap, const char *tag, ns2__BusinessRules **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__BusinessRules **)soap_malloc(soap, sizeof(ns2__BusinessRules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__BusinessRules *)soap_instantiate_ns2__BusinessRules(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__BusinessRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BusinessRules, sizeof(ns2__BusinessRules), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BusinessRules(struct soap *soap, ns2__BusinessRules *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__BusinessRules(soap, tag?tag:"ns2:BusinessRules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__BusinessRules ** SOAP_FMAC4 soap_get_PointerTons2__BusinessRules(struct soap *soap, ns2__BusinessRules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BusinessRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VoidService(struct soap *soap, ns2__VoidService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VoidService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VoidService(struct soap *soap, const char *tag, int id, ns2__VoidService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VoidService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__VoidService ** SOAP_FMAC4 soap_in_PointerTons2__VoidService(struct soap *soap, const char *tag, ns2__VoidService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__VoidService **)soap_malloc(soap, sizeof(ns2__VoidService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__VoidService *)soap_instantiate_ns2__VoidService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__VoidService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VoidService, sizeof(ns2__VoidService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VoidService(struct soap *soap, ns2__VoidService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__VoidService(soap, tag?tag:"ns2:VoidService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__VoidService ** SOAP_FMAC4 soap_get_PointerTons2__VoidService(struct soap *soap, ns2__VoidService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VoidService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalCreditService(struct soap *soap, ns2__PayPalCreditService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalCreditService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalCreditService(struct soap *soap, const char *tag, int id, ns2__PayPalCreditService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalCreditService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalCreditService ** SOAP_FMAC4 soap_in_PointerTons2__PayPalCreditService(struct soap *soap, const char *tag, ns2__PayPalCreditService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalCreditService **)soap_malloc(soap, sizeof(ns2__PayPalCreditService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalCreditService *)soap_instantiate_ns2__PayPalCreditService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalCreditService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalCreditService, sizeof(ns2__PayPalCreditService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalCreditService(struct soap *soap, ns2__PayPalCreditService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalCreditService(soap, tag?tag:"ns2:PayPalCreditService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalCreditService ** SOAP_FMAC4 soap_get_PointerTons2__PayPalCreditService(struct soap *soap, ns2__PayPalCreditService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalCreditService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPalPaymentService(struct soap *soap, ns2__PayPalPaymentService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPalPaymentService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPalPaymentService(struct soap *soap, const char *tag, int id, ns2__PayPalPaymentService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPalPaymentService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPalPaymentService ** SOAP_FMAC4 soap_in_PointerTons2__PayPalPaymentService(struct soap *soap, const char *tag, ns2__PayPalPaymentService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPalPaymentService **)soap_malloc(soap, sizeof(ns2__PayPalPaymentService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPalPaymentService *)soap_instantiate_ns2__PayPalPaymentService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPalPaymentService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPalPaymentService, sizeof(ns2__PayPalPaymentService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPalPaymentService(struct soap *soap, ns2__PayPalPaymentService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPalPaymentService(soap, tag?tag:"ns2:PayPalPaymentService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPalPaymentService ** SOAP_FMAC4 soap_get_PointerTons2__PayPalPaymentService(struct soap *soap, ns2__PayPalPaymentService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPalPaymentService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PaySubscriptionDeleteService(struct soap *soap, ns2__PaySubscriptionDeleteService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PaySubscriptionDeleteService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PaySubscriptionDeleteService(struct soap *soap, const char *tag, int id, ns2__PaySubscriptionDeleteService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PaySubscriptionDeleteService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PaySubscriptionDeleteService ** SOAP_FMAC4 soap_in_PointerTons2__PaySubscriptionDeleteService(struct soap *soap, const char *tag, ns2__PaySubscriptionDeleteService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PaySubscriptionDeleteService **)soap_malloc(soap, sizeof(ns2__PaySubscriptionDeleteService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PaySubscriptionDeleteService *)soap_instantiate_ns2__PaySubscriptionDeleteService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PaySubscriptionDeleteService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PaySubscriptionDeleteService, sizeof(ns2__PaySubscriptionDeleteService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PaySubscriptionDeleteService(struct soap *soap, ns2__PaySubscriptionDeleteService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PaySubscriptionDeleteService(soap, tag?tag:"ns2:PaySubscriptionDeleteService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PaySubscriptionDeleteService ** SOAP_FMAC4 soap_get_PointerTons2__PaySubscriptionDeleteService(struct soap *soap, ns2__PaySubscriptionDeleteService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PaySubscriptionDeleteService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PaySubscriptionRetrieveService(struct soap *soap, ns2__PaySubscriptionRetrieveService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PaySubscriptionRetrieveService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PaySubscriptionRetrieveService(struct soap *soap, const char *tag, int id, ns2__PaySubscriptionRetrieveService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PaySubscriptionRetrieveService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PaySubscriptionRetrieveService ** SOAP_FMAC4 soap_in_PointerTons2__PaySubscriptionRetrieveService(struct soap *soap, const char *tag, ns2__PaySubscriptionRetrieveService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PaySubscriptionRetrieveService **)soap_malloc(soap, sizeof(ns2__PaySubscriptionRetrieveService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PaySubscriptionRetrieveService *)soap_instantiate_ns2__PaySubscriptionRetrieveService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PaySubscriptionRetrieveService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PaySubscriptionRetrieveService, sizeof(ns2__PaySubscriptionRetrieveService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PaySubscriptionRetrieveService(struct soap *soap, ns2__PaySubscriptionRetrieveService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PaySubscriptionRetrieveService(soap, tag?tag:"ns2:PaySubscriptionRetrieveService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PaySubscriptionRetrieveService ** SOAP_FMAC4 soap_get_PointerTons2__PaySubscriptionRetrieveService(struct soap *soap, ns2__PaySubscriptionRetrieveService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PaySubscriptionRetrieveService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PaySubscriptionEventUpdateService(struct soap *soap, ns2__PaySubscriptionEventUpdateService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PaySubscriptionEventUpdateService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PaySubscriptionEventUpdateService(struct soap *soap, const char *tag, int id, ns2__PaySubscriptionEventUpdateService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PaySubscriptionEventUpdateService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PaySubscriptionEventUpdateService ** SOAP_FMAC4 soap_in_PointerTons2__PaySubscriptionEventUpdateService(struct soap *soap, const char *tag, ns2__PaySubscriptionEventUpdateService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PaySubscriptionEventUpdateService **)soap_malloc(soap, sizeof(ns2__PaySubscriptionEventUpdateService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PaySubscriptionEventUpdateService *)soap_instantiate_ns2__PaySubscriptionEventUpdateService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PaySubscriptionEventUpdateService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PaySubscriptionEventUpdateService, sizeof(ns2__PaySubscriptionEventUpdateService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PaySubscriptionEventUpdateService(struct soap *soap, ns2__PaySubscriptionEventUpdateService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PaySubscriptionEventUpdateService(soap, tag?tag:"ns2:PaySubscriptionEventUpdateService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PaySubscriptionEventUpdateService ** SOAP_FMAC4 soap_get_PointerTons2__PaySubscriptionEventUpdateService(struct soap *soap, ns2__PaySubscriptionEventUpdateService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PaySubscriptionEventUpdateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PaySubscriptionUpdateService(struct soap *soap, ns2__PaySubscriptionUpdateService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PaySubscriptionUpdateService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PaySubscriptionUpdateService(struct soap *soap, const char *tag, int id, ns2__PaySubscriptionUpdateService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PaySubscriptionUpdateService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PaySubscriptionUpdateService ** SOAP_FMAC4 soap_in_PointerTons2__PaySubscriptionUpdateService(struct soap *soap, const char *tag, ns2__PaySubscriptionUpdateService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PaySubscriptionUpdateService **)soap_malloc(soap, sizeof(ns2__PaySubscriptionUpdateService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PaySubscriptionUpdateService *)soap_instantiate_ns2__PaySubscriptionUpdateService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PaySubscriptionUpdateService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PaySubscriptionUpdateService, sizeof(ns2__PaySubscriptionUpdateService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PaySubscriptionUpdateService(struct soap *soap, ns2__PaySubscriptionUpdateService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PaySubscriptionUpdateService(soap, tag?tag:"ns2:PaySubscriptionUpdateService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PaySubscriptionUpdateService ** SOAP_FMAC4 soap_get_PointerTons2__PaySubscriptionUpdateService(struct soap *soap, ns2__PaySubscriptionUpdateService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PaySubscriptionUpdateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PaySubscriptionCreateService(struct soap *soap, ns2__PaySubscriptionCreateService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PaySubscriptionCreateService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PaySubscriptionCreateService(struct soap *soap, const char *tag, int id, ns2__PaySubscriptionCreateService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PaySubscriptionCreateService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PaySubscriptionCreateService ** SOAP_FMAC4 soap_in_PointerTons2__PaySubscriptionCreateService(struct soap *soap, const char *tag, ns2__PaySubscriptionCreateService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PaySubscriptionCreateService **)soap_malloc(soap, sizeof(ns2__PaySubscriptionCreateService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PaySubscriptionCreateService *)soap_instantiate_ns2__PaySubscriptionCreateService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PaySubscriptionCreateService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PaySubscriptionCreateService, sizeof(ns2__PaySubscriptionCreateService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PaySubscriptionCreateService(struct soap *soap, ns2__PaySubscriptionCreateService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PaySubscriptionCreateService(soap, tag?tag:"ns2:PaySubscriptionCreateService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PaySubscriptionCreateService ** SOAP_FMAC4 soap_get_PointerTons2__PaySubscriptionCreateService(struct soap *soap, ns2__PaySubscriptionCreateService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PaySubscriptionCreateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DirectDebitValidateService(struct soap *soap, ns2__DirectDebitValidateService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DirectDebitValidateService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DirectDebitValidateService(struct soap *soap, const char *tag, int id, ns2__DirectDebitValidateService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DirectDebitValidateService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DirectDebitValidateService ** SOAP_FMAC4 soap_in_PointerTons2__DirectDebitValidateService(struct soap *soap, const char *tag, ns2__DirectDebitValidateService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DirectDebitValidateService **)soap_malloc(soap, sizeof(ns2__DirectDebitValidateService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DirectDebitValidateService *)soap_instantiate_ns2__DirectDebitValidateService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DirectDebitValidateService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DirectDebitValidateService, sizeof(ns2__DirectDebitValidateService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DirectDebitValidateService(struct soap *soap, ns2__DirectDebitValidateService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DirectDebitValidateService(soap, tag?tag:"ns2:DirectDebitValidateService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DirectDebitValidateService ** SOAP_FMAC4 soap_get_PointerTons2__DirectDebitValidateService(struct soap *soap, ns2__DirectDebitValidateService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DirectDebitValidateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DirectDebitRefundService(struct soap *soap, ns2__DirectDebitRefundService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DirectDebitRefundService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DirectDebitRefundService(struct soap *soap, const char *tag, int id, ns2__DirectDebitRefundService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DirectDebitRefundService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DirectDebitRefundService ** SOAP_FMAC4 soap_in_PointerTons2__DirectDebitRefundService(struct soap *soap, const char *tag, ns2__DirectDebitRefundService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DirectDebitRefundService **)soap_malloc(soap, sizeof(ns2__DirectDebitRefundService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DirectDebitRefundService *)soap_instantiate_ns2__DirectDebitRefundService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DirectDebitRefundService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DirectDebitRefundService, sizeof(ns2__DirectDebitRefundService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DirectDebitRefundService(struct soap *soap, ns2__DirectDebitRefundService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DirectDebitRefundService(soap, tag?tag:"ns2:DirectDebitRefundService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DirectDebitRefundService ** SOAP_FMAC4 soap_get_PointerTons2__DirectDebitRefundService(struct soap *soap, ns2__DirectDebitRefundService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DirectDebitRefundService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DirectDebitService(struct soap *soap, ns2__DirectDebitService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DirectDebitService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DirectDebitService(struct soap *soap, const char *tag, int id, ns2__DirectDebitService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DirectDebitService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DirectDebitService ** SOAP_FMAC4 soap_in_PointerTons2__DirectDebitService(struct soap *soap, const char *tag, ns2__DirectDebitService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DirectDebitService **)soap_malloc(soap, sizeof(ns2__DirectDebitService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DirectDebitService *)soap_instantiate_ns2__DirectDebitService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DirectDebitService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DirectDebitService, sizeof(ns2__DirectDebitService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DirectDebitService(struct soap *soap, ns2__DirectDebitService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DirectDebitService(soap, tag?tag:"ns2:DirectDebitService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DirectDebitService ** SOAP_FMAC4 soap_get_PointerTons2__DirectDebitService(struct soap *soap, ns2__DirectDebitService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DirectDebitService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DirectDebitMandateService(struct soap *soap, ns2__DirectDebitMandateService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DirectDebitMandateService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DirectDebitMandateService(struct soap *soap, const char *tag, int id, ns2__DirectDebitMandateService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DirectDebitMandateService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DirectDebitMandateService ** SOAP_FMAC4 soap_in_PointerTons2__DirectDebitMandateService(struct soap *soap, const char *tag, ns2__DirectDebitMandateService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DirectDebitMandateService **)soap_malloc(soap, sizeof(ns2__DirectDebitMandateService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DirectDebitMandateService *)soap_instantiate_ns2__DirectDebitMandateService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DirectDebitMandateService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DirectDebitMandateService, sizeof(ns2__DirectDebitMandateService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DirectDebitMandateService(struct soap *soap, ns2__DirectDebitMandateService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DirectDebitMandateService(soap, tag?tag:"ns2:DirectDebitMandateService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DirectDebitMandateService ** SOAP_FMAC4 soap_get_PointerTons2__DirectDebitMandateService(struct soap *soap, ns2__DirectDebitMandateService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DirectDebitMandateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BankTransferRealTimeService(struct soap *soap, ns2__BankTransferRealTimeService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BankTransferRealTimeService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BankTransferRealTimeService(struct soap *soap, const char *tag, int id, ns2__BankTransferRealTimeService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BankTransferRealTimeService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__BankTransferRealTimeService ** SOAP_FMAC4 soap_in_PointerTons2__BankTransferRealTimeService(struct soap *soap, const char *tag, ns2__BankTransferRealTimeService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__BankTransferRealTimeService **)soap_malloc(soap, sizeof(ns2__BankTransferRealTimeService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__BankTransferRealTimeService *)soap_instantiate_ns2__BankTransferRealTimeService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__BankTransferRealTimeService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BankTransferRealTimeService, sizeof(ns2__BankTransferRealTimeService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BankTransferRealTimeService(struct soap *soap, ns2__BankTransferRealTimeService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__BankTransferRealTimeService(soap, tag?tag:"ns2:BankTransferRealTimeService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__BankTransferRealTimeService ** SOAP_FMAC4 soap_get_PointerTons2__BankTransferRealTimeService(struct soap *soap, ns2__BankTransferRealTimeService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BankTransferRealTimeService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BankTransferRefundService(struct soap *soap, ns2__BankTransferRefundService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BankTransferRefundService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BankTransferRefundService(struct soap *soap, const char *tag, int id, ns2__BankTransferRefundService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BankTransferRefundService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__BankTransferRefundService ** SOAP_FMAC4 soap_in_PointerTons2__BankTransferRefundService(struct soap *soap, const char *tag, ns2__BankTransferRefundService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__BankTransferRefundService **)soap_malloc(soap, sizeof(ns2__BankTransferRefundService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__BankTransferRefundService *)soap_instantiate_ns2__BankTransferRefundService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__BankTransferRefundService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BankTransferRefundService, sizeof(ns2__BankTransferRefundService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BankTransferRefundService(struct soap *soap, ns2__BankTransferRefundService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__BankTransferRefundService(soap, tag?tag:"ns2:BankTransferRefundService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__BankTransferRefundService ** SOAP_FMAC4 soap_get_PointerTons2__BankTransferRefundService(struct soap *soap, ns2__BankTransferRefundService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BankTransferRefundService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BankTransferService(struct soap *soap, ns2__BankTransferService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BankTransferService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BankTransferService(struct soap *soap, const char *tag, int id, ns2__BankTransferService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BankTransferService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__BankTransferService ** SOAP_FMAC4 soap_in_PointerTons2__BankTransferService(struct soap *soap, const char *tag, ns2__BankTransferService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__BankTransferService **)soap_malloc(soap, sizeof(ns2__BankTransferService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__BankTransferService *)soap_instantiate_ns2__BankTransferService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__BankTransferService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BankTransferService, sizeof(ns2__BankTransferService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BankTransferService(struct soap *soap, ns2__BankTransferService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__BankTransferService(soap, tag?tag:"ns2:BankTransferService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__BankTransferService ** SOAP_FMAC4 soap_get_PointerTons2__BankTransferService(struct soap *soap, ns2__BankTransferService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BankTransferService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FXRatesService(struct soap *soap, ns2__FXRatesService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FXRatesService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FXRatesService(struct soap *soap, const char *tag, int id, ns2__FXRatesService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FXRatesService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__FXRatesService ** SOAP_FMAC4 soap_in_PointerTons2__FXRatesService(struct soap *soap, const char *tag, ns2__FXRatesService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__FXRatesService **)soap_malloc(soap, sizeof(ns2__FXRatesService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__FXRatesService *)soap_instantiate_ns2__FXRatesService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__FXRatesService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FXRatesService, sizeof(ns2__FXRatesService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FXRatesService(struct soap *soap, ns2__FXRatesService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__FXRatesService(soap, tag?tag:"ns2:FXRatesService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__FXRatesService ** SOAP_FMAC4 soap_get_PointerTons2__FXRatesService(struct soap *soap, ns2__FXRatesService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FXRatesService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ExportService(struct soap *soap, ns2__ExportService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ExportService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ExportService(struct soap *soap, const char *tag, int id, ns2__ExportService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ExportService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ExportService ** SOAP_FMAC4 soap_in_PointerTons2__ExportService(struct soap *soap, const char *tag, ns2__ExportService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ExportService **)soap_malloc(soap, sizeof(ns2__ExportService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ExportService *)soap_instantiate_ns2__ExportService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ExportService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ExportService, sizeof(ns2__ExportService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ExportService(struct soap *soap, ns2__ExportService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ExportService(soap, tag?tag:"ns2:ExportService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ExportService ** SOAP_FMAC4 soap_get_PointerTons2__ExportService(struct soap *soap, ns2__ExportService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ExportService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DAVService(struct soap *soap, ns2__DAVService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DAVService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DAVService(struct soap *soap, const char *tag, int id, ns2__DAVService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DAVService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DAVService ** SOAP_FMAC4 soap_in_PointerTons2__DAVService(struct soap *soap, const char *tag, ns2__DAVService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DAVService **)soap_malloc(soap, sizeof(ns2__DAVService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DAVService *)soap_instantiate_ns2__DAVService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DAVService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DAVService, sizeof(ns2__DAVService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DAVService(struct soap *soap, ns2__DAVService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DAVService(soap, tag?tag:"ns2:DAVService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DAVService ** SOAP_FMAC4 soap_get_PointerTons2__DAVService(struct soap *soap, ns2__DAVService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DAVService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AFSService(struct soap *soap, ns2__AFSService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AFSService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AFSService(struct soap *soap, const char *tag, int id, ns2__AFSService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AFSService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AFSService ** SOAP_FMAC4 soap_in_PointerTons2__AFSService(struct soap *soap, const char *tag, ns2__AFSService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AFSService **)soap_malloc(soap, sizeof(ns2__AFSService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AFSService *)soap_instantiate_ns2__AFSService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__AFSService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AFSService, sizeof(ns2__AFSService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AFSService(struct soap *soap, ns2__AFSService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__AFSService(soap, tag?tag:"ns2:AFSService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AFSService ** SOAP_FMAC4 soap_get_PointerTons2__AFSService(struct soap *soap, ns2__AFSService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AFSService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DMEService(struct soap *soap, ns2__DMEService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DMEService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DMEService(struct soap *soap, const char *tag, int id, ns2__DMEService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DMEService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DMEService ** SOAP_FMAC4 soap_in_PointerTons2__DMEService(struct soap *soap, const char *tag, ns2__DMEService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DMEService **)soap_malloc(soap, sizeof(ns2__DMEService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DMEService *)soap_instantiate_ns2__DMEService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DMEService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DMEService, sizeof(ns2__DMEService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DMEService(struct soap *soap, ns2__DMEService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DMEService(soap, tag?tag:"ns2:DMEService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DMEService ** SOAP_FMAC4 soap_get_PointerTons2__DMEService(struct soap *soap, ns2__DMEService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DMEService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TaxService(struct soap *soap, ns2__TaxService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TaxService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TaxService(struct soap *soap, const char *tag, int id, ns2__TaxService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TaxService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__TaxService ** SOAP_FMAC4 soap_in_PointerTons2__TaxService(struct soap *soap, const char *tag, ns2__TaxService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TaxService **)soap_malloc(soap, sizeof(ns2__TaxService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TaxService *)soap_instantiate_ns2__TaxService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__TaxService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TaxService, sizeof(ns2__TaxService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TaxService(struct soap *soap, ns2__TaxService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__TaxService(soap, tag?tag:"ns2:TaxService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TaxService ** SOAP_FMAC4 soap_get_PointerTons2__TaxService(struct soap *soap, ns2__TaxService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TaxService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayerAuthValidateService(struct soap *soap, ns2__PayerAuthValidateService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayerAuthValidateService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayerAuthValidateService(struct soap *soap, const char *tag, int id, ns2__PayerAuthValidateService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayerAuthValidateService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayerAuthValidateService ** SOAP_FMAC4 soap_in_PointerTons2__PayerAuthValidateService(struct soap *soap, const char *tag, ns2__PayerAuthValidateService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayerAuthValidateService **)soap_malloc(soap, sizeof(ns2__PayerAuthValidateService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayerAuthValidateService *)soap_instantiate_ns2__PayerAuthValidateService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayerAuthValidateService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayerAuthValidateService, sizeof(ns2__PayerAuthValidateService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayerAuthValidateService(struct soap *soap, ns2__PayerAuthValidateService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayerAuthValidateService(soap, tag?tag:"ns2:PayerAuthValidateService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayerAuthValidateService ** SOAP_FMAC4 soap_get_PointerTons2__PayerAuthValidateService(struct soap *soap, ns2__PayerAuthValidateService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayerAuthValidateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayerAuthEnrollService(struct soap *soap, ns2__PayerAuthEnrollService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayerAuthEnrollService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayerAuthEnrollService(struct soap *soap, const char *tag, int id, ns2__PayerAuthEnrollService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayerAuthEnrollService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayerAuthEnrollService ** SOAP_FMAC4 soap_in_PointerTons2__PayerAuthEnrollService(struct soap *soap, const char *tag, ns2__PayerAuthEnrollService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayerAuthEnrollService **)soap_malloc(soap, sizeof(ns2__PayerAuthEnrollService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayerAuthEnrollService *)soap_instantiate_ns2__PayerAuthEnrollService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayerAuthEnrollService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayerAuthEnrollService, sizeof(ns2__PayerAuthEnrollService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayerAuthEnrollService(struct soap *soap, ns2__PayerAuthEnrollService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayerAuthEnrollService(soap, tag?tag:"ns2:PayerAuthEnrollService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayerAuthEnrollService ** SOAP_FMAC4 soap_get_PointerTons2__PayerAuthEnrollService(struct soap *soap, ns2__PayerAuthEnrollService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayerAuthEnrollService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ECAuthenticateService(struct soap *soap, ns2__ECAuthenticateService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ECAuthenticateService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ECAuthenticateService(struct soap *soap, const char *tag, int id, ns2__ECAuthenticateService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ECAuthenticateService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ECAuthenticateService ** SOAP_FMAC4 soap_in_PointerTons2__ECAuthenticateService(struct soap *soap, const char *tag, ns2__ECAuthenticateService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ECAuthenticateService **)soap_malloc(soap, sizeof(ns2__ECAuthenticateService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ECAuthenticateService *)soap_instantiate_ns2__ECAuthenticateService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ECAuthenticateService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ECAuthenticateService, sizeof(ns2__ECAuthenticateService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ECAuthenticateService(struct soap *soap, ns2__ECAuthenticateService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ECAuthenticateService(soap, tag?tag:"ns2:ECAuthenticateService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ECAuthenticateService ** SOAP_FMAC4 soap_get_PointerTons2__ECAuthenticateService(struct soap *soap, ns2__ECAuthenticateService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ECAuthenticateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ECCreditService(struct soap *soap, ns2__ECCreditService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ECCreditService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ECCreditService(struct soap *soap, const char *tag, int id, ns2__ECCreditService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ECCreditService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ECCreditService ** SOAP_FMAC4 soap_in_PointerTons2__ECCreditService(struct soap *soap, const char *tag, ns2__ECCreditService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ECCreditService **)soap_malloc(soap, sizeof(ns2__ECCreditService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ECCreditService *)soap_instantiate_ns2__ECCreditService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ECCreditService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ECCreditService, sizeof(ns2__ECCreditService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ECCreditService(struct soap *soap, ns2__ECCreditService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ECCreditService(soap, tag?tag:"ns2:ECCreditService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ECCreditService ** SOAP_FMAC4 soap_get_PointerTons2__ECCreditService(struct soap *soap, ns2__ECCreditService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ECCreditService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ECDebitService(struct soap *soap, ns2__ECDebitService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ECDebitService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ECDebitService(struct soap *soap, const char *tag, int id, ns2__ECDebitService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ECDebitService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ECDebitService ** SOAP_FMAC4 soap_in_PointerTons2__ECDebitService(struct soap *soap, const char *tag, ns2__ECDebitService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ECDebitService **)soap_malloc(soap, sizeof(ns2__ECDebitService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ECDebitService *)soap_instantiate_ns2__ECDebitService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ECDebitService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ECDebitService, sizeof(ns2__ECDebitService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ECDebitService(struct soap *soap, ns2__ECDebitService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ECDebitService(soap, tag?tag:"ns2:ECDebitService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ECDebitService ** SOAP_FMAC4 soap_get_PointerTons2__ECDebitService(struct soap *soap, ns2__ECDebitService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ECDebitService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ServiceFeeCalculateService(struct soap *soap, ns2__ServiceFeeCalculateService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ServiceFeeCalculateService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ServiceFeeCalculateService(struct soap *soap, const char *tag, int id, ns2__ServiceFeeCalculateService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ServiceFeeCalculateService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ServiceFeeCalculateService ** SOAP_FMAC4 soap_in_PointerTons2__ServiceFeeCalculateService(struct soap *soap, const char *tag, ns2__ServiceFeeCalculateService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ServiceFeeCalculateService **)soap_malloc(soap, sizeof(ns2__ServiceFeeCalculateService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ServiceFeeCalculateService *)soap_instantiate_ns2__ServiceFeeCalculateService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ServiceFeeCalculateService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ServiceFeeCalculateService, sizeof(ns2__ServiceFeeCalculateService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ServiceFeeCalculateService(struct soap *soap, ns2__ServiceFeeCalculateService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ServiceFeeCalculateService(soap, tag?tag:"ns2:ServiceFeeCalculateService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ServiceFeeCalculateService ** SOAP_FMAC4 soap_get_PointerTons2__ServiceFeeCalculateService(struct soap *soap, ns2__ServiceFeeCalculateService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ServiceFeeCalculateService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CCDCCService(struct soap *soap, ns2__CCDCCService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CCDCCService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CCDCCService(struct soap *soap, const char *tag, int id, ns2__CCDCCService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CCDCCService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CCDCCService ** SOAP_FMAC4 soap_in_PointerTons2__CCDCCService(struct soap *soap, const char *tag, ns2__CCDCCService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CCDCCService **)soap_malloc(soap, sizeof(ns2__CCDCCService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CCDCCService *)soap_instantiate_ns2__CCDCCService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CCDCCService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CCDCCService, sizeof(ns2__CCDCCService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CCDCCService(struct soap *soap, ns2__CCDCCService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CCDCCService(soap, tag?tag:"ns2:CCDCCService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CCDCCService ** SOAP_FMAC4 soap_get_PointerTons2__CCDCCService(struct soap *soap, ns2__CCDCCService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CCDCCService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CCAutoAuthReversalService(struct soap *soap, ns2__CCAutoAuthReversalService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CCAutoAuthReversalService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CCAutoAuthReversalService(struct soap *soap, const char *tag, int id, ns2__CCAutoAuthReversalService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CCAutoAuthReversalService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CCAutoAuthReversalService ** SOAP_FMAC4 soap_in_PointerTons2__CCAutoAuthReversalService(struct soap *soap, const char *tag, ns2__CCAutoAuthReversalService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CCAutoAuthReversalService **)soap_malloc(soap, sizeof(ns2__CCAutoAuthReversalService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CCAutoAuthReversalService *)soap_instantiate_ns2__CCAutoAuthReversalService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CCAutoAuthReversalService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CCAutoAuthReversalService, sizeof(ns2__CCAutoAuthReversalService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CCAutoAuthReversalService(struct soap *soap, ns2__CCAutoAuthReversalService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CCAutoAuthReversalService(soap, tag?tag:"ns2:CCAutoAuthReversalService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CCAutoAuthReversalService ** SOAP_FMAC4 soap_get_PointerTons2__CCAutoAuthReversalService(struct soap *soap, ns2__CCAutoAuthReversalService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CCAutoAuthReversalService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CCAuthReversalService(struct soap *soap, ns2__CCAuthReversalService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CCAuthReversalService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CCAuthReversalService(struct soap *soap, const char *tag, int id, ns2__CCAuthReversalService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CCAuthReversalService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CCAuthReversalService ** SOAP_FMAC4 soap_in_PointerTons2__CCAuthReversalService(struct soap *soap, const char *tag, ns2__CCAuthReversalService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CCAuthReversalService **)soap_malloc(soap, sizeof(ns2__CCAuthReversalService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CCAuthReversalService *)soap_instantiate_ns2__CCAuthReversalService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CCAuthReversalService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CCAuthReversalService, sizeof(ns2__CCAuthReversalService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CCAuthReversalService(struct soap *soap, ns2__CCAuthReversalService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CCAuthReversalService(soap, tag?tag:"ns2:CCAuthReversalService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CCAuthReversalService ** SOAP_FMAC4 soap_get_PointerTons2__CCAuthReversalService(struct soap *soap, ns2__CCAuthReversalService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CCAuthReversalService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CCCreditService(struct soap *soap, ns2__CCCreditService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CCCreditService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CCCreditService(struct soap *soap, const char *tag, int id, ns2__CCCreditService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CCCreditService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CCCreditService ** SOAP_FMAC4 soap_in_PointerTons2__CCCreditService(struct soap *soap, const char *tag, ns2__CCCreditService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CCCreditService **)soap_malloc(soap, sizeof(ns2__CCCreditService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CCCreditService *)soap_instantiate_ns2__CCCreditService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CCCreditService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CCCreditService, sizeof(ns2__CCCreditService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CCCreditService(struct soap *soap, ns2__CCCreditService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CCCreditService(soap, tag?tag:"ns2:CCCreditService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CCCreditService ** SOAP_FMAC4 soap_get_PointerTons2__CCCreditService(struct soap *soap, ns2__CCCreditService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CCCreditService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CCCaptureService(struct soap *soap, ns2__CCCaptureService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CCCaptureService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CCCaptureService(struct soap *soap, const char *tag, int id, ns2__CCCaptureService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CCCaptureService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CCCaptureService ** SOAP_FMAC4 soap_in_PointerTons2__CCCaptureService(struct soap *soap, const char *tag, ns2__CCCaptureService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CCCaptureService **)soap_malloc(soap, sizeof(ns2__CCCaptureService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CCCaptureService *)soap_instantiate_ns2__CCCaptureService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CCCaptureService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CCCaptureService, sizeof(ns2__CCCaptureService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CCCaptureService(struct soap *soap, ns2__CCCaptureService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CCCaptureService(soap, tag?tag:"ns2:CCCaptureService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CCCaptureService ** SOAP_FMAC4 soap_get_PointerTons2__CCCaptureService(struct soap *soap, ns2__CCCaptureService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CCCaptureService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CCIncrementalAuthService(struct soap *soap, ns2__CCIncrementalAuthService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CCIncrementalAuthService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CCIncrementalAuthService(struct soap *soap, const char *tag, int id, ns2__CCIncrementalAuthService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CCIncrementalAuthService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CCIncrementalAuthService ** SOAP_FMAC4 soap_in_PointerTons2__CCIncrementalAuthService(struct soap *soap, const char *tag, ns2__CCIncrementalAuthService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CCIncrementalAuthService **)soap_malloc(soap, sizeof(ns2__CCIncrementalAuthService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CCIncrementalAuthService *)soap_instantiate_ns2__CCIncrementalAuthService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CCIncrementalAuthService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CCIncrementalAuthService, sizeof(ns2__CCIncrementalAuthService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CCIncrementalAuthService(struct soap *soap, ns2__CCIncrementalAuthService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CCIncrementalAuthService(soap, tag?tag:"ns2:CCIncrementalAuthService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CCIncrementalAuthService ** SOAP_FMAC4 soap_get_PointerTons2__CCIncrementalAuthService(struct soap *soap, ns2__CCIncrementalAuthService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CCIncrementalAuthService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CCSaleReversalService(struct soap *soap, ns2__CCSaleReversalService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CCSaleReversalService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CCSaleReversalService(struct soap *soap, const char *tag, int id, ns2__CCSaleReversalService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CCSaleReversalService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CCSaleReversalService ** SOAP_FMAC4 soap_in_PointerTons2__CCSaleReversalService(struct soap *soap, const char *tag, ns2__CCSaleReversalService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CCSaleReversalService **)soap_malloc(soap, sizeof(ns2__CCSaleReversalService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CCSaleReversalService *)soap_instantiate_ns2__CCSaleReversalService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CCSaleReversalService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CCSaleReversalService, sizeof(ns2__CCSaleReversalService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CCSaleReversalService(struct soap *soap, ns2__CCSaleReversalService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CCSaleReversalService(soap, tag?tag:"ns2:CCSaleReversalService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CCSaleReversalService ** SOAP_FMAC4 soap_get_PointerTons2__CCSaleReversalService(struct soap *soap, ns2__CCSaleReversalService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CCSaleReversalService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CCSaleCreditService(struct soap *soap, ns2__CCSaleCreditService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CCSaleCreditService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CCSaleCreditService(struct soap *soap, const char *tag, int id, ns2__CCSaleCreditService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CCSaleCreditService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CCSaleCreditService ** SOAP_FMAC4 soap_in_PointerTons2__CCSaleCreditService(struct soap *soap, const char *tag, ns2__CCSaleCreditService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CCSaleCreditService **)soap_malloc(soap, sizeof(ns2__CCSaleCreditService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CCSaleCreditService *)soap_instantiate_ns2__CCSaleCreditService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CCSaleCreditService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CCSaleCreditService, sizeof(ns2__CCSaleCreditService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CCSaleCreditService(struct soap *soap, ns2__CCSaleCreditService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CCSaleCreditService(soap, tag?tag:"ns2:CCSaleCreditService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CCSaleCreditService ** SOAP_FMAC4 soap_get_PointerTons2__CCSaleCreditService(struct soap *soap, ns2__CCSaleCreditService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CCSaleCreditService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CCSaleService(struct soap *soap, ns2__CCSaleService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CCSaleService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CCSaleService(struct soap *soap, const char *tag, int id, ns2__CCSaleService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CCSaleService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CCSaleService ** SOAP_FMAC4 soap_in_PointerTons2__CCSaleService(struct soap *soap, const char *tag, ns2__CCSaleService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CCSaleService **)soap_malloc(soap, sizeof(ns2__CCSaleService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CCSaleService *)soap_instantiate_ns2__CCSaleService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CCSaleService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CCSaleService, sizeof(ns2__CCSaleService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CCSaleService(struct soap *soap, ns2__CCSaleService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CCSaleService(soap, tag?tag:"ns2:CCSaleService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CCSaleService ** SOAP_FMAC4 soap_get_PointerTons2__CCSaleService(struct soap *soap, ns2__CCSaleService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CCSaleService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__VerificationService(struct soap *soap, ns2__VerificationService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__VerificationService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__VerificationService(struct soap *soap, const char *tag, int id, ns2__VerificationService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__VerificationService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__VerificationService ** SOAP_FMAC4 soap_in_PointerTons2__VerificationService(struct soap *soap, const char *tag, ns2__VerificationService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__VerificationService **)soap_malloc(soap, sizeof(ns2__VerificationService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__VerificationService *)soap_instantiate_ns2__VerificationService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__VerificationService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__VerificationService, sizeof(ns2__VerificationService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__VerificationService(struct soap *soap, ns2__VerificationService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__VerificationService(soap, tag?tag:"ns2:VerificationService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__VerificationService ** SOAP_FMAC4 soap_get_PointerTons2__VerificationService(struct soap *soap, ns2__VerificationService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__VerificationService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OCTService(struct soap *soap, ns2__OCTService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OCTService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OCTService(struct soap *soap, const char *tag, int id, ns2__OCTService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OCTService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__OCTService ** SOAP_FMAC4 soap_in_PointerTons2__OCTService(struct soap *soap, const char *tag, ns2__OCTService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__OCTService **)soap_malloc(soap, sizeof(ns2__OCTService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__OCTService *)soap_instantiate_ns2__OCTService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__OCTService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OCTService, sizeof(ns2__OCTService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OCTService(struct soap *soap, ns2__OCTService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__OCTService(soap, tag?tag:"ns2:OCTService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__OCTService ** SOAP_FMAC4 soap_get_PointerTons2__OCTService(struct soap *soap, ns2__OCTService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OCTService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CCAuthService(struct soap *soap, ns2__CCAuthService *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CCAuthService))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CCAuthService(struct soap *soap, const char *tag, int id, ns2__CCAuthService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CCAuthService, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CCAuthService ** SOAP_FMAC4 soap_in_PointerTons2__CCAuthService(struct soap *soap, const char *tag, ns2__CCAuthService **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CCAuthService **)soap_malloc(soap, sizeof(ns2__CCAuthService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CCAuthService *)soap_instantiate_ns2__CCAuthService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__CCAuthService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CCAuthService, sizeof(ns2__CCAuthService), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CCAuthService(struct soap *soap, ns2__CCAuthService *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__CCAuthService(soap, tag?tag:"ns2:CCAuthService", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CCAuthService ** SOAP_FMAC4 soap_get_PointerTons2__CCAuthService(struct soap *soap, ns2__CCAuthService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CCAuthService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ServiceFee(struct soap *soap, ns2__ServiceFee *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ServiceFee))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ServiceFee(struct soap *soap, const char *tag, int id, ns2__ServiceFee *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ServiceFee, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ServiceFee ** SOAP_FMAC4 soap_in_PointerTons2__ServiceFee(struct soap *soap, const char *tag, ns2__ServiceFee **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ServiceFee **)soap_malloc(soap, sizeof(ns2__ServiceFee *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ServiceFee *)soap_instantiate_ns2__ServiceFee(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ServiceFee **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ServiceFee, sizeof(ns2__ServiceFee), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ServiceFee(struct soap *soap, ns2__ServiceFee *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ServiceFee(soap, tag?tag:"ns2:ServiceFee", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ServiceFee ** SOAP_FMAC4 soap_get_PointerTons2__ServiceFee(struct soap *soap, ns2__ServiceFee **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ServiceFee(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__JPO(struct soap *soap, ns2__JPO *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__JPO))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__JPO(struct soap *soap, const char *tag, int id, ns2__JPO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__JPO, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__JPO ** SOAP_FMAC4 soap_in_PointerTons2__JPO(struct soap *soap, const char *tag, ns2__JPO **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__JPO **)soap_malloc(soap, sizeof(ns2__JPO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__JPO *)soap_instantiate_ns2__JPO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__JPO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__JPO, sizeof(ns2__JPO), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__JPO(struct soap *soap, ns2__JPO *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__JPO(soap, tag?tag:"ns2:JPO", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__JPO ** SOAP_FMAC4 soap_get_PointerTons2__JPO(struct soap *soap, ns2__JPO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__JPO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MerchantSecureData(struct soap *soap, ns2__MerchantSecureData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MerchantSecureData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MerchantSecureData(struct soap *soap, const char *tag, int id, ns2__MerchantSecureData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MerchantSecureData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MerchantSecureData ** SOAP_FMAC4 soap_in_PointerTons2__MerchantSecureData(struct soap *soap, const char *tag, ns2__MerchantSecureData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MerchantSecureData **)soap_malloc(soap, sizeof(ns2__MerchantSecureData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MerchantSecureData *)soap_instantiate_ns2__MerchantSecureData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__MerchantSecureData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MerchantSecureData, sizeof(ns2__MerchantSecureData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MerchantSecureData(struct soap *soap, ns2__MerchantSecureData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__MerchantSecureData(soap, tag?tag:"ns2:MerchantSecureData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MerchantSecureData ** SOAP_FMAC4 soap_get_PointerTons2__MerchantSecureData(struct soap *soap, ns2__MerchantSecureData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MerchantSecureData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MerchantDefinedData(struct soap *soap, ns2__MerchantDefinedData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MerchantDefinedData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MerchantDefinedData(struct soap *soap, const char *tag, int id, ns2__MerchantDefinedData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MerchantDefinedData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MerchantDefinedData ** SOAP_FMAC4 soap_in_PointerTons2__MerchantDefinedData(struct soap *soap, const char *tag, ns2__MerchantDefinedData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MerchantDefinedData **)soap_malloc(soap, sizeof(ns2__MerchantDefinedData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MerchantDefinedData *)soap_instantiate_ns2__MerchantDefinedData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__MerchantDefinedData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MerchantDefinedData, sizeof(ns2__MerchantDefinedData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MerchantDefinedData(struct soap *soap, ns2__MerchantDefinedData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__MerchantDefinedData(soap, tag?tag:"ns2:MerchantDefinedData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MerchantDefinedData ** SOAP_FMAC4 soap_get_PointerTons2__MerchantDefinedData(struct soap *soap, ns2__MerchantDefinedData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MerchantDefinedData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayPal(struct soap *soap, ns2__PayPal *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayPal))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayPal(struct soap *soap, const char *tag, int id, ns2__PayPal *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayPal, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayPal ** SOAP_FMAC4 soap_in_PointerTons2__PayPal(struct soap *soap, const char *tag, ns2__PayPal **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayPal **)soap_malloc(soap, sizeof(ns2__PayPal *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayPal *)soap_instantiate_ns2__PayPal(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PayPal **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayPal, sizeof(ns2__PayPal), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayPal(struct soap *soap, ns2__PayPal *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PayPal(soap, tag?tag:"ns2:PayPal", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PayPal ** SOAP_FMAC4 soap_get_PointerTons2__PayPal(struct soap *soap, ns2__PayPal **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayPal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OtherTax(struct soap *soap, ns2__OtherTax *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OtherTax))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OtherTax(struct soap *soap, const char *tag, int id, ns2__OtherTax *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OtherTax, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__OtherTax ** SOAP_FMAC4 soap_in_PointerTons2__OtherTax(struct soap *soap, const char *tag, ns2__OtherTax **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__OtherTax **)soap_malloc(soap, sizeof(ns2__OtherTax *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__OtherTax *)soap_instantiate_ns2__OtherTax(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__OtherTax **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OtherTax, sizeof(ns2__OtherTax), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OtherTax(struct soap *soap, ns2__OtherTax *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__OtherTax(soap, tag?tag:"ns2:OtherTax", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__OtherTax ** SOAP_FMAC4 soap_get_PointerTons2__OtherTax(struct soap *soap, ns2__OtherTax **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OtherTax(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DecisionManager(struct soap *soap, ns2__DecisionManager *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DecisionManager))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DecisionManager(struct soap *soap, const char *tag, int id, ns2__DecisionManager *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DecisionManager, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DecisionManager ** SOAP_FMAC4 soap_in_PointerTons2__DecisionManager(struct soap *soap, const char *tag, ns2__DecisionManager **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DecisionManager **)soap_malloc(soap, sizeof(ns2__DecisionManager *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DecisionManager *)soap_instantiate_ns2__DecisionManager(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DecisionManager **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DecisionManager, sizeof(ns2__DecisionManager), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DecisionManager(struct soap *soap, ns2__DecisionManager *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DecisionManager(soap, tag?tag:"ns2:DecisionManager", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DecisionManager ** SOAP_FMAC4 soap_get_PointerTons2__DecisionManager(struct soap *soap, ns2__DecisionManager **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DecisionManager(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RecurringSubscriptionInfo(struct soap *soap, ns2__RecurringSubscriptionInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RecurringSubscriptionInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RecurringSubscriptionInfo(struct soap *soap, const char *tag, int id, ns2__RecurringSubscriptionInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RecurringSubscriptionInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RecurringSubscriptionInfo ** SOAP_FMAC4 soap_in_PointerTons2__RecurringSubscriptionInfo(struct soap *soap, const char *tag, ns2__RecurringSubscriptionInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RecurringSubscriptionInfo **)soap_malloc(soap, sizeof(ns2__RecurringSubscriptionInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RecurringSubscriptionInfo *)soap_instantiate_ns2__RecurringSubscriptionInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__RecurringSubscriptionInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RecurringSubscriptionInfo, sizeof(ns2__RecurringSubscriptionInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RecurringSubscriptionInfo(struct soap *soap, ns2__RecurringSubscriptionInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__RecurringSubscriptionInfo(soap, tag?tag:"ns2:RecurringSubscriptionInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RecurringSubscriptionInfo ** SOAP_FMAC4 soap_get_PointerTons2__RecurringSubscriptionInfo(struct soap *soap, ns2__RecurringSubscriptionInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RecurringSubscriptionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Subscription(struct soap *soap, ns2__Subscription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Subscription))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Subscription(struct soap *soap, const char *tag, int id, ns2__Subscription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Subscription, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Subscription ** SOAP_FMAC4 soap_in_PointerTons2__Subscription(struct soap *soap, const char *tag, ns2__Subscription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Subscription **)soap_malloc(soap, sizeof(ns2__Subscription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Subscription *)soap_instantiate_ns2__Subscription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Subscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Subscription, sizeof(ns2__Subscription), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Subscription(struct soap *soap, ns2__Subscription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Subscription(soap, tag?tag:"ns2:Subscription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Subscription ** SOAP_FMAC4 soap_get_PointerTons2__Subscription(struct soap *soap, ns2__Subscription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Subscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BankInfo(struct soap *soap, ns2__BankInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BankInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BankInfo(struct soap *soap, const char *tag, int id, ns2__BankInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BankInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__BankInfo ** SOAP_FMAC4 soap_in_PointerTons2__BankInfo(struct soap *soap, const char *tag, ns2__BankInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__BankInfo **)soap_malloc(soap, sizeof(ns2__BankInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__BankInfo *)soap_instantiate_ns2__BankInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__BankInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BankInfo, sizeof(ns2__BankInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BankInfo(struct soap *soap, ns2__BankInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__BankInfo(soap, tag?tag:"ns2:BankInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__BankInfo ** SOAP_FMAC4 soap_get_PointerTons2__BankInfo(struct soap *soap, ns2__BankInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BankInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FundTransfer(struct soap *soap, ns2__FundTransfer *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FundTransfer))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FundTransfer(struct soap *soap, const char *tag, int id, ns2__FundTransfer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FundTransfer, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__FundTransfer ** SOAP_FMAC4 soap_in_PointerTons2__FundTransfer(struct soap *soap, const char *tag, ns2__FundTransfer **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__FundTransfer **)soap_malloc(soap, sizeof(ns2__FundTransfer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__FundTransfer *)soap_instantiate_ns2__FundTransfer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__FundTransfer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FundTransfer, sizeof(ns2__FundTransfer), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FundTransfer(struct soap *soap, ns2__FundTransfer *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__FundTransfer(soap, tag?tag:"ns2:FundTransfer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__FundTransfer ** SOAP_FMAC4 soap_get_PointerTons2__FundTransfer(struct soap *soap, ns2__FundTransfer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FundTransfer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__UCAF(struct soap *soap, ns2__UCAF *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__UCAF))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__UCAF(struct soap *soap, const char *tag, int id, ns2__UCAF *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__UCAF, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__UCAF ** SOAP_FMAC4 soap_in_PointerTons2__UCAF(struct soap *soap, const char *tag, ns2__UCAF **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__UCAF **)soap_malloc(soap, sizeof(ns2__UCAF *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__UCAF *)soap_instantiate_ns2__UCAF(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__UCAF **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__UCAF, sizeof(ns2__UCAF), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__UCAF(struct soap *soap, ns2__UCAF *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__UCAF(soap, tag?tag:"ns2:UCAF", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__UCAF ** SOAP_FMAC4 soap_get_PointerTons2__UCAF(struct soap *soap, ns2__UCAF **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__UCAF(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__GECC(struct soap *soap, ns2__GECC *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__GECC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__GECC(struct soap *soap, const char *tag, int id, ns2__GECC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__GECC, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__GECC ** SOAP_FMAC4 soap_in_PointerTons2__GECC(struct soap *soap, const char *tag, ns2__GECC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__GECC **)soap_malloc(soap, sizeof(ns2__GECC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__GECC *)soap_instantiate_ns2__GECC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__GECC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__GECC, sizeof(ns2__GECC), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__GECC(struct soap *soap, ns2__GECC *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__GECC(soap, tag?tag:"ns2:GECC", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__GECC ** SOAP_FMAC4 soap_get_PointerTons2__GECC(struct soap *soap, ns2__GECC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__GECC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BML(struct soap *soap, ns2__BML *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BML))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BML(struct soap *soap, const char *tag, int id, ns2__BML *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BML, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__BML ** SOAP_FMAC4 soap_in_PointerTons2__BML(struct soap *soap, const char *tag, ns2__BML **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__BML **)soap_malloc(soap, sizeof(ns2__BML *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__BML *)soap_instantiate_ns2__BML(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__BML **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BML, sizeof(ns2__BML), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BML(struct soap *soap, ns2__BML *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__BML(soap, tag?tag:"ns2:BML", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__BML ** SOAP_FMAC4 soap_get_PointerTons2__BML(struct soap *soap, ns2__BML **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BML(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Check(struct soap *soap, ns2__Check *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Check))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Check(struct soap *soap, const char *tag, int id, ns2__Check *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Check, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Check ** SOAP_FMAC4 soap_in_PointerTons2__Check(struct soap *soap, const char *tag, ns2__Check **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Check **)soap_malloc(soap, sizeof(ns2__Check *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Check *)soap_instantiate_ns2__Check(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Check **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Check, sizeof(ns2__Check), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Check(struct soap *soap, ns2__Check *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Check(soap, tag?tag:"ns2:Check", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Check ** SOAP_FMAC4 soap_get_PointerTons2__Check(struct soap *soap, ns2__Check **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Check(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Card(struct soap *soap, ns2__Card *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Card))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Card(struct soap *soap, const char *tag, int id, ns2__Card *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Card, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Card ** SOAP_FMAC4 soap_in_PointerTons2__Card(struct soap *soap, const char *tag, ns2__Card **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Card **)soap_malloc(soap, sizeof(ns2__Card *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Card *)soap_instantiate_ns2__Card(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Card **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Card, sizeof(ns2__Card), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Card(struct soap *soap, ns2__Card *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Card(soap, tag?tag:"ns2:Card", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Card ** SOAP_FMAC4 soap_get_PointerTons2__Card(struct soap *soap, ns2__Card **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Card(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Installment(struct soap *soap, ns2__Installment *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Installment))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Installment(struct soap *soap, const char *tag, int id, ns2__Installment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Installment, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Installment ** SOAP_FMAC4 soap_in_PointerTons2__Installment(struct soap *soap, const char *tag, ns2__Installment **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Installment **)soap_malloc(soap, sizeof(ns2__Installment *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Installment *)soap_instantiate_ns2__Installment(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Installment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Installment, sizeof(ns2__Installment), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Installment(struct soap *soap, ns2__Installment *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Installment(soap, tag?tag:"ns2:Installment", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Installment ** SOAP_FMAC4 soap_get_PointerTons2__Installment(struct soap *soap, ns2__Installment **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Installment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__EncryptedPayment(struct soap *soap, ns2__EncryptedPayment *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__EncryptedPayment))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__EncryptedPayment(struct soap *soap, const char *tag, int id, ns2__EncryptedPayment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__EncryptedPayment, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__EncryptedPayment ** SOAP_FMAC4 soap_in_PointerTons2__EncryptedPayment(struct soap *soap, const char *tag, ns2__EncryptedPayment **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__EncryptedPayment **)soap_malloc(soap, sizeof(ns2__EncryptedPayment *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__EncryptedPayment *)soap_instantiate_ns2__EncryptedPayment(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__EncryptedPayment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__EncryptedPayment, sizeof(ns2__EncryptedPayment), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__EncryptedPayment(struct soap *soap, ns2__EncryptedPayment *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__EncryptedPayment(soap, tag?tag:"ns2:EncryptedPayment", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__EncryptedPayment ** SOAP_FMAC4 soap_get_PointerTons2__EncryptedPayment(struct soap *soap, ns2__EncryptedPayment **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__EncryptedPayment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Pos(struct soap *soap, ns2__Pos *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Pos))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Pos(struct soap *soap, const char *tag, int id, ns2__Pos *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Pos, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Pos ** SOAP_FMAC4 soap_in_PointerTons2__Pos(struct soap *soap, const char *tag, ns2__Pos **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Pos **)soap_malloc(soap, sizeof(ns2__Pos *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Pos *)soap_instantiate_ns2__Pos(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Pos **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Pos, sizeof(ns2__Pos), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Pos(struct soap *soap, ns2__Pos *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Pos(soap, tag?tag:"ns2:Pos", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Pos ** SOAP_FMAC4 soap_get_PointerTons2__Pos(struct soap *soap, ns2__Pos **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Pos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DCC(struct soap *soap, ns2__DCC *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DCC))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DCC(struct soap *soap, const char *tag, int id, ns2__DCC *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DCC, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DCC ** SOAP_FMAC4 soap_in_PointerTons2__DCC(struct soap *soap, const char *tag, ns2__DCC **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DCC **)soap_malloc(soap, sizeof(ns2__DCC *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DCC *)soap_instantiate_ns2__DCC(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DCC **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DCC, sizeof(ns2__DCC), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DCC(struct soap *soap, ns2__DCC *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DCC(soap, tag?tag:"ns2:DCC", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DCC ** SOAP_FMAC4 soap_get_PointerTons2__DCC(struct soap *soap, ns2__DCC **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DCC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FundingTotals(struct soap *soap, ns2__FundingTotals *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FundingTotals))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FundingTotals(struct soap *soap, const char *tag, int id, ns2__FundingTotals *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FundingTotals, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__FundingTotals ** SOAP_FMAC4 soap_in_PointerTons2__FundingTotals(struct soap *soap, const char *tag, ns2__FundingTotals **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__FundingTotals **)soap_malloc(soap, sizeof(ns2__FundingTotals *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__FundingTotals *)soap_instantiate_ns2__FundingTotals(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__FundingTotals **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FundingTotals, sizeof(ns2__FundingTotals), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FundingTotals(struct soap *soap, ns2__FundingTotals *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__FundingTotals(soap, tag?tag:"ns2:FundingTotals", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__FundingTotals ** SOAP_FMAC4 soap_get_PointerTons2__FundingTotals(struct soap *soap, ns2__FundingTotals **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FundingTotals(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PurchaseTotals(struct soap *soap, ns2__PurchaseTotals *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PurchaseTotals))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PurchaseTotals(struct soap *soap, const char *tag, int id, ns2__PurchaseTotals *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PurchaseTotals, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PurchaseTotals ** SOAP_FMAC4 soap_in_PointerTons2__PurchaseTotals(struct soap *soap, const char *tag, ns2__PurchaseTotals **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PurchaseTotals **)soap_malloc(soap, sizeof(ns2__PurchaseTotals *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PurchaseTotals *)soap_instantiate_ns2__PurchaseTotals(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PurchaseTotals **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PurchaseTotals, sizeof(ns2__PurchaseTotals), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PurchaseTotals(struct soap *soap, ns2__PurchaseTotals *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PurchaseTotals(soap, tag?tag:"ns2:PurchaseTotals", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PurchaseTotals ** SOAP_FMAC4 soap_get_PointerTons2__PurchaseTotals(struct soap *soap, ns2__PurchaseTotals **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PurchaseTotals(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Item(struct soap *soap, ns2__Item *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Item))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Item(struct soap *soap, const char *tag, int id, ns2__Item *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Item, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Item ** SOAP_FMAC4 soap_in_PointerTons2__Item(struct soap *soap, const char *tag, ns2__Item **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Item **)soap_malloc(soap, sizeof(ns2__Item *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Item *)soap_instantiate_ns2__Item(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Item **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Item, sizeof(ns2__Item), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Item(struct soap *soap, ns2__Item *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Item(soap, tag?tag:"ns2:Item", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Item ** SOAP_FMAC4 soap_get_PointerTons2__Item(struct soap *soap, ns2__Item **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Item(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ShipFrom(struct soap *soap, ns2__ShipFrom *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ShipFrom))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ShipFrom(struct soap *soap, const char *tag, int id, ns2__ShipFrom *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ShipFrom, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ShipFrom ** SOAP_FMAC4 soap_in_PointerTons2__ShipFrom(struct soap *soap, const char *tag, ns2__ShipFrom **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ShipFrom **)soap_malloc(soap, sizeof(ns2__ShipFrom *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ShipFrom *)soap_instantiate_ns2__ShipFrom(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ShipFrom **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ShipFrom, sizeof(ns2__ShipFrom), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ShipFrom(struct soap *soap, ns2__ShipFrom *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ShipFrom(soap, tag?tag:"ns2:ShipFrom", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ShipFrom ** SOAP_FMAC4 soap_get_PointerTons2__ShipFrom(struct soap *soap, ns2__ShipFrom **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ShipFrom(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PersonalId(struct soap *soap, ns2__PersonalId *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PersonalId))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PersonalId(struct soap *soap, const char *tag, int id, ns2__PersonalId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PersonalId, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PersonalId ** SOAP_FMAC4 soap_in_PointerTons2__PersonalId(struct soap *soap, const char *tag, ns2__PersonalId **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PersonalId **)soap_malloc(soap, sizeof(ns2__PersonalId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PersonalId *)soap_instantiate_ns2__PersonalId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PersonalId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PersonalId, sizeof(ns2__PersonalId), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PersonalId(struct soap *soap, ns2__PersonalId *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PersonalId(soap, tag?tag:"ns2:PersonalId", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PersonalId ** SOAP_FMAC4 soap_get_PointerTons2__PersonalId(struct soap *soap, ns2__PersonalId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PersonalId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ShipTo(struct soap *soap, ns2__ShipTo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ShipTo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ShipTo(struct soap *soap, const char *tag, int id, ns2__ShipTo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ShipTo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ShipTo ** SOAP_FMAC4 soap_in_PointerTons2__ShipTo(struct soap *soap, const char *tag, ns2__ShipTo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ShipTo **)soap_malloc(soap, sizeof(ns2__ShipTo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ShipTo *)soap_instantiate_ns2__ShipTo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__ShipTo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ShipTo, sizeof(ns2__ShipTo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ShipTo(struct soap *soap, ns2__ShipTo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__ShipTo(soap, tag?tag:"ns2:ShipTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ShipTo ** SOAP_FMAC4 soap_get_PointerTons2__ShipTo(struct soap *soap, ns2__ShipTo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ShipTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__BillTo(struct soap *soap, ns2__BillTo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__BillTo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__BillTo(struct soap *soap, const char *tag, int id, ns2__BillTo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__BillTo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__BillTo ** SOAP_FMAC4 soap_in_PointerTons2__BillTo(struct soap *soap, const char *tag, ns2__BillTo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__BillTo **)soap_malloc(soap, sizeof(ns2__BillTo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__BillTo *)soap_instantiate_ns2__BillTo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__BillTo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__BillTo, sizeof(ns2__BillTo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__BillTo(struct soap *soap, ns2__BillTo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__BillTo(soap, tag?tag:"ns2:BillTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__BillTo ** SOAP_FMAC4 soap_get_PointerTons2__BillTo(struct soap *soap, ns2__BillTo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__BillTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__InvoiceHeader(struct soap *soap, ns2__InvoiceHeader *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__InvoiceHeader))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__InvoiceHeader(struct soap *soap, const char *tag, int id, ns2__InvoiceHeader *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__InvoiceHeader, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__InvoiceHeader ** SOAP_FMAC4 soap_in_PointerTons2__InvoiceHeader(struct soap *soap, const char *tag, ns2__InvoiceHeader **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__InvoiceHeader **)soap_malloc(soap, sizeof(ns2__InvoiceHeader *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__InvoiceHeader *)soap_instantiate_ns2__InvoiceHeader(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__InvoiceHeader **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__InvoiceHeader, sizeof(ns2__InvoiceHeader), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__InvoiceHeader(struct soap *soap, ns2__InvoiceHeader *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__InvoiceHeader(soap, tag?tag:"ns2:InvoiceHeader", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__InvoiceHeader ** SOAP_FMAC4 soap_get_PointerTons2__InvoiceHeader(struct soap *soap, ns2__InvoiceHeader **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__InvoiceHeader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__APDevice(struct soap *soap, ns2__APDevice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__APDevice))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__APDevice(struct soap *soap, const char *tag, int id, ns2__APDevice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__APDevice, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__APDevice ** SOAP_FMAC4 soap_in_PointerTons2__APDevice(struct soap *soap, const char *tag, ns2__APDevice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__APDevice **)soap_malloc(soap, sizeof(ns2__APDevice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__APDevice *)soap_instantiate_ns2__APDevice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__APDevice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__APDevice, sizeof(ns2__APDevice), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__APDevice(struct soap *soap, ns2__APDevice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__APDevice(soap, tag?tag:"ns2:APDevice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__APDevice ** SOAP_FMAC4 soap_get_PointerTons2__APDevice(struct soap *soap, ns2__APDevice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__APDevice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DecisionManagerTravelLeg(struct soap *soap, ns2__DecisionManagerTravelLeg *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DecisionManagerTravelLeg))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DecisionManagerTravelLeg(struct soap *soap, const char *tag, int id, ns2__DecisionManagerTravelLeg *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DecisionManagerTravelLeg, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DecisionManagerTravelLeg ** SOAP_FMAC4 soap_in_PointerTons2__DecisionManagerTravelLeg(struct soap *soap, const char *tag, ns2__DecisionManagerTravelLeg **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DecisionManagerTravelLeg **)soap_malloc(soap, sizeof(ns2__DecisionManagerTravelLeg *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DecisionManagerTravelLeg *)soap_instantiate_ns2__DecisionManagerTravelLeg(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DecisionManagerTravelLeg **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DecisionManagerTravelLeg, sizeof(ns2__DecisionManagerTravelLeg), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DecisionManagerTravelLeg(struct soap *soap, ns2__DecisionManagerTravelLeg *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DecisionManagerTravelLeg(soap, tag?tag:"ns2:DecisionManagerTravelLeg", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DecisionManagerTravelLeg ** SOAP_FMAC4 soap_get_PointerTons2__DecisionManagerTravelLeg(struct soap *soap, ns2__DecisionManagerTravelLeg **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DecisionManagerTravelLeg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DecisionManagerTravelData(struct soap *soap, ns2__DecisionManagerTravelData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DecisionManagerTravelData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DecisionManagerTravelData(struct soap *soap, const char *tag, int id, ns2__DecisionManagerTravelData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DecisionManagerTravelData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DecisionManagerTravelData ** SOAP_FMAC4 soap_in_PointerTons2__DecisionManagerTravelData(struct soap *soap, const char *tag, ns2__DecisionManagerTravelData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DecisionManagerTravelData **)soap_malloc(soap, sizeof(ns2__DecisionManagerTravelData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DecisionManagerTravelData *)soap_instantiate_ns2__DecisionManagerTravelData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__DecisionManagerTravelData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DecisionManagerTravelData, sizeof(ns2__DecisionManagerTravelData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DecisionManagerTravelData(struct soap *soap, ns2__DecisionManagerTravelData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__DecisionManagerTravelData(soap, tag?tag:"ns2:DecisionManagerTravelData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DecisionManagerTravelData ** SOAP_FMAC4 soap_get_PointerTons2__DecisionManagerTravelData(struct soap *soap, ns2__DecisionManagerTravelData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DecisionManagerTravelData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PaySubscriptionEvent(struct soap *soap, ns2__PaySubscriptionEvent *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PaySubscriptionEvent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PaySubscriptionEvent(struct soap *soap, const char *tag, int id, ns2__PaySubscriptionEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PaySubscriptionEvent, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PaySubscriptionEvent ** SOAP_FMAC4 soap_in_PointerTons2__PaySubscriptionEvent(struct soap *soap, const char *tag, ns2__PaySubscriptionEvent **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PaySubscriptionEvent **)soap_malloc(soap, sizeof(ns2__PaySubscriptionEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PaySubscriptionEvent *)soap_instantiate_ns2__PaySubscriptionEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__PaySubscriptionEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PaySubscriptionEvent, sizeof(ns2__PaySubscriptionEvent), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PaySubscriptionEvent(struct soap *soap, ns2__PaySubscriptionEvent *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__PaySubscriptionEvent(soap, tag?tag:"ns2:PaySubscriptionEvent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PaySubscriptionEvent ** SOAP_FMAC4 soap_get_PointerTons2__PaySubscriptionEvent(struct soap *soap, ns2__PaySubscriptionEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PaySubscriptionEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Address(struct soap *soap, ns2__Address *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Address))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Address(struct soap *soap, const char *tag, int id, ns2__Address *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Address, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Address ** SOAP_FMAC4 soap_in_PointerTons2__Address(struct soap *soap, const char *tag, ns2__Address **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Address **)soap_malloc(soap, sizeof(ns2__Address *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Address *)soap_instantiate_ns2__Address(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns2__Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Address, sizeof(ns2__Address), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Address(struct soap *soap, ns2__Address *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__Address(soap, tag?tag:"ns2:Address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Address ** SOAP_FMAC4 soap_get_PointerTons2__Address(struct soap *soap, ns2__Address **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__dateTime(struct soap *soap, wchar_t **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__dateTime))
		soap_serialize_ns2__dateTime(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__dateTime(struct soap *soap, const char *tag, int id, wchar_t **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__dateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__dateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 wchar_t *** SOAP_FMAC4 soap_in_PointerTons2__dateTime(struct soap *soap, const char *tag, wchar_t ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wchar_t ***)soap_malloc(soap, sizeof(wchar_t **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__dateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (wchar_t ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__dateTime, sizeof(wchar_t *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__dateTime(struct soap *soap, wchar_t **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__dateTime(soap, tag?tag:"ns2:dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wchar_t *** SOAP_FMAC4 soap_get_PointerTons2__dateTime(struct soap *soap, wchar_t ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__integer(struct soap *soap, wchar_t **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__integer))
		soap_serialize_xsd__integer(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__integer(struct soap *soap, const char *tag, int id, wchar_t **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__integer, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__integer(soap, tag, id, *a, type);
}

SOAP_FMAC3 wchar_t *** SOAP_FMAC4 soap_in_PointerToxsd__integer(struct soap *soap, const char *tag, wchar_t ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wchar_t ***)soap_malloc(soap, sizeof(wchar_t **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__integer(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (wchar_t ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__integer, sizeof(wchar_t *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__integer(struct soap *soap, wchar_t **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__integer(soap, tag?tag:"xsd:integer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wchar_t *** SOAP_FMAC4 soap_get_PointerToxsd__integer(struct soap *soap, wchar_t ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__boolean(struct soap *soap, wchar_t **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__boolean))
		soap_serialize_ns2__boolean(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__boolean(struct soap *soap, const char *tag, int id, wchar_t **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__boolean, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__boolean(soap, tag, id, *a, type);
}

SOAP_FMAC3 wchar_t *** SOAP_FMAC4 soap_in_PointerTons2__boolean(struct soap *soap, const char *tag, wchar_t ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wchar_t ***)soap_malloc(soap, sizeof(wchar_t **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__boolean(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (wchar_t ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__boolean, sizeof(wchar_t *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__boolean(struct soap *soap, wchar_t **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__boolean(soap, tag?tag:"ns2:boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wchar_t *** SOAP_FMAC4 soap_get_PointerTons2__boolean(struct soap *soap, wchar_t ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__amount(struct soap *soap, wchar_t **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__amount))
		soap_serialize_ns2__amount(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__amount(struct soap *soap, const char *tag, int id, wchar_t **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__amount, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns2__amount(soap, tag, id, *a, type);
}

SOAP_FMAC3 wchar_t *** SOAP_FMAC4 soap_in_PointerTons2__amount(struct soap *soap, const char *tag, wchar_t ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wchar_t ***)soap_malloc(soap, sizeof(wchar_t **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns2__amount(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (wchar_t ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__amount, sizeof(wchar_t *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__amount(struct soap *soap, wchar_t **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons2__amount(soap, tag?tag:"ns2:amount", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wchar_t *** SOAP_FMAC4 soap_get_PointerTons2__amount(struct soap *soap, wchar_t ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__amount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__dateTime(struct soap *soap, wchar_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns2__dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__dateTime(struct soap *soap, const char *tag, int id, wchar_t *const*a, const char *type)
{
	return soap_outwstring(soap, tag, id, a, type, SOAP_TYPE_ns2__dateTime);
}

SOAP_FMAC3 wchar_t * * SOAP_FMAC4 soap_in_ns2__dateTime(struct soap *soap, const char *tag, wchar_t **a, const char *type)
{
	a = soap_inwstring(soap, tag, a, type, SOAP_TYPE_ns2__dateTime, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__dateTime(struct soap *soap, wchar_t *const*a, const char *tag, const char *type)
{
	if (soap_out_ns2__dateTime(soap, tag?tag:"ns2:dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wchar_t ** SOAP_FMAC4 soap_get_ns2__dateTime(struct soap *soap, wchar_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__boolean(struct soap *soap, wchar_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns2__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__boolean(struct soap *soap, const char *tag, int id, wchar_t *const*a, const char *type)
{
	return soap_outwstring(soap, tag, id, a, type, SOAP_TYPE_ns2__boolean);
}

SOAP_FMAC3 wchar_t * * SOAP_FMAC4 soap_in_ns2__boolean(struct soap *soap, const char *tag, wchar_t **a, const char *type)
{
	a = soap_inwstring(soap, tag, a, type, SOAP_TYPE_ns2__boolean, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__boolean(struct soap *soap, wchar_t *const*a, const char *tag, const char *type)
{
	if (soap_out_ns2__boolean(soap, tag?tag:"ns2:boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wchar_t ** SOAP_FMAC4 soap_get_ns2__boolean(struct soap *soap, wchar_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__amount(struct soap *soap, wchar_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns2__amount);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__amount(struct soap *soap, const char *tag, int id, wchar_t *const*a, const char *type)
{
	return soap_outwstring(soap, tag, id, a, type, SOAP_TYPE_ns2__amount);
}

SOAP_FMAC3 wchar_t * * SOAP_FMAC4 soap_in_ns2__amount(struct soap *soap, const char *tag, wchar_t **a, const char *type)
{
	a = soap_inwstring(soap, tag, a, type, SOAP_TYPE_ns2__amount, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__amount(struct soap *soap, wchar_t *const*a, const char *tag, const char *type)
{
	if (soap_out_ns2__amount(soap, tag?tag:"ns2:amount", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wchar_t ** SOAP_FMAC4 soap_get_ns2__amount(struct soap *soap, wchar_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__amount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap *soap, wchar_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__integer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, wchar_t *const*a, const char *type)
{
	return soap_outwstring(soap, tag, id, a, type, SOAP_TYPE_xsd__integer);
}

SOAP_FMAC3 wchar_t * * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, wchar_t **a, const char *type)
{
	a = soap_inwstring(soap, tag, a, type, SOAP_TYPE_xsd__integer, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, wchar_t *const*a, const char *tag, const char *type)
{
	if (soap_out_xsd__integer(soap, tag?tag:"xsd:integer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wchar_t ** SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, wchar_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstring(struct soap *soap, wchar_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_wstring);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstring(struct soap *soap, const char *tag, int id, wchar_t *const*a, const char *type)
{
	return soap_outwstring(soap, tag, id, a, type, SOAP_TYPE_wstring);
}

SOAP_FMAC3 wchar_t * * SOAP_FMAC4 soap_in_wstring(struct soap *soap, const char *tag, wchar_t **a, const char *type)
{
	a = soap_inwstring(soap, tag, a, type, SOAP_TYPE_wstring, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstring(struct soap *soap, wchar_t *const*a, const char *tag, const char *type)
{
	if (soap_out_wstring(soap, tag?tag:"string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wchar_t ** SOAP_FMAC4 soap_get_wstring(struct soap *soap, wchar_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Security))
		soap_serialize__wsse__Security(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Security(struct soap *soap, const char *tag, int id, struct _wsse__Security *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Security, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Security(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_in_PointerTo_wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Security **)soap_malloc(soap, sizeof(struct _wsse__Security *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Security(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__Security(soap, tag?tag:"wsse:Security", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_get_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureType))
		soap_serialize_ds__SignatureType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureType(struct soap *soap, const char *tag, int id, struct ds__SignatureType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_in_PointerTods__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureType **)soap_malloc(soap, sizeof(struct ds__SignatureType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__SignatureType(soap, tag?tag:"ds:SignatureType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_get_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsc__SecurityContextTokenType))
		soap_serialize_wsc__SecurityContextTokenType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsc__SecurityContextTokenType(struct soap *soap, const char *tag, int id, struct wsc__SecurityContextTokenType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsc__SecurityContextTokenType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsc__SecurityContextTokenType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType ** SOAP_FMAC4 soap_in_PointerTowsc__SecurityContextTokenType(struct soap *soap, const char *tag, struct wsc__SecurityContextTokenType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsc__SecurityContextTokenType **)soap_malloc(soap, sizeof(struct wsc__SecurityContextTokenType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsc__SecurityContextTokenType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsc__SecurityContextTokenType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsc__SecurityContextTokenType, sizeof(struct wsc__SecurityContextTokenType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsc__SecurityContextTokenType(soap, tag?tag:"wsc:SecurityContextTokenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType ** SOAP_FMAC4 soap_get_PointerTowsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsc__SecurityContextTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptedKeyType))
		soap_serialize_xenc__EncryptedKeyType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, struct xenc__EncryptedKeyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptedKeyType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptedKeyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptedKeyType **)soap_malloc(soap, sizeof(struct xenc__EncryptedKeyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptedKeyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedKeyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__EncryptedKeyType(soap, tag?tag:"xenc:EncryptedKeyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptedKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__BinarySecurityToken))
		soap_serialize__wsse__BinarySecurityToken(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, struct _wsse__BinarySecurityToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__BinarySecurityToken, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__BinarySecurityToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__BinarySecurityToken **)soap_malloc(soap, sizeof(struct _wsse__BinarySecurityToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__BinarySecurityToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__BinarySecurityToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag?tag:"wsse:BinarySecurityToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__UsernameToken))
		soap_serialize__wsse__UsernameToken(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, int id, struct _wsse__UsernameToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__UsernameToken, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__UsernameToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__UsernameToken **)soap_malloc(soap, sizeof(struct _wsse__UsernameToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__UsernameToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__UsernameToken(soap, tag?tag:"wsse:UsernameToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsu__Timestamp))
		soap_serialize__wsu__Timestamp(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, int id, struct _wsu__Timestamp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsu__Timestamp, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsu__Timestamp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_in_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsu__Timestamp **)soap_malloc(soap, sizeof(struct _wsu__Timestamp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsu__Timestamp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsu__Timestamp(soap, tag?tag:"wsu:Timestamp", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_get_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence))
		soap_serialize___wsc__DerivedKeyTokenType_sequence(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, int id, struct __wsc__DerivedKeyTokenType_sequence *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___wsc__DerivedKeyTokenType_sequence(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence ** SOAP_FMAC4 soap_in_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, struct __wsc__DerivedKeyTokenType_sequence **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __wsc__DerivedKeyTokenType_sequence **)soap_malloc(soap, sizeof(struct __wsc__DerivedKeyTokenType_sequence *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___wsc__DerivedKeyTokenType_sequence(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __wsc__DerivedKeyTokenType_sequence **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence, sizeof(struct __wsc__DerivedKeyTokenType_sequence), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, tag?tag:"-wsc:DerivedKeyTokenType-sequence", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence ** SOAP_FMAC4 soap_get_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToULONG64(struct soap *soap, ULONG64 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ULONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToULONG64(struct soap *soap, const char *tag, int id, ULONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ULONG64, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ULONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_in_PointerToULONG64(struct soap *soap, const char *tag, ULONG64 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ULONG64 **)soap_malloc(soap, sizeof(ULONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ULONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ULONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ULONG64, sizeof(ULONG64), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToULONG64(struct soap *soap, ULONG64 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToULONG64(soap, tag?tag:"unsignedLong", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_get_PointerToULONG64(struct soap *soap, ULONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToULONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsc__PropertiesType))
		soap_serialize_wsc__PropertiesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsc__PropertiesType(struct soap *soap, const char *tag, int id, struct wsc__PropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsc__PropertiesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsc__PropertiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsc__PropertiesType ** SOAP_FMAC4 soap_in_PointerTowsc__PropertiesType(struct soap *soap, const char *tag, struct wsc__PropertiesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsc__PropertiesType **)soap_malloc(soap, sizeof(struct wsc__PropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsc__PropertiesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsc__PropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsc__PropertiesType, sizeof(struct wsc__PropertiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsc__PropertiesType(soap, tag?tag:"wsc:PropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__PropertiesType ** SOAP_FMAC4 soap_get_PointerTowsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsc__PropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__FaultCodeOpenEnumType(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsc__FaultCodeOpenEnumType
	*a = SOAP_DEFAULT_wsc__FaultCodeOpenEnumType;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__FaultCodeOpenEnumType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_wsc__FaultCodeOpenEnumType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__FaultCodeOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsc__FaultCodeOpenEnumType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsc__FaultCodeOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsc__FaultCodeOpenEnumType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__FaultCodeOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsc__FaultCodeOpenEnumType(soap, tag?tag:"wsc:FaultCodeOpenEnumType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsc__FaultCodeOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__FaultCodeOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__xenc__ReferenceList))
		soap_serialize__xenc__ReferenceList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xenc__ReferenceList(struct soap *soap, const char *tag, int id, struct _xenc__ReferenceList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__xenc__ReferenceList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__xenc__ReferenceList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _xenc__ReferenceList ** SOAP_FMAC4 soap_in_PointerTo_xenc__ReferenceList(struct soap *soap, const char *tag, struct _xenc__ReferenceList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _xenc__ReferenceList **)soap_malloc(soap, sizeof(struct _xenc__ReferenceList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__xenc__ReferenceList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _xenc__ReferenceList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_xenc__ReferenceList(soap, tag?tag:"xenc:ReferenceList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xenc__ReferenceList ** SOAP_FMAC4 soap_get_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_xenc__ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___xenc__union_ReferenceList))
		soap_serialize___xenc__union_ReferenceList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__xenc__union_ReferenceList(struct soap *soap, const char *tag, int id, struct __xenc__union_ReferenceList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___xenc__union_ReferenceList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___xenc__union_ReferenceList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __xenc__union_ReferenceList ** SOAP_FMAC4 soap_in_PointerTo__xenc__union_ReferenceList(struct soap *soap, const char *tag, struct __xenc__union_ReferenceList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __xenc__union_ReferenceList **)soap_malloc(soap, sizeof(struct __xenc__union_ReferenceList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___xenc__union_ReferenceList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __xenc__union_ReferenceList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___xenc__union_ReferenceList, sizeof(struct __xenc__union_ReferenceList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__xenc__union_ReferenceList(soap, tag?tag:"-xenc:union-ReferenceList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __xenc__union_ReferenceList ** SOAP_FMAC4 soap_get_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__xenc__union_ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__ReferenceType))
		soap_serialize_xenc__ReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__ReferenceType(struct soap *soap, const char *tag, int id, struct xenc__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__ReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__ReferenceType ** SOAP_FMAC4 soap_in_PointerToxenc__ReferenceType(struct soap *soap, const char *tag, struct xenc__ReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__ReferenceType **)soap_malloc(soap, sizeof(struct xenc__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__ReferenceType(soap, tag?tag:"xenc:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__ReferenceType ** SOAP_FMAC4 soap_get_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionPropertyType))
		soap_serialize_xenc__EncryptionPropertyType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionPropertyType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionPropertyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionPropertyType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionPropertyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionPropertyType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertyType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionPropertyType **)soap_malloc(soap, sizeof(struct xenc__EncryptionPropertyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptionPropertyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__EncryptionPropertyType(soap, tag?tag:"xenc:EncryptionPropertyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionPropertyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__TransformsType))
		soap_serialize_xenc__TransformsType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__TransformsType(struct soap *soap, const char *tag, int id, struct xenc__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__TransformsType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__TransformsType ** SOAP_FMAC4 soap_in_PointerToxenc__TransformsType(struct soap *soap, const char *tag, struct xenc__TransformsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__TransformsType **)soap_malloc(soap, sizeof(struct xenc__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__TransformsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__TransformsType(soap, tag?tag:"xenc:TransformsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__TransformsType ** SOAP_FMAC4 soap_get_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__CipherReferenceType))
		soap_serialize_xenc__CipherReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__CipherReferenceType(struct soap *soap, const char *tag, int id, struct xenc__CipherReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__CipherReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__CipherReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__CipherReferenceType ** SOAP_FMAC4 soap_in_PointerToxenc__CipherReferenceType(struct soap *soap, const char *tag, struct xenc__CipherReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__CipherReferenceType **)soap_malloc(soap, sizeof(struct xenc__CipherReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__CipherReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__CipherReferenceType(soap, tag?tag:"xenc:CipherReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherReferenceType ** SOAP_FMAC4 soap_get_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__CipherReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionPropertiesType))
		soap_serialize_xenc__EncryptionPropertiesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionPropertiesType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionPropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionPropertiesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionPropertiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionPropertiesType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertiesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionPropertiesType **)soap_malloc(soap, sizeof(struct xenc__EncryptionPropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptionPropertiesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, tag?tag:"xenc:EncryptionPropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__CipherDataType))
		soap_serialize_xenc__CipherDataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__CipherDataType(struct soap *soap, const char *tag, int id, struct xenc__CipherDataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__CipherDataType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__CipherDataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__CipherDataType ** SOAP_FMAC4 soap_in_PointerToxenc__CipherDataType(struct soap *soap, const char *tag, struct xenc__CipherDataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__CipherDataType **)soap_malloc(soap, sizeof(struct xenc__CipherDataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__CipherDataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherDataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__CipherDataType(soap, tag?tag:"xenc:CipherDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherDataType ** SOAP_FMAC4 soap_get_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__CipherDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ds__KeyInfo))
		soap_serialize__ds__KeyInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ds__KeyInfo(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ds__KeyInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ds__KeyInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTo_ds__KeyInfo(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ds__KeyInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ds__KeyInfo, sizeof(struct ds__KeyInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ds__KeyInfo(soap, tag?tag:"ds:KeyInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ds__KeyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionMethodType))
		soap_serialize_xenc__EncryptionMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionMethodType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionMethodType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionMethodType(struct soap *soap, const char *tag, struct xenc__EncryptionMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionMethodType **)soap_malloc(soap, sizeof(struct xenc__EncryptionMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptionMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, tag?tag:"xenc:EncryptionMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509IssuerSerialType))
		soap_serialize_ds__X509IssuerSerialType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, int id, struct ds__X509IssuerSerialType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509IssuerSerialType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509IssuerSerialType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_in_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509IssuerSerialType **)soap_malloc(soap, sizeof(struct ds__X509IssuerSerialType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509IssuerSerialType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__X509IssuerSerialType(soap, tag?tag:"ds:X509IssuerSerialType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_get_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RSAKeyValueType))
		soap_serialize_ds__RSAKeyValueType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__RSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RSAKeyValueType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__RSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__RSAKeyValueType(soap, tag?tag:"ds:RSAKeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DSAKeyValueType))
		soap_serialize_ds__DSAKeyValueType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__DSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DSAKeyValueType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__DSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__DSAKeyValueType(soap, tag?tag:"ds:DSAKeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformType))
		soap_serialize_ds__TransformType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformType(struct soap *soap, const char *tag, int id, struct ds__TransformType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_in_PointerTods__TransformType(struct soap *soap, const char *tag, struct ds__TransformType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformType **)soap_malloc(soap, sizeof(struct ds__TransformType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__TransformType(soap, tag?tag:"ds:TransformType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_get_PointerTods__TransformType(struct soap *soap, struct ds__TransformType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DigestMethodType))
		soap_serialize_ds__DigestMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DigestMethodType(struct soap *soap, const char *tag, int id, struct ds__DigestMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DigestMethodType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DigestMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_in_PointerTods__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DigestMethodType **)soap_malloc(soap, sizeof(struct ds__DigestMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DigestMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__DigestMethodType(soap, tag?tag:"ds:DigestMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_get_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformsType))
		soap_serialize_ds__TransformsType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformsType(struct soap *soap, const char *tag, int id, struct ds__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformsType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_in_PointerTods__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformsType **)soap_malloc(soap, sizeof(struct ds__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__TransformsType(soap, tag?tag:"ds:TransformsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_get_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToint(soap, tag?tag:"int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTods__ReferenceType))
		soap_serialize_PointerTods__ReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTods__ReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTods__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_in_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType ***)soap_malloc(soap, sizeof(struct ds__ReferenceType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTods__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTods__ReferenceType(soap, tag?tag:"ds:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_get_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__ReferenceType))
		soap_serialize_ds__ReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__ReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_in_PointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType **)soap_malloc(soap, sizeof(struct ds__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__ReferenceType(soap, tag?tag:"ds:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_get_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureMethodType))
		soap_serialize_ds__SignatureMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, int id, struct ds__SignatureMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureMethodType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_in_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureMethodType **)soap_malloc(soap, sizeof(struct ds__SignatureMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__SignatureMethodType(soap, tag?tag:"ds:SignatureMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_get_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__CanonicalizationMethodType))
		soap_serialize_ds__CanonicalizationMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, struct ds__CanonicalizationMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__CanonicalizationMethodType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__CanonicalizationMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_in_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__CanonicalizationMethodType **)soap_malloc(soap, sizeof(struct ds__CanonicalizationMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__CanonicalizationMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__CanonicalizationMethodType(soap, tag?tag:"ds:CanonicalizationMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_get_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__SecurityTokenReference))
		soap_serialize__wsse__SecurityTokenReference(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, struct _wsse__SecurityTokenReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__SecurityTokenReference, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__SecurityTokenReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_in_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__SecurityTokenReference **)soap_malloc(soap, sizeof(struct _wsse__SecurityTokenReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__SecurityTokenReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag?tag:"wsse:SecurityTokenReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_get_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RetrievalMethodType))
		soap_serialize_ds__RetrievalMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, int id, struct ds__RetrievalMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RetrievalMethodType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RetrievalMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_in_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RetrievalMethodType **)soap_malloc(soap, sizeof(struct ds__RetrievalMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RetrievalMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__RetrievalMethodType(soap, tag?tag:"ds:RetrievalMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_get_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyValueType))
		soap_serialize_ds__KeyValueType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyValueType(struct soap *soap, const char *tag, int id, struct ds__KeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyValueType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_in_PointerTods__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyValueType **)soap_malloc(soap, sizeof(struct ds__KeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__KeyValueType(soap, tag?tag:"ds:KeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_get_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__c14n__InclusiveNamespaces))
		soap_serialize__c14n__InclusiveNamespaces(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, struct _c14n__InclusiveNamespaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__c14n__InclusiveNamespaces, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__c14n__InclusiveNamespaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_in_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _c14n__InclusiveNamespaces **)soap_malloc(soap, sizeof(struct _c14n__InclusiveNamespaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__c14n__InclusiveNamespaces(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag?tag:"c14n:InclusiveNamespaces", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_get_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyInfoType))
		soap_serialize_ds__KeyInfoType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyInfoType(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyInfoType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTods__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__KeyInfoType(soap, tag?tag:"ds:KeyInfoType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignedInfoType))
		soap_serialize_ds__SignedInfoType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignedInfoType(struct soap *soap, const char *tag, int id, struct ds__SignedInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignedInfoType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignedInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_in_PointerTods__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignedInfoType **)soap_malloc(soap, sizeof(struct ds__SignedInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignedInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__SignedInfoType(soap, tag?tag:"ds:SignedInfoType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_get_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509DataType))
		soap_serialize_ds__X509DataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509DataType(struct soap *soap, const char *tag, int id, struct ds__X509DataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509DataType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509DataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_in_PointerTods__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509DataType **)soap_malloc(soap, sizeof(struct ds__X509DataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509DataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTods__X509DataType(soap, tag?tag:"ds:X509DataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_get_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Embedded))
		soap_serialize__wsse__Embedded(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, int id, struct _wsse__Embedded *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Embedded, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Embedded(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_in_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Embedded **)soap_malloc(soap, sizeof(struct _wsse__Embedded *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Embedded(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__Embedded(soap, tag?tag:"wsse:Embedded", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_get_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__KeyIdentifier))
		soap_serialize__wsse__KeyIdentifier(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, struct _wsse__KeyIdentifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__KeyIdentifier, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__KeyIdentifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_in_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__KeyIdentifier **)soap_malloc(soap, sizeof(struct _wsse__KeyIdentifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__KeyIdentifier(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__KeyIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, tag?tag:"wsse:KeyIdentifier", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_get_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Reference))
		soap_serialize__wsse__Reference(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Reference(struct soap *soap, const char *tag, int id, struct _wsse__Reference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Reference, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Reference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_in_PointerTo_wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Reference **)soap_malloc(soap, sizeof(struct _wsse__Reference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Reference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__Reference(soap, tag?tag:"wsse:Reference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_get_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsse__EncodedString(struct soap *soap, struct wsse__EncodedString *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsse__EncodedString))
		soap_serialize_wsse__EncodedString(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsse__EncodedString(struct soap *soap, const char *tag, int id, struct wsse__EncodedString *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsse__EncodedString, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsse__EncodedString(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsse__EncodedString ** SOAP_FMAC4 soap_in_PointerTowsse__EncodedString(struct soap *soap, const char *tag, struct wsse__EncodedString **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsse__EncodedString **)soap_malloc(soap, sizeof(struct wsse__EncodedString *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsse__EncodedString(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsse__EncodedString **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsse__EncodedString, sizeof(struct wsse__EncodedString), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsse__EncodedString(struct soap *soap, struct wsse__EncodedString *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsse__EncodedString(soap, tag?tag:"wsse:EncodedString", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsse__EncodedString ** SOAP_FMAC4 soap_get_PointerTowsse__EncodedString(struct soap *soap, struct wsse__EncodedString **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsse__EncodedString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Password))
		soap_serialize__wsse__Password(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Password(struct soap *soap, const char *tag, int id, struct _wsse__Password *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Password, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Password(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_in_PointerTo_wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Password **)soap_malloc(soap, sizeof(struct _wsse__Password *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Password(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Password **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsse__Password(soap, tag?tag:"wsse:Password", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_get_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__QName
	*a = SOAP_DEFAULT__QName;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag?tag:"QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag?tag:"string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__PaypalTransaction(struct soap *soap, std::vector<ns2__PaypalTransaction *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__PaypalTransaction(struct soap *soap, const std::vector<ns2__PaypalTransaction *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__PaypalTransaction *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__PaypalTransaction(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__PaypalTransaction(struct soap *soap, const char *tag, int id, const std::vector<ns2__PaypalTransaction *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__PaypalTransaction *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__PaypalTransaction(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__PaypalTransaction *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__PaypalTransaction(struct soap *soap, const char *tag, std::vector<ns2__PaypalTransaction *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__PaypalTransaction(soap)))
			return NULL;
		else if (a->size() >= soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__PaypalTransaction *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__PaypalTransaction, SOAP_TYPE_std__vectorTemplateOfPointerTons2__PaypalTransaction, sizeof(ns2__PaypalTransaction), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__PaypalTransaction(soap, tag, NULL, "ns2:PaypalTransaction"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__PaypalTransaction(soap, tag, &n, "ns2:PaypalTransaction"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__PaypalTransaction *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__PaypalTransaction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__PaypalTransaction(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__PaypalTransaction *> *p;
	size_t k = sizeof(std::vector<ns2__PaypalTransaction *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns2__PaypalTransaction *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns2__PaypalTransaction *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__PaypalTransaction *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons2__PaypalTransaction, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__MDDField(struct soap *soap, std::vector<ns2__MDDField *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__MDDField(struct soap *soap, const std::vector<ns2__MDDField *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__MDDField *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__MDDField(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__MDDField(struct soap *soap, const char *tag, int id, const std::vector<ns2__MDDField *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__MDDField *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__MDDField(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__MDDField *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__MDDField(struct soap *soap, const char *tag, std::vector<ns2__MDDField *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__MDDField(soap)))
			return NULL;
		else if (a->size() >= soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__MDDField *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__MDDField, SOAP_TYPE_std__vectorTemplateOfPointerTons2__MDDField, sizeof(ns2__MDDField), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__MDDField(soap, tag, NULL, "ns2:MDDField"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__MDDField(soap, tag, &n, "ns2:MDDField"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__MDDField *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__MDDField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__MDDField(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__MDDField *> *p;
	size_t k = sizeof(std::vector<ns2__MDDField *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns2__MDDField *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns2__MDDField *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__MDDField *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons2__MDDField, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__Service(struct soap *soap, std::vector<ns2__Service *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__Service(struct soap *soap, const std::vector<ns2__Service *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__Service *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__Service(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__Service(struct soap *soap, const char *tag, int id, const std::vector<ns2__Service *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__Service *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__Service(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__Service *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__Service(struct soap *soap, const char *tag, std::vector<ns2__Service *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__Service(soap)))
			return NULL;
		else if (a->size() >= soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__Service *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__Service, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Service, sizeof(ns2__Service), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__Service(soap, tag, NULL, "ns2:Service"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__Service(soap, tag, &n, "ns2:Service"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__Service *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__Service(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__Service(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__Service *> *p;
	size_t k = sizeof(std::vector<ns2__Service *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns2__Service *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns2__Service *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__Service *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Service, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__Leg(struct soap *soap, std::vector<ns2__Leg *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__Leg(struct soap *soap, const std::vector<ns2__Leg *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__Leg *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__Leg(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__Leg(struct soap *soap, const char *tag, int id, const std::vector<ns2__Leg *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__Leg *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__Leg(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__Leg *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__Leg(struct soap *soap, const char *tag, std::vector<ns2__Leg *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__Leg(soap)))
			return NULL;
		else if (a->size() >= soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__Leg *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__Leg, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Leg, sizeof(ns2__Leg), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__Leg(soap, tag, NULL, "ns2:Leg"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__Leg(soap, tag, &n, "ns2:Leg"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__Leg *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__Leg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__Leg(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__Leg *> *p;
	size_t k = sizeof(std::vector<ns2__Leg *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns2__Leg *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns2__Leg *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__Leg *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Leg, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__PromotionGroupReply(struct soap *soap, std::vector<ns2__PromotionGroupReply *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__PromotionGroupReply(struct soap *soap, const std::vector<ns2__PromotionGroupReply *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__PromotionGroupReply *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__PromotionGroupReply(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__PromotionGroupReply(struct soap *soap, const char *tag, int id, const std::vector<ns2__PromotionGroupReply *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__PromotionGroupReply *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__PromotionGroupReply(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__PromotionGroupReply *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__PromotionGroupReply(struct soap *soap, const char *tag, std::vector<ns2__PromotionGroupReply *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__PromotionGroupReply(soap)))
			return NULL;
		else if (a->size() >= soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__PromotionGroupReply *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__PromotionGroupReply, SOAP_TYPE_std__vectorTemplateOfPointerTons2__PromotionGroupReply, sizeof(ns2__PromotionGroupReply), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__PromotionGroupReply(soap, tag, NULL, "ns2:PromotionGroupReply"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__PromotionGroupReply(soap, tag, &n, "ns2:PromotionGroupReply"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__PromotionGroupReply *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__PromotionGroupReply(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__PromotionGroupReply(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__PromotionGroupReply *> *p;
	size_t k = sizeof(std::vector<ns2__PromotionGroupReply *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns2__PromotionGroupReply *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns2__PromotionGroupReply *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__PromotionGroupReply *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons2__PromotionGroupReply, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__DeniedPartiesMatch(struct soap *soap, std::vector<ns2__DeniedPartiesMatch *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__DeniedPartiesMatch(struct soap *soap, const std::vector<ns2__DeniedPartiesMatch *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__DeniedPartiesMatch *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__DeniedPartiesMatch(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__DeniedPartiesMatch(struct soap *soap, const char *tag, int id, const std::vector<ns2__DeniedPartiesMatch *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__DeniedPartiesMatch *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__DeniedPartiesMatch(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__DeniedPartiesMatch *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__DeniedPartiesMatch(struct soap *soap, const char *tag, std::vector<ns2__DeniedPartiesMatch *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__DeniedPartiesMatch(soap)))
			return NULL;
		else if (a->size() >= soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__DeniedPartiesMatch *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__DeniedPartiesMatch, SOAP_TYPE_std__vectorTemplateOfPointerTons2__DeniedPartiesMatch, sizeof(ns2__DeniedPartiesMatch), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__DeniedPartiesMatch(soap, tag, NULL, "ns2:DeniedPartiesMatch"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__DeniedPartiesMatch(soap, tag, &n, "ns2:DeniedPartiesMatch"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__DeniedPartiesMatch *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__DeniedPartiesMatch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__DeniedPartiesMatch(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__DeniedPartiesMatch *> *p;
	size_t k = sizeof(std::vector<ns2__DeniedPartiesMatch *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns2__DeniedPartiesMatch *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns2__DeniedPartiesMatch *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__DeniedPartiesMatch *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons2__DeniedPartiesMatch, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__Field(struct soap *soap, std::vector<ns2__Field *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__Field(struct soap *soap, const std::vector<ns2__Field *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__Field *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__Field(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__Field(struct soap *soap, const char *tag, int id, const std::vector<ns2__Field *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__Field *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__Field(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__Field *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__Field(struct soap *soap, const char *tag, std::vector<ns2__Field *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__Field(soap)))
			return NULL;
		else if (a->size() >= soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__Field *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__Field, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Field, sizeof(ns2__Field), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__Field(soap, tag, NULL, "ns2:Field"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__Field(soap, tag, &n, "ns2:Field"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__Field *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__Field(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__Field(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__Field *> *p;
	size_t k = sizeof(std::vector<ns2__Field *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns2__Field *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns2__Field *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__Field *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Field, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__RuleResultItem(struct soap *soap, std::vector<ns2__RuleResultItem *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__RuleResultItem(struct soap *soap, const std::vector<ns2__RuleResultItem *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__RuleResultItem *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__RuleResultItem(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__RuleResultItem(struct soap *soap, const char *tag, int id, const std::vector<ns2__RuleResultItem *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__RuleResultItem *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__RuleResultItem(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__RuleResultItem *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__RuleResultItem(struct soap *soap, const char *tag, std::vector<ns2__RuleResultItem *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__RuleResultItem(soap)))
			return NULL;
		else if (a->size() >= soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__RuleResultItem *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__RuleResultItem, SOAP_TYPE_std__vectorTemplateOfPointerTons2__RuleResultItem, sizeof(ns2__RuleResultItem), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__RuleResultItem(soap, tag, NULL, "ns2:RuleResultItem"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__RuleResultItem(soap, tag, &n, "ns2:RuleResultItem"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__RuleResultItem *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__RuleResultItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__RuleResultItem(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__RuleResultItem *> *p;
	size_t k = sizeof(std::vector<ns2__RuleResultItem *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns2__RuleResultItem *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns2__RuleResultItem *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__RuleResultItem *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons2__RuleResultItem, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__FXQuote(struct soap *soap, std::vector<ns2__FXQuote *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__FXQuote(struct soap *soap, const std::vector<ns2__FXQuote *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__FXQuote *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__FXQuote(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__FXQuote(struct soap *soap, const char *tag, int id, const std::vector<ns2__FXQuote *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__FXQuote *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__FXQuote(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__FXQuote *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__FXQuote(struct soap *soap, const char *tag, std::vector<ns2__FXQuote *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__FXQuote(soap)))
			return NULL;
		else if (a->size() >= soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__FXQuote *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__FXQuote, SOAP_TYPE_std__vectorTemplateOfPointerTons2__FXQuote, sizeof(ns2__FXQuote), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__FXQuote(soap, tag, NULL, "ns2:FXQuote"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__FXQuote(soap, tag, &n, "ns2:FXQuote"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__FXQuote *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__FXQuote(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__FXQuote(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__FXQuote *> *p;
	size_t k = sizeof(std::vector<ns2__FXQuote *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns2__FXQuote *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns2__FXQuote *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__FXQuote *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons2__FXQuote, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__TaxReplyItem(struct soap *soap, std::vector<ns2__TaxReplyItem *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__TaxReplyItem(struct soap *soap, const std::vector<ns2__TaxReplyItem *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__TaxReplyItem *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__TaxReplyItem(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__TaxReplyItem(struct soap *soap, const char *tag, int id, const std::vector<ns2__TaxReplyItem *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__TaxReplyItem *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__TaxReplyItem(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__TaxReplyItem *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__TaxReplyItem(struct soap *soap, const char *tag, std::vector<ns2__TaxReplyItem *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__TaxReplyItem(soap)))
			return NULL;
		else if (a->size() >= soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__TaxReplyItem *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__TaxReplyItem, SOAP_TYPE_std__vectorTemplateOfPointerTons2__TaxReplyItem, sizeof(ns2__TaxReplyItem), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__TaxReplyItem(soap, tag, NULL, "ns2:TaxReplyItem"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__TaxReplyItem(soap, tag, &n, "ns2:TaxReplyItem"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__TaxReplyItem *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__TaxReplyItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__TaxReplyItem(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__TaxReplyItem *> *p;
	size_t k = sizeof(std::vector<ns2__TaxReplyItem *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns2__TaxReplyItem *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns2__TaxReplyItem *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__TaxReplyItem *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons2__TaxReplyItem, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__PromotionGroup(struct soap *soap, std::vector<ns2__PromotionGroup *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__PromotionGroup(struct soap *soap, const std::vector<ns2__PromotionGroup *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__PromotionGroup *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__PromotionGroup(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__PromotionGroup(struct soap *soap, const char *tag, int id, const std::vector<ns2__PromotionGroup *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__PromotionGroup *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__PromotionGroup(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__PromotionGroup *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__PromotionGroup(struct soap *soap, const char *tag, std::vector<ns2__PromotionGroup *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__PromotionGroup(soap)))
			return NULL;
		else if (a->size() >= soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__PromotionGroup *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__PromotionGroup, SOAP_TYPE_std__vectorTemplateOfPointerTons2__PromotionGroup, sizeof(ns2__PromotionGroup), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__PromotionGroup(soap, tag, NULL, "ns2:PromotionGroup"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__PromotionGroup(soap, tag, &n, "ns2:PromotionGroup"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__PromotionGroup *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__PromotionGroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__PromotionGroup(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__PromotionGroup *> *p;
	size_t k = sizeof(std::vector<ns2__PromotionGroup *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns2__PromotionGroup *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns2__PromotionGroup *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__PromotionGroup *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons2__PromotionGroup, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__RequestReserved(struct soap *soap, std::vector<ns2__RequestReserved *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__RequestReserved(struct soap *soap, const std::vector<ns2__RequestReserved *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__RequestReserved *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__RequestReserved(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__RequestReserved(struct soap *soap, const char *tag, int id, const std::vector<ns2__RequestReserved *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__RequestReserved *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__RequestReserved(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__RequestReserved *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__RequestReserved(struct soap *soap, const char *tag, std::vector<ns2__RequestReserved *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__RequestReserved(soap)))
			return NULL;
		else if (a->size() >= soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__RequestReserved *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__RequestReserved, SOAP_TYPE_std__vectorTemplateOfPointerTons2__RequestReserved, sizeof(ns2__RequestReserved), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__RequestReserved(soap, tag, NULL, "ns2:RequestReserved"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__RequestReserved(soap, tag, &n, "ns2:RequestReserved"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__RequestReserved *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__RequestReserved(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__RequestReserved(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__RequestReserved *> *p;
	size_t k = sizeof(std::vector<ns2__RequestReserved *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns2__RequestReserved *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns2__RequestReserved *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__RequestReserved *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons2__RequestReserved, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__Item(struct soap *soap, std::vector<ns2__Item *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__Item(struct soap *soap, const std::vector<ns2__Item *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__Item *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__Item(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__Item(struct soap *soap, const char *tag, int id, const std::vector<ns2__Item *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__Item *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__Item(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__Item *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__Item(struct soap *soap, const char *tag, std::vector<ns2__Item *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__Item(soap)))
			return NULL;
		else if (a->size() >= soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__Item *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__Item, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Item, sizeof(ns2__Item), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__Item(soap, tag, NULL, "ns2:Item"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__Item(soap, tag, &n, "ns2:Item"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__Item *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__Item(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__Item(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__Item *> *p;
	size_t k = sizeof(std::vector<ns2__Item *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns2__Item *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns2__Item *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__Item *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Item, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap *soap, const std::vector<char *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, int id, const std::vector<char *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<char *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_outliteral(soap, tag, (char*const*)&(*i), NULL))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char *> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, std::vector<char *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap)))
			return NULL;
		else if (a->size() >= soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		char *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__XML, SOAP_TYPE_std__vectorTemplateOf_XML, sizeof(char *), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_inliteral(soap, tag, NULL))
				break;
		}
		else
		{	if (!soap_inliteral(soap, tag, &n))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<char *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_XML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_XML(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<char *> *p;
	size_t k = sizeof(std::vector<char *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<char *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<char *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<char *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOf_XML, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__DecisionManagerTravelLeg(struct soap *soap, std::vector<ns2__DecisionManagerTravelLeg *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__DecisionManagerTravelLeg(struct soap *soap, const std::vector<ns2__DecisionManagerTravelLeg *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns2__DecisionManagerTravelLeg *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__DecisionManagerTravelLeg(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__DecisionManagerTravelLeg(struct soap *soap, const char *tag, int id, const std::vector<ns2__DecisionManagerTravelLeg *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns2__DecisionManagerTravelLeg *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__DecisionManagerTravelLeg(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__DecisionManagerTravelLeg *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__DecisionManagerTravelLeg(struct soap *soap, const char *tag, std::vector<ns2__DecisionManagerTravelLeg *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__DecisionManagerTravelLeg(soap)))
			return NULL;
		else if (a->size() >= soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns2__DecisionManagerTravelLeg *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__DecisionManagerTravelLeg, SOAP_TYPE_std__vectorTemplateOfPointerTons2__DecisionManagerTravelLeg, sizeof(ns2__DecisionManagerTravelLeg), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons2__DecisionManagerTravelLeg(soap, tag, NULL, "ns2:DecisionManagerTravelLeg"))
				break;
		}
		else
		{	if (!soap_in_PointerTons2__DecisionManagerTravelLeg(soap, tag, &n, "ns2:DecisionManagerTravelLeg"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__DecisionManagerTravelLeg *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__DecisionManagerTravelLeg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__DecisionManagerTravelLeg(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns2__DecisionManagerTravelLeg *> *p;
	size_t k = sizeof(std::vector<ns2__DecisionManagerTravelLeg *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns2__DecisionManagerTravelLeg *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns2__DecisionManagerTravelLeg *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns2__DecisionManagerTravelLeg *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons2__DecisionManagerTravelLeg, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfwstring(struct soap *soap, std::vector<wchar_t *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfwstring(struct soap *soap, const std::vector<wchar_t *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wchar_t *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_wstring(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfwstring(struct soap *soap, const char *tag, int id, const std::vector<wchar_t *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wchar_t *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_wstring(soap, tag, -1, (wchar_t*const*)&(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wchar_t *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfwstring(struct soap *soap, const char *tag, std::vector<wchar_t *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfwstring(soap)))
			return NULL;
		else if (a->size() >= soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wchar_t *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_wstring, SOAP_TYPE_std__vectorTemplateOfwstring, sizeof(wchar_t *), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_wstring(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{	if (!soap_in_wstring(soap, tag, &n, "xsd:string"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wchar_t *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfwstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfwstring(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wchar_t *> *p;
	size_t k = sizeof(std::vector<wchar_t *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<wchar_t *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<wchar_t *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wchar_t *>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfwstring, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
