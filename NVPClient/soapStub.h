/* soapStub.h
   Generated by gSOAP 2.8.116 for CyberSourceTransaction_nvp_1.183.h

gSOAP XML Web services tools
Copyright (C) 2000-2021, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#define SOAP_NAMESPACE_OF_wsu	"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
#define SOAP_NAMESPACE_OF_wsse	"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"
#define SOAP_NAMESPACE_OF_ds	"http://www.w3.org/2000/09/xmldsig#"
#define SOAP_NAMESPACE_OF_xenc	"http://www.w3.org/2001/04/xmlenc#"
#define SOAP_NAMESPACE_OF_wsc	"http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512"
#define SOAP_NAMESPACE_OF_saml1	"urn:oasis:names:tc:SAML:1.0:assertion"
#define SOAP_NAMESPACE_OF_saml2	"urn:oasis:names:tc:SAML:2.0:assertion"
#include <vector>
#define SOAP_NAMESPACE_OF_ns2	"urn:schemas-cybersource-com:transaction-data-1.183"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 208116
# error "GSOAP VERSION 208116 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* wsu.h:67 */
#ifndef SOAP_TYPE_wsu__tTimestampFault
#define SOAP_TYPE_wsu__tTimestampFault (7)
/* wsu:tTimestampFault */
enum wsu__tTimestampFault {
	wsu__MessageExpired = 0
};
#endif

/* wsse.h:117 */
#ifndef SOAP_TYPE_wsse__FaultcodeEnum
#define SOAP_TYPE_wsse__FaultcodeEnum (10)
/* wsse:FaultcodeEnum */
enum wsse__FaultcodeEnum {
	wsse__UnsupportedSecurityToken = 0,
	wsse__UnsupportedAlgorithm = 1,
	wsse__InvalidSecurity = 2,
	wsse__InvalidSecurityToken = 3,
	wsse__FailedAuthentication = 4,
	wsse__FailedCheck = 5,
	wsse__SecurityTokenUnavailable = 6
};
#endif

/* wsc.h:63 */
#ifndef SOAP_TYPE_wsc__FaultCodeType
#define SOAP_TYPE_wsc__FaultCodeType (88)
/* wsc:FaultCodeType */
enum wsc__FaultCodeType {
	wsc__BadContextToken = 0,
	wsc__UnsupportedContextToken = 1,
	wsc__UnknownDerivationSource = 2,
	wsc__RenewNeeded = 3,
	wsc__UnableToRenew = 4
};
#endif

/* saml1.h:146 */
#ifndef SOAP_TYPE_saml1__DecisionType
#define SOAP_TYPE_saml1__DecisionType (120)
/* saml1:DecisionType */
enum saml1__DecisionType {
	saml1__DecisionType__Permit = 0,
	saml1__DecisionType__Deny = 1,
	saml1__DecisionType__Indeterminate = 2
};
#endif

/* saml2.h:155 */
#ifndef SOAP_TYPE_saml2__DecisionType
#define SOAP_TYPE_saml2__DecisionType (200)
/* saml2:DecisionType */
enum saml2__DecisionType {
	saml2__DecisionType__Permit = 0,
	saml2__DecisionType__Deny = 1,
	saml2__DecisionType__Indeterminate = 2
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/* custom/struct_timeval.h:77 */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (99)
typedef struct timeval xsd__dateTime;
#endif

/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

struct _wsu__Timestamp;	/* wsu.h:77 */
struct wsse__EncodedString;	/* wsse.h:74 */
struct _wsse__UsernameToken;	/* wsse.h:145 */
struct _wsse__BinarySecurityToken;	/* wsse.h:158 */
struct _wsse__Reference;	/* wsse.h:168 */
struct _wsse__Embedded;	/* wsse.h:176 */
struct _wsse__KeyIdentifier;	/* wsse.h:185 */
struct _wsse__SecurityTokenReference;	/* wsse.h:195 */
struct ds__KeyInfoType;	/* xenc.h:38 */
struct ds__SignatureType;	/* ds.h:50 */
struct _c14n__InclusiveNamespaces;	/* c14n.h:24 */
struct ds__TransformType;	/* ds.h:77 */
struct ds__SignedInfoType;	/* ds.h:50 */
struct ds__CanonicalizationMethodType;	/* ds.h:63 */
struct ds__SignatureMethodType;	/* ds.h:66 */
struct ds__ReferenceType;	/* ds.h:69 */
struct ds__TransformsType;	/* ds.h:72 */
struct ds__DigestMethodType;	/* ds.h:83 */
struct ds__KeyValueType;	/* ds.h:88 */
struct ds__RetrievalMethodType;	/* ds.h:89 */
struct ds__X509DataType;	/* wsse.h:198 */
struct ds__X509IssuerSerialType;	/* ds.h:106 */
struct ds__DSAKeyValueType;	/* ds.h:127 */
struct ds__RSAKeyValueType;	/* ds.h:130 */
struct xenc__EncryptionPropertyType;	/* xenc.h:101 */
struct xenc__EncryptedType;	/* xenc.h:70 */
struct xenc__EncryptionMethodType;	/* xenc.h:73 */
struct xenc__CipherDataType;	/* xenc.h:76 */
struct xenc__CipherReferenceType;	/* xenc.h:79 */
struct xenc__TransformsType;	/* xenc.h:82 */
struct xenc__AgreementMethodType;	/* xenc.h:91 */
struct xenc__ReferenceType;	/* xenc.h:94 */
struct xenc__EncryptionPropertiesType;	/* xenc.h:97 */
struct __xenc__union_ReferenceList;	/* xenc.h:253 */
struct _xenc__ReferenceList;	/* xenc.h:106 */
struct xenc__EncryptedDataType;	/* xenc.h:85 */
struct xenc__EncryptedKeyType;	/* xenc.h:39 */
struct wsc__SecurityContextTokenType;	/* wsc.h:88 */
union _wsc__union_DerivedKeyTokenType;	/* wsc.h:121 */
struct __wsc__DerivedKeyTokenType_sequence;	/* wsc.h:117 */
struct wsc__DerivedKeyTokenType;	/* wsc.h:110 */
struct wsc__PropertiesType;	/* wsc.h:114 */
struct __saml1__union_AssertionType;	/* saml1.h:181 */
struct saml1__AssertionType;	/* saml1.h:75 */
struct __saml1__union_ConditionsType;	/* saml1.h:224 */
struct saml1__ConditionsType;	/* saml1.h:78 */
struct saml1__ConditionAbstractType;	/* saml1.h:81 */
struct __saml1__union_AdviceType;	/* saml1.h:270 */
struct saml1__AdviceType;	/* saml1.h:90 */
struct saml1__StatementAbstractType;	/* saml1.h:93 */
struct saml1__SubjectType;	/* saml1.h:99 */
struct saml1__SubjectConfirmationType;	/* saml1.h:105 */
struct saml1__SubjectLocalityType;	/* saml1.h:111 */
struct saml1__AuthorityBindingType;	/* saml1.h:114 */
struct __saml1__union_EvidenceType;	/* saml1.h:395 */
struct saml1__EvidenceType;	/* saml1.h:123 */
struct saml1__AttributeDesignatorType;	/* saml1.h:129 */
struct saml1__AudienceRestrictionConditionType;	/* saml1.h:84 */
struct saml1__DoNotCacheConditionType;	/* saml1.h:87 */
struct saml1__SubjectStatementAbstractType;	/* saml1.h:96 */
struct saml1__NameIdentifierType;	/* saml1.h:102 */
struct saml1__ActionType;	/* saml1.h:120 */
struct saml1__AttributeType;	/* saml1.h:132 */
struct saml1__AuthenticationStatementType;	/* saml1.h:108 */
struct saml1__AuthorizationDecisionStatementType;	/* saml1.h:117 */
struct saml1__AttributeStatementType;	/* saml1.h:126 */
struct saml2__BaseIDAbstractType;	/* saml2.h:75 */
struct saml2__EncryptedElementType;	/* saml2.h:81 */
struct __saml2__union_AssertionType;	/* saml2.h:234 */
struct saml2__AssertionType;	/* saml2.h:84 */
struct saml2__SubjectType;	/* saml2.h:87 */
struct saml2__SubjectConfirmationType;	/* saml2.h:90 */
struct __saml2__union_ConditionsType;	/* saml2.h:327 */
struct saml2__ConditionsType;	/* saml2.h:99 */
struct saml2__ConditionAbstractType;	/* saml2.h:102 */
struct __saml2__union_AdviceType;	/* saml2.h:376 */
struct saml2__AdviceType;	/* saml2.h:114 */
struct saml2__StatementAbstractType;	/* saml2.h:117 */
struct saml2__SubjectLocalityType;	/* saml2.h:123 */
struct saml2__AuthnContextType;	/* saml2.h:126 */
struct __saml2__union_EvidenceType;	/* saml2.h:479 */
struct saml2__EvidenceType;	/* saml2.h:135 */
struct saml2__AttributeType;	/* saml2.h:141 */
struct saml2__NameIDType;	/* saml2.h:78 */
struct saml2__SubjectConfirmationDataType;	/* saml2.h:93 */
struct saml2__AudienceRestrictionType;	/* saml2.h:105 */
struct saml2__OneTimeUseType;	/* saml2.h:108 */
struct saml2__ProxyRestrictionType;	/* saml2.h:111 */
struct saml2__AuthnStatementType;	/* saml2.h:120 */
struct saml2__AuthzDecisionStatementType;	/* saml2.h:129 */
struct saml2__ActionType;	/* saml2.h:132 */
struct __saml2__union_AttributeStatementType;	/* saml2.h:729 */
struct saml2__AttributeStatementType;	/* saml2.h:138 */
struct saml2__KeyInfoConfirmationDataType;	/* saml2.h:96 */
struct _wsse__Security;	/* wsse.h:212 */
struct _wsse__Password;	/* wsse.h:146 */
class xsd__base64Binary;	/* CyberSourceTransaction_nvp_1.183.h:155 */
class ns2__Item;	/* CyberSourceTransaction_nvp_1.183.h:176 */
class ns2__CCAuthService;	/* CyberSourceTransaction_nvp_1.183.h:178 */
class ns2__OCTService;	/* CyberSourceTransaction_nvp_1.183.h:180 */
class ns2__VerificationService;	/* CyberSourceTransaction_nvp_1.183.h:182 */
class ns2__CCSaleService;	/* CyberSourceTransaction_nvp_1.183.h:184 */
class ns2__CCSaleCreditService;	/* CyberSourceTransaction_nvp_1.183.h:186 */
class ns2__CCSaleReversalService;	/* CyberSourceTransaction_nvp_1.183.h:188 */
class ns2__CCIncrementalAuthService;	/* CyberSourceTransaction_nvp_1.183.h:190 */
class ns2__CCCaptureService;	/* CyberSourceTransaction_nvp_1.183.h:192 */
class ns2__CCCreditService;	/* CyberSourceTransaction_nvp_1.183.h:194 */
class ns2__CCAuthReversalService;	/* CyberSourceTransaction_nvp_1.183.h:196 */
class ns2__CCAutoAuthReversalService;	/* CyberSourceTransaction_nvp_1.183.h:198 */
class ns2__CCDCCService;	/* CyberSourceTransaction_nvp_1.183.h:200 */
class ns2__ServiceFeeCalculateService;	/* CyberSourceTransaction_nvp_1.183.h:202 */
class ns2__ECDebitService;	/* CyberSourceTransaction_nvp_1.183.h:204 */
class ns2__ECCreditService;	/* CyberSourceTransaction_nvp_1.183.h:206 */
class ns2__ECAuthenticateService;	/* CyberSourceTransaction_nvp_1.183.h:208 */
class ns2__PayerAuthEnrollService;	/* CyberSourceTransaction_nvp_1.183.h:210 */
class ns2__PayerAuthValidateService;	/* CyberSourceTransaction_nvp_1.183.h:212 */
class ns2__PayerAuthSetupService;	/* CyberSourceTransaction_nvp_1.183.h:214 */
class ns2__TaxService;	/* CyberSourceTransaction_nvp_1.183.h:216 */
class ns2__DMEService;	/* CyberSourceTransaction_nvp_1.183.h:218 */
class ns2__AFSService;	/* CyberSourceTransaction_nvp_1.183.h:220 */
class ns2__DAVService;	/* CyberSourceTransaction_nvp_1.183.h:222 */
class ns2__ExportService;	/* CyberSourceTransaction_nvp_1.183.h:224 */
class ns2__FXRatesService;	/* CyberSourceTransaction_nvp_1.183.h:226 */
class ns2__BankTransferService;	/* CyberSourceTransaction_nvp_1.183.h:228 */
class ns2__BankTransferRefundService;	/* CyberSourceTransaction_nvp_1.183.h:230 */
class ns2__BankTransferRealTimeService;	/* CyberSourceTransaction_nvp_1.183.h:232 */
class ns2__DirectDebitMandateService;	/* CyberSourceTransaction_nvp_1.183.h:234 */
class ns2__DirectDebitService;	/* CyberSourceTransaction_nvp_1.183.h:236 */
class ns2__DirectDebitRefundService;	/* CyberSourceTransaction_nvp_1.183.h:238 */
class ns2__DirectDebitValidateService;	/* CyberSourceTransaction_nvp_1.183.h:240 */
class ns2__DeviceFingerprintData;	/* CyberSourceTransaction_nvp_1.183.h:242 */
class ns2__PaySubscriptionCreateService;	/* CyberSourceTransaction_nvp_1.183.h:244 */
class ns2__PaySubscriptionUpdateService;	/* CyberSourceTransaction_nvp_1.183.h:246 */
class ns2__PaySubscriptionEventUpdateService;	/* CyberSourceTransaction_nvp_1.183.h:248 */
class ns2__PaySubscriptionRetrieveService;	/* CyberSourceTransaction_nvp_1.183.h:250 */
class ns2__PaySubscriptionDeleteService;	/* CyberSourceTransaction_nvp_1.183.h:252 */
class ns2__PayPalPaymentService;	/* CyberSourceTransaction_nvp_1.183.h:254 */
class ns2__PayPalCreditService;	/* CyberSourceTransaction_nvp_1.183.h:256 */
class ns2__PayPalEcSetService;	/* CyberSourceTransaction_nvp_1.183.h:258 */
class ns2__PayPalEcGetDetailsService;	/* CyberSourceTransaction_nvp_1.183.h:260 */
class ns2__PayPalEcDoPaymentService;	/* CyberSourceTransaction_nvp_1.183.h:262 */
class ns2__PayPalDoCaptureService;	/* CyberSourceTransaction_nvp_1.183.h:264 */
class ns2__PayPalAuthReversalService;	/* CyberSourceTransaction_nvp_1.183.h:266 */
class ns2__PayPalRefundService;	/* CyberSourceTransaction_nvp_1.183.h:268 */
class ns2__PayPalEcOrderSetupService;	/* CyberSourceTransaction_nvp_1.183.h:270 */
class ns2__PayPalAuthorizationService;	/* CyberSourceTransaction_nvp_1.183.h:272 */
class ns2__PayPalUpdateAgreementService;	/* CyberSourceTransaction_nvp_1.183.h:274 */
class ns2__PayPalCreateAgreementService;	/* CyberSourceTransaction_nvp_1.183.h:276 */
class ns2__PayPalDoRefTransactionService;	/* CyberSourceTransaction_nvp_1.183.h:278 */
class ns2__VoidService;	/* CyberSourceTransaction_nvp_1.183.h:280 */
class ns2__PinlessDebitService;	/* CyberSourceTransaction_nvp_1.183.h:282 */
class ns2__PinlessDebitValidateService;	/* CyberSourceTransaction_nvp_1.183.h:284 */
class ns2__PinlessDebitReversalService;	/* CyberSourceTransaction_nvp_1.183.h:286 */
class ns2__PinDebitPurchaseService;	/* CyberSourceTransaction_nvp_1.183.h:288 */
class ns2__PinDebitCreditService;	/* CyberSourceTransaction_nvp_1.183.h:290 */
class ns2__PinDebitReversalService;	/* CyberSourceTransaction_nvp_1.183.h:292 */
class ns2__PayPalButtonCreateService;	/* CyberSourceTransaction_nvp_1.183.h:294 */
class ns2__PayPalPreapprovedPaymentService;	/* CyberSourceTransaction_nvp_1.183.h:296 */
class ns2__PayPalPreapprovedUpdateService;	/* CyberSourceTransaction_nvp_1.183.h:298 */
class ns2__ChinaPaymentService;	/* CyberSourceTransaction_nvp_1.183.h:300 */
class ns2__ChinaRefundService;	/* CyberSourceTransaction_nvp_1.183.h:302 */
class ns2__BoletoPaymentService;	/* CyberSourceTransaction_nvp_1.183.h:304 */
class ns2__PersonalID;	/* CyberSourceTransaction_nvp_1.183.h:306 */
class ns2__Routing;	/* CyberSourceTransaction_nvp_1.183.h:308 */
class ns2__Address;	/* CyberSourceTransaction_nvp_1.183.h:310 */
class ns2__APInitiateService;	/* CyberSourceTransaction_nvp_1.183.h:312 */
class ns2__APCheckStatusService;	/* CyberSourceTransaction_nvp_1.183.h:314 */
class ns2__RiskUpdateService;	/* CyberSourceTransaction_nvp_1.183.h:316 */
class ns2__FraudUpdateService;	/* CyberSourceTransaction_nvp_1.183.h:318 */
class ns2__CaseManagementActionService;	/* CyberSourceTransaction_nvp_1.183.h:320 */
class ns2__EncryptPaymentDataService;	/* CyberSourceTransaction_nvp_1.183.h:322 */
class ns2__InvoiceHeader;	/* CyberSourceTransaction_nvp_1.183.h:324 */
class ns2__BusinessRules;	/* CyberSourceTransaction_nvp_1.183.h:326 */
class ns2__BillTo;	/* CyberSourceTransaction_nvp_1.183.h:328 */
class ns2__ShipTo;	/* CyberSourceTransaction_nvp_1.183.h:330 */
class ns2__ShipFrom;	/* CyberSourceTransaction_nvp_1.183.h:332 */
class ns2__Card;	/* CyberSourceTransaction_nvp_1.183.h:334 */
class ns2__Check;	/* CyberSourceTransaction_nvp_1.183.h:336 */
class ns2__BML;	/* CyberSourceTransaction_nvp_1.183.h:338 */
class ns2__OtherTax;	/* CyberSourceTransaction_nvp_1.183.h:340 */
class ns2__Aft;	/* CyberSourceTransaction_nvp_1.183.h:342 */
class ns2__Wallet;	/* CyberSourceTransaction_nvp_1.183.h:344 */
class ns2__PurchaseTotals;	/* CyberSourceTransaction_nvp_1.183.h:346 */
class ns2__FundingTotals;	/* CyberSourceTransaction_nvp_1.183.h:348 */
class ns2__GECC;	/* CyberSourceTransaction_nvp_1.183.h:350 */
class ns2__UCAF;	/* CyberSourceTransaction_nvp_1.183.h:352 */
class ns2__Network;	/* CyberSourceTransaction_nvp_1.183.h:354 */
class ns2__Brands;	/* CyberSourceTransaction_nvp_1.183.h:356 */
class ns2__FundTransfer;	/* CyberSourceTransaction_nvp_1.183.h:358 */
class ns2__BankInfo;	/* CyberSourceTransaction_nvp_1.183.h:360 */
class ns2__RecurringSubscriptionInfo;	/* CyberSourceTransaction_nvp_1.183.h:362 */
class ns2__PaySubscriptionEvent;	/* CyberSourceTransaction_nvp_1.183.h:364 */
class ns2__Subscription;	/* CyberSourceTransaction_nvp_1.183.h:366 */
class ns2__TokenSource;	/* CyberSourceTransaction_nvp_1.183.h:368 */
class ns2__PaymentNetworkToken;	/* CyberSourceTransaction_nvp_1.183.h:370 */
class ns2__DecisionManager;	/* CyberSourceTransaction_nvp_1.183.h:372 */
class ns2__Authentication;	/* CyberSourceTransaction_nvp_1.183.h:374 */
class ns2__DecisionManagerTravelData;	/* CyberSourceTransaction_nvp_1.183.h:376 */
class ns2__DecisionManagerTravelLeg;	/* CyberSourceTransaction_nvp_1.183.h:378 */
class ns2__Batch;	/* CyberSourceTransaction_nvp_1.183.h:380 */
class ns2__PayPal;	/* CyberSourceTransaction_nvp_1.183.h:382 */
class ns2__JPO;	/* CyberSourceTransaction_nvp_1.183.h:384 */
class ns2__Token;	/* CyberSourceTransaction_nvp_1.183.h:386 */
class ns2__AP;	/* CyberSourceTransaction_nvp_1.183.h:388 */
class ns2__APDevice;	/* CyberSourceTransaction_nvp_1.183.h:390 */
class ns2__APAuthService;	/* CyberSourceTransaction_nvp_1.183.h:392 */
class ns2__APImportMandateService;	/* CyberSourceTransaction_nvp_1.183.h:394 */
class ns2__APAuthReversalService;	/* CyberSourceTransaction_nvp_1.183.h:396 */
class ns2__APCaptureService;	/* CyberSourceTransaction_nvp_1.183.h:398 */
class ns2__APOptionsService;	/* CyberSourceTransaction_nvp_1.183.h:400 */
class ns2__APRefundService;	/* CyberSourceTransaction_nvp_1.183.h:402 */
class ns2__APSaleService;	/* CyberSourceTransaction_nvp_1.183.h:404 */
class ns2__APCheckOutDetailsService;	/* CyberSourceTransaction_nvp_1.183.h:406 */
class ns2__APTransactionDetailsService;	/* CyberSourceTransaction_nvp_1.183.h:408 */
class ns2__APConfirmPurchaseService;	/* CyberSourceTransaction_nvp_1.183.h:410 */
class ns2__APSessionsService;	/* CyberSourceTransaction_nvp_1.183.h:412 */
class ns2__APUI;	/* CyberSourceTransaction_nvp_1.183.h:414 */
class ns2__PayPalGetTxnDetailsService;	/* CyberSourceTransaction_nvp_1.183.h:416 */
class ns2__PayPalTransactionSearchService;	/* CyberSourceTransaction_nvp_1.183.h:418 */
class ns2__Recipient;	/* CyberSourceTransaction_nvp_1.183.h:420 */
class ns2__Sender;	/* CyberSourceTransaction_nvp_1.183.h:422 */
class ns2__CCCheckStatusService;	/* CyberSourceTransaction_nvp_1.183.h:424 */
class ns2__RequestMessage;	/* CyberSourceTransaction_nvp_1.183.h:426 */
class ns2__VC;	/* CyberSourceTransaction_nvp_1.183.h:428 */
class ns2__DecryptVisaCheckoutDataService;	/* CyberSourceTransaction_nvp_1.183.h:430 */
class ns2__DCC;	/* CyberSourceTransaction_nvp_1.183.h:432 */
class ns2__Promotion;	/* CyberSourceTransaction_nvp_1.183.h:434 */
class ns2__PromotionGroup;	/* CyberSourceTransaction_nvp_1.183.h:436 */
class ns2__PromotionGroupReply;	/* CyberSourceTransaction_nvp_1.183.h:438 */
class ns2__BalanceInfo;	/* CyberSourceTransaction_nvp_1.183.h:440 */
class ns2__CCAuthReply;	/* CyberSourceTransaction_nvp_1.183.h:442 */
class ns2__OCTReply;	/* CyberSourceTransaction_nvp_1.183.h:444 */
class ns2__VerificationReply;	/* CyberSourceTransaction_nvp_1.183.h:446 */
class ns2__CCSaleReply;	/* CyberSourceTransaction_nvp_1.183.h:448 */
class ns2__CCSaleCreditReply;	/* CyberSourceTransaction_nvp_1.183.h:450 */
class ns2__CCSaleReversalReply;	/* CyberSourceTransaction_nvp_1.183.h:452 */
class ns2__CCIncrementalAuthReply;	/* CyberSourceTransaction_nvp_1.183.h:454 */
class ns2__CCCaptureReply;	/* CyberSourceTransaction_nvp_1.183.h:456 */
class ns2__ServiceFeeCalculateReply;	/* CyberSourceTransaction_nvp_1.183.h:458 */
class ns2__CCCreditReply;	/* CyberSourceTransaction_nvp_1.183.h:460 */
class ns2__PinDebitPurchaseReply;	/* CyberSourceTransaction_nvp_1.183.h:462 */
class ns2__PinDebitCreditReply;	/* CyberSourceTransaction_nvp_1.183.h:464 */
class ns2__PinDebitReversalReply;	/* CyberSourceTransaction_nvp_1.183.h:466 */
class ns2__CCAuthReversalReply;	/* CyberSourceTransaction_nvp_1.183.h:468 */
class ns2__CCAutoAuthReversalReply;	/* CyberSourceTransaction_nvp_1.183.h:470 */
class ns2__ECAVSReply;	/* CyberSourceTransaction_nvp_1.183.h:472 */
class ns2__ECDebitReply;	/* CyberSourceTransaction_nvp_1.183.h:474 */
class ns2__ECCreditReply;	/* CyberSourceTransaction_nvp_1.183.h:476 */
class ns2__ECAuthenticateReply;	/* CyberSourceTransaction_nvp_1.183.h:478 */
class ns2__PayerAuthSetupReply;	/* CyberSourceTransaction_nvp_1.183.h:480 */
class ns2__PayerAuthEnrollReply;	/* CyberSourceTransaction_nvp_1.183.h:482 */
class ns2__PayerAuthValidateReply;	/* CyberSourceTransaction_nvp_1.183.h:484 */
class ns2__TaxReplyItem;	/* CyberSourceTransaction_nvp_1.183.h:486 */
class ns2__TaxReplyItemJurisdiction;	/* CyberSourceTransaction_nvp_1.183.h:488 */
class ns2__TaxReply;	/* CyberSourceTransaction_nvp_1.183.h:490 */
class ns2__DeviceFingerprint;	/* CyberSourceTransaction_nvp_1.183.h:492 */
class ns2__AFSReply;	/* CyberSourceTransaction_nvp_1.183.h:494 */
class ns2__DAVReply;	/* CyberSourceTransaction_nvp_1.183.h:496 */
class ns2__DeniedPartiesMatch;	/* CyberSourceTransaction_nvp_1.183.h:498 */
class ns2__ExportReply;	/* CyberSourceTransaction_nvp_1.183.h:500 */
class ns2__FXQuote;	/* CyberSourceTransaction_nvp_1.183.h:502 */
class ns2__FXRatesReply;	/* CyberSourceTransaction_nvp_1.183.h:504 */
class ns2__BankTransferReply;	/* CyberSourceTransaction_nvp_1.183.h:506 */
class ns2__BankTransferRealTimeReply;	/* CyberSourceTransaction_nvp_1.183.h:508 */
class ns2__DirectDebitMandateReply;	/* CyberSourceTransaction_nvp_1.183.h:510 */
class ns2__BankTransferRefundReply;	/* CyberSourceTransaction_nvp_1.183.h:512 */
class ns2__DirectDebitReply;	/* CyberSourceTransaction_nvp_1.183.h:514 */
class ns2__DirectDebitValidateReply;	/* CyberSourceTransaction_nvp_1.183.h:516 */
class ns2__DirectDebitRefundReply;	/* CyberSourceTransaction_nvp_1.183.h:518 */
class ns2__PaySubscriptionCreateReply;	/* CyberSourceTransaction_nvp_1.183.h:520 */
class ns2__PaySubscriptionUpdateReply;	/* CyberSourceTransaction_nvp_1.183.h:522 */
class ns2__PaySubscriptionEventUpdateReply;	/* CyberSourceTransaction_nvp_1.183.h:524 */
class ns2__PaySubscriptionRetrieveReply;	/* CyberSourceTransaction_nvp_1.183.h:526 */
class ns2__PaySubscriptionDeleteReply;	/* CyberSourceTransaction_nvp_1.183.h:528 */
class ns2__PayPalPaymentReply;	/* CyberSourceTransaction_nvp_1.183.h:530 */
class ns2__PayPalCreditReply;	/* CyberSourceTransaction_nvp_1.183.h:532 */
class ns2__VoidReply;	/* CyberSourceTransaction_nvp_1.183.h:534 */
class ns2__PinlessDebitReply;	/* CyberSourceTransaction_nvp_1.183.h:536 */
class ns2__PinlessDebitValidateReply;	/* CyberSourceTransaction_nvp_1.183.h:538 */
class ns2__PinlessDebitReversalReply;	/* CyberSourceTransaction_nvp_1.183.h:540 */
class ns2__PayPalButtonCreateReply;	/* CyberSourceTransaction_nvp_1.183.h:542 */
class ns2__PayPalPreapprovedPaymentReply;	/* CyberSourceTransaction_nvp_1.183.h:544 */
class ns2__PayPalPreapprovedUpdateReply;	/* CyberSourceTransaction_nvp_1.183.h:546 */
class ns2__PayPalEcSetReply;	/* CyberSourceTransaction_nvp_1.183.h:548 */
class ns2__PayPalEcGetDetailsReply;	/* CyberSourceTransaction_nvp_1.183.h:550 */
class ns2__PayPalEcDoPaymentReply;	/* CyberSourceTransaction_nvp_1.183.h:552 */
class ns2__PayPalDoCaptureReply;	/* CyberSourceTransaction_nvp_1.183.h:554 */
class ns2__PayPalAuthReversalReply;	/* CyberSourceTransaction_nvp_1.183.h:556 */
class ns2__PayPalRefundReply;	/* CyberSourceTransaction_nvp_1.183.h:558 */
class ns2__PayPalEcOrderSetupReply;	/* CyberSourceTransaction_nvp_1.183.h:560 */
class ns2__PayPalAuthorizationReply;	/* CyberSourceTransaction_nvp_1.183.h:562 */
class ns2__PayPalUpdateAgreementReply;	/* CyberSourceTransaction_nvp_1.183.h:564 */
class ns2__PayPalCreateAgreementReply;	/* CyberSourceTransaction_nvp_1.183.h:566 */
class ns2__PayPalDoRefTransactionReply;	/* CyberSourceTransaction_nvp_1.183.h:568 */
class ns2__RiskUpdateReply;	/* CyberSourceTransaction_nvp_1.183.h:570 */
class ns2__FraudUpdateReply;	/* CyberSourceTransaction_nvp_1.183.h:572 */
class ns2__CaseManagementActionReply;	/* CyberSourceTransaction_nvp_1.183.h:574 */
class ns2__RuleResultItem;	/* CyberSourceTransaction_nvp_1.183.h:576 */
class ns2__RuleResultItems;	/* CyberSourceTransaction_nvp_1.183.h:578 */
class ns2__DecisionReply;	/* CyberSourceTransaction_nvp_1.183.h:580 */
class ns2__ProviderFields;	/* CyberSourceTransaction_nvp_1.183.h:582 */
class ns2__Provider;	/* CyberSourceTransaction_nvp_1.183.h:584 */
class ns2__ProviderField;	/* CyberSourceTransaction_nvp_1.183.h:586 */
class ns2__AdditionalFields;	/* CyberSourceTransaction_nvp_1.183.h:588 */
class ns2__Field;	/* CyberSourceTransaction_nvp_1.183.h:590 */
class ns2__MorphingElement;	/* CyberSourceTransaction_nvp_1.183.h:592 */
class ns2__Element;	/* CyberSourceTransaction_nvp_1.183.h:594 */
class ns2__Travel;	/* CyberSourceTransaction_nvp_1.183.h:596 */
class ns2__DMEReply;	/* CyberSourceTransaction_nvp_1.183.h:598 */
class ns2__ProfileReply;	/* CyberSourceTransaction_nvp_1.183.h:600 */
class ns2__CCDCCReply;	/* CyberSourceTransaction_nvp_1.183.h:602 */
class ns2__paymentCurrencyOffer;	/* CyberSourceTransaction_nvp_1.183.h:604 */
class ns2__CCDCCUpdateReply;	/* CyberSourceTransaction_nvp_1.183.h:606 */
class ns2__ChinaPaymentReply;	/* CyberSourceTransaction_nvp_1.183.h:608 */
class ns2__ChinaRefundReply;	/* CyberSourceTransaction_nvp_1.183.h:610 */
class ns2__BoletoPaymentReply;	/* CyberSourceTransaction_nvp_1.183.h:612 */
class ns2__APInitiateReply;	/* CyberSourceTransaction_nvp_1.183.h:614 */
class ns2__APCheckStatusReply;	/* CyberSourceTransaction_nvp_1.183.h:616 */
class ns2__SellerProtection;	/* CyberSourceTransaction_nvp_1.183.h:618 */
class ns2__APReply;	/* CyberSourceTransaction_nvp_1.183.h:620 */
class ns2__APAuthReply;	/* CyberSourceTransaction_nvp_1.183.h:622 */
class ns2__APAuthReversalReply;	/* CyberSourceTransaction_nvp_1.183.h:624 */
class ns2__APCaptureReply;	/* CyberSourceTransaction_nvp_1.183.h:626 */
class ns2__APOptionsReply;	/* CyberSourceTransaction_nvp_1.183.h:628 */
class ns2__APOptionsOption;	/* CyberSourceTransaction_nvp_1.183.h:630 */
class ns2__APRefundReply;	/* CyberSourceTransaction_nvp_1.183.h:632 */
class ns2__APSaleReply;	/* CyberSourceTransaction_nvp_1.183.h:634 */
class ns2__APCheckOutDetailsReply;	/* CyberSourceTransaction_nvp_1.183.h:636 */
class ns2__APTransactionDetailsReply;	/* CyberSourceTransaction_nvp_1.183.h:638 */
class ns2__APConfirmPurchaseReply;	/* CyberSourceTransaction_nvp_1.183.h:640 */
class ns2__APSessionsReply;	/* CyberSourceTransaction_nvp_1.183.h:642 */
class ns2__CCCheckStatusReply;	/* CyberSourceTransaction_nvp_1.183.h:644 */
class ns2__ReplyMessage;	/* CyberSourceTransaction_nvp_1.183.h:646 */
class ns2__FaultDetails;	/* CyberSourceTransaction_nvp_1.183.h:648 */
class ns2__AirlineData;	/* CyberSourceTransaction_nvp_1.183.h:650 */
class ns2__Leg;	/* CyberSourceTransaction_nvp_1.183.h:652 */
class ns2__AncillaryData;	/* CyberSourceTransaction_nvp_1.183.h:654 */
class ns2__Service;	/* CyberSourceTransaction_nvp_1.183.h:656 */
class ns2__LodgingData;	/* CyberSourceTransaction_nvp_1.183.h:658 */
class ns2__Pos;	/* CyberSourceTransaction_nvp_1.183.h:660 */
class ns2__Pin;	/* CyberSourceTransaction_nvp_1.183.h:662 */
class ns2__EncryptedPayment;	/* CyberSourceTransaction_nvp_1.183.h:664 */
class ns2__Installment;	/* CyberSourceTransaction_nvp_1.183.h:666 */
class ns2__MerchantDefinedData;	/* CyberSourceTransaction_nvp_1.183.h:670 */
class ns2__AuxiliaryData;	/* CyberSourceTransaction_nvp_1.183.h:674 */
class ns2__MerchantSecureData;	/* CyberSourceTransaction_nvp_1.183.h:676 */
class ns2__ReplyReserved;	/* CyberSourceTransaction_nvp_1.183.h:678 */
class ns2__RequestReserved;	/* CyberSourceTransaction_nvp_1.183.h:680 */
class ns2__PayPalGetTxnDetailsReply;	/* CyberSourceTransaction_nvp_1.183.h:682 */
class ns2__PayPalTransactionSearchReply;	/* CyberSourceTransaction_nvp_1.183.h:684 */
class ns2__PaypalTransaction;	/* CyberSourceTransaction_nvp_1.183.h:686 */
class ns2__CCDCCUpdateService;	/* CyberSourceTransaction_nvp_1.183.h:688 */
class ns2__ServiceFee;	/* CyberSourceTransaction_nvp_1.183.h:690 */
class ns2__EmvRequest;	/* CyberSourceTransaction_nvp_1.183.h:692 */
class ns2__EmvReply;	/* CyberSourceTransaction_nvp_1.183.h:694 */
class ns2__OriginalTransaction;	/* CyberSourceTransaction_nvp_1.183.h:696 */
class ns2__HostedDataCreateService;	/* CyberSourceTransaction_nvp_1.183.h:698 */
class ns2__HostedDataRetrieveService;	/* CyberSourceTransaction_nvp_1.183.h:700 */
class ns2__HostedDataCreateReply;	/* CyberSourceTransaction_nvp_1.183.h:702 */
class ns2__HostedDataRetrieveReply;	/* CyberSourceTransaction_nvp_1.183.h:704 */
class ns2__AutoRentalData;	/* CyberSourceTransaction_nvp_1.183.h:706 */
class ns2__AutoRental;	/* CyberSourceTransaction_nvp_1.183.h:708 */
class ns2__AgencyInformation;	/* CyberSourceTransaction_nvp_1.183.h:710 */
class ns2__HealthCare;	/* CyberSourceTransaction_nvp_1.183.h:712 */
class ns2__VCReply;	/* CyberSourceTransaction_nvp_1.183.h:714 */
class ns2__VCCardArt;	/* CyberSourceTransaction_nvp_1.183.h:716 */
class ns2__VCCustomData;	/* CyberSourceTransaction_nvp_1.183.h:718 */
class ns2__DecryptVisaCheckoutDataReply;	/* CyberSourceTransaction_nvp_1.183.h:720 */
class ns2__GetVisaCheckoutDataReply;	/* CyberSourceTransaction_nvp_1.183.h:722 */
class ns2__EncryptPaymentDataReply;	/* CyberSourceTransaction_nvp_1.183.h:724 */
class ns2__BinLookupService;	/* CyberSourceTransaction_nvp_1.183.h:726 */
class ns2__BinLookupReply;	/* CyberSourceTransaction_nvp_1.183.h:728 */
class ns2__issuer;	/* CyberSourceTransaction_nvp_1.183.h:730 */
class ns2__GETVisaCheckoutDataService;	/* CyberSourceTransaction_nvp_1.183.h:732 */
class ns2__TransactionMetadataService;	/* CyberSourceTransaction_nvp_1.183.h:734 */
class ns2__Loan;	/* CyberSourceTransaction_nvp_1.183.h:736 */
class ns2__APOrderService;	/* CyberSourceTransaction_nvp_1.183.h:738 */
class ns2__APOrderReply;	/* CyberSourceTransaction_nvp_1.183.h:740 */
class ns2__APCancelService;	/* CyberSourceTransaction_nvp_1.183.h:742 */
class ns2__APCancelReply;	/* CyberSourceTransaction_nvp_1.183.h:744 */
class ns2__APBillingAgreementService;	/* CyberSourceTransaction_nvp_1.183.h:746 */
class ns2__APBillingAgreementReply;	/* CyberSourceTransaction_nvp_1.183.h:748 */
class ns2__Passenger;	/* CyberSourceTransaction_nvp_1.183.h:750 */
class ns2__PostdatedTransaction;	/* CyberSourceTransaction_nvp_1.183.h:752 */
class ns2__APCreateMandateService;	/* CyberSourceTransaction_nvp_1.183.h:754 */
class ns2__APCreateMandateReply;	/* CyberSourceTransaction_nvp_1.183.h:756 */
class ns2__APMandateStatusService;	/* CyberSourceTransaction_nvp_1.183.h:758 */
class ns2__APMandateStatusReply;	/* CyberSourceTransaction_nvp_1.183.h:760 */
class ns2__APUpdateMandateService;	/* CyberSourceTransaction_nvp_1.183.h:762 */
class ns2__GetMasterpassDataService;	/* CyberSourceTransaction_nvp_1.183.h:764 */
class ns2__GetMasterpassDataReply;	/* CyberSourceTransaction_nvp_1.183.h:766 */
class ns2__APUpdateMandateReply;	/* CyberSourceTransaction_nvp_1.183.h:768 */
class ns2__APImportMandateReply;	/* CyberSourceTransaction_nvp_1.183.h:770 */
class ns2__APRevokeMandateService;	/* CyberSourceTransaction_nvp_1.183.h:772 */
class ns2__APRevokeMandateReply;	/* CyberSourceTransaction_nvp_1.183.h:774 */
class ns2__Category;	/* CyberSourceTransaction_nvp_1.183.h:776 */
class ns2__ECAVSService;	/* CyberSourceTransaction_nvp_1.183.h:778 */
class ns2__GiftCardActivationService;	/* CyberSourceTransaction_nvp_1.183.h:780 */
class ns2__GiftCardBalanceInquiryService;	/* CyberSourceTransaction_nvp_1.183.h:782 */
class ns2__GiftCardVoidService;	/* CyberSourceTransaction_nvp_1.183.h:784 */
class ns2__GiftCardReversalService;	/* CyberSourceTransaction_nvp_1.183.h:786 */
class ns2__GiftCardRedemptionService;	/* CyberSourceTransaction_nvp_1.183.h:788 */
class ns2__GiftCardReloadService;	/* CyberSourceTransaction_nvp_1.183.h:790 */
class ns2__GiftCardRefundService;	/* CyberSourceTransaction_nvp_1.183.h:792 */
class ns2__GiftCard;	/* CyberSourceTransaction_nvp_1.183.h:794 */
class ns2__GiftCardActivationReply;	/* CyberSourceTransaction_nvp_1.183.h:796 */
class ns2__GiftCardBalanceInquiryReply;	/* CyberSourceTransaction_nvp_1.183.h:798 */
class ns2__GiftCardRedemptionReply;	/* CyberSourceTransaction_nvp_1.183.h:800 */
class ns2__GiftCardReversalReply;	/* CyberSourceTransaction_nvp_1.183.h:802 */
class ns2__GiftCardVoidReply;	/* CyberSourceTransaction_nvp_1.183.h:804 */
class ns2__GiftCardReloadReply;	/* CyberSourceTransaction_nvp_1.183.h:806 */
class ns2__GiftCardRefundReply;	/* CyberSourceTransaction_nvp_1.183.h:808 */
class ns2__mPOS;	/* CyberSourceTransaction_nvp_1.183.h:810 */
class ns2__AbortService;	/* CyberSourceTransaction_nvp_1.183.h:812 */
class ns2__AbortReply;	/* CyberSourceTransaction_nvp_1.183.h:814 */
class ns2__merchant;	/* CyberSourceTransaction_nvp_1.183.h:816 */
class ns2__DecisionEarlyReply;	/* CyberSourceTransaction_nvp_1.183.h:818 */
class ns2__ProfileReplyEarly;	/* CyberSourceTransaction_nvp_1.183.h:820 */
class ns2__PauseRuleResultItems;	/* CyberSourceTransaction_nvp_1.183.h:822 */
class ns2__PauseRuleResultItem;	/* CyberSourceTransaction_nvp_1.183.h:824 */
class ns2__payByPoints;	/* CyberSourceTransaction_nvp_1.183.h:826 */
class ns2__MDDField;	/* CyberSourceTransaction_nvp_1.183.h:668 */
class ns2__AuxiliaryField;	/* CyberSourceTransaction_nvp_1.183.h:672 */
struct __ns1__runTransactionResponse;	/* CyberSourceTransaction_nvp_1.183.h:14497 */
struct __ns1__runTransaction;	/* CyberSourceTransaction_nvp_1.183.h:14497 */

/* wsu.h:77 */
#ifndef SOAP_TYPE__wsu__Timestamp
#define SOAP_TYPE__wsu__Timestamp (8)
/* complex XML schema type 'wsu:Timestamp': */
struct SOAP_CMAC _wsu__Timestamp {
      public:
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional element 'wsu:Created' of XML schema type 'xsd:string' */
        char *Created;
        /** Optional element 'wsu:Expires' of XML schema type 'xsd:string' */
        char *Expires;
      public:
        /** Return unique type id SOAP_TYPE__wsu__Timestamp */
        long soap_type() const { return SOAP_TYPE__wsu__Timestamp; }
        /** Constructor with member initializations */
        _wsu__Timestamp() : wsu__Id(), Created(), Expires() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsu__Timestamp * SOAP_FMAC2 soap_instantiate__wsu__Timestamp(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:74 */
#ifndef SOAP_TYPE_wsse__EncodedString
#define SOAP_TYPE_wsse__EncodedString (9)
/* simple XML schema type 'wsse:EncodedString': */
struct SOAP_CMAC wsse__EncodedString {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'EncodingType' of XML schema type 'xsd:string' */
        char *EncodingType;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE_wsse__EncodedString */
        long soap_type() const { return SOAP_TYPE_wsse__EncodedString; }
        /** Constructor with member initializations */
        wsse__EncodedString() : __item(), EncodingType(), wsu__Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsse__EncodedString * SOAP_FMAC2 soap_instantiate_wsse__EncodedString(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:145 */
#ifndef SOAP_TYPE__wsse__UsernameToken
#define SOAP_TYPE__wsse__UsernameToken (11)
/* complex XML schema type 'wsse:UsernameToken': */
struct SOAP_CMAC _wsse__UsernameToken {
      public:
        /** Optional element 'wsse:Username' of XML schema type 'xsd:string' */
        char *Username;
        /** Optional element 'wsse:Password' of XML schema type 'wsse:Password' */
        struct _wsse__Password *Password;
        /** Optional element 'wsse:Nonce' of XML schema type 'wsse:EncodedString' */
        struct wsse__EncodedString *Nonce;
        /** Optional element 'wsse:Salt' of XML schema type 'xsd:string' */
        char *Salt;
        /** Optional element 'wsse:Iteration' of XML schema type 'xsd:unsignedInt' */
        unsigned int *Iteration;
        /** Optional element 'wsu:Created' of XML schema type 'xsd:string' */
        char *wsu__Created;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE__wsse__UsernameToken */
        long soap_type() const { return SOAP_TYPE__wsse__UsernameToken; }
        /** Constructor with member initializations */
        _wsse__UsernameToken() : Username(), Password(), Nonce(), Salt(), Iteration(), wsu__Created(), wsu__Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__UsernameToken * SOAP_FMAC2 soap_instantiate__wsse__UsernameToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:158 */
#ifndef SOAP_TYPE__wsse__BinarySecurityToken
#define SOAP_TYPE__wsse__BinarySecurityToken (17)
/* simple XML schema type 'wsse:BinarySecurityToken': */
struct SOAP_CMAC _wsse__BinarySecurityToken {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XML schema type 'xsd:string' */
        char *ValueType;
        /** Optional attribute 'EncodingType' of XML schema type 'xsd:string' */
        char *EncodingType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__BinarySecurityToken */
        long soap_type() const { return SOAP_TYPE__wsse__BinarySecurityToken; }
        /** Constructor with member initializations */
        _wsse__BinarySecurityToken() : __item(), wsu__Id(), ValueType(), EncodingType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__BinarySecurityToken * SOAP_FMAC2 soap_instantiate__wsse__BinarySecurityToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:168 */
#ifndef SOAP_TYPE__wsse__Reference
#define SOAP_TYPE__wsse__Reference (18)
/* complex XML schema type 'wsse:Reference': */
struct SOAP_CMAC _wsse__Reference {
      public:
        /** Optional attribute 'URI' of XML schema type 'xsd:string' */
        char *URI;
        /** Optional attribute 'ValueType' of XML schema type 'xsd:string' */
        char *ValueType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Reference */
        long soap_type() const { return SOAP_TYPE__wsse__Reference; }
        /** Constructor with member initializations */
        _wsse__Reference() : URI(), ValueType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__Reference * SOAP_FMAC2 soap_instantiate__wsse__Reference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:176 */
#ifndef SOAP_TYPE__wsse__Embedded
#define SOAP_TYPE__wsse__Embedded (19)
/* complex XML schema type 'wsse:Embedded': */
struct SOAP_CMAC _wsse__Embedded {
      public:
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XML schema type 'xsd:string' */
        char *ValueType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Embedded */
        long soap_type() const { return SOAP_TYPE__wsse__Embedded; }
        /** Constructor with member initializations */
        _wsse__Embedded() : wsu__Id(), ValueType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__Embedded * SOAP_FMAC2 soap_instantiate__wsse__Embedded(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:185 */
#ifndef SOAP_TYPE__wsse__KeyIdentifier
#define SOAP_TYPE__wsse__KeyIdentifier (20)
/* simple XML schema type 'wsse:KeyIdentifier': */
struct SOAP_CMAC _wsse__KeyIdentifier {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XML schema type 'xsd:string' */
        char *ValueType;
        /** Optional attribute 'EncodingType' of XML schema type 'xsd:string' */
        char *EncodingType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__KeyIdentifier */
        long soap_type() const { return SOAP_TYPE__wsse__KeyIdentifier; }
        /** Constructor with member initializations */
        _wsse__KeyIdentifier() : __item(), wsu__Id(), ValueType(), EncodingType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__KeyIdentifier * SOAP_FMAC2 soap_instantiate__wsse__KeyIdentifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:195 */
#ifndef SOAP_TYPE__wsse__SecurityTokenReference
#define SOAP_TYPE__wsse__SecurityTokenReference (21)
/* complex XML schema type 'wsse:SecurityTokenReference': */
struct SOAP_CMAC _wsse__SecurityTokenReference {
      public:
        /** Optional element 'wsse:Reference' of XML schema type 'wsse:Reference' */
        struct _wsse__Reference *Reference;
        /** Optional element 'wsse:KeyIdentifier' of XML schema type 'wsse:KeyIdentifier' */
        struct _wsse__KeyIdentifier *KeyIdentifier;
        /** Optional element 'wsse:Embedded' of XML schema type 'wsse:Embedded' */
        struct _wsse__Embedded *Embedded;
        /** Optional element 'ds:X509Data' of XML schema type 'ds:X509DataType' */
        struct ds__X509DataType *ds__X509Data;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'wsc:Instance' of XML schema type 'xsd:string' */
        char *wsc__Instance;
        /** Optional attribute 'Usage' of XML schema type 'xsd:string' */
        char *Usage;
      public:
        /** Return unique type id SOAP_TYPE__wsse__SecurityTokenReference */
        long soap_type() const { return SOAP_TYPE__wsse__SecurityTokenReference; }
        /** Constructor with member initializations */
        _wsse__SecurityTokenReference() : Reference(), KeyIdentifier(), Embedded(), ds__X509Data(), wsu__Id(), wsc__Instance(), Usage() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__SecurityTokenReference * SOAP_FMAC2 soap_instantiate__wsse__SecurityTokenReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:38 */
#ifndef SOAP_TYPE_ds__KeyInfoType
#define SOAP_TYPE_ds__KeyInfoType (27)
/* complex XML schema type 'ds:KeyInfoType': */
struct SOAP_CMAC ds__KeyInfoType {
      public:
        /** Optional element 'xenc:EncryptedKey' of XML schema type 'xenc:EncryptedKeyType' */
        struct xenc__EncryptedKeyType *xenc__EncryptedKey;
        /** Optional element 'ds:KeyName' of XML schema type 'xsd:string' */
        char *KeyName;
        /** Optional element 'ds:KeyValue' of XML schema type 'ds:KeyValueType' */
        struct ds__KeyValueType *KeyValue;
        /** Optional element 'ds:RetrievalMethod' of XML schema type 'ds:RetrievalMethodType' */
        struct ds__RetrievalMethodType *RetrievalMethod;
        /** Optional element 'ds:X509Data' of XML schema type 'ds:X509DataType' */
        struct ds__X509DataType *X509Data;
        /** Optional element 'wsse:SecurityTokenReference' of XML schema type 'wsse:SecurityTokenReference' */
        struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__KeyInfoType */
        long soap_type() const { return SOAP_TYPE_ds__KeyInfoType; }
        /** Constructor with member initializations */
        ds__KeyInfoType() : xenc__EncryptedKey(), KeyName(), KeyValue(), RetrievalMethod(), X509Data(), wsse__SecurityTokenReference(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__KeyInfoType * SOAP_FMAC2 soap_instantiate_ds__KeyInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:50 */
#ifndef SOAP_TYPE_ds__SignatureType
#define SOAP_TYPE_ds__SignatureType (31)
/* complex XML schema type 'ds:SignatureType': */
struct SOAP_CMAC ds__SignatureType {
      public:
        /** Optional element 'ds:SignedInfo' of XML schema type 'ds:SignedInfoType' */
        struct ds__SignedInfoType *SignedInfo;
        /** Optional element 'ds:SignatureValue' of XML schema type 'ds:SignatureValue' */
        char *SignatureValue;
        /** Optional element 'ds:KeyInfo' of XML schema type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *KeyInfo;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignatureType */
        long soap_type() const { return SOAP_TYPE_ds__SignatureType; }
        /** Constructor with member initializations */
        ds__SignatureType() : SignedInfo(), SignatureValue(), KeyInfo(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__SignatureType * SOAP_FMAC2 soap_instantiate_ds__SignatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* c14n.h:24 */
#ifndef SOAP_TYPE__c14n__InclusiveNamespaces
#define SOAP_TYPE__c14n__InclusiveNamespaces (40)
/* complex XML schema type 'c14n:InclusiveNamespaces': */
struct SOAP_CMAC _c14n__InclusiveNamespaces {
      public:
        /** Optional attribute 'PrefixList' of XML schema type 'xsd:string' */
        char *PrefixList;
      public:
        /** Return unique type id SOAP_TYPE__c14n__InclusiveNamespaces */
        long soap_type() const { return SOAP_TYPE__c14n__InclusiveNamespaces; }
        /** Constructor with member initializations */
        _c14n__InclusiveNamespaces() : PrefixList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _c14n__InclusiveNamespaces * SOAP_FMAC2 soap_instantiate__c14n__InclusiveNamespaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:77 */
#ifndef SOAP_TYPE_ds__TransformType
#define SOAP_TYPE_ds__TransformType (41)
/* complex XML schema type 'ds:TransformType': */
struct SOAP_CMAC ds__TransformType {
      public:
        /** Optional element 'c14n:InclusiveNamespaces' of XML schema type 'c14n:InclusiveNamespaces' */
        struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;
        char *__any;
        /** Optional attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__TransformType */
        long soap_type() const { return SOAP_TYPE_ds__TransformType; }
        /** Constructor with member initializations */
        ds__TransformType() : c14n__InclusiveNamespaces(), __any(), Algorithm() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__TransformType * SOAP_FMAC2 soap_instantiate_ds__TransformType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:50 */
#ifndef SOAP_TYPE_ds__SignedInfoType
#define SOAP_TYPE_ds__SignedInfoType (32)
/* complex XML schema type 'ds:SignedInfoType': */
struct SOAP_CMAC ds__SignedInfoType {
      public:
        /** Required element 'ds:CanonicalizationMethod' of XML schema type 'ds:CanonicalizationMethodType' */
        struct ds__CanonicalizationMethodType *CanonicalizationMethod;
        /** Required element 'ds:SignatureMethod' of XML schema type 'ds:SignatureMethodType' */
        struct ds__SignatureMethodType *SignatureMethod;
        /** Sequence of elements 'ds:Reference' of XML schema type 'ds:ReferenceType' stored in dynamic array Reference of length __sizeReference */
        int __sizeReference;
        struct ds__ReferenceType **Reference;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignedInfoType */
        long soap_type() const { return SOAP_TYPE_ds__SignedInfoType; }
        /** Constructor with member initializations */
        ds__SignedInfoType() : CanonicalizationMethod(), SignatureMethod(), __sizeReference(), Reference(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__SignedInfoType * SOAP_FMAC2 soap_instantiate_ds__SignedInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:63 */
#ifndef SOAP_TYPE_ds__CanonicalizationMethodType
#define SOAP_TYPE_ds__CanonicalizationMethodType (36)
/* complex XML schema type 'ds:CanonicalizationMethodType': */
struct SOAP_CMAC ds__CanonicalizationMethodType {
      public:
        /** Required attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
        /** Optional element 'c14n:InclusiveNamespaces' of XML schema type 'c14n:InclusiveNamespaces' */
        struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;
      public:
        /** Return unique type id SOAP_TYPE_ds__CanonicalizationMethodType */
        long soap_type() const { return SOAP_TYPE_ds__CanonicalizationMethodType; }
        /** Constructor with member initializations */
        ds__CanonicalizationMethodType() : Algorithm(), c14n__InclusiveNamespaces() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__CanonicalizationMethodType * SOAP_FMAC2 soap_instantiate_ds__CanonicalizationMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:66 */
#ifndef SOAP_TYPE_ds__SignatureMethodType
#define SOAP_TYPE_ds__SignatureMethodType (37)
/* complex XML schema type 'ds:SignatureMethodType': */
struct SOAP_CMAC ds__SignatureMethodType {
      public:
        /** Optional element 'ds:HMACOutputLength' of XML schema type 'xsd:int' */
        int *HMACOutputLength;
        /** Required attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignatureMethodType */
        long soap_type() const { return SOAP_TYPE_ds__SignatureMethodType; }
        /** Constructor with member initializations */
        ds__SignatureMethodType() : HMACOutputLength(), Algorithm() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__SignatureMethodType * SOAP_FMAC2 soap_instantiate_ds__SignatureMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:69 */
#ifndef SOAP_TYPE_ds__ReferenceType
#define SOAP_TYPE_ds__ReferenceType (38)
/* complex XML schema type 'ds:ReferenceType': */
struct SOAP_CMAC ds__ReferenceType {
      public:
        /** Optional element 'ds:Transforms' of XML schema type 'ds:TransformsType' */
        struct ds__TransformsType *Transforms;
        /** Required element 'ds:DigestMethod' of XML schema type 'ds:DigestMethodType' */
        struct ds__DigestMethodType *DigestMethod;
        /** Required element 'ds:DigestValue' of XML schema type 'xsd:string' */
        char *DigestValue;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
        /** Optional attribute 'URI' of XML schema type 'xsd:string' */
        char *URI;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE_ds__ReferenceType */
        long soap_type() const { return SOAP_TYPE_ds__ReferenceType; }
        /** Constructor with member initializations */
        ds__ReferenceType() : Transforms(), DigestMethod(), DigestValue(), Id(), URI(), Type() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__ReferenceType * SOAP_FMAC2 soap_instantiate_ds__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:72 */
#ifndef SOAP_TYPE_ds__TransformsType
#define SOAP_TYPE_ds__TransformsType (39)
/* complex XML schema type 'ds:TransformsType': */
struct SOAP_CMAC ds__TransformsType {
      public:
        /** Sequence of elements 'ds:Transform' of XML schema type 'ds:TransformType' stored in dynamic array Transform of length __sizeTransform */
        int __sizeTransform;
        struct ds__TransformType *Transform;
      public:
        /** Return unique type id SOAP_TYPE_ds__TransformsType */
        long soap_type() const { return SOAP_TYPE_ds__TransformsType; }
        /** Constructor with member initializations */
        ds__TransformsType() : __sizeTransform(), Transform() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__TransformsType * SOAP_FMAC2 soap_instantiate_ds__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:83 */
#ifndef SOAP_TYPE_ds__DigestMethodType
#define SOAP_TYPE_ds__DigestMethodType (44)
/* complex XML schema type 'ds:DigestMethodType': */
struct SOAP_CMAC ds__DigestMethodType {
      public:
        /** Required attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__DigestMethodType */
        long soap_type() const { return SOAP_TYPE_ds__DigestMethodType; }
        /** Constructor with member initializations */
        ds__DigestMethodType() : Algorithm() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__DigestMethodType * SOAP_FMAC2 soap_instantiate_ds__DigestMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:88 */
#ifndef SOAP_TYPE_ds__KeyValueType
#define SOAP_TYPE_ds__KeyValueType (45)
/* complex XML schema type 'ds:KeyValueType': */
struct SOAP_CMAC ds__KeyValueType {
      public:
        /** Optional element 'ds:DSAKeyValue' of XML schema type 'ds:DSAKeyValueType' */
        struct ds__DSAKeyValueType *DSAKeyValue;
        /** Optional element 'ds:RSAKeyValue' of XML schema type 'ds:RSAKeyValueType' */
        struct ds__RSAKeyValueType *RSAKeyValue;
      public:
        /** Return unique type id SOAP_TYPE_ds__KeyValueType */
        long soap_type() const { return SOAP_TYPE_ds__KeyValueType; }
        /** Constructor with member initializations */
        ds__KeyValueType() : DSAKeyValue(), RSAKeyValue() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__KeyValueType * SOAP_FMAC2 soap_instantiate_ds__KeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:89 */
#ifndef SOAP_TYPE_ds__RetrievalMethodType
#define SOAP_TYPE_ds__RetrievalMethodType (47)
/* complex XML schema type 'ds:RetrievalMethodType': */
struct SOAP_CMAC ds__RetrievalMethodType {
      public:
        /** Optional element 'ds:Transforms' of XML schema type 'ds:TransformsType' */
        struct ds__TransformsType *Transforms;
        /** Optional attribute 'URI' of XML schema type 'xsd:string' */
        char *URI;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE_ds__RetrievalMethodType */
        long soap_type() const { return SOAP_TYPE_ds__RetrievalMethodType; }
        /** Constructor with member initializations */
        ds__RetrievalMethodType() : Transforms(), URI(), Type() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__RetrievalMethodType * SOAP_FMAC2 soap_instantiate_ds__RetrievalMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:198 */
#ifndef SOAP_TYPE_ds__X509DataType
#define SOAP_TYPE_ds__X509DataType (25)
/* complex XML schema type 'ds:X509DataType': */
struct SOAP_CMAC ds__X509DataType {
      public:
        /** Optional element 'ds:X509IssuerSerial' of XML schema type 'ds:X509IssuerSerialType' */
        struct ds__X509IssuerSerialType *X509IssuerSerial;
        /** Optional element 'ds:X509SKI' of XML schema type 'xsd:string' */
        char *X509SKI;
        /** Optional element 'ds:X509SubjectName' of XML schema type 'xsd:string' */
        char *X509SubjectName;
        /** Optional element 'ds:X509Certificate' of XML schema type 'xsd:string' */
        char *X509Certificate;
        /** Optional element 'ds:X509CRL' of XML schema type 'xsd:string' */
        char *X509CRL;
      public:
        /** Return unique type id SOAP_TYPE_ds__X509DataType */
        long soap_type() const { return SOAP_TYPE_ds__X509DataType; }
        /** Constructor with member initializations */
        ds__X509DataType() : X509IssuerSerial(), X509SKI(), X509SubjectName(), X509Certificate(), X509CRL() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__X509DataType * SOAP_FMAC2 soap_instantiate_ds__X509DataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:106 */
#ifndef SOAP_TYPE_ds__X509IssuerSerialType
#define SOAP_TYPE_ds__X509IssuerSerialType (51)
/* complex XML schema type 'ds:X509IssuerSerialType': */
struct SOAP_CMAC ds__X509IssuerSerialType {
      public:
        /** Required element 'ds:X509IssuerName' of XML schema type 'xsd:string' */
        char *X509IssuerName;
        /** Required element 'ds:X509SerialNumber' of XML schema type 'xsd:string' */
        char *X509SerialNumber;
      public:
        /** Return unique type id SOAP_TYPE_ds__X509IssuerSerialType */
        long soap_type() const { return SOAP_TYPE_ds__X509IssuerSerialType; }
        /** Constructor with member initializations */
        ds__X509IssuerSerialType() : X509IssuerName(), X509SerialNumber() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__X509IssuerSerialType * SOAP_FMAC2 soap_instantiate_ds__X509IssuerSerialType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:127 */
#ifndef SOAP_TYPE_ds__DSAKeyValueType
#define SOAP_TYPE_ds__DSAKeyValueType (52)
/* complex XML schema type 'ds:DSAKeyValueType': */
struct SOAP_CMAC ds__DSAKeyValueType {
      public:
        /** Optional element 'ds:G' of XML schema type 'xsd:string' */
        char *G;
        /** Required element 'ds:Y' of XML schema type 'xsd:string' */
        char *Y;
        /** Optional element 'ds:J' of XML schema type 'xsd:string' */
        char *J;
        /** Required element 'ds:P' of XML schema type 'xsd:string' */
        char *P;
        /** Required element 'ds:Q' of XML schema type 'xsd:string' */
        char *Q;
        /** Required element 'ds:Seed' of XML schema type 'xsd:string' */
        char *Seed;
        /** Required element 'ds:PgenCounter' of XML schema type 'xsd:string' */
        char *PgenCounter;
      public:
        /** Return unique type id SOAP_TYPE_ds__DSAKeyValueType */
        long soap_type() const { return SOAP_TYPE_ds__DSAKeyValueType; }
        /** Constructor with member initializations */
        ds__DSAKeyValueType() : G(), Y(), J(), P(), Q(), Seed(), PgenCounter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__DSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__DSAKeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:130 */
#ifndef SOAP_TYPE_ds__RSAKeyValueType
#define SOAP_TYPE_ds__RSAKeyValueType (53)
/* complex XML schema type 'ds:RSAKeyValueType': */
struct SOAP_CMAC ds__RSAKeyValueType {
      public:
        /** Required element 'ds:Modulus' of XML schema type 'xsd:string' */
        char *Modulus;
        /** Required element 'ds:Exponent' of XML schema type 'xsd:string' */
        char *Exponent;
      public:
        /** Return unique type id SOAP_TYPE_ds__RSAKeyValueType */
        long soap_type() const { return SOAP_TYPE_ds__RSAKeyValueType; }
        /** Constructor with member initializations */
        ds__RSAKeyValueType() : Modulus(), Exponent() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__RSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__RSAKeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:101 */
#ifndef SOAP_TYPE_xenc__EncryptionPropertyType
#define SOAP_TYPE_xenc__EncryptionPropertyType (74)
/* complex XML schema type 'xenc:EncryptionPropertyType': */
struct SOAP_CMAC xenc__EncryptionPropertyType {
      public:
        /** Optional attribute 'Target' of XML schema type 'xsd:string' */
        char *Target;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionPropertyType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptionPropertyType; }
        /** Constructor with member initializations */
        xenc__EncryptionPropertyType() : Target(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptionPropertyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:70 */
#ifndef SOAP_TYPE_xenc__EncryptedType
#define SOAP_TYPE_xenc__EncryptedType (65)
/* complex XML schema type 'xenc:EncryptedType': */
struct SOAP_CMAC xenc__EncryptedType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XML schema type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XML schema type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XML schema type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XML schema type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XML schema type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XML schema type 'xsd:string' */
        char *Encoding;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptedType; }
        /** Constructor with member initializations */
        xenc__EncryptedType() : EncryptionMethod(), ds__KeyInfo(), CipherData(), EncryptionProperties(), Id(), Type(), MimeType(), Encoding() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptedType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:73 */
#ifndef SOAP_TYPE_xenc__EncryptionMethodType
#define SOAP_TYPE_xenc__EncryptionMethodType (66)
/* complex XML schema type 'xenc:EncryptionMethodType': */
struct SOAP_CMAC xenc__EncryptionMethodType {
      public:
        /** Optional element 'xenc:KeySize' of XML schema type 'xsd:int' */
        int *KeySize;
        /** Optional element 'xenc:OAEPparams' of XML schema type 'xsd:string' */
        char *OAEPparams;
        /** Required attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
        /** Optional element 'ds:DigestMethod' of XML schema type 'ds:DigestMethodType' */
        struct ds__DigestMethodType *ds__DigestMethod;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionMethodType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptionMethodType; }
        /** Constructor with member initializations */
        xenc__EncryptionMethodType() : KeySize(), OAEPparams(), Algorithm(), ds__DigestMethod(), __mixed() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptionMethodType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:76 */
#ifndef SOAP_TYPE_xenc__CipherDataType
#define SOAP_TYPE_xenc__CipherDataType (67)
/* complex XML schema type 'xenc:CipherDataType': */
struct SOAP_CMAC xenc__CipherDataType {
      public:
        /** Optional element 'xenc:CipherValue' of XML schema type 'xsd:string' */
        char *CipherValue;
        /** Optional element 'xenc:CipherReference' of XML schema type 'xenc:CipherReferenceType' */
        struct xenc__CipherReferenceType *CipherReference;
      public:
        /** Return unique type id SOAP_TYPE_xenc__CipherDataType */
        long soap_type() const { return SOAP_TYPE_xenc__CipherDataType; }
        /** Constructor with member initializations */
        xenc__CipherDataType() : CipherValue(), CipherReference() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__CipherDataType * SOAP_FMAC2 soap_instantiate_xenc__CipherDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:79 */
#ifndef SOAP_TYPE_xenc__CipherReferenceType
#define SOAP_TYPE_xenc__CipherReferenceType (68)
/* complex XML schema type 'xenc:CipherReferenceType': */
struct SOAP_CMAC xenc__CipherReferenceType {
      public:
        /** Optional element 'xenc:Transforms' of XML schema type 'xenc:TransformsType' */
        struct xenc__TransformsType *Transforms;
        /** Required attribute 'URI' of XML schema type 'xsd:string' */
        char *URI;
      public:
        /** Return unique type id SOAP_TYPE_xenc__CipherReferenceType */
        long soap_type() const { return SOAP_TYPE_xenc__CipherReferenceType; }
        /** Constructor with member initializations */
        xenc__CipherReferenceType() : Transforms(), URI() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__CipherReferenceType * SOAP_FMAC2 soap_instantiate_xenc__CipherReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:82 */
#ifndef SOAP_TYPE_xenc__TransformsType
#define SOAP_TYPE_xenc__TransformsType (69)
/* complex XML schema type 'xenc:TransformsType': */
struct SOAP_CMAC xenc__TransformsType {
      public:
        /** Required element 'ds:Transform' of XML schema type 'ds:Transform' */
        struct ds__TransformType ds__Transform;
      public:
        /** Return unique type id SOAP_TYPE_xenc__TransformsType */
        long soap_type() const { return SOAP_TYPE_xenc__TransformsType; }
        /** Constructor with member initializations */
        xenc__TransformsType() : ds__Transform() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__TransformsType * SOAP_FMAC2 soap_instantiate_xenc__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:91 */
#ifndef SOAP_TYPE_xenc__AgreementMethodType
#define SOAP_TYPE_xenc__AgreementMethodType (71)
/* complex XML schema type 'xenc:AgreementMethodType': */
struct SOAP_CMAC xenc__AgreementMethodType {
      public:
        /** Optional element 'xenc:KA-Nonce' of XML schema type 'xsd:string' */
        char *KA_Nonce;
        /** Optional element 'xenc:OriginatorKeyInfo' of XML schema type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *OriginatorKeyInfo;
        /** Optional element 'xenc:RecipientKeyInfo' of XML schema type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *RecipientKeyInfo;
        /** Required attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_xenc__AgreementMethodType */
        long soap_type() const { return SOAP_TYPE_xenc__AgreementMethodType; }
        /** Constructor with member initializations */
        xenc__AgreementMethodType() : KA_Nonce(), OriginatorKeyInfo(), RecipientKeyInfo(), Algorithm(), __mixed() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__AgreementMethodType * SOAP_FMAC2 soap_instantiate_xenc__AgreementMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:94 */
#ifndef SOAP_TYPE_xenc__ReferenceType
#define SOAP_TYPE_xenc__ReferenceType (72)
/* complex XML schema type 'xenc:ReferenceType': */
struct SOAP_CMAC xenc__ReferenceType {
      public:
        /** Required attribute 'URI' of XML schema type 'xsd:string' */
        char *URI;
      public:
        /** Return unique type id SOAP_TYPE_xenc__ReferenceType */
        long soap_type() const { return SOAP_TYPE_xenc__ReferenceType; }
        /** Constructor with member initializations */
        xenc__ReferenceType() : URI() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__ReferenceType * SOAP_FMAC2 soap_instantiate_xenc__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:97 */
#ifndef SOAP_TYPE_xenc__EncryptionPropertiesType
#define SOAP_TYPE_xenc__EncryptionPropertiesType (73)
/* complex XML schema type 'xenc:EncryptionPropertiesType': */
struct SOAP_CMAC xenc__EncryptionPropertiesType {
      public:
        /** Sequence of at least 1 elements 'xenc:EncryptionProperty' of XML schema type 'xenc:EncryptionPropertyType' stored in dynamic array EncryptionProperty of length __sizeEncryptionProperty */
        int __sizeEncryptionProperty;
        struct xenc__EncryptionPropertyType *EncryptionProperty;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionPropertiesType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptionPropertiesType; }
        /** Constructor with member initializations */
        xenc__EncryptionPropertiesType() : __sizeEncryptionProperty(), EncryptionProperty(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptionPropertiesType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:253 */
#ifndef SOAP_TYPE___xenc__union_ReferenceList
#define SOAP_TYPE___xenc__union_ReferenceList (83)
/* Wrapper: */
struct SOAP_CMAC __xenc__union_ReferenceList {
      public:
        /** Optional element 'xenc:DataReference' of XML schema type 'xenc:ReferenceType' */
        struct xenc__ReferenceType *DataReference;
        /** Optional element 'xenc:KeyReference' of XML schema type 'xenc:ReferenceType' */
        struct xenc__ReferenceType *KeyReference;
      public:
        /** Return unique type id SOAP_TYPE___xenc__union_ReferenceList */
        long soap_type() const { return SOAP_TYPE___xenc__union_ReferenceList; }
        /** Constructor with member initializations */
        __xenc__union_ReferenceList() : DataReference(), KeyReference() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __xenc__union_ReferenceList * SOAP_FMAC2 soap_instantiate___xenc__union_ReferenceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:106 */
#ifndef SOAP_TYPE__xenc__ReferenceList
#define SOAP_TYPE__xenc__ReferenceList (75)
/* complex XML schema type 'xenc:ReferenceList': */
struct SOAP_CMAC _xenc__ReferenceList {
      public:
        /** Sequence of at least 1 elements '-union-ReferenceList' of XML schema type '-xenc:union-ReferenceList' stored in dynamic array __union_ReferenceList of length __size_ReferenceList */
        int __size_ReferenceList;
        struct __xenc__union_ReferenceList *__union_ReferenceList;
      public:
        /** Return unique type id SOAP_TYPE__xenc__ReferenceList */
        long soap_type() const { return SOAP_TYPE__xenc__ReferenceList; }
        /** Constructor with member initializations */
        _xenc__ReferenceList() : __size_ReferenceList(), __union_ReferenceList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _xenc__ReferenceList * SOAP_FMAC2 soap_instantiate__xenc__ReferenceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:85 */
#ifndef SOAP_TYPE_xenc__EncryptedDataType
#define SOAP_TYPE_xenc__EncryptedDataType (70)
/* complex XML schema type 'xenc:EncryptedDataType': */
struct SOAP_CMAC xenc__EncryptedDataType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XML schema type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XML schema type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XML schema type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XML schema type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XML schema type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XML schema type 'xsd:string' */
        char *Encoding;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedDataType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptedDataType; }
        /** Constructor with member initializations */
        xenc__EncryptedDataType() : EncryptionMethod(), ds__KeyInfo(), CipherData(), EncryptionProperties(), Id(), Type(), MimeType(), Encoding() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptedDataType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:39 */
#ifndef SOAP_TYPE_xenc__EncryptedKeyType
#define SOAP_TYPE_xenc__EncryptedKeyType (28)
/* Type xenc__EncryptedKeyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'xenc:EncryptedKeyType': */
struct SOAP_CMAC xenc__EncryptedKeyType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XML schema type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XML schema type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XML schema type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XML schema type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XML schema type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XML schema type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XML schema type 'xsd:string' */
        char *Encoding;
        /** Optional element 'xenc:ReferenceList' of XML schema type 'xenc:ReferenceList' */
        struct _xenc__ReferenceList *ReferenceList;
        /** Optional element 'xenc:CarriedKeyName' of XML schema type 'xsd:string' */
        char *CarriedKeyName;
        /** Optional attribute 'Recipient' of XML schema type 'xsd:string' */
        char *Recipient;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedKeyType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptedKeyType; }
        /** Constructor with member initializations */
        xenc__EncryptedKeyType() : EncryptionMethod(), ds__KeyInfo(), CipherData(), EncryptionProperties(), Id(), Type(), MimeType(), Encoding(), ReferenceList(), CarriedKeyName(), Recipient() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptedKeyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedKeyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:88 */
#ifndef SOAP_TYPE_wsc__SecurityContextTokenType
#define SOAP_TYPE_wsc__SecurityContextTokenType (89)
/* complex XML schema type 'wsc:SecurityContextTokenType': */
struct SOAP_CMAC wsc__SecurityContextTokenType {
      public:
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional element 'wsc:Identifier' of XML schema type 'xsd:string' */
        char *Identifier;
        /** Optional element 'wsc:Instance' of XML schema type 'xsd:string' */
        char *Instance;
      public:
        /** Return unique type id SOAP_TYPE_wsc__SecurityContextTokenType */
        long soap_type() const { return SOAP_TYPE_wsc__SecurityContextTokenType; }
        /** Constructor with member initializations */
        wsc__SecurityContextTokenType() : wsu__Id(), Identifier(), Instance() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsc__SecurityContextTokenType * SOAP_FMAC2 soap_instantiate_wsc__SecurityContextTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:121 */
#ifndef SOAP_TYPE__wsc__union_DerivedKeyTokenType
#define SOAP_TYPE__wsc__union_DerivedKeyTokenType (94)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _wsc__union_DerivedKeyTokenType
{
        #define SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation	(1)	/**< union variant selector value for member Generation */
        ULONG64 Generation;
        #define SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset	(2)	/**< union variant selector value for member Offset */
        ULONG64 Offset;
};
#endif

/* wsc.h:117 */
#ifndef SOAP_TYPE___wsc__DerivedKeyTokenType_sequence
#define SOAP_TYPE___wsc__DerivedKeyTokenType_sequence (93)
/* Wrapper: */
struct SOAP_CMAC __wsc__DerivedKeyTokenType_sequence {
      public:
        /** Union with union _wsc__union_DerivedKeyTokenType variant selector __union_DerivedKeyTokenType set to one of: SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset */
        int __union_DerivedKeyTokenType;
        union _wsc__union_DerivedKeyTokenType union_DerivedKeyTokenType;
        /** Optional element 'wsc:Length' of XML schema type 'xsd:unsignedLong' */
        ULONG64 *Length;
      public:
        /** Return unique type id SOAP_TYPE___wsc__DerivedKeyTokenType_sequence */
        long soap_type() const { return SOAP_TYPE___wsc__DerivedKeyTokenType_sequence; }
        /** Constructor with member initializations */
        __wsc__DerivedKeyTokenType_sequence() : __union_DerivedKeyTokenType(), Length() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC2 soap_instantiate___wsc__DerivedKeyTokenType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:110 */
#ifndef SOAP_TYPE_wsc__DerivedKeyTokenType
#define SOAP_TYPE_wsc__DerivedKeyTokenType (90)
/* complex XML schema type 'wsc:DerivedKeyTokenType': */
struct SOAP_CMAC wsc__DerivedKeyTokenType {
      public:
        /** Optional element 'wsse:SecurityTokenReference' of XML schema type 'wsse:SecurityTokenReference' */
        struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;
        /** Optional element 'wsc:Properties' of XML schema type 'wsc:PropertiesType' */
        struct wsc__PropertiesType *Properties;
        struct __wsc__DerivedKeyTokenType_sequence *__DerivedKeyTokenType_sequence;
        /** Optional element 'wsc:Label' of XML schema type 'xsd:string' */
        char *Label;
        /** Optional element 'wsc:Nonce' of XML schema type 'xsd:string' */
        char *Nonce;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'Algorithm' of XML schema type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_wsc__DerivedKeyTokenType */
        long soap_type() const { return SOAP_TYPE_wsc__DerivedKeyTokenType; }
        /** Constructor with member initializations */
        wsc__DerivedKeyTokenType() : wsse__SecurityTokenReference(), Properties(), __DerivedKeyTokenType_sequence(), Label(), Nonce(), wsu__Id(), Algorithm() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsc__DerivedKeyTokenType * SOAP_FMAC2 soap_instantiate_wsc__DerivedKeyTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:114 */
#ifndef SOAP_TYPE_wsc__PropertiesType
#define SOAP_TYPE_wsc__PropertiesType (91)
/* complex XML schema type 'wsc:PropertiesType': */
struct SOAP_CMAC wsc__PropertiesType {
      public:
        /** Return unique type id SOAP_TYPE_wsc__PropertiesType */
        long soap_type() const { return SOAP_TYPE_wsc__PropertiesType; }
        /** Constructor with member initializations */
        wsc__PropertiesType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsc__PropertiesType * SOAP_FMAC2 soap_instantiate_wsc__PropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:181 */
#ifndef SOAP_TYPE___saml1__union_AssertionType
#define SOAP_TYPE___saml1__union_AssertionType (123)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_AssertionType {
      public:
        /** Optional element 'saml1:Statement' of XML schema type 'saml1:StatementAbstractType' */
        struct saml1__StatementAbstractType *saml1__Statement;
        /** Optional element 'saml1:SubjectStatement' of XML schema type 'saml1:SubjectStatementAbstractType' */
        struct saml1__SubjectStatementAbstractType *saml1__SubjectStatement;
        /** Optional element 'saml1:AuthenticationStatement' of XML schema type 'saml1:AuthenticationStatementType' */
        struct saml1__AuthenticationStatementType *saml1__AuthenticationStatement;
        /** Optional element 'saml1:AuthorizationDecisionStatement' of XML schema type 'saml1:AuthorizationDecisionStatementType' */
        struct saml1__AuthorizationDecisionStatementType *saml1__AuthorizationDecisionStatement;
        /** Optional element 'saml1:AttributeStatement' of XML schema type 'saml1:AttributeStatementType' */
        struct saml1__AttributeStatementType *saml1__AttributeStatement;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_AssertionType */
        long soap_type() const { return SOAP_TYPE___saml1__union_AssertionType; }
        /** Constructor with member initializations */
        __saml1__union_AssertionType() : saml1__Statement(), saml1__SubjectStatement(), saml1__AuthenticationStatement(), saml1__AuthorizationDecisionStatement(), saml1__AttributeStatement() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml1__union_AssertionType * SOAP_FMAC2 soap_instantiate___saml1__union_AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:75 */
#ifndef SOAP_TYPE_saml1__AssertionType
#define SOAP_TYPE_saml1__AssertionType (100)
/* Type saml1__AssertionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'saml1:AssertionType': */
struct SOAP_CMAC saml1__AssertionType {
      public:
        /** Optional element 'saml1:Conditions' of XML schema type 'saml1:ConditionsType' */
        struct saml1__ConditionsType *saml1__Conditions;
        /** Optional element 'saml1:Advice' of XML schema type 'saml1:AdviceType' */
        struct saml1__AdviceType *saml1__Advice;
        /** Sequence of elements '-union-AssertionType' of XML schema type '-saml1:union-AssertionType' stored in dynamic array __union_AssertionType of length __size_AssertionType */
        int __size_AssertionType;
        struct __saml1__union_AssertionType *__union_AssertionType;
        /** Optional element 'ds:Signature' of XML schema type 'ds:Signature' */
        struct ds__SignatureType *ds__Signature;
        /** Required attribute 'MajorVersion' of XML schema type 'xsd:string' */
        char *MajorVersion;
        /** Required attribute 'MinorVersion' of XML schema type 'xsd:string' */
        char *MinorVersion;
        /** Required attribute 'AssertionID' of XML schema type 'xsd:string' */
        char *AssertionID;
        /** Required attribute 'Issuer' of XML schema type 'xsd:string' */
        char *Issuer;
        /** Required attribute 'IssueInstant' of XML schema type 'xsd:dateTime' */
        struct timeval IssueInstant;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AssertionType */
        long soap_type() const { return SOAP_TYPE_saml1__AssertionType; }
        /** Constructor with member initializations */
        saml1__AssertionType() : saml1__Conditions(), saml1__Advice(), __size_AssertionType(), __union_AssertionType(), ds__Signature(), MajorVersion(), MinorVersion(), AssertionID(), Issuer(), IssueInstant(), wsu__Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AssertionType * SOAP_FMAC2 soap_instantiate_saml1__AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:224 */
#ifndef SOAP_TYPE___saml1__union_ConditionsType
#define SOAP_TYPE___saml1__union_ConditionsType (131)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_ConditionsType {
      public:
        /** Optional element 'saml1:AudienceRestrictionCondition' of XML schema type 'saml1:AudienceRestrictionConditionType' */
        struct saml1__AudienceRestrictionConditionType *saml1__AudienceRestrictionCondition;
        /** Optional element 'saml1:DoNotCacheCondition' of XML schema type 'saml1:DoNotCacheConditionType' */
        struct saml1__DoNotCacheConditionType *saml1__DoNotCacheCondition;
        /** Optional element 'saml1:Condition' of XML schema type 'saml1:ConditionAbstractType' */
        struct saml1__ConditionAbstractType *saml1__Condition;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_ConditionsType */
        long soap_type() const { return SOAP_TYPE___saml1__union_ConditionsType; }
        /** Constructor with member initializations */
        __saml1__union_ConditionsType() : saml1__AudienceRestrictionCondition(), saml1__DoNotCacheCondition(), saml1__Condition() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml1__union_ConditionsType * SOAP_FMAC2 soap_instantiate___saml1__union_ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:78 */
#ifndef SOAP_TYPE_saml1__ConditionsType
#define SOAP_TYPE_saml1__ConditionsType (101)
/* complex XML schema type 'saml1:ConditionsType': */
struct SOAP_CMAC saml1__ConditionsType {
      public:
        /** Sequence of elements '-union-ConditionsType' of XML schema type '-saml1:union-ConditionsType' stored in dynamic array __union_ConditionsType of length __size_ConditionsType */
        int __size_ConditionsType;
        struct __saml1__union_ConditionsType *__union_ConditionsType;
        /** Optional attribute 'NotBefore' of XML schema type 'xsd:dateTime' */
        struct timeval *NotBefore;
        /** Optional attribute 'NotOnOrAfter' of XML schema type 'xsd:dateTime' */
        struct timeval *NotOnOrAfter;
      public:
        /** Return unique type id SOAP_TYPE_saml1__ConditionsType */
        long soap_type() const { return SOAP_TYPE_saml1__ConditionsType; }
        /** Constructor with member initializations */
        saml1__ConditionsType() : __size_ConditionsType(), __union_ConditionsType(), NotBefore(), NotOnOrAfter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__ConditionsType * SOAP_FMAC2 soap_instantiate_saml1__ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:81 */
#ifndef SOAP_TYPE_saml1__ConditionAbstractType
#define SOAP_TYPE_saml1__ConditionAbstractType (102)
/* complex XML schema type 'saml1:ConditionAbstractType': */
struct SOAP_CMAC saml1__ConditionAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml1__ConditionAbstractType */
        long soap_type() const { return SOAP_TYPE_saml1__ConditionAbstractType; }
        /** Constructor with member initializations */
        saml1__ConditionAbstractType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__ConditionAbstractType * SOAP_FMAC2 soap_instantiate_saml1__ConditionAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:270 */
#ifndef SOAP_TYPE___saml1__union_AdviceType
#define SOAP_TYPE___saml1__union_AdviceType (137)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_AdviceType {
      public:
        /** Optional element 'saml1:AssertionIDReference' of XML schema type 'xsd:string' */
        char *saml1__AssertionIDReference;
        /** Optional element 'saml1:Assertion' of XML schema type 'saml1:AssertionType' */
        struct saml1__AssertionType *saml1__Assertion;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_AdviceType */
        long soap_type() const { return SOAP_TYPE___saml1__union_AdviceType; }
        /** Constructor with member initializations */
        __saml1__union_AdviceType() : saml1__AssertionIDReference(), saml1__Assertion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml1__union_AdviceType * SOAP_FMAC2 soap_instantiate___saml1__union_AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:90 */
#ifndef SOAP_TYPE_saml1__AdviceType
#define SOAP_TYPE_saml1__AdviceType (105)
/* complex XML schema type 'saml1:AdviceType': */
struct SOAP_CMAC saml1__AdviceType {
      public:
        /** Sequence of elements '-union-AdviceType' of XML schema type '-saml1:union-AdviceType' stored in dynamic array __union_AdviceType of length __size_AdviceType */
        int __size_AdviceType;
        struct __saml1__union_AdviceType *__union_AdviceType;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AdviceType */
        long soap_type() const { return SOAP_TYPE_saml1__AdviceType; }
        /** Constructor with member initializations */
        saml1__AdviceType() : __size_AdviceType(), __union_AdviceType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AdviceType * SOAP_FMAC2 soap_instantiate_saml1__AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:93 */
#ifndef SOAP_TYPE_saml1__StatementAbstractType
#define SOAP_TYPE_saml1__StatementAbstractType (106)
/* complex XML schema type 'saml1:StatementAbstractType': */
struct SOAP_CMAC saml1__StatementAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml1__StatementAbstractType */
        long soap_type() const { return SOAP_TYPE_saml1__StatementAbstractType; }
        /** Constructor with member initializations */
        saml1__StatementAbstractType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__StatementAbstractType * SOAP_FMAC2 soap_instantiate_saml1__StatementAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:99 */
#ifndef SOAP_TYPE_saml1__SubjectType
#define SOAP_TYPE_saml1__SubjectType (108)
/* complex XML schema type 'saml1:SubjectType': */
struct SOAP_CMAC saml1__SubjectType {
      public:
        /** Optional element 'saml1:NameIdentifier' of XML schema type 'saml1:NameIdentifierType' */
        struct saml1__NameIdentifierType *saml1__NameIdentifier;
        /** Optional element 'saml1:SubjectConfirmation' of XML schema type 'saml1:SubjectConfirmationType' */
        struct saml1__SubjectConfirmationType *saml1__SubjectConfirmation;
        /** Optional element 'saml1:SubjectConfirmation' of XML schema type 'saml1:SubjectConfirmationType' */
        struct saml1__SubjectConfirmationType *saml1__SubjectConfirmation_;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectType */
        long soap_type() const { return SOAP_TYPE_saml1__SubjectType; }
        /** Constructor with member initializations */
        saml1__SubjectType() : saml1__NameIdentifier(), saml1__SubjectConfirmation(), saml1__SubjectConfirmation_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__SubjectType * SOAP_FMAC2 soap_instantiate_saml1__SubjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:105 */
#ifndef SOAP_TYPE_saml1__SubjectConfirmationType
#define SOAP_TYPE_saml1__SubjectConfirmationType (110)
/* complex XML schema type 'saml1:SubjectConfirmationType': */
struct SOAP_CMAC saml1__SubjectConfirmationType {
      public:
        /** Sequence of at least 1 elements 'saml1:ConfirmationMethod' of XML schema type 'xsd:string' stored in dynamic array saml1__ConfirmationMethod of length __sizeConfirmationMethod */
        int __sizeConfirmationMethod;
        char **saml1__ConfirmationMethod;
        /** Optional element 'saml1:SubjectConfirmationData' of XML schema type 'xsd:anyType' */
        char *saml1__SubjectConfirmationData;
        /** Optional element 'ds:KeyInfo' of XML schema type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectConfirmationType */
        long soap_type() const { return SOAP_TYPE_saml1__SubjectConfirmationType; }
        /** Constructor with member initializations */
        saml1__SubjectConfirmationType() : __sizeConfirmationMethod(), saml1__ConfirmationMethod(), saml1__SubjectConfirmationData(), ds__KeyInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__SubjectConfirmationType * SOAP_FMAC2 soap_instantiate_saml1__SubjectConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:111 */
#ifndef SOAP_TYPE_saml1__SubjectLocalityType
#define SOAP_TYPE_saml1__SubjectLocalityType (112)
/* complex XML schema type 'saml1:SubjectLocalityType': */
struct SOAP_CMAC saml1__SubjectLocalityType {
      public:
        /** Optional attribute 'IPAddress' of XML schema type 'xsd:string' */
        char *IPAddress;
        /** Optional attribute 'DNSAddress' of XML schema type 'xsd:string' */
        char *DNSAddress;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectLocalityType */
        long soap_type() const { return SOAP_TYPE_saml1__SubjectLocalityType; }
        /** Constructor with member initializations */
        saml1__SubjectLocalityType() : IPAddress(), DNSAddress() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__SubjectLocalityType * SOAP_FMAC2 soap_instantiate_saml1__SubjectLocalityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:114 */
#ifndef SOAP_TYPE_saml1__AuthorityBindingType
#define SOAP_TYPE_saml1__AuthorityBindingType (113)
/* complex XML schema type 'saml1:AuthorityBindingType': */
struct SOAP_CMAC saml1__AuthorityBindingType {
      public:
        /** Required attribute 'AuthorityKind' of XML schema type 'xsd:QName' */
        char *AuthorityKind;
        /** Required attribute 'Location' of XML schema type 'xsd:string' */
        char *Location;
        /** Required attribute 'Binding' of XML schema type 'xsd:string' */
        char *Binding;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AuthorityBindingType */
        long soap_type() const { return SOAP_TYPE_saml1__AuthorityBindingType; }
        /** Constructor with member initializations */
        saml1__AuthorityBindingType() : AuthorityKind(), Location(), Binding() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AuthorityBindingType * SOAP_FMAC2 soap_instantiate_saml1__AuthorityBindingType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:395 */
#ifndef SOAP_TYPE___saml1__union_EvidenceType
#define SOAP_TYPE___saml1__union_EvidenceType (143)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_EvidenceType {
      public:
        /** Optional element 'saml1:AssertionIDReference' of XML schema type 'xsd:string' */
        char *saml1__AssertionIDReference;
        /** Optional element 'saml1:Assertion' of XML schema type 'saml1:AssertionType' */
        struct saml1__AssertionType *saml1__Assertion;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_EvidenceType */
        long soap_type() const { return SOAP_TYPE___saml1__union_EvidenceType; }
        /** Constructor with member initializations */
        __saml1__union_EvidenceType() : saml1__AssertionIDReference(), saml1__Assertion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml1__union_EvidenceType * SOAP_FMAC2 soap_instantiate___saml1__union_EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:123 */
#ifndef SOAP_TYPE_saml1__EvidenceType
#define SOAP_TYPE_saml1__EvidenceType (116)
/* complex XML schema type 'saml1:EvidenceType': */
struct SOAP_CMAC saml1__EvidenceType {
      public:
        /** Sequence of elements '-union-EvidenceType' of XML schema type '-saml1:union-EvidenceType' stored in dynamic array __union_EvidenceType of length __size_EvidenceType */
        int __size_EvidenceType;
        struct __saml1__union_EvidenceType *__union_EvidenceType;
      public:
        /** Return unique type id SOAP_TYPE_saml1__EvidenceType */
        long soap_type() const { return SOAP_TYPE_saml1__EvidenceType; }
        /** Constructor with member initializations */
        saml1__EvidenceType() : __size_EvidenceType(), __union_EvidenceType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__EvidenceType * SOAP_FMAC2 soap_instantiate_saml1__EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:129 */
#ifndef SOAP_TYPE_saml1__AttributeDesignatorType
#define SOAP_TYPE_saml1__AttributeDesignatorType (118)
/* complex XML schema type 'saml1:AttributeDesignatorType': */
struct SOAP_CMAC saml1__AttributeDesignatorType {
      public:
        /** Required attribute 'AttributeName' of XML schema type 'xsd:string' */
        char *AttributeName;
        /** Required attribute 'AttributeNamespace' of XML schema type 'xsd:string' */
        char *AttributeNamespace;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AttributeDesignatorType */
        long soap_type() const { return SOAP_TYPE_saml1__AttributeDesignatorType; }
        /** Constructor with member initializations */
        saml1__AttributeDesignatorType() : AttributeName(), AttributeNamespace() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AttributeDesignatorType * SOAP_FMAC2 soap_instantiate_saml1__AttributeDesignatorType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:84 */
#ifndef SOAP_TYPE_saml1__AudienceRestrictionConditionType
#define SOAP_TYPE_saml1__AudienceRestrictionConditionType (103)
/* complex XML schema type 'saml1:AudienceRestrictionConditionType': */
struct SOAP_CMAC saml1__AudienceRestrictionConditionType {
      public:
        /** Sequence of at least 1 elements 'saml1:Audience' of XML schema type 'xsd:string' stored in dynamic array saml1__Audience of length __sizeAudience */
        int __sizeAudience;
        char **saml1__Audience;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AudienceRestrictionConditionType */
        long soap_type() const { return SOAP_TYPE_saml1__AudienceRestrictionConditionType; }
        /** Constructor with member initializations */
        saml1__AudienceRestrictionConditionType() : __sizeAudience(), saml1__Audience() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AudienceRestrictionConditionType * SOAP_FMAC2 soap_instantiate_saml1__AudienceRestrictionConditionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:87 */
#ifndef SOAP_TYPE_saml1__DoNotCacheConditionType
#define SOAP_TYPE_saml1__DoNotCacheConditionType (104)
/* complex XML schema type 'saml1:DoNotCacheConditionType': */
struct SOAP_CMAC saml1__DoNotCacheConditionType {
      public:
        /** Return unique type id SOAP_TYPE_saml1__DoNotCacheConditionType */
        long soap_type() const { return SOAP_TYPE_saml1__DoNotCacheConditionType; }
        /** Constructor with member initializations */
        saml1__DoNotCacheConditionType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__DoNotCacheConditionType * SOAP_FMAC2 soap_instantiate_saml1__DoNotCacheConditionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:96 */
#ifndef SOAP_TYPE_saml1__SubjectStatementAbstractType
#define SOAP_TYPE_saml1__SubjectStatementAbstractType (107)
/* complex XML schema type 'saml1:SubjectStatementAbstractType': */
struct SOAP_CMAC saml1__SubjectStatementAbstractType {
      public:
        /** Required element 'saml1:Subject' of XML schema type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectStatementAbstractType */
        long soap_type() const { return SOAP_TYPE_saml1__SubjectStatementAbstractType; }
        /** Constructor with member initializations */
        saml1__SubjectStatementAbstractType() : saml1__Subject() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__SubjectStatementAbstractType * SOAP_FMAC2 soap_instantiate_saml1__SubjectStatementAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:102 */
#ifndef SOAP_TYPE_saml1__NameIdentifierType
#define SOAP_TYPE_saml1__NameIdentifierType (109)
/* simple XML schema type 'saml1:NameIdentifierType': */
struct SOAP_CMAC saml1__NameIdentifierType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'NameQualifier' of XML schema type 'xsd:string' */
        char *NameQualifier;
        /** Optional attribute 'Format' of XML schema type 'xsd:string' */
        char *Format;
      public:
        /** Return unique type id SOAP_TYPE_saml1__NameIdentifierType */
        long soap_type() const { return SOAP_TYPE_saml1__NameIdentifierType; }
        /** Constructor with member initializations */
        saml1__NameIdentifierType() : __item(), NameQualifier(), Format() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__NameIdentifierType * SOAP_FMAC2 soap_instantiate_saml1__NameIdentifierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:120 */
#ifndef SOAP_TYPE_saml1__ActionType
#define SOAP_TYPE_saml1__ActionType (115)
/* simple XML schema type 'saml1:ActionType': */
struct SOAP_CMAC saml1__ActionType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Namespace' of XML schema type 'xsd:string' */
        char *Namespace;
      public:
        /** Return unique type id SOAP_TYPE_saml1__ActionType */
        long soap_type() const { return SOAP_TYPE_saml1__ActionType; }
        /** Constructor with member initializations */
        saml1__ActionType() : __item(), Namespace() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__ActionType * SOAP_FMAC2 soap_instantiate_saml1__ActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:132 */
#ifndef SOAP_TYPE_saml1__AttributeType
#define SOAP_TYPE_saml1__AttributeType (119)
/* complex XML schema type 'saml1:AttributeType': */
struct SOAP_CMAC saml1__AttributeType {
      public:
        /** Required attribute 'AttributeName' of XML schema type 'xsd:string' */
        char *AttributeName;
        /** Required attribute 'AttributeNamespace' of XML schema type 'xsd:string' */
        char *AttributeNamespace;
        /** Sequence of at least 1 elements 'saml1:AttributeValue' of XML schema type 'xsd:anyType' stored in dynamic array saml1__AttributeValue of length __sizeAttributeValue */
        int __sizeAttributeValue;
        char **saml1__AttributeValue;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AttributeType */
        long soap_type() const { return SOAP_TYPE_saml1__AttributeType; }
        /** Constructor with member initializations */
        saml1__AttributeType() : AttributeName(), AttributeNamespace(), __sizeAttributeValue(), saml1__AttributeValue() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AttributeType * SOAP_FMAC2 soap_instantiate_saml1__AttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:108 */
#ifndef SOAP_TYPE_saml1__AuthenticationStatementType
#define SOAP_TYPE_saml1__AuthenticationStatementType (111)
/* complex XML schema type 'saml1:AuthenticationStatementType': */
struct SOAP_CMAC saml1__AuthenticationStatementType {
      public:
        /** Required element 'saml1:Subject' of XML schema type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
        /** Optional element 'saml1:SubjectLocality' of XML schema type 'saml1:SubjectLocalityType' */
        struct saml1__SubjectLocalityType *saml1__SubjectLocality;
        /** Sequence of elements 'saml1:AuthorityBinding' of XML schema type 'saml1:AuthorityBindingType' stored in dynamic array saml1__AuthorityBinding of length __sizeAuthorityBinding */
        int __sizeAuthorityBinding;
        struct saml1__AuthorityBindingType *saml1__AuthorityBinding;
        /** Required attribute 'AuthenticationMethod' of XML schema type 'xsd:string' */
        char *AuthenticationMethod;
        /** Required attribute 'AuthenticationInstant' of XML schema type 'xsd:dateTime' */
        struct timeval AuthenticationInstant;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AuthenticationStatementType */
        long soap_type() const { return SOAP_TYPE_saml1__AuthenticationStatementType; }
        /** Constructor with member initializations */
        saml1__AuthenticationStatementType() : saml1__Subject(), saml1__SubjectLocality(), __sizeAuthorityBinding(), saml1__AuthorityBinding(), AuthenticationMethod(), AuthenticationInstant() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AuthenticationStatementType * SOAP_FMAC2 soap_instantiate_saml1__AuthenticationStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:117 */
#ifndef SOAP_TYPE_saml1__AuthorizationDecisionStatementType
#define SOAP_TYPE_saml1__AuthorizationDecisionStatementType (114)
/* complex XML schema type 'saml1:AuthorizationDecisionStatementType': */
struct SOAP_CMAC saml1__AuthorizationDecisionStatementType {
      public:
        /** Required element 'saml1:Subject' of XML schema type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
        /** Sequence of at least 1 elements 'saml1:Action' of XML schema type 'saml1:ActionType' stored in dynamic array saml1__Action of length __sizeAction */
        int __sizeAction;
        struct saml1__ActionType *saml1__Action;
        /** Optional element 'saml1:Evidence' of XML schema type 'saml1:EvidenceType' */
        struct saml1__EvidenceType *saml1__Evidence;
        /** Required attribute 'Resource' of XML schema type 'xsd:string' */
        char *Resource;
        /** Required attribute 'Decision' of XML schema type 'saml1:DecisionType' */
        enum saml1__DecisionType Decision;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AuthorizationDecisionStatementType */
        long soap_type() const { return SOAP_TYPE_saml1__AuthorizationDecisionStatementType; }
        /** Constructor with member initializations */
        saml1__AuthorizationDecisionStatementType() : saml1__Subject(), __sizeAction(), saml1__Action(), saml1__Evidence(), Resource(), Decision() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AuthorizationDecisionStatementType * SOAP_FMAC2 soap_instantiate_saml1__AuthorizationDecisionStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:126 */
#ifndef SOAP_TYPE_saml1__AttributeStatementType
#define SOAP_TYPE_saml1__AttributeStatementType (117)
/* complex XML schema type 'saml1:AttributeStatementType': */
struct SOAP_CMAC saml1__AttributeStatementType {
      public:
        /** Required element 'saml1:Subject' of XML schema type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
        /** Sequence of at least 1 elements 'saml1:Attribute' of XML schema type 'saml1:AttributeType' stored in dynamic array saml1__Attribute of length __sizeAttribute */
        int __sizeAttribute;
        struct saml1__AttributeType *saml1__Attribute;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AttributeStatementType */
        long soap_type() const { return SOAP_TYPE_saml1__AttributeStatementType; }
        /** Constructor with member initializations */
        saml1__AttributeStatementType() : saml1__Subject(), __sizeAttribute(), saml1__Attribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AttributeStatementType * SOAP_FMAC2 soap_instantiate_saml1__AttributeStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:75 */
#ifndef SOAP_TYPE_saml2__BaseIDAbstractType
#define SOAP_TYPE_saml2__BaseIDAbstractType (177)
/* complex XML schema type 'saml2:BaseIDAbstractType': */
struct SOAP_CMAC saml2__BaseIDAbstractType {
      public:
        /** Optional attribute 'NameQualifier' of XML schema type 'xsd:string' */
        char *NameQualifier;
        /** Optional attribute 'SPNameQualifier' of XML schema type 'xsd:string' */
        char *SPNameQualifier;
      public:
        /** Return unique type id SOAP_TYPE_saml2__BaseIDAbstractType */
        long soap_type() const { return SOAP_TYPE_saml2__BaseIDAbstractType; }
        /** Constructor with member initializations */
        saml2__BaseIDAbstractType() : NameQualifier(), SPNameQualifier() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__BaseIDAbstractType * SOAP_FMAC2 soap_instantiate_saml2__BaseIDAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:81 */
#ifndef SOAP_TYPE_saml2__EncryptedElementType
#define SOAP_TYPE_saml2__EncryptedElementType (179)
/* complex XML schema type 'saml2:EncryptedElementType': */
struct SOAP_CMAC saml2__EncryptedElementType {
      public:
        /** Required element 'xenc:EncryptedData' of XML schema type 'xenc:EncryptedDataType' */
        struct xenc__EncryptedDataType xenc__EncryptedData;
        /** Sequence of elements 'xenc:EncryptedKey' of XML schema type 'xenc:EncryptedKeyType' stored in dynamic array xenc__EncryptedKey of length __sizexenc__EncryptedKey */
        int __sizexenc__EncryptedKey;
        struct xenc__EncryptedKeyType **xenc__EncryptedKey;
      public:
        /** Return unique type id SOAP_TYPE_saml2__EncryptedElementType */
        long soap_type() const { return SOAP_TYPE_saml2__EncryptedElementType; }
        /** Constructor with member initializations */
        saml2__EncryptedElementType() : xenc__EncryptedData(), __sizexenc__EncryptedKey(), xenc__EncryptedKey() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__EncryptedElementType * SOAP_FMAC2 soap_instantiate_saml2__EncryptedElementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:234 */
#ifndef SOAP_TYPE___saml2__union_AssertionType
#define SOAP_TYPE___saml2__union_AssertionType (206)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_AssertionType {
      public:
        /** Optional element 'saml2:Statement' of XML schema type 'saml2:StatementAbstractType' */
        struct saml2__StatementAbstractType *saml2__Statement;
        /** Optional element 'saml2:AuthnStatement' of XML schema type 'saml2:AuthnStatementType' */
        struct saml2__AuthnStatementType *saml2__AuthnStatement;
        /** Optional element 'saml2:AuthzDecisionStatement' of XML schema type 'saml2:AuthzDecisionStatementType' */
        struct saml2__AuthzDecisionStatementType *saml2__AuthzDecisionStatement;
        /** Optional element 'saml2:AttributeStatement' of XML schema type 'saml2:AttributeStatementType' */
        struct saml2__AttributeStatementType *saml2__AttributeStatement;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_AssertionType */
        long soap_type() const { return SOAP_TYPE___saml2__union_AssertionType; }
        /** Constructor with member initializations */
        __saml2__union_AssertionType() : saml2__Statement(), saml2__AuthnStatement(), saml2__AuthzDecisionStatement(), saml2__AttributeStatement() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_AssertionType * SOAP_FMAC2 soap_instantiate___saml2__union_AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:84 */
#ifndef SOAP_TYPE_saml2__AssertionType
#define SOAP_TYPE_saml2__AssertionType (180)
/* Type saml2__AssertionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'saml2:AssertionType': */
struct SOAP_CMAC saml2__AssertionType {
      public:
        /** Required element 'saml2:Issuer' of XML schema type 'saml2:NameIDType' */
        struct saml2__NameIDType *saml2__Issuer;
        /** Optional element 'ds:Signature' of XML schema type 'ds:Signature' */
        struct ds__SignatureType *ds__Signature;
        /** Optional element 'saml2:Subject' of XML schema type 'saml2:SubjectType' */
        struct saml2__SubjectType *saml2__Subject;
        /** Optional element 'saml2:Conditions' of XML schema type 'saml2:ConditionsType' */
        struct saml2__ConditionsType *saml2__Conditions;
        /** Optional element 'saml2:Advice' of XML schema type 'saml2:AdviceType' */
        struct saml2__AdviceType *saml2__Advice;
        /** Sequence of elements '-union-AssertionType' of XML schema type '-saml2:union-AssertionType' stored in dynamic array __union_AssertionType of length __size_AssertionType */
        int __size_AssertionType;
        struct __saml2__union_AssertionType *__union_AssertionType;
        /** Required attribute 'Version' of XML schema type 'xsd:string' */
        char *Version;
        /** Required attribute 'ID' of XML schema type 'xsd:string' */
        char *ID;
        /** Required attribute 'IssueInstant' of XML schema type 'xsd:dateTime' */
        struct timeval IssueInstant;
        /** Optional attribute 'wsu:Id' of XML schema type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AssertionType */
        long soap_type() const { return SOAP_TYPE_saml2__AssertionType; }
        /** Constructor with member initializations */
        saml2__AssertionType() : saml2__Issuer(), ds__Signature(), saml2__Subject(), saml2__Conditions(), saml2__Advice(), __size_AssertionType(), __union_AssertionType(), Version(), ID(), IssueInstant(), wsu__Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AssertionType * SOAP_FMAC2 soap_instantiate_saml2__AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:87 */
#ifndef SOAP_TYPE_saml2__SubjectType
#define SOAP_TYPE_saml2__SubjectType (181)
/* complex XML schema type 'saml2:SubjectType': */
struct SOAP_CMAC saml2__SubjectType {
      public:
        /** Optional element 'saml2:BaseID' of XML schema type 'saml2:BaseIDAbstractType' */
        struct saml2__BaseIDAbstractType *saml2__BaseID;
        /** Optional element 'saml2:NameID' of XML schema type 'saml2:NameIDType' */
        struct saml2__NameIDType *saml2__NameID;
        /** Optional element 'saml2:EncryptedID' of XML schema type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedID;
        /** Sequence of elements 'saml2:SubjectConfirmation' of XML schema type 'saml2:SubjectConfirmationType' stored in dynamic array saml2__SubjectConfirmation of length __sizeSubjectConfirmation */
        int __sizeSubjectConfirmation;
        struct saml2__SubjectConfirmationType *saml2__SubjectConfirmation;
        /** Sequence of elements 'saml2:SubjectConfirmation' of XML schema type 'saml2:SubjectConfirmationType' stored in dynamic array saml2__SubjectConfirmation_ of length __sizeSubjectConfirmation_ */
        int __sizeSubjectConfirmation_;
        struct saml2__SubjectConfirmationType *saml2__SubjectConfirmation_;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectType */
        long soap_type() const { return SOAP_TYPE_saml2__SubjectType; }
        /** Constructor with member initializations */
        saml2__SubjectType() : saml2__BaseID(), saml2__NameID(), saml2__EncryptedID(), __sizeSubjectConfirmation(), saml2__SubjectConfirmation(), __sizeSubjectConfirmation_(), saml2__SubjectConfirmation_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__SubjectType * SOAP_FMAC2 soap_instantiate_saml2__SubjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:90 */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationType
#define SOAP_TYPE_saml2__SubjectConfirmationType (182)
/* complex XML schema type 'saml2:SubjectConfirmationType': */
struct SOAP_CMAC saml2__SubjectConfirmationType {
      public:
        /** Optional element 'saml2:BaseID' of XML schema type 'saml2:BaseIDAbstractType' */
        struct saml2__BaseIDAbstractType *saml2__BaseID;
        /** Optional element 'saml2:NameID' of XML schema type 'saml2:NameIDType' */
        struct saml2__NameIDType *saml2__NameID;
        /** Optional element 'saml2:EncryptedID' of XML schema type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedID;
        /** Optional element 'saml2:SubjectConfirmationData' of XML schema type 'saml2:SubjectConfirmationDataType' */
        struct saml2__SubjectConfirmationDataType *saml2__SubjectConfirmationData;
        /** Required attribute 'Method' of XML schema type 'xsd:string' */
        char *Method;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectConfirmationType */
        long soap_type() const { return SOAP_TYPE_saml2__SubjectConfirmationType; }
        /** Constructor with member initializations */
        saml2__SubjectConfirmationType() : saml2__BaseID(), saml2__NameID(), saml2__EncryptedID(), saml2__SubjectConfirmationData(), Method() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__SubjectConfirmationType * SOAP_FMAC2 soap_instantiate_saml2__SubjectConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:327 */
#ifndef SOAP_TYPE___saml2__union_ConditionsType
#define SOAP_TYPE___saml2__union_ConditionsType (216)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_ConditionsType {
      public:
        /** Optional element 'saml2:Condition' of XML schema type 'saml2:ConditionAbstractType' */
        struct saml2__ConditionAbstractType *saml2__Condition;
        /** Optional element 'saml2:AudienceRestriction' of XML schema type 'saml2:AudienceRestrictionType' */
        struct saml2__AudienceRestrictionType *saml2__AudienceRestriction;
        /** Optional element 'saml2:OneTimeUse' of XML schema type 'saml2:OneTimeUseType' */
        struct saml2__OneTimeUseType *saml2__OneTimeUse;
        /** Optional element 'saml2:ProxyRestriction' of XML schema type 'saml2:ProxyRestrictionType' */
        struct saml2__ProxyRestrictionType *saml2__ProxyRestriction;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_ConditionsType */
        long soap_type() const { return SOAP_TYPE___saml2__union_ConditionsType; }
        /** Constructor with member initializations */
        __saml2__union_ConditionsType() : saml2__Condition(), saml2__AudienceRestriction(), saml2__OneTimeUse(), saml2__ProxyRestriction() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_ConditionsType * SOAP_FMAC2 soap_instantiate___saml2__union_ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:99 */
#ifndef SOAP_TYPE_saml2__ConditionsType
#define SOAP_TYPE_saml2__ConditionsType (185)
/* complex XML schema type 'saml2:ConditionsType': */
struct SOAP_CMAC saml2__ConditionsType {
      public:
        /** Sequence of elements '-union-ConditionsType' of XML schema type '-saml2:union-ConditionsType' stored in dynamic array __union_ConditionsType of length __size_ConditionsType */
        int __size_ConditionsType;
        struct __saml2__union_ConditionsType *__union_ConditionsType;
        /** Optional attribute 'NotBefore' of XML schema type 'xsd:dateTime' */
        struct timeval *NotBefore;
        /** Optional attribute 'NotOnOrAfter' of XML schema type 'xsd:dateTime' */
        struct timeval *NotOnOrAfter;
      public:
        /** Return unique type id SOAP_TYPE_saml2__ConditionsType */
        long soap_type() const { return SOAP_TYPE_saml2__ConditionsType; }
        /** Constructor with member initializations */
        saml2__ConditionsType() : __size_ConditionsType(), __union_ConditionsType(), NotBefore(), NotOnOrAfter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__ConditionsType * SOAP_FMAC2 soap_instantiate_saml2__ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:102 */
#ifndef SOAP_TYPE_saml2__ConditionAbstractType
#define SOAP_TYPE_saml2__ConditionAbstractType (186)
/* complex XML schema type 'saml2:ConditionAbstractType': */
struct SOAP_CMAC saml2__ConditionAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml2__ConditionAbstractType */
        long soap_type() const { return SOAP_TYPE_saml2__ConditionAbstractType; }
        /** Constructor with member initializations */
        saml2__ConditionAbstractType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__ConditionAbstractType * SOAP_FMAC2 soap_instantiate_saml2__ConditionAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:376 */
#ifndef SOAP_TYPE___saml2__union_AdviceType
#define SOAP_TYPE___saml2__union_AdviceType (222)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_AdviceType {
      public:
        /** Optional element 'saml2:AssertionIDRef' of XML schema type 'xsd:string' */
        char *saml2__AssertionIDRef;
        /** Optional element 'saml2:AssertionURIRef' of XML schema type 'xsd:string' */
        char *saml2__AssertionURIRef;
        /** Optional element 'saml2:Assertion' of XML schema type 'saml2:AssertionType' */
        struct saml2__AssertionType *saml2__Assertion;
        /** Optional element 'saml2:EncryptedAssertion' of XML schema type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedAssertion;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_AdviceType */
        long soap_type() const { return SOAP_TYPE___saml2__union_AdviceType; }
        /** Constructor with member initializations */
        __saml2__union_AdviceType() : saml2__AssertionIDRef(), saml2__AssertionURIRef(), saml2__Assertion(), saml2__EncryptedAssertion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_AdviceType * SOAP_FMAC2 soap_instantiate___saml2__union_AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:114 */
#ifndef SOAP_TYPE_saml2__AdviceType
#define SOAP_TYPE_saml2__AdviceType (190)
/* complex XML schema type 'saml2:AdviceType': */
struct SOAP_CMAC saml2__AdviceType {
      public:
        /** Sequence of elements '-union-AdviceType' of XML schema type '-saml2:union-AdviceType' stored in dynamic array __union_AdviceType of length __size_AdviceType */
        int __size_AdviceType;
        struct __saml2__union_AdviceType *__union_AdviceType;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AdviceType */
        long soap_type() const { return SOAP_TYPE_saml2__AdviceType; }
        /** Constructor with member initializations */
        saml2__AdviceType() : __size_AdviceType(), __union_AdviceType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AdviceType * SOAP_FMAC2 soap_instantiate_saml2__AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:117 */
#ifndef SOAP_TYPE_saml2__StatementAbstractType
#define SOAP_TYPE_saml2__StatementAbstractType (191)
/* complex XML schema type 'saml2:StatementAbstractType': */
struct SOAP_CMAC saml2__StatementAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml2__StatementAbstractType */
        long soap_type() const { return SOAP_TYPE_saml2__StatementAbstractType; }
        /** Constructor with member initializations */
        saml2__StatementAbstractType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__StatementAbstractType * SOAP_FMAC2 soap_instantiate_saml2__StatementAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:123 */
#ifndef SOAP_TYPE_saml2__SubjectLocalityType
#define SOAP_TYPE_saml2__SubjectLocalityType (193)
/* complex XML schema type 'saml2:SubjectLocalityType': */
struct SOAP_CMAC saml2__SubjectLocalityType {
      public:
        /** Optional attribute 'Address' of XML schema type 'xsd:string' */
        char *Address;
        /** Optional attribute 'DNSName' of XML schema type 'xsd:string' */
        char *DNSName;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectLocalityType */
        long soap_type() const { return SOAP_TYPE_saml2__SubjectLocalityType; }
        /** Constructor with member initializations */
        saml2__SubjectLocalityType() : Address(), DNSName() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__SubjectLocalityType * SOAP_FMAC2 soap_instantiate_saml2__SubjectLocalityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:126 */
#ifndef SOAP_TYPE_saml2__AuthnContextType
#define SOAP_TYPE_saml2__AuthnContextType (194)
/* complex XML schema type 'saml2:AuthnContextType': */
struct SOAP_CMAC saml2__AuthnContextType {
      public:
        /** Optional element 'saml2:AuthnContextClassRef' of XML schema type 'xsd:string' */
        char *saml2__AuthnContextClassRef;
        /** Optional element 'saml2:AuthnContextDecl' of XML schema type 'xsd:anyType' */
        char *saml2__AuthnContextDecl;
        /** Optional element 'saml2:AuthnContextDeclRef' of XML schema type 'xsd:string' */
        char *saml2__AuthnContextDeclRef;
        /** Optional element 'saml2:AuthnContextDecl' of XML schema type 'xsd:anyType' */
        char *saml2__AuthnContextDecl_;
        /** Optional element 'saml2:AuthnContextDeclRef' of XML schema type 'xsd:string' */
        char *saml2__AuthnContextDeclRef_;
        /** Sequence of elements 'saml2:AuthenticatingAuthority' of XML schema type 'xsd:string' stored in dynamic array saml2__AuthenticatingAuthority of length __sizeAuthenticatingAuthority */
        int __sizeAuthenticatingAuthority;
        char **saml2__AuthenticatingAuthority;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AuthnContextType */
        long soap_type() const { return SOAP_TYPE_saml2__AuthnContextType; }
        /** Constructor with member initializations */
        saml2__AuthnContextType() : saml2__AuthnContextClassRef(), saml2__AuthnContextDecl(), saml2__AuthnContextDeclRef(), saml2__AuthnContextDecl_(), saml2__AuthnContextDeclRef_(), __sizeAuthenticatingAuthority(), saml2__AuthenticatingAuthority() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AuthnContextType * SOAP_FMAC2 soap_instantiate_saml2__AuthnContextType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:479 */
#ifndef SOAP_TYPE___saml2__union_EvidenceType
#define SOAP_TYPE___saml2__union_EvidenceType (225)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_EvidenceType {
      public:
        /** Optional element 'saml2:AssertionIDRef' of XML schema type 'xsd:string' */
        char *saml2__AssertionIDRef;
        /** Optional element 'saml2:AssertionURIRef' of XML schema type 'xsd:string' */
        char *saml2__AssertionURIRef;
        /** Optional element 'saml2:Assertion' of XML schema type 'saml2:AssertionType' */
        struct saml2__AssertionType *saml2__Assertion;
        /** Optional element 'saml2:EncryptedAssertion' of XML schema type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedAssertion;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_EvidenceType */
        long soap_type() const { return SOAP_TYPE___saml2__union_EvidenceType; }
        /** Constructor with member initializations */
        __saml2__union_EvidenceType() : saml2__AssertionIDRef(), saml2__AssertionURIRef(), saml2__Assertion(), saml2__EncryptedAssertion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_EvidenceType * SOAP_FMAC2 soap_instantiate___saml2__union_EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:135 */
#ifndef SOAP_TYPE_saml2__EvidenceType
#define SOAP_TYPE_saml2__EvidenceType (197)
/* complex XML schema type 'saml2:EvidenceType': */
struct SOAP_CMAC saml2__EvidenceType {
      public:
        /** Sequence of elements '-union-EvidenceType' of XML schema type '-saml2:union-EvidenceType' stored in dynamic array __union_EvidenceType of length __size_EvidenceType */
        int __size_EvidenceType;
        struct __saml2__union_EvidenceType *__union_EvidenceType;
      public:
        /** Return unique type id SOAP_TYPE_saml2__EvidenceType */
        long soap_type() const { return SOAP_TYPE_saml2__EvidenceType; }
        /** Constructor with member initializations */
        saml2__EvidenceType() : __size_EvidenceType(), __union_EvidenceType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__EvidenceType * SOAP_FMAC2 soap_instantiate_saml2__EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:141 */
#ifndef SOAP_TYPE_saml2__AttributeType
#define SOAP_TYPE_saml2__AttributeType (199)
/* complex XML schema type 'saml2:AttributeType': */
struct SOAP_CMAC saml2__AttributeType {
      public:
        /** Sequence of elements 'saml2:AttributeValue' of XML schema type 'xsd:anyType' stored in dynamic array saml2__AttributeValue of length __sizeAttributeValue */
        int __sizeAttributeValue;
        char **saml2__AttributeValue;
        /** Required attribute 'Name' of XML schema type 'xsd:string' */
        char *Name;
        /** Optional attribute 'NameFormat' of XML schema type 'xsd:string' */
        char *NameFormat;
        /** Optional attribute 'FriendlyName' of XML schema type 'xsd:string' */
        char *FriendlyName;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AttributeType */
        long soap_type() const { return SOAP_TYPE_saml2__AttributeType; }
        /** Constructor with member initializations */
        saml2__AttributeType() : __sizeAttributeValue(), saml2__AttributeValue(), Name(), NameFormat(), FriendlyName() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AttributeType * SOAP_FMAC2 soap_instantiate_saml2__AttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:78 */
#ifndef SOAP_TYPE_saml2__NameIDType
#define SOAP_TYPE_saml2__NameIDType (178)
/* simple XML schema type 'saml2:NameIDType': */
struct SOAP_CMAC saml2__NameIDType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Format' of XML schema type 'xsd:string' */
        char *Format;
        /** Optional attribute 'SPProvidedID' of XML schema type 'xsd:string' */
        char *SPProvidedID;
        /** Optional attribute 'NameQualifier' of XML schema type 'xsd:string' */
        char *NameQualifier;
        /** Optional attribute 'SPNameQualifier' of XML schema type 'xsd:string' */
        char *SPNameQualifier;
      public:
        /** Return unique type id SOAP_TYPE_saml2__NameIDType */
        long soap_type() const { return SOAP_TYPE_saml2__NameIDType; }
        /** Constructor with member initializations */
        saml2__NameIDType() : __item(), Format(), SPProvidedID(), NameQualifier(), SPNameQualifier() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__NameIDType * SOAP_FMAC2 soap_instantiate_saml2__NameIDType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:93 */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationDataType
#define SOAP_TYPE_saml2__SubjectConfirmationDataType (183)
/* complex XML schema type 'saml2:SubjectConfirmationDataType': */
struct SOAP_CMAC saml2__SubjectConfirmationDataType {
      public:
        /** Optional attribute 'NotBefore' of XML schema type 'xsd:dateTime' */
        struct timeval *NotBefore;
        /** Optional attribute 'NotOnOrAfter' of XML schema type 'xsd:dateTime' */
        struct timeval *NotOnOrAfter;
        /** Optional attribute 'Recipient' of XML schema type 'xsd:string' */
        char *Recipient;
        /** Optional attribute 'InResponseTo' of XML schema type 'xsd:string' */
        char *InResponseTo;
        /** Optional attribute 'Address' of XML schema type 'xsd:string' */
        char *Address;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectConfirmationDataType */
        long soap_type() const { return SOAP_TYPE_saml2__SubjectConfirmationDataType; }
        /** Constructor with member initializations */
        saml2__SubjectConfirmationDataType() : NotBefore(), NotOnOrAfter(), Recipient(), InResponseTo(), Address(), __mixed() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__SubjectConfirmationDataType * SOAP_FMAC2 soap_instantiate_saml2__SubjectConfirmationDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:105 */
#ifndef SOAP_TYPE_saml2__AudienceRestrictionType
#define SOAP_TYPE_saml2__AudienceRestrictionType (187)
/* complex XML schema type 'saml2:AudienceRestrictionType': */
struct SOAP_CMAC saml2__AudienceRestrictionType {
      public:
        /** Sequence of at least 1 elements 'saml2:Audience' of XML schema type 'xsd:string' stored in dynamic array saml2__Audience of length __sizeAudience */
        int __sizeAudience;
        char **saml2__Audience;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AudienceRestrictionType */
        long soap_type() const { return SOAP_TYPE_saml2__AudienceRestrictionType; }
        /** Constructor with member initializations */
        saml2__AudienceRestrictionType() : __sizeAudience(), saml2__Audience() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AudienceRestrictionType * SOAP_FMAC2 soap_instantiate_saml2__AudienceRestrictionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:108 */
#ifndef SOAP_TYPE_saml2__OneTimeUseType
#define SOAP_TYPE_saml2__OneTimeUseType (188)
/* complex XML schema type 'saml2:OneTimeUseType': */
struct SOAP_CMAC saml2__OneTimeUseType {
      public:
        /** Return unique type id SOAP_TYPE_saml2__OneTimeUseType */
        long soap_type() const { return SOAP_TYPE_saml2__OneTimeUseType; }
        /** Constructor with member initializations */
        saml2__OneTimeUseType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__OneTimeUseType * SOAP_FMAC2 soap_instantiate_saml2__OneTimeUseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:111 */
#ifndef SOAP_TYPE_saml2__ProxyRestrictionType
#define SOAP_TYPE_saml2__ProxyRestrictionType (189)
/* complex XML schema type 'saml2:ProxyRestrictionType': */
struct SOAP_CMAC saml2__ProxyRestrictionType {
      public:
        /** Sequence of elements 'saml2:Audience' of XML schema type 'xsd:string' stored in dynamic array saml2__Audience of length __sizeAudience */
        int __sizeAudience;
        char **saml2__Audience;
        /** Optional attribute 'Count' of XML schema type 'xsd:string' */
        char *Count;
      public:
        /** Return unique type id SOAP_TYPE_saml2__ProxyRestrictionType */
        long soap_type() const { return SOAP_TYPE_saml2__ProxyRestrictionType; }
        /** Constructor with member initializations */
        saml2__ProxyRestrictionType() : __sizeAudience(), saml2__Audience(), Count() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__ProxyRestrictionType * SOAP_FMAC2 soap_instantiate_saml2__ProxyRestrictionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:120 */
#ifndef SOAP_TYPE_saml2__AuthnStatementType
#define SOAP_TYPE_saml2__AuthnStatementType (192)
/* complex XML schema type 'saml2:AuthnStatementType': */
struct SOAP_CMAC saml2__AuthnStatementType {
      public:
        /** Optional element 'saml2:SubjectLocality' of XML schema type 'saml2:SubjectLocalityType' */
        struct saml2__SubjectLocalityType *saml2__SubjectLocality;
        /** Required element 'saml2:AuthnContext' of XML schema type 'saml2:AuthnContextType' */
        struct saml2__AuthnContextType *saml2__AuthnContext;
        /** Required attribute 'AuthnInstant' of XML schema type 'xsd:dateTime' */
        struct timeval AuthnInstant;
        /** Optional attribute 'SessionIndex' of XML schema type 'xsd:string' */
        char *SessionIndex;
        /** Optional attribute 'SessionNotOnOrAfter' of XML schema type 'xsd:dateTime' */
        struct timeval *SessionNotOnOrAfter;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AuthnStatementType */
        long soap_type() const { return SOAP_TYPE_saml2__AuthnStatementType; }
        /** Constructor with member initializations */
        saml2__AuthnStatementType() : saml2__SubjectLocality(), saml2__AuthnContext(), AuthnInstant(), SessionIndex(), SessionNotOnOrAfter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AuthnStatementType * SOAP_FMAC2 soap_instantiate_saml2__AuthnStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:129 */
#ifndef SOAP_TYPE_saml2__AuthzDecisionStatementType
#define SOAP_TYPE_saml2__AuthzDecisionStatementType (195)
/* complex XML schema type 'saml2:AuthzDecisionStatementType': */
struct SOAP_CMAC saml2__AuthzDecisionStatementType {
      public:
        /** Sequence of at least 1 elements 'saml2:Action' of XML schema type 'saml2:ActionType' stored in dynamic array saml2__Action of length __sizeAction */
        int __sizeAction;
        struct saml2__ActionType *saml2__Action;
        /** Optional element 'saml2:Evidence' of XML schema type 'saml2:EvidenceType' */
        struct saml2__EvidenceType *saml2__Evidence;
        /** Required attribute 'Resource' of XML schema type 'xsd:string' */
        char *Resource;
        /** Required attribute 'Decision' of XML schema type 'saml2:DecisionType' */
        enum saml2__DecisionType Decision;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AuthzDecisionStatementType */
        long soap_type() const { return SOAP_TYPE_saml2__AuthzDecisionStatementType; }
        /** Constructor with member initializations */
        saml2__AuthzDecisionStatementType() : __sizeAction(), saml2__Action(), saml2__Evidence(), Resource(), Decision() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AuthzDecisionStatementType * SOAP_FMAC2 soap_instantiate_saml2__AuthzDecisionStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:132 */
#ifndef SOAP_TYPE_saml2__ActionType
#define SOAP_TYPE_saml2__ActionType (196)
/* simple XML schema type 'saml2:ActionType': */
struct SOAP_CMAC saml2__ActionType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Required attribute 'Namespace' of XML schema type 'xsd:string' */
        char *Namespace;
      public:
        /** Return unique type id SOAP_TYPE_saml2__ActionType */
        long soap_type() const { return SOAP_TYPE_saml2__ActionType; }
        /** Constructor with member initializations */
        saml2__ActionType() : __item(), Namespace() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__ActionType * SOAP_FMAC2 soap_instantiate_saml2__ActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:729 */
#ifndef SOAP_TYPE___saml2__union_AttributeStatementType
#define SOAP_TYPE___saml2__union_AttributeStatementType (231)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_AttributeStatementType {
      public:
        /** Optional element 'saml2:Attribute' of XML schema type 'saml2:AttributeType' */
        struct saml2__AttributeType *saml2__Attribute;
        /** Optional element 'saml2:EncryptedAttribute' of XML schema type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedAttribute;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_AttributeStatementType */
        long soap_type() const { return SOAP_TYPE___saml2__union_AttributeStatementType; }
        /** Constructor with member initializations */
        __saml2__union_AttributeStatementType() : saml2__Attribute(), saml2__EncryptedAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_AttributeStatementType * SOAP_FMAC2 soap_instantiate___saml2__union_AttributeStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:138 */
#ifndef SOAP_TYPE_saml2__AttributeStatementType
#define SOAP_TYPE_saml2__AttributeStatementType (198)
/* complex XML schema type 'saml2:AttributeStatementType': */
struct SOAP_CMAC saml2__AttributeStatementType {
      public:
        /** Sequence of elements '-union-AttributeStatementType' of XML schema type '-saml2:union-AttributeStatementType' stored in dynamic array __union_AttributeStatementType of length __size_AttributeStatementType */
        int __size_AttributeStatementType;
        struct __saml2__union_AttributeStatementType *__union_AttributeStatementType;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AttributeStatementType */
        long soap_type() const { return SOAP_TYPE_saml2__AttributeStatementType; }
        /** Constructor with member initializations */
        saml2__AttributeStatementType() : __size_AttributeStatementType(), __union_AttributeStatementType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AttributeStatementType * SOAP_FMAC2 soap_instantiate_saml2__AttributeStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:96 */
#ifndef SOAP_TYPE_saml2__KeyInfoConfirmationDataType
#define SOAP_TYPE_saml2__KeyInfoConfirmationDataType (184)
/* complex XML schema type 'saml2:KeyInfoConfirmationDataType': */
struct SOAP_CMAC saml2__KeyInfoConfirmationDataType {
      public:
        /** Sequence of at least 1 elements 'ds:KeyInfo' of XML schema type 'ds:KeyInfo' stored in dynamic array ds__KeyInfo of length __sizeds__KeyInfo */
        int __sizeds__KeyInfo;
        struct ds__KeyInfoType **ds__KeyInfo;
      public:
        /** Return unique type id SOAP_TYPE_saml2__KeyInfoConfirmationDataType */
        long soap_type() const { return SOAP_TYPE_saml2__KeyInfoConfirmationDataType; }
        /** Constructor with member initializations */
        saml2__KeyInfoConfirmationDataType() : __sizeds__KeyInfo(), ds__KeyInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__KeyInfoConfirmationDataType * SOAP_FMAC2 soap_instantiate_saml2__KeyInfoConfirmationDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:212 */
#ifndef SOAP_TYPE__wsse__Security
#define SOAP_TYPE__wsse__Security (268)
/* complex XML schema type 'wsse:Security': */
struct SOAP_CMAC _wsse__Security {
      public:
        /** Optional element 'wsu:Timestamp' of XML schema type 'wsu:Timestamp' */
        struct _wsu__Timestamp *wsu__Timestamp;
        /** Optional element 'wsse:UsernameToken' of XML schema type 'wsse:UsernameToken' */
        struct _wsse__UsernameToken *UsernameToken;
        /** Optional element 'wsse:BinarySecurityToken' of XML schema type 'wsse:BinarySecurityToken' */
        struct _wsse__BinarySecurityToken *BinarySecurityToken;
        /** Optional element 'xenc:EncryptedKey' of XML schema type 'xenc:EncryptedKeyType' */
        struct xenc__EncryptedKeyType *xenc__EncryptedKey;
        /** Optional element 'xenc:ReferenceList' of XML schema type 'xenc:ReferenceList' */
        struct _xenc__ReferenceList *xenc__ReferenceList;
        /** Optional element 'wsc:SecurityContextToken' of XML schema type 'wsc:SecurityContextTokenType' */
        struct wsc__SecurityContextTokenType *wsc__SecurityContextToken;
        /** Optional element 'ds:Signature' of XML schema type 'ds:SignatureType' */
        struct ds__SignatureType *ds__Signature;
        /** Optional element 'saml1:Assertion' of XML schema type 'saml1:AssertionType' */
        struct saml1__AssertionType *saml1__Assertion;
        /** Optional element 'saml2:Assertion' of XML schema type 'saml2:AssertionType' */
        struct saml2__AssertionType *saml2__Assertion;
        /** Optional attribute 'SOAP-ENV:actor' of XML schema type 'xsd:string' */
        char *SOAP_ENV__actor;
        /** Optional attribute 'SOAP-ENV:role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__role;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Security */
        long soap_type() const { return SOAP_TYPE__wsse__Security; }
        /** Constructor with member initializations */
        _wsse__Security() : wsu__Timestamp(), UsernameToken(), BinarySecurityToken(), xenc__EncryptedKey(), xenc__ReferenceList(), wsc__SecurityContextToken(), ds__Signature(), saml1__Assertion(), saml2__Assertion(), SOAP_ENV__actor(), SOAP_ENV__role() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__Security * SOAP_FMAC2 soap_instantiate__wsse__Security(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:146 */
#ifndef SOAP_TYPE__wsse__Password
#define SOAP_TYPE__wsse__Password (12)
/* simple XML schema type 'wsse:Password': */
struct SOAP_CMAC _wsse__Password {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Type' of XML schema type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Password */
        long soap_type() const { return SOAP_TYPE__wsse__Password; }
        /** Constructor with member initializations */
        _wsse__Password() : __item(), Type() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__Password * SOAP_FMAC2 soap_instantiate__wsse__Password(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:244 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (274)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** MustUnderstand */
        struct _wsse__Security *wsse__Security;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() : wsse__Security() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* CyberSourceTransaction_nvp_1.183.h:155 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (277)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XML schema type 'xsd:string'
        char *id;
        /// Optional element 'type' of XML schema type 'xsd:string'
        char *type;
        /// Optional element 'options' of XML schema type 'xsd:string'
        char *options;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary); }
      public:
        /// Constructor with default initializations
        xsd__base64Binary() : __ptr(), __size(), id(), type(), options() { }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:176 */
#ifndef SOAP_TYPE_ns2__Item
#define SOAP_TYPE_ns2__Item (283)
/* complex XML schema type 'ns2:Item': */
class SOAP_CMAC ns2__Item {
      public:
        /// Optional element 'ns2:unitPrice' of XML schema type 'ns2:amount'
        std::string *unitPrice;
        /// Optional element 'ns2:quantity' of XML schema type 'ns2:amount'
        std::string *quantity;
        /// Optional element 'ns2:productCode' of XML schema type 'xsd:string'
        std::string *productCode;
        /// Optional element 'ns2:productName' of XML schema type 'xsd:string'
        std::string *productName;
        /// Optional element 'ns2:productSKU' of XML schema type 'xsd:string'
        std::string *productSKU;
        /// Optional element 'ns2:productRisk' of XML schema type 'xsd:string'
        std::string *productRisk;
        /// Optional element 'ns2:taxAmount' of XML schema type 'ns2:amount'
        std::string *taxAmount;
        /// Optional element 'ns2:cityOverrideAmount' of XML schema type 'ns2:amount'
        std::string *cityOverrideAmount;
        /// Optional element 'ns2:cityOverrideRate' of XML schema type 'ns2:amount'
        std::string *cityOverrideRate;
        /// Optional element 'ns2:countyOverrideAmount' of XML schema type 'ns2:amount'
        std::string *countyOverrideAmount;
        /// Optional element 'ns2:countyOverrideRate' of XML schema type 'ns2:amount'
        std::string *countyOverrideRate;
        /// Optional element 'ns2:districtOverrideAmount' of XML schema type 'ns2:amount'
        std::string *districtOverrideAmount;
        /// Optional element 'ns2:districtOverrideRate' of XML schema type 'ns2:amount'
        std::string *districtOverrideRate;
        /// Optional element 'ns2:stateOverrideAmount' of XML schema type 'ns2:amount'
        std::string *stateOverrideAmount;
        /// Optional element 'ns2:stateOverrideRate' of XML schema type 'ns2:amount'
        std::string *stateOverrideRate;
        /// Optional element 'ns2:countryOverrideAmount' of XML schema type 'ns2:amount'
        std::string *countryOverrideAmount;
        /// Optional element 'ns2:countryOverrideRate' of XML schema type 'ns2:amount'
        std::string *countryOverrideRate;
        /// Optional element 'ns2:orderAcceptanceCity' of XML schema type 'xsd:string'
        std::string *orderAcceptanceCity;
        /// Optional element 'ns2:orderAcceptanceCounty' of XML schema type 'xsd:string'
        std::string *orderAcceptanceCounty;
        /// Optional element 'ns2:orderAcceptanceCountry' of XML schema type 'xsd:string'
        std::string *orderAcceptanceCountry;
        /// Optional element 'ns2:orderAcceptanceState' of XML schema type 'xsd:string'
        std::string *orderAcceptanceState;
        /// Optional element 'ns2:orderAcceptancePostalCode' of XML schema type 'xsd:string'
        std::string *orderAcceptancePostalCode;
        /// Optional element 'ns2:orderOriginCity' of XML schema type 'xsd:string'
        std::string *orderOriginCity;
        /// Optional element 'ns2:orderOriginCounty' of XML schema type 'xsd:string'
        std::string *orderOriginCounty;
        /// Optional element 'ns2:orderOriginCountry' of XML schema type 'xsd:string'
        std::string *orderOriginCountry;
        /// Optional element 'ns2:orderOriginState' of XML schema type 'xsd:string'
        std::string *orderOriginState;
        /// Optional element 'ns2:orderOriginPostalCode' of XML schema type 'xsd:string'
        std::string *orderOriginPostalCode;
        /// Optional element 'ns2:shipFromCity' of XML schema type 'xsd:string'
        std::string *shipFromCity;
        /// Optional element 'ns2:shipFromCounty' of XML schema type 'xsd:string'
        std::string *shipFromCounty;
        /// Optional element 'ns2:shipFromCountry' of XML schema type 'xsd:string'
        std::string *shipFromCountry;
        /// Optional element 'ns2:shipFromState' of XML schema type 'xsd:string'
        std::string *shipFromState;
        /// Optional element 'ns2:shipFromPostalCode' of XML schema type 'xsd:string'
        std::string *shipFromPostalCode;
        /// Optional element 'ns2:export' of XML schema type 'xsd:string'
        std::string *export_;
        /// Optional element 'ns2:noExport' of XML schema type 'xsd:string'
        std::string *noExport;
        /// Optional element 'ns2:nationalTax' of XML schema type 'ns2:amount'
        std::string *nationalTax;
        /// Optional element 'ns2:vatRate' of XML schema type 'ns2:amount'
        std::string *vatRate;
        /// Optional element 'ns2:sellerRegistration' of XML schema type 'xsd:string'
        std::string *sellerRegistration;
        /// Optional element 'ns2:sellerRegistration0' of XML schema type 'xsd:string'
        std::string *sellerRegistration0;
        /// Optional element 'ns2:sellerRegistration1' of XML schema type 'xsd:string'
        std::string *sellerRegistration1;
        /// Optional element 'ns2:sellerRegistration2' of XML schema type 'xsd:string'
        std::string *sellerRegistration2;
        /// Optional element 'ns2:sellerRegistration3' of XML schema type 'xsd:string'
        std::string *sellerRegistration3;
        /// Optional element 'ns2:sellerRegistration4' of XML schema type 'xsd:string'
        std::string *sellerRegistration4;
        /// Optional element 'ns2:sellerRegistration5' of XML schema type 'xsd:string'
        std::string *sellerRegistration5;
        /// Optional element 'ns2:sellerRegistration6' of XML schema type 'xsd:string'
        std::string *sellerRegistration6;
        /// Optional element 'ns2:sellerRegistration7' of XML schema type 'xsd:string'
        std::string *sellerRegistration7;
        /// Optional element 'ns2:sellerRegistration8' of XML schema type 'xsd:string'
        std::string *sellerRegistration8;
        /// Optional element 'ns2:sellerRegistration9' of XML schema type 'xsd:string'
        std::string *sellerRegistration9;
        /// Optional element 'ns2:buyerRegistration' of XML schema type 'xsd:string'
        std::string *buyerRegistration;
        /// Optional element 'ns2:middlemanRegistration' of XML schema type 'xsd:string'
        std::string *middlemanRegistration;
        /// Optional element 'ns2:pointOfTitleTransfer' of XML schema type 'xsd:string'
        std::string *pointOfTitleTransfer;
        /// Optional element 'ns2:giftCategory' of XML schema type 'ns2:boolean'
        std::string *giftCategory;
        /// Optional element 'ns2:timeCategory' of XML schema type 'xsd:string'
        std::string *timeCategory;
        /// Optional element 'ns2:hostHedge' of XML schema type 'xsd:string'
        std::string *hostHedge;
        /// Optional element 'ns2:timeHedge' of XML schema type 'xsd:string'
        std::string *timeHedge;
        /// Optional element 'ns2:velocityHedge' of XML schema type 'xsd:string'
        std::string *velocityHedge;
        /// Optional element 'ns2:nonsensicalHedge' of XML schema type 'xsd:string'
        std::string *nonsensicalHedge;
        /// Optional element 'ns2:phoneHedge' of XML schema type 'xsd:string'
        std::string *phoneHedge;
        /// Optional element 'ns2:obscenitiesHedge' of XML schema type 'xsd:string'
        std::string *obscenitiesHedge;
        /// Optional element 'ns2:unitOfMeasure' of XML schema type 'xsd:string'
        std::string *unitOfMeasure;
        /// Optional element 'ns2:taxRate' of XML schema type 'ns2:amount'
        std::string *taxRate;
        /// Optional element 'ns2:totalAmount' of XML schema type 'ns2:amount'
        std::string *totalAmount;
        /// Optional element 'ns2:discountAmount' of XML schema type 'ns2:amount'
        std::string *discountAmount;
        /// Optional element 'ns2:discountRate' of XML schema type 'ns2:amount'
        std::string *discountRate;
        /// Optional element 'ns2:commodityCode' of XML schema type 'xsd:string'
        std::string *commodityCode;
        /// Optional element 'ns2:grossNetIndicator' of XML schema type 'xsd:string'
        std::string *grossNetIndicator;
        /// Optional element 'ns2:taxTypeApplied' of XML schema type 'xsd:string'
        std::string *taxTypeApplied;
        /// Optional element 'ns2:discountIndicator' of XML schema type 'xsd:string'
        std::string *discountIndicator;
        /// Optional element 'ns2:alternateTaxID' of XML schema type 'xsd:string'
        std::string *alternateTaxID;
        /// Optional element 'ns2:alternateTaxAmount' of XML schema type 'ns2:amount'
        std::string *alternateTaxAmount;
        /// Optional element 'ns2:alternateTaxTypeApplied' of XML schema type 'xsd:string'
        std::string *alternateTaxTypeApplied;
        /// Optional element 'ns2:alternateTaxRate' of XML schema type 'ns2:amount'
        std::string *alternateTaxRate;
        /// Optional element 'ns2:alternateTaxType' of XML schema type 'xsd:string'
        std::string *alternateTaxType;
        /// Optional element 'ns2:localTax' of XML schema type 'ns2:amount'
        std::string *localTax;
        /// Optional element 'ns2:zeroCostToCustomerIndicator' of XML schema type 'xsd:string'
        std::string *zeroCostToCustomerIndicator;
        /// Optional element 'ns2:passengerFirstName' of XML schema type 'xsd:string'
        std::string *passengerFirstName;
        /// Optional element 'ns2:passengerLastName' of XML schema type 'xsd:string'
        std::string *passengerLastName;
        /// Optional element 'ns2:passengerID' of XML schema type 'xsd:string'
        std::string *passengerID;
        /// Optional element 'ns2:passengerStatus' of XML schema type 'xsd:string'
        std::string *passengerStatus;
        /// Optional element 'ns2:passengerType' of XML schema type 'xsd:string'
        std::string *passengerType;
        /// Optional element 'ns2:passengerEmail' of XML schema type 'xsd:string'
        std::string *passengerEmail;
        /// Optional element 'ns2:passengerPhone' of XML schema type 'xsd:string'
        std::string *passengerPhone;
        /// Optional element 'ns2:passengerNationality' of XML schema type 'xsd:string'
        std::string *passengerNationality;
        /// Optional element 'ns2:invoiceNumber' of XML schema type 'xsd:string'
        std::string *invoiceNumber;
        /// Optional element 'ns2:productDescription' of XML schema type 'xsd:string'
        std::string *productDescription;
        /// Optional element 'ns2:taxStatusIndicator' of XML schema type 'xsd:string'
        std::string *taxStatusIndicator;
        /// Optional element 'ns2:discountManagementIndicator' of XML schema type 'xsd:string'
        std::string *discountManagementIndicator;
        /// Optional element 'ns2:typeOfSupply' of XML schema type 'xsd:string'
        std::string *typeOfSupply;
        /// Optional element 'ns2:sign' of XML schema type 'xsd:string'
        std::string *sign;
        /// Optional element 'ns2:unitTaxAmount' of XML schema type 'xsd:string'
        std::string *unitTaxAmount;
        /// Optional element 'ns2:weightAmount' of XML schema type 'xsd:string'
        std::string *weightAmount;
        /// Optional element 'ns2:weightID' of XML schema type 'xsd:string'
        std::string *weightID;
        /// Optional element 'ns2:weightUnitMeasurement' of XML schema type 'xsd:string'
        std::string *weightUnitMeasurement;
        /// Optional element 'ns2:otherTax_1_type' of XML schema type 'xsd:string'
        std::string *otherTax_USCORE1_USCOREtype;
        /// Optional element 'ns2:otherTax_1_amount' of XML schema type 'ns2:amount'
        std::string *otherTax_USCORE1_USCOREamount;
        /// Optional element 'ns2:otherTax_1_rate' of XML schema type 'ns2:amount'
        std::string *otherTax_USCORE1_USCORErate;
        /// Optional element 'ns2:otherTax_1_statusIndicator' of XML schema type 'xsd:string'
        std::string *otherTax_USCORE1_USCOREstatusIndicator;
        /// Optional element 'ns2:otherTax_2_type' of XML schema type 'xsd:string'
        std::string *otherTax_USCORE2_USCOREtype;
        /// Optional element 'ns2:otherTax_2_amount' of XML schema type 'ns2:amount'
        std::string *otherTax_USCORE2_USCOREamount;
        /// Optional element 'ns2:otherTax_2_rate' of XML schema type 'ns2:amount'
        std::string *otherTax_USCORE2_USCORErate;
        /// Optional element 'ns2:otherTax_2_statusIndicator' of XML schema type 'xsd:string'
        std::string *otherTax_USCORE2_USCOREstatusIndicator;
        /// Optional element 'ns2:otherTax_3_type' of XML schema type 'xsd:string'
        std::string *otherTax_USCORE3_USCOREtype;
        /// Optional element 'ns2:otherTax_3_amount' of XML schema type 'ns2:amount'
        std::string *otherTax_USCORE3_USCOREamount;
        /// Optional element 'ns2:otherTax_3_rate' of XML schema type 'ns2:amount'
        std::string *otherTax_USCORE3_USCORErate;
        /// Optional element 'ns2:otherTax_3_statusIndicator' of XML schema type 'xsd:string'
        std::string *otherTax_USCORE3_USCOREstatusIndicator;
        /// Optional element 'ns2:otherTax_4_type' of XML schema type 'xsd:string'
        std::string *otherTax_USCORE4_USCOREtype;
        /// Optional element 'ns2:otherTax_4_amount' of XML schema type 'ns2:amount'
        std::string *otherTax_USCORE4_USCOREamount;
        /// Optional element 'ns2:otherTax_4_rate' of XML schema type 'ns2:amount'
        std::string *otherTax_USCORE4_USCORErate;
        /// Optional element 'ns2:otherTax_4_statusIndicator' of XML schema type 'xsd:string'
        std::string *otherTax_USCORE4_USCOREstatusIndicator;
        /// Optional element 'ns2:otherTax_5_type' of XML schema type 'xsd:string'
        std::string *otherTax_USCORE5_USCOREtype;
        /// Optional element 'ns2:otherTax_5_amount' of XML schema type 'ns2:amount'
        std::string *otherTax_USCORE5_USCOREamount;
        /// Optional element 'ns2:otherTax_5_rate' of XML schema type 'ns2:amount'
        std::string *otherTax_USCORE5_USCORErate;
        /// Optional element 'ns2:otherTax_5_statusIndicator' of XML schema type 'xsd:string'
        std::string *otherTax_USCORE5_USCOREstatusIndicator;
        /// Optional element 'ns2:otherTax_6_type' of XML schema type 'xsd:string'
        std::string *otherTax_USCORE6_USCOREtype;
        /// Optional element 'ns2:otherTax_6_amount' of XML schema type 'ns2:amount'
        std::string *otherTax_USCORE6_USCOREamount;
        /// Optional element 'ns2:otherTax_6_rate' of XML schema type 'ns2:amount'
        std::string *otherTax_USCORE6_USCORErate;
        /// Optional element 'ns2:otherTax_6_statusIndicator' of XML schema type 'xsd:string'
        std::string *otherTax_USCORE6_USCOREstatusIndicator;
        /// Optional element 'ns2:otherTax_7_type' of XML schema type 'xsd:string'
        std::string *otherTax_USCORE7_USCOREtype;
        /// Optional element 'ns2:otherTax_7_amount' of XML schema type 'ns2:amount'
        std::string *otherTax_USCORE7_USCOREamount;
        /// Optional element 'ns2:otherTax_7_rate' of XML schema type 'ns2:amount'
        std::string *otherTax_USCORE7_USCORErate;
        /// Optional element 'ns2:otherTax_7_statusIndicator' of XML schema type 'xsd:string'
        std::string *otherTax_USCORE7_USCOREstatusIndicator;
        /// Optional element 'ns2:referenceData_1_number' of XML schema type 'xsd:string'
        std::string *referenceData_USCORE1_USCOREnumber;
        /// Optional element 'ns2:referenceData_1_code' of XML schema type 'xsd:string'
        std::string *referenceData_USCORE1_USCOREcode;
        /// Optional element 'ns2:referenceData_2_number' of XML schema type 'xsd:string'
        std::string *referenceData_USCORE2_USCOREnumber;
        /// Optional element 'ns2:referenceData_2_code' of XML schema type 'xsd:string'
        std::string *referenceData_USCORE2_USCOREcode;
        /// Optional element 'ns2:referenceData_3_number' of XML schema type 'xsd:string'
        std::string *referenceData_USCORE3_USCOREnumber;
        /// Optional element 'ns2:referenceData_3_code' of XML schema type 'xsd:string'
        std::string *referenceData_USCORE3_USCOREcode;
        /// Optional element 'ns2:referenceData_4_number' of XML schema type 'xsd:string'
        std::string *referenceData_USCORE4_USCOREnumber;
        /// Optional element 'ns2:referenceData_4_code' of XML schema type 'xsd:string'
        std::string *referenceData_USCORE4_USCOREcode;
        /// Optional element 'ns2:referenceData_5_number' of XML schema type 'xsd:string'
        std::string *referenceData_USCORE5_USCOREnumber;
        /// Optional element 'ns2:referenceData_5_code' of XML schema type 'xsd:string'
        std::string *referenceData_USCORE5_USCOREcode;
        /// Optional element 'ns2:referenceData_6_number' of XML schema type 'xsd:string'
        std::string *referenceData_USCORE6_USCOREnumber;
        /// Optional element 'ns2:referenceData_6_code' of XML schema type 'xsd:string'
        std::string *referenceData_USCORE6_USCOREcode;
        /// Optional element 'ns2:referenceData_7_number' of XML schema type 'xsd:string'
        std::string *referenceData_USCORE7_USCOREnumber;
        /// Optional element 'ns2:referenceData_7_code' of XML schema type 'xsd:string'
        std::string *referenceData_USCORE7_USCOREcode;
        /// Optional element 'ns2:shippingDestinationTypes' of XML schema type 'xsd:string'
        std::string *shippingDestinationTypes;
        /// Optional attribute 'id' of XML schema type 'xsd:integer'
        std::string *id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Item
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Item; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Item, default initialized and not managed by a soap context
        virtual ns2__Item *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Item); }
      public:
        /// Constructor with default initializations
        ns2__Item() : unitPrice(), quantity(), productCode(), productName(), productSKU(), productRisk(), taxAmount(), cityOverrideAmount(), cityOverrideRate(), countyOverrideAmount(), countyOverrideRate(), districtOverrideAmount(), districtOverrideRate(), stateOverrideAmount(), stateOverrideRate(), countryOverrideAmount(), countryOverrideRate(), orderAcceptanceCity(), orderAcceptanceCounty(), orderAcceptanceCountry(), orderAcceptanceState(), orderAcceptancePostalCode(), orderOriginCity(), orderOriginCounty(), orderOriginCountry(), orderOriginState(), orderOriginPostalCode(), shipFromCity(), shipFromCounty(), shipFromCountry(), shipFromState(), shipFromPostalCode(), export_(), noExport(), nationalTax(), vatRate(), sellerRegistration(), sellerRegistration0(), sellerRegistration1(), sellerRegistration2(), sellerRegistration3(), sellerRegistration4(), sellerRegistration5(), sellerRegistration6(), sellerRegistration7(), sellerRegistration8(), sellerRegistration9(), buyerRegistration(), middlemanRegistration(), pointOfTitleTransfer(), giftCategory(), timeCategory(), hostHedge(), timeHedge(), velocityHedge(), nonsensicalHedge(), phoneHedge(), obscenitiesHedge(), unitOfMeasure(), taxRate(), totalAmount(), discountAmount(), discountRate(), commodityCode(), grossNetIndicator(), taxTypeApplied(), discountIndicator(), alternateTaxID(), alternateTaxAmount(), alternateTaxTypeApplied(), alternateTaxRate(), alternateTaxType(), localTax(), zeroCostToCustomerIndicator(), passengerFirstName(), passengerLastName(), passengerID(), passengerStatus(), passengerType(), passengerEmail(), passengerPhone(), passengerNationality(), invoiceNumber(), productDescription(), taxStatusIndicator(), discountManagementIndicator(), typeOfSupply(), sign(), unitTaxAmount(), weightAmount(), weightID(), weightUnitMeasurement(), otherTax_USCORE1_USCOREtype(), otherTax_USCORE1_USCOREamount(), otherTax_USCORE1_USCORErate(), otherTax_USCORE1_USCOREstatusIndicator(), otherTax_USCORE2_USCOREtype(), otherTax_USCORE2_USCOREamount(), otherTax_USCORE2_USCORErate(), otherTax_USCORE2_USCOREstatusIndicator(), otherTax_USCORE3_USCOREtype(), otherTax_USCORE3_USCOREamount(), otherTax_USCORE3_USCORErate(), otherTax_USCORE3_USCOREstatusIndicator(), otherTax_USCORE4_USCOREtype(), otherTax_USCORE4_USCOREamount(), otherTax_USCORE4_USCORErate(), otherTax_USCORE4_USCOREstatusIndicator(), otherTax_USCORE5_USCOREtype(), otherTax_USCORE5_USCOREamount(), otherTax_USCORE5_USCORErate(), otherTax_USCORE5_USCOREstatusIndicator(), otherTax_USCORE6_USCOREtype(), otherTax_USCORE6_USCOREamount(), otherTax_USCORE6_USCORErate(), otherTax_USCORE6_USCOREstatusIndicator(), otherTax_USCORE7_USCOREtype(), otherTax_USCORE7_USCOREamount(), otherTax_USCORE7_USCORErate(), otherTax_USCORE7_USCOREstatusIndicator(), referenceData_USCORE1_USCOREnumber(), referenceData_USCORE1_USCOREcode(), referenceData_USCORE2_USCOREnumber(), referenceData_USCORE2_USCOREcode(), referenceData_USCORE3_USCOREnumber(), referenceData_USCORE3_USCOREcode(), referenceData_USCORE4_USCOREnumber(), referenceData_USCORE4_USCOREcode(), referenceData_USCORE5_USCOREnumber(), referenceData_USCORE5_USCOREcode(), referenceData_USCORE6_USCOREnumber(), referenceData_USCORE6_USCOREcode(), referenceData_USCORE7_USCOREnumber(), referenceData_USCORE7_USCOREcode(), shippingDestinationTypes(), id(), soap() { }
        virtual ~ns2__Item() { }
        /// Friend allocator used by soap_new_ns2__Item(struct soap*, int)
        friend SOAP_FMAC1 ns2__Item * SOAP_FMAC2 soap_instantiate_ns2__Item(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:178 */
#ifndef SOAP_TYPE_ns2__CCAuthService
#define SOAP_TYPE_ns2__CCAuthService (284)
/* complex XML schema type 'ns2:CCAuthService': */
class SOAP_CMAC ns2__CCAuthService {
      public:
        /// Optional element 'ns2:cavv' of XML schema type 'xsd:string'
        std::string *cavv;
        /// Optional element 'ns2:cavvAlgorithm' of XML schema type 'xsd:string'
        std::string *cavvAlgorithm;
        /// Optional element 'ns2:networkTokenCryptogram' of XML schema type 'xsd:string'
        std::string *networkTokenCryptogram;
        /// Optional element 'ns2:paSpecificationVersion' of XML schema type 'xsd:string'
        std::string *paSpecificationVersion;
        /// Optional element 'ns2:directoryServerTransactionID' of XML schema type 'xsd:string'
        std::string *directoryServerTransactionID;
        /// Optional element 'ns2:acsServerTransactionID' of XML schema type 'xsd:string'
        std::string *acsServerTransactionID;
        /// Optional element 'ns2:commerceIndicator' of XML schema type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:eciRaw' of XML schema type 'xsd:string'
        std::string *eciRaw;
        /// Optional element 'ns2:xid' of XML schema type 'xsd:string'
        std::string *xid;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:avsLevel' of XML schema type 'xsd:string'
        std::string *avsLevel;
        /// Optional element 'ns2:fxQuoteID' of XML schema type 'xsd:string'
        std::string *fxQuoteID;
        /// Optional element 'ns2:returnAuthRecord' of XML schema type 'ns2:boolean'
        std::string *returnAuthRecord;
        /// Optional element 'ns2:authType' of XML schema type 'xsd:string'
        std::string *authType;
        /// Optional element 'ns2:verbalAuthCode' of XML schema type 'xsd:string'
        std::string *verbalAuthCode;
        /// Optional element 'ns2:billPayment' of XML schema type 'ns2:boolean'
        std::string *billPayment;
        /// Optional element 'ns2:authenticationXID' of XML schema type 'xsd:string'
        std::string *authenticationXID;
        /// Optional element 'ns2:authorizationXID' of XML schema type 'xsd:string'
        std::string *authorizationXID;
        /// Optional element 'ns2:industryDatatype' of XML schema type 'xsd:string'
        std::string *industryDatatype;
        /// Optional element 'ns2:traceNumber' of XML schema type 'xsd:string'
        std::string *traceNumber;
        /// Optional element 'ns2:checksumKey' of XML schema type 'xsd:string'
        std::string *checksumKey;
        /// Optional element 'ns2:aggregatorID' of XML schema type 'xsd:string'
        std::string *aggregatorID;
        /// Optional element 'ns2:aggregatorName' of XML schema type 'xsd:string'
        std::string *aggregatorName;
        /// Optional element 'ns2:splitTenderIndicator' of XML schema type 'xsd:string'
        std::string *splitTenderIndicator;
        /// Optional element 'ns2:veresEnrolled' of XML schema type 'xsd:string'
        std::string *veresEnrolled;
        /// Optional element 'ns2:paresStatus' of XML schema type 'xsd:string'
        std::string *paresStatus;
        /// Optional element 'ns2:partialAuthIndicator' of XML schema type 'ns2:boolean'
        std::string *partialAuthIndicator;
        /// Optional element 'ns2:captureDate' of XML schema type 'xsd:string'
        std::string *captureDate;
        /// Optional element 'ns2:firstRecurringPayment' of XML schema type 'xsd:string'
        std::string *firstRecurringPayment;
        /// Optional element 'ns2:duration' of XML schema type 'xsd:integer'
        std::string *duration;
        /// Optional element 'ns2:overridePaymentMethod' of XML schema type 'xsd:string'
        std::string *overridePaymentMethod;
        /// Optional element 'ns2:mobileRemotePaymentType' of XML schema type 'xsd:string'
        std::string *mobileRemotePaymentType;
        /// Optional element 'ns2:cardholderVerificationMethod' of XML schema type 'xsd:string'
        std::string *cardholderVerificationMethod;
        /// Optional element 'ns2:dccRequestID' of XML schema type 'xsd:string'
        std::string *dccRequestID;
        /// Optional element 'ns2:overridePaymentDetails' of XML schema type 'xsd:string'
        std::string *overridePaymentDetails;
        /// Optional element 'ns2:cardholderAuthenticationMethod' of XML schema type 'xsd:string'
        std::string *cardholderAuthenticationMethod;
        /// Optional element 'ns2:leastCostRouting' of XML schema type 'ns2:boolean'
        std::string *leastCostRouting;
        /// Optional element 'ns2:verificationType' of XML schema type 'xsd:string'
        std::string *verificationType;
        /// Optional element 'ns2:cryptocurrencyPurchase' of XML schema type 'xsd:string'
        std::string *cryptocurrencyPurchase;
        /// Optional element 'ns2:lowValueExemptionIndicator' of XML schema type 'xsd:string'
        std::string *lowValueExemptionIndicator;
        /// Optional element 'ns2:riskAnalysisExemptionIndicator' of XML schema type 'xsd:string'
        std::string *riskAnalysisExemptionIndicator;
        /// Optional element 'ns2:trustedMerchantExemptionIndicator' of XML schema type 'xsd:string'
        std::string *trustedMerchantExemptionIndicator;
        /// Optional element 'ns2:secureCorporatePaymentIndicator' of XML schema type 'xsd:string'
        std::string *secureCorporatePaymentIndicator;
        /// Optional element 'ns2:deferredAuthIndicator' of XML schema type 'xsd:string'
        std::string *deferredAuthIndicator;
        /// Optional element 'ns2:aggregatedAuthIndicator' of XML schema type 'xsd:string'
        std::string *aggregatedAuthIndicator;
        /// Optional element 'ns2:debtRecoveryIndicator' of XML schema type 'xsd:string'
        std::string *debtRecoveryIndicator;
        /// Optional element 'ns2:delegatedAuthenticationExemptionIndicator' of XML schema type 'xsd:string'
        std::string *delegatedAuthenticationExemptionIndicator;
        /// Optional element 'ns2:transitTransactionType' of XML schema type 'xsd:string'
        std::string *transitTransactionType;
        /// Optional element 'ns2:transportationMode' of XML schema type 'xsd:string'
        std::string *transportationMode;
        /// Optional element 'ns2:totaloffersCount' of XML schema type 'xsd:string'
        std::string *totaloffersCount;
        /// Optional element 'ns2:effectiveAuthenticationType' of XML schema type 'xsd:string'
        std::string *effectiveAuthenticationType;
        /// Optional element 'ns2:paChallengeCode' of XML schema type 'xsd:string'
        std::string *paChallengeCode;
        /// Optional element 'ns2:paresStatusReason' of XML schema type 'xsd:string'
        std::string *paresStatusReason;
        /// Optional element 'ns2:challengeCancelCode' of XML schema type 'xsd:string'
        std::string *challengeCancelCode;
        /// Optional element 'ns2:paNetworkScore' of XML schema type 'xsd:string'
        std::string *paNetworkScore;
        /// Optional element 'ns2:paAuthenticationDate' of XML schema type 'xsd:string'
        std::string *paAuthenticationDate;
        /// Optional element 'ns2:authenticationOutageExemptionIndicator' of XML schema type 'xsd:string'
        std::string *authenticationOutageExemptionIndicator;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCAuthService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCAuthService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCAuthService, default initialized and not managed by a soap context
        virtual ns2__CCAuthService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCAuthService); }
      public:
        /// Constructor with default initializations
        ns2__CCAuthService() : cavv(), cavvAlgorithm(), networkTokenCryptogram(), paSpecificationVersion(), directoryServerTransactionID(), acsServerTransactionID(), commerceIndicator(), eciRaw(), xid(), reconciliationID(), avsLevel(), fxQuoteID(), returnAuthRecord(), authType(), verbalAuthCode(), billPayment(), authenticationXID(), authorizationXID(), industryDatatype(), traceNumber(), checksumKey(), aggregatorID(), aggregatorName(), splitTenderIndicator(), veresEnrolled(), paresStatus(), partialAuthIndicator(), captureDate(), firstRecurringPayment(), duration(), overridePaymentMethod(), mobileRemotePaymentType(), cardholderVerificationMethod(), dccRequestID(), overridePaymentDetails(), cardholderAuthenticationMethod(), leastCostRouting(), verificationType(), cryptocurrencyPurchase(), lowValueExemptionIndicator(), riskAnalysisExemptionIndicator(), trustedMerchantExemptionIndicator(), secureCorporatePaymentIndicator(), deferredAuthIndicator(), aggregatedAuthIndicator(), debtRecoveryIndicator(), delegatedAuthenticationExemptionIndicator(), transitTransactionType(), transportationMode(), totaloffersCount(), effectiveAuthenticationType(), paChallengeCode(), paresStatusReason(), challengeCancelCode(), paNetworkScore(), paAuthenticationDate(), authenticationOutageExemptionIndicator(), run(), soap() { }
        virtual ~ns2__CCAuthService() { }
        /// Friend allocator used by soap_new_ns2__CCAuthService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCAuthService * SOAP_FMAC2 soap_instantiate_ns2__CCAuthService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:180 */
#ifndef SOAP_TYPE_ns2__OCTService
#define SOAP_TYPE_ns2__OCTService (285)
/* complex XML schema type 'ns2:OCTService': */
class SOAP_CMAC ns2__OCTService {
      public:
        /// Optional element 'ns2:commerceIndicator' of XML schema type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:networkOrder' of XML schema type 'xsd:string'
        std::string *networkOrder;
        /// Optional element 'ns2:overridePaymentMethod' of XML schema type 'xsd:string'
        std::string *overridePaymentMethod;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OCTService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__OCTService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OCTService, default initialized and not managed by a soap context
        virtual ns2__OCTService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__OCTService); }
      public:
        /// Constructor with default initializations
        ns2__OCTService() : commerceIndicator(), reconciliationID(), networkOrder(), overridePaymentMethod(), run(), soap() { }
        virtual ~ns2__OCTService() { }
        /// Friend allocator used by soap_new_ns2__OCTService(struct soap*, int)
        friend SOAP_FMAC1 ns2__OCTService * SOAP_FMAC2 soap_instantiate_ns2__OCTService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:182 */
#ifndef SOAP_TYPE_ns2__VerificationService
#define SOAP_TYPE_ns2__VerificationService (286)
/* complex XML schema type 'ns2:VerificationService': */
class SOAP_CMAC ns2__VerificationService {
      public:
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VerificationService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__VerificationService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VerificationService, default initialized and not managed by a soap context
        virtual ns2__VerificationService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__VerificationService); }
      public:
        /// Constructor with default initializations
        ns2__VerificationService() : reconciliationID(), run(), soap() { }
        virtual ~ns2__VerificationService() { }
        /// Friend allocator used by soap_new_ns2__VerificationService(struct soap*, int)
        friend SOAP_FMAC1 ns2__VerificationService * SOAP_FMAC2 soap_instantiate_ns2__VerificationService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:184 */
#ifndef SOAP_TYPE_ns2__CCSaleService
#define SOAP_TYPE_ns2__CCSaleService (287)
/* complex XML schema type 'ns2:CCSaleService': */
class SOAP_CMAC ns2__CCSaleService {
      public:
        /// Optional element 'ns2:overridePaymentMethod' of XML schema type 'xsd:string'
        std::string *overridePaymentMethod;
        /// Optional element 'ns2:commerceIndicator' of XML schema type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:partialAuthIndicator' of XML schema type 'ns2:boolean'
        std::string *partialAuthIndicator;
        /// Optional element 'ns2:cavv' of XML schema type 'xsd:string'
        std::string *cavv;
        /// Optional element 'ns2:xid' of XML schema type 'xsd:string'
        std::string *xid;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:industryDatatype' of XML schema type 'xsd:string'
        std::string *industryDatatype;
        /// Optional element 'ns2:networkTokenCryptogram' of XML schema type 'xsd:string'
        std::string *networkTokenCryptogram;
        /// Optional element 'ns2:paSpecificationVersion' of XML schema type 'xsd:string'
        std::string *paSpecificationVersion;
        /// Optional element 'ns2:directoryServerTransactionID' of XML schema type 'xsd:string'
        std::string *directoryServerTransactionID;
        /// Optional element 'ns2:cryptocurrencyPurchase' of XML schema type 'xsd:string'
        std::string *cryptocurrencyPurchase;
        /// Optional element 'ns2:lowValueExemptionIndicator' of XML schema type 'xsd:string'
        std::string *lowValueExemptionIndicator;
        /// Optional element 'ns2:riskAnalysisExemptionIndicator' of XML schema type 'xsd:string'
        std::string *riskAnalysisExemptionIndicator;
        /// Optional element 'ns2:trustedMerchantExemptionIndicator' of XML schema type 'xsd:string'
        std::string *trustedMerchantExemptionIndicator;
        /// Optional element 'ns2:secureCorporatePaymentIndicator' of XML schema type 'xsd:string'
        std::string *secureCorporatePaymentIndicator;
        /// Optional element 'ns2:deferredAuthIndicator' of XML schema type 'xsd:string'
        std::string *deferredAuthIndicator;
        /// Optional element 'ns2:delegatedAuthenticationExemptionIndicator' of XML schema type 'xsd:string'
        std::string *delegatedAuthenticationExemptionIndicator;
        /// Optional element 'ns2:transitTransactionType' of XML schema type 'xsd:string'
        std::string *transitTransactionType;
        /// Optional element 'ns2:transportationMode' of XML schema type 'xsd:string'
        std::string *transportationMode;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCSaleService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCSaleService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCSaleService, default initialized and not managed by a soap context
        virtual ns2__CCSaleService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCSaleService); }
      public:
        /// Constructor with default initializations
        ns2__CCSaleService() : overridePaymentMethod(), commerceIndicator(), partialAuthIndicator(), cavv(), xid(), reconciliationID(), industryDatatype(), networkTokenCryptogram(), paSpecificationVersion(), directoryServerTransactionID(), cryptocurrencyPurchase(), lowValueExemptionIndicator(), riskAnalysisExemptionIndicator(), trustedMerchantExemptionIndicator(), secureCorporatePaymentIndicator(), deferredAuthIndicator(), delegatedAuthenticationExemptionIndicator(), transitTransactionType(), transportationMode(), run(), soap() { }
        virtual ~ns2__CCSaleService() { }
        /// Friend allocator used by soap_new_ns2__CCSaleService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCSaleService * SOAP_FMAC2 soap_instantiate_ns2__CCSaleService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:186 */
#ifndef SOAP_TYPE_ns2__CCSaleCreditService
#define SOAP_TYPE_ns2__CCSaleCreditService (288)
/* complex XML schema type 'ns2:CCSaleCreditService': */
class SOAP_CMAC ns2__CCSaleCreditService {
      public:
        /// Optional element 'ns2:overridePaymentMethod' of XML schema type 'xsd:string'
        std::string *overridePaymentMethod;
        /// Optional element 'ns2:commerceIndicator' of XML schema type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:refundReason' of XML schema type 'xsd:string'
        std::string *refundReason;
        /// Optional element 'ns2:saleRequestID' of XML schema type 'xsd:string'
        std::string *saleRequestID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCSaleCreditService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCSaleCreditService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCSaleCreditService, default initialized and not managed by a soap context
        virtual ns2__CCSaleCreditService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCSaleCreditService); }
      public:
        /// Constructor with default initializations
        ns2__CCSaleCreditService() : overridePaymentMethod(), commerceIndicator(), reconciliationID(), refundReason(), saleRequestID(), run(), soap() { }
        virtual ~ns2__CCSaleCreditService() { }
        /// Friend allocator used by soap_new_ns2__CCSaleCreditService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCSaleCreditService * SOAP_FMAC2 soap_instantiate_ns2__CCSaleCreditService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:188 */
#ifndef SOAP_TYPE_ns2__CCSaleReversalService
#define SOAP_TYPE_ns2__CCSaleReversalService (289)
/* complex XML schema type 'ns2:CCSaleReversalService': */
class SOAP_CMAC ns2__CCSaleReversalService {
      public:
        /// Optional element 'ns2:saleRequestID' of XML schema type 'xsd:string'
        std::string *saleRequestID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCSaleReversalService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCSaleReversalService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCSaleReversalService, default initialized and not managed by a soap context
        virtual ns2__CCSaleReversalService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCSaleReversalService); }
      public:
        /// Constructor with default initializations
        ns2__CCSaleReversalService() : saleRequestID(), run(), soap() { }
        virtual ~ns2__CCSaleReversalService() { }
        /// Friend allocator used by soap_new_ns2__CCSaleReversalService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCSaleReversalService * SOAP_FMAC2 soap_instantiate_ns2__CCSaleReversalService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:190 */
#ifndef SOAP_TYPE_ns2__CCIncrementalAuthService
#define SOAP_TYPE_ns2__CCIncrementalAuthService (290)
/* complex XML schema type 'ns2:CCIncrementalAuthService': */
class SOAP_CMAC ns2__CCIncrementalAuthService {
      public:
        /// Optional element 'ns2:authRequestID' of XML schema type 'xsd:string'
        std::string *authRequestID;
        /// Optional element 'ns2:duration' of XML schema type 'xsd:integer'
        std::string *duration;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCIncrementalAuthService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCIncrementalAuthService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCIncrementalAuthService, default initialized and not managed by a soap context
        virtual ns2__CCIncrementalAuthService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCIncrementalAuthService); }
      public:
        /// Constructor with default initializations
        ns2__CCIncrementalAuthService() : authRequestID(), duration(), run(), soap() { }
        virtual ~ns2__CCIncrementalAuthService() { }
        /// Friend allocator used by soap_new_ns2__CCIncrementalAuthService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCIncrementalAuthService * SOAP_FMAC2 soap_instantiate_ns2__CCIncrementalAuthService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:192 */
#ifndef SOAP_TYPE_ns2__CCCaptureService
#define SOAP_TYPE_ns2__CCCaptureService (291)
/* complex XML schema type 'ns2:CCCaptureService': */
class SOAP_CMAC ns2__CCCaptureService {
      public:
        /// Optional element 'ns2:authType' of XML schema type 'xsd:string'
        std::string *authType;
        /// Optional element 'ns2:verbalAuthCode' of XML schema type 'xsd:string'
        std::string *verbalAuthCode;
        /// Optional element 'ns2:authRequestID' of XML schema type 'xsd:string'
        std::string *authRequestID;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:partialPaymentID' of XML schema type 'xsd:string'
        std::string *partialPaymentID;
        /// Optional element 'ns2:purchasingLevel' of XML schema type 'xsd:string'
        std::string *purchasingLevel;
        /// Optional element 'ns2:industryDatatype' of XML schema type 'xsd:string'
        std::string *industryDatatype;
        /// Optional element 'ns2:authRequestToken' of XML schema type 'xsd:string'
        std::string *authRequestToken;
        /// Optional element 'ns2:merchantReceiptNumber' of XML schema type 'xsd:string'
        std::string *merchantReceiptNumber;
        /// Optional element 'ns2:posData' of XML schema type 'xsd:string'
        std::string *posData;
        /// Optional element 'ns2:transactionID' of XML schema type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:checksumKey' of XML schema type 'xsd:string'
        std::string *checksumKey;
        /// Optional element 'ns2:gratuityAmount' of XML schema type 'xsd:string'
        std::string *gratuityAmount;
        /// Optional element 'ns2:duration' of XML schema type 'xsd:integer'
        std::string *duration;
        /// Optional element 'ns2:dpdeBillingMonth' of XML schema type 'xsd:integer'
        std::string *dpdeBillingMonth;
        /// Optional element 'ns2:sequence' of XML schema type 'xsd:string'
        std::string *sequence;
        /// Optional element 'ns2:totalCount' of XML schema type 'xsd:string'
        std::string *totalCount;
        /// Optional element 'ns2:reconciliationIDAlternate' of XML schema type 'xsd:string'
        std::string *reconciliationIDAlternate;
        /// Optional element 'ns2:aggregatorID' of XML schema type 'xsd:string'
        std::string *aggregatorID;
        /// Optional element 'ns2:aggregatorName' of XML schema type 'xsd:string'
        std::string *aggregatorName;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCCaptureService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCCaptureService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCCaptureService, default initialized and not managed by a soap context
        virtual ns2__CCCaptureService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCCaptureService); }
      public:
        /// Constructor with default initializations
        ns2__CCCaptureService() : authType(), verbalAuthCode(), authRequestID(), reconciliationID(), partialPaymentID(), purchasingLevel(), industryDatatype(), authRequestToken(), merchantReceiptNumber(), posData(), transactionID(), checksumKey(), gratuityAmount(), duration(), dpdeBillingMonth(), sequence(), totalCount(), reconciliationIDAlternate(), aggregatorID(), aggregatorName(), run(), soap() { }
        virtual ~ns2__CCCaptureService() { }
        /// Friend allocator used by soap_new_ns2__CCCaptureService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCCaptureService * SOAP_FMAC2 soap_instantiate_ns2__CCCaptureService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:194 */
#ifndef SOAP_TYPE_ns2__CCCreditService
#define SOAP_TYPE_ns2__CCCreditService (292)
/* complex XML schema type 'ns2:CCCreditService': */
class SOAP_CMAC ns2__CCCreditService {
      public:
        /// Optional element 'ns2:captureRequestID' of XML schema type 'xsd:string'
        std::string *captureRequestID;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:partialPaymentID' of XML schema type 'xsd:string'
        std::string *partialPaymentID;
        /// Optional element 'ns2:purchasingLevel' of XML schema type 'xsd:string'
        std::string *purchasingLevel;
        /// Optional element 'ns2:industryDatatype' of XML schema type 'xsd:string'
        std::string *industryDatatype;
        /// Optional element 'ns2:commerceIndicator' of XML schema type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:billPayment' of XML schema type 'ns2:boolean'
        std::string *billPayment;
        /// Optional element 'ns2:authorizationXID' of XML schema type 'xsd:string'
        std::string *authorizationXID;
        /// Optional element 'ns2:occurrenceNumber' of XML schema type 'xsd:string'
        std::string *occurrenceNumber;
        /// Optional element 'ns2:authCode' of XML schema type 'xsd:string'
        std::string *authCode;
        /// Optional element 'ns2:captureRequestToken' of XML schema type 'xsd:string'
        std::string *captureRequestToken;
        /// Optional element 'ns2:merchantReceiptNumber' of XML schema type 'xsd:string'
        std::string *merchantReceiptNumber;
        /// Optional element 'ns2:checksumKey' of XML schema type 'xsd:string'
        std::string *checksumKey;
        /// Optional element 'ns2:aggregatorID' of XML schema type 'xsd:string'
        std::string *aggregatorID;
        /// Optional element 'ns2:aggregatorName' of XML schema type 'xsd:string'
        std::string *aggregatorName;
        /// Optional element 'ns2:duration' of XML schema type 'xsd:integer'
        std::string *duration;
        /// Optional element 'ns2:dpdeBillingMonth' of XML schema type 'xsd:integer'
        std::string *dpdeBillingMonth;
        /// Optional element 'ns2:reconciliationIDAlternate' of XML schema type 'xsd:string'
        std::string *reconciliationIDAlternate;
        /// Optional element 'ns2:refundReason' of XML schema type 'xsd:string'
        std::string *refundReason;
        /// Optional element 'ns2:overridePaymentMethod' of XML schema type 'xsd:string'
        std::string *overridePaymentMethod;
        /// Optional element 'ns2:overridePaymentDetails' of XML schema type 'xsd:string'
        std::string *overridePaymentDetails;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCCreditService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCCreditService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCCreditService, default initialized and not managed by a soap context
        virtual ns2__CCCreditService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCCreditService); }
      public:
        /// Constructor with default initializations
        ns2__CCCreditService() : captureRequestID(), reconciliationID(), partialPaymentID(), purchasingLevel(), industryDatatype(), commerceIndicator(), billPayment(), authorizationXID(), occurrenceNumber(), authCode(), captureRequestToken(), merchantReceiptNumber(), checksumKey(), aggregatorID(), aggregatorName(), duration(), dpdeBillingMonth(), reconciliationIDAlternate(), refundReason(), overridePaymentMethod(), overridePaymentDetails(), run(), soap() { }
        virtual ~ns2__CCCreditService() { }
        /// Friend allocator used by soap_new_ns2__CCCreditService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCCreditService * SOAP_FMAC2 soap_instantiate_ns2__CCCreditService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:196 */
#ifndef SOAP_TYPE_ns2__CCAuthReversalService
#define SOAP_TYPE_ns2__CCAuthReversalService (293)
/* complex XML schema type 'ns2:CCAuthReversalService': */
class SOAP_CMAC ns2__CCAuthReversalService {
      public:
        /// Optional element 'ns2:authRequestID' of XML schema type 'xsd:string'
        std::string *authRequestID;
        /// Optional element 'ns2:authRequestToken' of XML schema type 'xsd:string'
        std::string *authRequestToken;
        /// Optional element 'ns2:reversalReason' of XML schema type 'xsd:string'
        std::string *reversalReason;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCAuthReversalService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCAuthReversalService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCAuthReversalService, default initialized and not managed by a soap context
        virtual ns2__CCAuthReversalService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCAuthReversalService); }
      public:
        /// Constructor with default initializations
        ns2__CCAuthReversalService() : authRequestID(), authRequestToken(), reversalReason(), run(), soap() { }
        virtual ~ns2__CCAuthReversalService() { }
        /// Friend allocator used by soap_new_ns2__CCAuthReversalService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCAuthReversalService * SOAP_FMAC2 soap_instantiate_ns2__CCAuthReversalService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:198 */
#ifndef SOAP_TYPE_ns2__CCAutoAuthReversalService
#define SOAP_TYPE_ns2__CCAutoAuthReversalService (294)
/* complex XML schema type 'ns2:CCAutoAuthReversalService': */
class SOAP_CMAC ns2__CCAutoAuthReversalService {
      public:
        /// Optional element 'ns2:authPaymentServiceData' of XML schema type 'xsd:string'
        std::string *authPaymentServiceData;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:authAmount' of XML schema type 'xsd:string'
        std::string *authAmount;
        /// Optional element 'ns2:commerceIndicator' of XML schema type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:authRequestID' of XML schema type 'xsd:string'
        std::string *authRequestID;
        /// Optional element 'ns2:billAmount' of XML schema type 'xsd:string'
        std::string *billAmount;
        /// Optional element 'ns2:authCode' of XML schema type 'xsd:string'
        std::string *authCode;
        /// Optional element 'ns2:authType' of XML schema type 'xsd:string'
        std::string *authType;
        /// Optional element 'ns2:billPayment' of XML schema type 'ns2:boolean'
        std::string *billPayment;
        /// Optional element 'ns2:dateAdded' of XML schema type 'xsd:string'
        std::string *dateAdded;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCAutoAuthReversalService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCAutoAuthReversalService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCAutoAuthReversalService, default initialized and not managed by a soap context
        virtual ns2__CCAutoAuthReversalService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCAutoAuthReversalService); }
      public:
        /// Constructor with default initializations
        ns2__CCAutoAuthReversalService() : authPaymentServiceData(), reconciliationID(), authAmount(), commerceIndicator(), authRequestID(), billAmount(), authCode(), authType(), billPayment(), dateAdded(), run(), soap() { }
        virtual ~ns2__CCAutoAuthReversalService() { }
        /// Friend allocator used by soap_new_ns2__CCAutoAuthReversalService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCAutoAuthReversalService * SOAP_FMAC2 soap_instantiate_ns2__CCAutoAuthReversalService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:200 */
#ifndef SOAP_TYPE_ns2__CCDCCService
#define SOAP_TYPE_ns2__CCDCCService (295)
/* complex XML schema type 'ns2:CCDCCService': */
class SOAP_CMAC ns2__CCDCCService {
      public:
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCDCCService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCDCCService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCDCCService, default initialized and not managed by a soap context
        virtual ns2__CCDCCService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCDCCService); }
      public:
        /// Constructor with default initializations
        ns2__CCDCCService() : run(), soap() { }
        virtual ~ns2__CCDCCService() { }
        /// Friend allocator used by soap_new_ns2__CCDCCService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCDCCService * SOAP_FMAC2 soap_instantiate_ns2__CCDCCService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:202 */
#ifndef SOAP_TYPE_ns2__ServiceFeeCalculateService
#define SOAP_TYPE_ns2__ServiceFeeCalculateService (296)
/* complex XML schema type 'ns2:ServiceFeeCalculateService': */
class SOAP_CMAC ns2__ServiceFeeCalculateService {
      public:
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ServiceFeeCalculateService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ServiceFeeCalculateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ServiceFeeCalculateService, default initialized and not managed by a soap context
        virtual ns2__ServiceFeeCalculateService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ServiceFeeCalculateService); }
      public:
        /// Constructor with default initializations
        ns2__ServiceFeeCalculateService() : run(), soap() { }
        virtual ~ns2__ServiceFeeCalculateService() { }
        /// Friend allocator used by soap_new_ns2__ServiceFeeCalculateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__ServiceFeeCalculateService * SOAP_FMAC2 soap_instantiate_ns2__ServiceFeeCalculateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:204 */
#ifndef SOAP_TYPE_ns2__ECDebitService
#define SOAP_TYPE_ns2__ECDebitService (297)
/* complex XML schema type 'ns2:ECDebitService': */
class SOAP_CMAC ns2__ECDebitService {
      public:
        /// Optional element 'ns2:paymentMode' of XML schema type 'xsd:integer'
        std::string *paymentMode;
        /// Optional element 'ns2:referenceNumber' of XML schema type 'xsd:string'
        std::string *referenceNumber;
        /// Optional element 'ns2:settlementMethod' of XML schema type 'xsd:string'
        std::string *settlementMethod;
        /// Optional element 'ns2:transactionToken' of XML schema type 'xsd:string'
        std::string *transactionToken;
        /// Optional element 'ns2:verificationLevel' of XML schema type 'xsd:integer'
        std::string *verificationLevel;
        /// Optional element 'ns2:partialPaymentID' of XML schema type 'xsd:string'
        std::string *partialPaymentID;
        /// Optional element 'ns2:commerceIndicator' of XML schema type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:debitRequestID' of XML schema type 'xsd:string'
        std::string *debitRequestID;
        /// Optional element 'ns2:effectiveDate' of XML schema type 'xsd:string'
        std::string *effectiveDate;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ECDebitService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ECDebitService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ECDebitService, default initialized and not managed by a soap context
        virtual ns2__ECDebitService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ECDebitService); }
      public:
        /// Constructor with default initializations
        ns2__ECDebitService() : paymentMode(), referenceNumber(), settlementMethod(), transactionToken(), verificationLevel(), partialPaymentID(), commerceIndicator(), debitRequestID(), effectiveDate(), run(), soap() { }
        virtual ~ns2__ECDebitService() { }
        /// Friend allocator used by soap_new_ns2__ECDebitService(struct soap*, int)
        friend SOAP_FMAC1 ns2__ECDebitService * SOAP_FMAC2 soap_instantiate_ns2__ECDebitService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:206 */
#ifndef SOAP_TYPE_ns2__ECCreditService
#define SOAP_TYPE_ns2__ECCreditService (298)
/* complex XML schema type 'ns2:ECCreditService': */
class SOAP_CMAC ns2__ECCreditService {
      public:
        /// Optional element 'ns2:referenceNumber' of XML schema type 'xsd:string'
        std::string *referenceNumber;
        /// Optional element 'ns2:settlementMethod' of XML schema type 'xsd:string'
        std::string *settlementMethod;
        /// Optional element 'ns2:transactionToken' of XML schema type 'xsd:string'
        std::string *transactionToken;
        /// Optional element 'ns2:debitRequestID' of XML schema type 'xsd:string'
        std::string *debitRequestID;
        /// Optional element 'ns2:partialPaymentID' of XML schema type 'xsd:string'
        std::string *partialPaymentID;
        /// Optional element 'ns2:commerceIndicator' of XML schema type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:debitRequestToken' of XML schema type 'xsd:string'
        std::string *debitRequestToken;
        /// Optional element 'ns2:effectiveDate' of XML schema type 'xsd:string'
        std::string *effectiveDate;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ECCreditService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ECCreditService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ECCreditService, default initialized and not managed by a soap context
        virtual ns2__ECCreditService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ECCreditService); }
      public:
        /// Constructor with default initializations
        ns2__ECCreditService() : referenceNumber(), settlementMethod(), transactionToken(), debitRequestID(), partialPaymentID(), commerceIndicator(), debitRequestToken(), effectiveDate(), run(), soap() { }
        virtual ~ns2__ECCreditService() { }
        /// Friend allocator used by soap_new_ns2__ECCreditService(struct soap*, int)
        friend SOAP_FMAC1 ns2__ECCreditService * SOAP_FMAC2 soap_instantiate_ns2__ECCreditService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:208 */
#ifndef SOAP_TYPE_ns2__ECAuthenticateService
#define SOAP_TYPE_ns2__ECAuthenticateService (299)
/* complex XML schema type 'ns2:ECAuthenticateService': */
class SOAP_CMAC ns2__ECAuthenticateService {
      public:
        /// Optional element 'ns2:referenceNumber' of XML schema type 'xsd:string'
        std::string *referenceNumber;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ECAuthenticateService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ECAuthenticateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ECAuthenticateService, default initialized and not managed by a soap context
        virtual ns2__ECAuthenticateService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ECAuthenticateService); }
      public:
        /// Constructor with default initializations
        ns2__ECAuthenticateService() : referenceNumber(), run(), soap() { }
        virtual ~ns2__ECAuthenticateService() { }
        /// Friend allocator used by soap_new_ns2__ECAuthenticateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__ECAuthenticateService * SOAP_FMAC2 soap_instantiate_ns2__ECAuthenticateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:210 */
#ifndef SOAP_TYPE_ns2__PayerAuthEnrollService
#define SOAP_TYPE_ns2__PayerAuthEnrollService (300)
/* complex XML schema type 'ns2:PayerAuthEnrollService': */
class SOAP_CMAC ns2__PayerAuthEnrollService {
      public:
        /// Optional element 'ns2:httpAccept' of XML schema type 'xsd:string'
        std::string *httpAccept;
        /// Optional element 'ns2:httpUserAgent' of XML schema type 'xsd:string'
        std::string *httpUserAgent;
        /// Optional element 'ns2:merchantName' of XML schema type 'xsd:string'
        std::string *merchantName;
        /// Optional element 'ns2:merchantURL' of XML schema type 'xsd:string'
        std::string *merchantURL;
        /// Optional element 'ns2:purchaseDescription' of XML schema type 'xsd:string'
        std::string *purchaseDescription;
        /// Optional element 'ns2:purchaseTime' of XML schema type 'ns2:dateTime'
        std::string *purchaseTime;
        /// Optional element 'ns2:countryCode' of XML schema type 'xsd:string'
        std::string *countryCode;
        /// Optional element 'ns2:acquirerBin' of XML schema type 'xsd:string'
        std::string *acquirerBin;
        /// Optional element 'ns2:loginID' of XML schema type 'xsd:string'
        std::string *loginID;
        /// Optional element 'ns2:password' of XML schema type 'xsd:string'
        std::string *password;
        /// Optional element 'ns2:merchantID' of XML schema type 'xsd:string'
        std::string *merchantID;
        /// Optional element 'ns2:overridePaymentMethod' of XML schema type 'xsd:string'
        std::string *overridePaymentMethod;
        /// Optional element 'ns2:mobilePhone' of XML schema type 'xsd:string'
        std::string *mobilePhone;
        /// Optional element 'ns2:MCC' of XML schema type 'xsd:string'
        std::string *MCC;
        /// Optional element 'ns2:productCode' of XML schema type 'xsd:string'
        std::string *productCode;
        /// Optional element 'ns2:referenceID' of XML schema type 'xsd:string'
        std::string *referenceID;
        /// Optional element 'ns2:marketingOptIn' of XML schema type 'ns2:boolean'
        std::string *marketingOptIn;
        /// Optional element 'ns2:marketingSource' of XML schema type 'xsd:string'
        std::string *marketingSource;
        /// Optional element 'ns2:defaultCard' of XML schema type 'ns2:boolean'
        std::string *defaultCard;
        /// Optional element 'ns2:shipAddressUsageDate' of XML schema type 'xsd:string'
        std::string *shipAddressUsageDate;
        /// Optional element 'ns2:transactionCountDay' of XML schema type 'xsd:string'
        std::string *transactionCountDay;
        /// Optional element 'ns2:transactionCountYear' of XML schema type 'xsd:string'
        std::string *transactionCountYear;
        /// Optional element 'ns2:addCardAttempts' of XML schema type 'xsd:string'
        std::string *addCardAttempts;
        /// Optional element 'ns2:accountPurchases' of XML schema type 'xsd:string'
        std::string *accountPurchases;
        /// Optional element 'ns2:fraudActivity' of XML schema type 'ns2:boolean'
        std::string *fraudActivity;
        /// Optional element 'ns2:paymentAccountDate' of XML schema type 'xsd:string'
        std::string *paymentAccountDate;
        /// Optional element 'ns2:alternateAuthenticationMethod' of XML schema type 'xsd:string'
        std::string *alternateAuthenticationMethod;
        /// Optional element 'ns2:alternateAuthenticationDate' of XML schema type 'xsd:string'
        std::string *alternateAuthenticationDate;
        /// Optional element 'ns2:alternateAuthenticationData' of XML schema type 'xsd:string'
        std::string *alternateAuthenticationData;
        /// Optional element 'ns2:challengeRequired' of XML schema type 'ns2:boolean'
        std::string *challengeRequired;
        /// Optional element 'ns2:challengeCode' of XML schema type 'xsd:string'
        std::string *challengeCode;
        /// Optional element 'ns2:preorder' of XML schema type 'xsd:string'
        std::string *preorder;
        /// Optional element 'ns2:reorder' of XML schema type 'xsd:string'
        std::string *reorder;
        /// Optional element 'ns2:preorderDate' of XML schema type 'xsd:string'
        std::string *preorderDate;
        /// Optional element 'ns2:giftCardAmount' of XML schema type 'xsd:string'
        std::string *giftCardAmount;
        /// Optional element 'ns2:giftCardCurrency' of XML schema type 'xsd:string'
        std::string *giftCardCurrency;
        /// Optional element 'ns2:giftCardCount' of XML schema type 'xsd:string'
        std::string *giftCardCount;
        /// Optional element 'ns2:messageCategory' of XML schema type 'xsd:string'
        std::string *messageCategory;
        /// Optional element 'ns2:npaCode' of XML schema type 'xsd:string'
        std::string *npaCode;
        /// Optional element 'ns2:recurringOriginalPurchaseDate' of XML schema type 'xsd:string'
        std::string *recurringOriginalPurchaseDate;
        /// Optional element 'ns2:returnURL' of XML schema type 'xsd:string'
        std::string *returnURL;
        /// Optional element 'ns2:transactionMode' of XML schema type 'xsd:string'
        std::string *transactionMode;
        /// Optional element 'ns2:recurringEndDate' of XML schema type 'xsd:string'
        std::string *recurringEndDate;
        /// Optional element 'ns2:recurringFrequency' of XML schema type 'xsd:string'
        std::string *recurringFrequency;
        /// Optional element 'ns2:merchantNewCustomer' of XML schema type 'xsd:string'
        std::string *merchantNewCustomer;
        /// Optional element 'ns2:customerCCAlias' of XML schema type 'xsd:string'
        std::string *customerCCAlias;
        /// Optional element 'ns2:installmentTotalCount' of XML schema type 'xsd:string'
        std::string *installmentTotalCount;
        /// Optional element 'ns2:authenticationTransactionID' of XML schema type 'xsd:string'
        std::string *authenticationTransactionID;
        /// Optional element 'ns2:httpUserAccept' of XML schema type 'xsd:string'
        std::string *httpUserAccept;
        /// Optional element 'ns2:mobilePhoneDomestic' of XML schema type 'xsd:string'
        std::string *mobilePhoneDomestic;
        /// Optional element 'ns2:pareqChannel' of XML schema type 'xsd:string'
        std::string *pareqChannel;
        /// Optional element 'ns2:shoppingChannel' of XML schema type 'xsd:string'
        std::string *shoppingChannel;
        /// Optional element 'ns2:authenticationChannel' of XML schema type 'xsd:string'
        std::string *authenticationChannel;
        /// Optional element 'ns2:merchantTTPCredential' of XML schema type 'xsd:string'
        std::string *merchantTTPCredential;
        /// Optional element 'ns2:requestorID' of XML schema type 'xsd:string'
        std::string *requestorID;
        /// Optional element 'ns2:requestorName' of XML schema type 'xsd:string'
        std::string *requestorName;
        /// Optional element 'ns2:acsWindowSize' of XML schema type 'xsd:integer'
        std::string *acsWindowSize;
        /// Optional element 'ns2:decoupledAuthenticationIndicator' of XML schema type 'xsd:string'
        std::string *decoupledAuthenticationIndicator;
        /// Optional element 'ns2:decoupledAuthenticationMaxTime' of XML schema type 'xsd:integer'
        std::string *decoupledAuthenticationMaxTime;
        /// Optional element 'ns2:deviceChannel' of XML schema type 'xsd:string'
        std::string *deviceChannel;
        /// Optional element 'ns2:priorAuthenticationReferenceID' of XML schema type 'xsd:string'
        std::string *priorAuthenticationReferenceID;
        /// Optional element 'ns2:priorAuthenticationData' of XML schema type 'xsd:string'
        std::string *priorAuthenticationData;
        /// Optional element 'ns2:priorAuthenticationMethod' of XML schema type 'xsd:integer'
        std::string *priorAuthenticationMethod;
        /// Optional element 'ns2:priorAuthenticationTime' of XML schema type 'xsd:integer'
        std::string *priorAuthenticationTime;
        /// Optional element 'ns2:requestorInitiatedAuthenticationIndicator' of XML schema type 'xsd:integer'
        std::string *requestorInitiatedAuthenticationIndicator;
        /// Optional element 'ns2:sdkMaxTimeout' of XML schema type 'xsd:string'
        std::string *sdkMaxTimeout;
        /// Optional element 'ns2:authenticationIndicator' of XML schema type 'xsd:integer'
        std::string *authenticationIndicator;
        /// Optional element 'ns2:whiteListStatus' of XML schema type 'xsd:string'
        std::string *whiteListStatus;
        /// Optional element 'ns2:totalOffersCount' of XML schema type 'xsd:integer'
        std::string *totalOffersCount;
        /// Optional element 'ns2:merchantScore' of XML schema type 'xsd:string'
        std::string *merchantScore;
        /// Optional element 'ns2:merchantFraudRate' of XML schema type 'xsd:integer'
        std::string *merchantFraudRate;
        /// Optional element 'ns2:acquirerCountry' of XML schema type 'xsd:string'
        std::string *acquirerCountry;
        /// Optional element 'ns2:secureCorporatePaymentIndicator' of XML schema type 'xsd:string'
        std::string *secureCorporatePaymentIndicator;
        /// Optional element 'ns2:resendCount' of XML schema type 'xsd:string'
        std::string *resendCount;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayerAuthEnrollService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayerAuthEnrollService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayerAuthEnrollService, default initialized and not managed by a soap context
        virtual ns2__PayerAuthEnrollService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayerAuthEnrollService); }
      public:
        /// Constructor with default initializations
        ns2__PayerAuthEnrollService() : httpAccept(), httpUserAgent(), merchantName(), merchantURL(), purchaseDescription(), purchaseTime(), countryCode(), acquirerBin(), loginID(), password(), merchantID(), overridePaymentMethod(), mobilePhone(), MCC(), productCode(), referenceID(), marketingOptIn(), marketingSource(), defaultCard(), shipAddressUsageDate(), transactionCountDay(), transactionCountYear(), addCardAttempts(), accountPurchases(), fraudActivity(), paymentAccountDate(), alternateAuthenticationMethod(), alternateAuthenticationDate(), alternateAuthenticationData(), challengeRequired(), challengeCode(), preorder(), reorder(), preorderDate(), giftCardAmount(), giftCardCurrency(), giftCardCount(), messageCategory(), npaCode(), recurringOriginalPurchaseDate(), returnURL(), transactionMode(), recurringEndDate(), recurringFrequency(), merchantNewCustomer(), customerCCAlias(), installmentTotalCount(), authenticationTransactionID(), httpUserAccept(), mobilePhoneDomestic(), pareqChannel(), shoppingChannel(), authenticationChannel(), merchantTTPCredential(), requestorID(), requestorName(), acsWindowSize(), decoupledAuthenticationIndicator(), decoupledAuthenticationMaxTime(), deviceChannel(), priorAuthenticationReferenceID(), priorAuthenticationData(), priorAuthenticationMethod(), priorAuthenticationTime(), requestorInitiatedAuthenticationIndicator(), sdkMaxTimeout(), authenticationIndicator(), whiteListStatus(), totalOffersCount(), merchantScore(), merchantFraudRate(), acquirerCountry(), secureCorporatePaymentIndicator(), resendCount(), run(), soap() { }
        virtual ~ns2__PayerAuthEnrollService() { }
        /// Friend allocator used by soap_new_ns2__PayerAuthEnrollService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayerAuthEnrollService * SOAP_FMAC2 soap_instantiate_ns2__PayerAuthEnrollService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:212 */
#ifndef SOAP_TYPE_ns2__PayerAuthValidateService
#define SOAP_TYPE_ns2__PayerAuthValidateService (301)
/* complex XML schema type 'ns2:PayerAuthValidateService': */
class SOAP_CMAC ns2__PayerAuthValidateService {
      public:
        /// Optional element 'ns2:signedPARes' of XML schema type 'xsd:string'
        std::string *signedPARes;
        /// Optional element 'ns2:authenticationTransactionID' of XML schema type 'xsd:string'
        std::string *authenticationTransactionID;
        /// Optional element 'ns2:responseAccessToken' of XML schema type 'xsd:string'
        std::string *responseAccessToken;
        /// Optional element 'ns2:otpToken' of XML schema type 'xsd:string'
        std::string *otpToken;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayerAuthValidateService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayerAuthValidateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayerAuthValidateService, default initialized and not managed by a soap context
        virtual ns2__PayerAuthValidateService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayerAuthValidateService); }
      public:
        /// Constructor with default initializations
        ns2__PayerAuthValidateService() : signedPARes(), authenticationTransactionID(), responseAccessToken(), otpToken(), run(), soap() { }
        virtual ~ns2__PayerAuthValidateService() { }
        /// Friend allocator used by soap_new_ns2__PayerAuthValidateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayerAuthValidateService * SOAP_FMAC2 soap_instantiate_ns2__PayerAuthValidateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:214 */
#ifndef SOAP_TYPE_ns2__PayerAuthSetupService
#define SOAP_TYPE_ns2__PayerAuthSetupService (302)
/* complex XML schema type 'ns2:PayerAuthSetupService': */
class SOAP_CMAC ns2__PayerAuthSetupService {
      public:
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayerAuthSetupService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayerAuthSetupService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayerAuthSetupService, default initialized and not managed by a soap context
        virtual ns2__PayerAuthSetupService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayerAuthSetupService); }
      public:
        /// Constructor with default initializations
        ns2__PayerAuthSetupService() : run(), soap() { }
        virtual ~ns2__PayerAuthSetupService() { }
        /// Friend allocator used by soap_new_ns2__PayerAuthSetupService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayerAuthSetupService * SOAP_FMAC2 soap_instantiate_ns2__PayerAuthSetupService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:216 */
#ifndef SOAP_TYPE_ns2__TaxService
#define SOAP_TYPE_ns2__TaxService (303)
/* complex XML schema type 'ns2:TaxService': */
class SOAP_CMAC ns2__TaxService {
      public:
        /// Optional element 'ns2:nexus' of XML schema type 'xsd:string'
        std::string *nexus;
        /// Optional element 'ns2:noNexus' of XML schema type 'xsd:string'
        std::string *noNexus;
        /// Optional element 'ns2:orderAcceptanceCity' of XML schema type 'xsd:string'
        std::string *orderAcceptanceCity;
        /// Optional element 'ns2:orderAcceptanceCounty' of XML schema type 'xsd:string'
        std::string *orderAcceptanceCounty;
        /// Optional element 'ns2:orderAcceptanceCountry' of XML schema type 'xsd:string'
        std::string *orderAcceptanceCountry;
        /// Optional element 'ns2:orderAcceptanceState' of XML schema type 'xsd:string'
        std::string *orderAcceptanceState;
        /// Optional element 'ns2:orderAcceptancePostalCode' of XML schema type 'xsd:string'
        std::string *orderAcceptancePostalCode;
        /// Optional element 'ns2:orderOriginCity' of XML schema type 'xsd:string'
        std::string *orderOriginCity;
        /// Optional element 'ns2:orderOriginCounty' of XML schema type 'xsd:string'
        std::string *orderOriginCounty;
        /// Optional element 'ns2:orderOriginCountry' of XML schema type 'xsd:string'
        std::string *orderOriginCountry;
        /// Optional element 'ns2:orderOriginState' of XML schema type 'xsd:string'
        std::string *orderOriginState;
        /// Optional element 'ns2:orderOriginPostalCode' of XML schema type 'xsd:string'
        std::string *orderOriginPostalCode;
        /// Optional element 'ns2:sellerRegistration' of XML schema type 'xsd:string'
        std::string *sellerRegistration;
        /// Optional element 'ns2:sellerRegistration0' of XML schema type 'xsd:string'
        std::string *sellerRegistration0;
        /// Optional element 'ns2:sellerRegistration1' of XML schema type 'xsd:string'
        std::string *sellerRegistration1;
        /// Optional element 'ns2:sellerRegistration2' of XML schema type 'xsd:string'
        std::string *sellerRegistration2;
        /// Optional element 'ns2:sellerRegistration3' of XML schema type 'xsd:string'
        std::string *sellerRegistration3;
        /// Optional element 'ns2:sellerRegistration4' of XML schema type 'xsd:string'
        std::string *sellerRegistration4;
        /// Optional element 'ns2:sellerRegistration5' of XML schema type 'xsd:string'
        std::string *sellerRegistration5;
        /// Optional element 'ns2:sellerRegistration6' of XML schema type 'xsd:string'
        std::string *sellerRegistration6;
        /// Optional element 'ns2:sellerRegistration7' of XML schema type 'xsd:string'
        std::string *sellerRegistration7;
        /// Optional element 'ns2:sellerRegistration8' of XML schema type 'xsd:string'
        std::string *sellerRegistration8;
        /// Optional element 'ns2:sellerRegistration9' of XML schema type 'xsd:string'
        std::string *sellerRegistration9;
        /// Optional element 'ns2:buyerRegistration' of XML schema type 'xsd:string'
        std::string *buyerRegistration;
        /// Optional element 'ns2:middlemanRegistration' of XML schema type 'xsd:string'
        std::string *middlemanRegistration;
        /// Optional element 'ns2:pointOfTitleTransfer' of XML schema type 'xsd:string'
        std::string *pointOfTitleTransfer;
        /// Optional element 'ns2:commitIndicator' of XML schema type 'xsd:string'
        std::string *commitIndicator;
        /// Optional element 'ns2:refundIndicator' of XML schema type 'xsd:string'
        std::string *refundIndicator;
        /// Optional element 'ns2:dateOverrideReason' of XML schema type 'xsd:string'
        std::string *dateOverrideReason;
        /// Optional element 'ns2:reportingDate' of XML schema type 'xsd:string'
        std::string *reportingDate;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__TaxService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__TaxService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__TaxService, default initialized and not managed by a soap context
        virtual ns2__TaxService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__TaxService); }
      public:
        /// Constructor with default initializations
        ns2__TaxService() : nexus(), noNexus(), orderAcceptanceCity(), orderAcceptanceCounty(), orderAcceptanceCountry(), orderAcceptanceState(), orderAcceptancePostalCode(), orderOriginCity(), orderOriginCounty(), orderOriginCountry(), orderOriginState(), orderOriginPostalCode(), sellerRegistration(), sellerRegistration0(), sellerRegistration1(), sellerRegistration2(), sellerRegistration3(), sellerRegistration4(), sellerRegistration5(), sellerRegistration6(), sellerRegistration7(), sellerRegistration8(), sellerRegistration9(), buyerRegistration(), middlemanRegistration(), pointOfTitleTransfer(), commitIndicator(), refundIndicator(), dateOverrideReason(), reportingDate(), run(), soap() { }
        virtual ~ns2__TaxService() { }
        /// Friend allocator used by soap_new_ns2__TaxService(struct soap*, int)
        friend SOAP_FMAC1 ns2__TaxService * SOAP_FMAC2 soap_instantiate_ns2__TaxService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:218 */
#ifndef SOAP_TYPE_ns2__DMEService
#define SOAP_TYPE_ns2__DMEService (304)
/* complex XML schema type 'ns2:DMEService': */
class SOAP_CMAC ns2__DMEService {
      public:
        /// Optional element 'ns2:eventType' of XML schema type 'xsd:string'
        std::string *eventType;
        /// Optional element 'ns2:eventPolicy' of XML schema type 'xsd:string'
        std::string *eventPolicy;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DMEService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DMEService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DMEService, default initialized and not managed by a soap context
        virtual ns2__DMEService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DMEService); }
      public:
        /// Constructor with default initializations
        ns2__DMEService() : eventType(), eventPolicy(), run(), soap() { }
        virtual ~ns2__DMEService() { }
        /// Friend allocator used by soap_new_ns2__DMEService(struct soap*, int)
        friend SOAP_FMAC1 ns2__DMEService * SOAP_FMAC2 soap_instantiate_ns2__DMEService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:220 */
#ifndef SOAP_TYPE_ns2__AFSService
#define SOAP_TYPE_ns2__AFSService (305)
/* complex XML schema type 'ns2:AFSService': */
class SOAP_CMAC ns2__AFSService {
      public:
        /// Optional element 'ns2:avsCode' of XML schema type 'xsd:string'
        std::string *avsCode;
        /// Optional element 'ns2:cvCode' of XML schema type 'xsd:string'
        std::string *cvCode;
        /// Optional element 'ns2:disableAVSScoring' of XML schema type 'ns2:boolean'
        std::string *disableAVSScoring;
        /// Optional element 'ns2:customRiskModel' of XML schema type 'xsd:string'
        std::string *customRiskModel;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AFSService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__AFSService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AFSService, default initialized and not managed by a soap context
        virtual ns2__AFSService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__AFSService); }
      public:
        /// Constructor with default initializations
        ns2__AFSService() : avsCode(), cvCode(), disableAVSScoring(), customRiskModel(), run(), soap() { }
        virtual ~ns2__AFSService() { }
        /// Friend allocator used by soap_new_ns2__AFSService(struct soap*, int)
        friend SOAP_FMAC1 ns2__AFSService * SOAP_FMAC2 soap_instantiate_ns2__AFSService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:222 */
#ifndef SOAP_TYPE_ns2__DAVService
#define SOAP_TYPE_ns2__DAVService (306)
/* complex XML schema type 'ns2:DAVService': */
class SOAP_CMAC ns2__DAVService {
      public:
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DAVService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DAVService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DAVService, default initialized and not managed by a soap context
        virtual ns2__DAVService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DAVService); }
      public:
        /// Constructor with default initializations
        ns2__DAVService() : run(), soap() { }
        virtual ~ns2__DAVService() { }
        /// Friend allocator used by soap_new_ns2__DAVService(struct soap*, int)
        friend SOAP_FMAC1 ns2__DAVService * SOAP_FMAC2 soap_instantiate_ns2__DAVService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:224 */
#ifndef SOAP_TYPE_ns2__ExportService
#define SOAP_TYPE_ns2__ExportService (307)
/* complex XML schema type 'ns2:ExportService': */
class SOAP_CMAC ns2__ExportService {
      public:
        /// Optional element 'ns2:addressOperator' of XML schema type 'xsd:string'
        std::string *addressOperator;
        /// Optional element 'ns2:addressWeight' of XML schema type 'xsd:string'
        std::string *addressWeight;
        /// Optional element 'ns2:companyWeight' of XML schema type 'xsd:string'
        std::string *companyWeight;
        /// Optional element 'ns2:nameWeight' of XML schema type 'xsd:string'
        std::string *nameWeight;
        /// Optional element 'ns2:sanctionsLists' of XML schema type 'xsd:string'
        std::string *sanctionsLists;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ExportService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ExportService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ExportService, default initialized and not managed by a soap context
        virtual ns2__ExportService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ExportService); }
      public:
        /// Constructor with default initializations
        ns2__ExportService() : addressOperator(), addressWeight(), companyWeight(), nameWeight(), sanctionsLists(), run(), soap() { }
        virtual ~ns2__ExportService() { }
        /// Friend allocator used by soap_new_ns2__ExportService(struct soap*, int)
        friend SOAP_FMAC1 ns2__ExportService * SOAP_FMAC2 soap_instantiate_ns2__ExportService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:226 */
#ifndef SOAP_TYPE_ns2__FXRatesService
#define SOAP_TYPE_ns2__FXRatesService (308)
/* complex XML schema type 'ns2:FXRatesService': */
class SOAP_CMAC ns2__FXRatesService {
      public:
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FXRatesService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__FXRatesService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FXRatesService, default initialized and not managed by a soap context
        virtual ns2__FXRatesService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__FXRatesService); }
      public:
        /// Constructor with default initializations
        ns2__FXRatesService() : run(), soap() { }
        virtual ~ns2__FXRatesService() { }
        /// Friend allocator used by soap_new_ns2__FXRatesService(struct soap*, int)
        friend SOAP_FMAC1 ns2__FXRatesService * SOAP_FMAC2 soap_instantiate_ns2__FXRatesService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:228 */
#ifndef SOAP_TYPE_ns2__BankTransferService
#define SOAP_TYPE_ns2__BankTransferService (309)
/* complex XML schema type 'ns2:BankTransferService': */
class SOAP_CMAC ns2__BankTransferService {
      public:
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BankTransferService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__BankTransferService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BankTransferService, default initialized and not managed by a soap context
        virtual ns2__BankTransferService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__BankTransferService); }
      public:
        /// Constructor with default initializations
        ns2__BankTransferService() : run(), soap() { }
        virtual ~ns2__BankTransferService() { }
        /// Friend allocator used by soap_new_ns2__BankTransferService(struct soap*, int)
        friend SOAP_FMAC1 ns2__BankTransferService * SOAP_FMAC2 soap_instantiate_ns2__BankTransferService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:230 */
#ifndef SOAP_TYPE_ns2__BankTransferRefundService
#define SOAP_TYPE_ns2__BankTransferRefundService (310)
/* complex XML schema type 'ns2:BankTransferRefundService': */
class SOAP_CMAC ns2__BankTransferRefundService {
      public:
        /// Optional element 'ns2:bankTransferRequestID' of XML schema type 'xsd:string'
        std::string *bankTransferRequestID;
        /// Optional element 'ns2:bankTransferRealTimeRequestID' of XML schema type 'xsd:string'
        std::string *bankTransferRealTimeRequestID;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:bankTransferRealTimeReconciliationID' of XML schema type 'xsd:string'
        std::string *bankTransferRealTimeReconciliationID;
        /// Optional element 'ns2:bankTransferRequestToken' of XML schema type 'xsd:string'
        std::string *bankTransferRequestToken;
        /// Optional element 'ns2:bankTransferRealTimeRequestToken' of XML schema type 'xsd:string'
        std::string *bankTransferRealTimeRequestToken;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BankTransferRefundService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__BankTransferRefundService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BankTransferRefundService, default initialized and not managed by a soap context
        virtual ns2__BankTransferRefundService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__BankTransferRefundService); }
      public:
        /// Constructor with default initializations
        ns2__BankTransferRefundService() : bankTransferRequestID(), bankTransferRealTimeRequestID(), reconciliationID(), bankTransferRealTimeReconciliationID(), bankTransferRequestToken(), bankTransferRealTimeRequestToken(), run(), soap() { }
        virtual ~ns2__BankTransferRefundService() { }
        /// Friend allocator used by soap_new_ns2__BankTransferRefundService(struct soap*, int)
        friend SOAP_FMAC1 ns2__BankTransferRefundService * SOAP_FMAC2 soap_instantiate_ns2__BankTransferRefundService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:232 */
#ifndef SOAP_TYPE_ns2__BankTransferRealTimeService
#define SOAP_TYPE_ns2__BankTransferRealTimeService (311)
/* complex XML schema type 'ns2:BankTransferRealTimeService': */
class SOAP_CMAC ns2__BankTransferRealTimeService {
      public:
        /// Optional element 'ns2:bankTransferRealTimeType' of XML schema type 'xsd:string'
        std::string *bankTransferRealTimeType;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BankTransferRealTimeService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__BankTransferRealTimeService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BankTransferRealTimeService, default initialized and not managed by a soap context
        virtual ns2__BankTransferRealTimeService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__BankTransferRealTimeService); }
      public:
        /// Constructor with default initializations
        ns2__BankTransferRealTimeService() : bankTransferRealTimeType(), run(), soap() { }
        virtual ~ns2__BankTransferRealTimeService() { }
        /// Friend allocator used by soap_new_ns2__BankTransferRealTimeService(struct soap*, int)
        friend SOAP_FMAC1 ns2__BankTransferRealTimeService * SOAP_FMAC2 soap_instantiate_ns2__BankTransferRealTimeService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:234 */
#ifndef SOAP_TYPE_ns2__DirectDebitMandateService
#define SOAP_TYPE_ns2__DirectDebitMandateService (312)
/* complex XML schema type 'ns2:DirectDebitMandateService': */
class SOAP_CMAC ns2__DirectDebitMandateService {
      public:
        /// Optional element 'ns2:mandateDescriptor' of XML schema type 'xsd:string'
        std::string *mandateDescriptor;
        /// Optional element 'ns2:firstDebitDate' of XML schema type 'xsd:string'
        std::string *firstDebitDate;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DirectDebitMandateService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DirectDebitMandateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DirectDebitMandateService, default initialized and not managed by a soap context
        virtual ns2__DirectDebitMandateService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DirectDebitMandateService); }
      public:
        /// Constructor with default initializations
        ns2__DirectDebitMandateService() : mandateDescriptor(), firstDebitDate(), run(), soap() { }
        virtual ~ns2__DirectDebitMandateService() { }
        /// Friend allocator used by soap_new_ns2__DirectDebitMandateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__DirectDebitMandateService * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitMandateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:236 */
#ifndef SOAP_TYPE_ns2__DirectDebitService
#define SOAP_TYPE_ns2__DirectDebitService (313)
/* complex XML schema type 'ns2:DirectDebitService': */
class SOAP_CMAC ns2__DirectDebitService {
      public:
        /// Optional element 'ns2:dateCollect' of XML schema type 'xsd:string'
        std::string *dateCollect;
        /// Optional element 'ns2:directDebitText' of XML schema type 'xsd:string'
        std::string *directDebitText;
        /// Optional element 'ns2:authorizationID' of XML schema type 'xsd:string'
        std::string *authorizationID;
        /// Optional element 'ns2:transactionType' of XML schema type 'xsd:string'
        std::string *transactionType;
        /// Optional element 'ns2:directDebitType' of XML schema type 'xsd:string'
        std::string *directDebitType;
        /// Optional element 'ns2:validateRequestID' of XML schema type 'xsd:string'
        std::string *validateRequestID;
        /// Optional element 'ns2:recurringType' of XML schema type 'xsd:string'
        std::string *recurringType;
        /// Optional element 'ns2:mandateID' of XML schema type 'xsd:string'
        std::string *mandateID;
        /// Optional element 'ns2:validateRequestToken' of XML schema type 'xsd:string'
        std::string *validateRequestToken;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:mandateAuthenticationDate' of XML schema type 'xsd:string'
        std::string *mandateAuthenticationDate;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DirectDebitService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DirectDebitService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DirectDebitService, default initialized and not managed by a soap context
        virtual ns2__DirectDebitService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DirectDebitService); }
      public:
        /// Constructor with default initializations
        ns2__DirectDebitService() : dateCollect(), directDebitText(), authorizationID(), transactionType(), directDebitType(), validateRequestID(), recurringType(), mandateID(), validateRequestToken(), reconciliationID(), mandateAuthenticationDate(), run(), soap() { }
        virtual ~ns2__DirectDebitService() { }
        /// Friend allocator used by soap_new_ns2__DirectDebitService(struct soap*, int)
        friend SOAP_FMAC1 ns2__DirectDebitService * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:238 */
#ifndef SOAP_TYPE_ns2__DirectDebitRefundService
#define SOAP_TYPE_ns2__DirectDebitRefundService (314)
/* complex XML schema type 'ns2:DirectDebitRefundService': */
class SOAP_CMAC ns2__DirectDebitRefundService {
      public:
        /// Optional element 'ns2:directDebitRequestID' of XML schema type 'xsd:string'
        std::string *directDebitRequestID;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:directDebitRequestToken' of XML schema type 'xsd:string'
        std::string *directDebitRequestToken;
        /// Optional element 'ns2:directDebitType' of XML schema type 'xsd:string'
        std::string *directDebitType;
        /// Optional element 'ns2:recurringType' of XML schema type 'xsd:string'
        std::string *recurringType;
        /// Optional element 'ns2:mandateID' of XML schema type 'xsd:string'
        std::string *mandateID;
        /// Optional element 'ns2:mandateAuthenticationDate' of XML schema type 'xsd:string'
        std::string *mandateAuthenticationDate;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DirectDebitRefundService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DirectDebitRefundService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DirectDebitRefundService, default initialized and not managed by a soap context
        virtual ns2__DirectDebitRefundService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DirectDebitRefundService); }
      public:
        /// Constructor with default initializations
        ns2__DirectDebitRefundService() : directDebitRequestID(), reconciliationID(), directDebitRequestToken(), directDebitType(), recurringType(), mandateID(), mandateAuthenticationDate(), run(), soap() { }
        virtual ~ns2__DirectDebitRefundService() { }
        /// Friend allocator used by soap_new_ns2__DirectDebitRefundService(struct soap*, int)
        friend SOAP_FMAC1 ns2__DirectDebitRefundService * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitRefundService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:240 */
#ifndef SOAP_TYPE_ns2__DirectDebitValidateService
#define SOAP_TYPE_ns2__DirectDebitValidateService (315)
/* complex XML schema type 'ns2:DirectDebitValidateService': */
class SOAP_CMAC ns2__DirectDebitValidateService {
      public:
        /// Optional element 'ns2:directDebitValidateText' of XML schema type 'xsd:string'
        std::string *directDebitValidateText;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DirectDebitValidateService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DirectDebitValidateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DirectDebitValidateService, default initialized and not managed by a soap context
        virtual ns2__DirectDebitValidateService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DirectDebitValidateService); }
      public:
        /// Constructor with default initializations
        ns2__DirectDebitValidateService() : directDebitValidateText(), run(), soap() { }
        virtual ~ns2__DirectDebitValidateService() { }
        /// Friend allocator used by soap_new_ns2__DirectDebitValidateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__DirectDebitValidateService * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitValidateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:242 */
#ifndef SOAP_TYPE_ns2__DeviceFingerprintData
#define SOAP_TYPE_ns2__DeviceFingerprintData (316)
/* complex XML schema type 'ns2:DeviceFingerprintData': */
class SOAP_CMAC ns2__DeviceFingerprintData {
      public:
        /// Optional element 'ns2:data' of XML schema type 'xsd:string'
        std::string *data;
        /// Optional element 'ns2:provider' of XML schema type 'xsd:string'
        std::string *provider;
        /// Required attribute 'id' of XML schema type 'xsd:integer'
        std::string id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DeviceFingerprintData
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DeviceFingerprintData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DeviceFingerprintData, default initialized and not managed by a soap context
        virtual ns2__DeviceFingerprintData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DeviceFingerprintData); }
      public:
        /// Constructor with default initializations
        ns2__DeviceFingerprintData() : data(), provider(), id(), soap() { }
        virtual ~ns2__DeviceFingerprintData() { }
        /// Friend allocator used by soap_new_ns2__DeviceFingerprintData(struct soap*, int)
        friend SOAP_FMAC1 ns2__DeviceFingerprintData * SOAP_FMAC2 soap_instantiate_ns2__DeviceFingerprintData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:244 */
#ifndef SOAP_TYPE_ns2__PaySubscriptionCreateService
#define SOAP_TYPE_ns2__PaySubscriptionCreateService (317)
/* complex XML schema type 'ns2:PaySubscriptionCreateService': */
class SOAP_CMAC ns2__PaySubscriptionCreateService {
      public:
        /// Optional element 'ns2:paymentRequestID' of XML schema type 'xsd:string'
        std::string *paymentRequestID;
        /// Optional element 'ns2:paymentRequestToken' of XML schema type 'xsd:string'
        std::string *paymentRequestToken;
        /// Optional element 'ns2:disableAutoAuth' of XML schema type 'ns2:boolean'
        std::string *disableAutoAuth;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaySubscriptionCreateService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PaySubscriptionCreateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaySubscriptionCreateService, default initialized and not managed by a soap context
        virtual ns2__PaySubscriptionCreateService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PaySubscriptionCreateService); }
      public:
        /// Constructor with default initializations
        ns2__PaySubscriptionCreateService() : paymentRequestID(), paymentRequestToken(), disableAutoAuth(), run(), soap() { }
        virtual ~ns2__PaySubscriptionCreateService() { }
        /// Friend allocator used by soap_new_ns2__PaySubscriptionCreateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaySubscriptionCreateService * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionCreateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:246 */
#ifndef SOAP_TYPE_ns2__PaySubscriptionUpdateService
#define SOAP_TYPE_ns2__PaySubscriptionUpdateService (318)
/* complex XML schema type 'ns2:PaySubscriptionUpdateService': */
class SOAP_CMAC ns2__PaySubscriptionUpdateService {
      public:
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaySubscriptionUpdateService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PaySubscriptionUpdateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaySubscriptionUpdateService, default initialized and not managed by a soap context
        virtual ns2__PaySubscriptionUpdateService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PaySubscriptionUpdateService); }
      public:
        /// Constructor with default initializations
        ns2__PaySubscriptionUpdateService() : run(), soap() { }
        virtual ~ns2__PaySubscriptionUpdateService() { }
        /// Friend allocator used by soap_new_ns2__PaySubscriptionUpdateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaySubscriptionUpdateService * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionUpdateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:248 */
#ifndef SOAP_TYPE_ns2__PaySubscriptionEventUpdateService
#define SOAP_TYPE_ns2__PaySubscriptionEventUpdateService (319)
/* complex XML schema type 'ns2:PaySubscriptionEventUpdateService': */
class SOAP_CMAC ns2__PaySubscriptionEventUpdateService {
      public:
        /// Optional element 'ns2:action' of XML schema type 'xsd:string'
        std::string *action;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaySubscriptionEventUpdateService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PaySubscriptionEventUpdateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaySubscriptionEventUpdateService, default initialized and not managed by a soap context
        virtual ns2__PaySubscriptionEventUpdateService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PaySubscriptionEventUpdateService); }
      public:
        /// Constructor with default initializations
        ns2__PaySubscriptionEventUpdateService() : action(), run(), soap() { }
        virtual ~ns2__PaySubscriptionEventUpdateService() { }
        /// Friend allocator used by soap_new_ns2__PaySubscriptionEventUpdateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaySubscriptionEventUpdateService * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionEventUpdateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:250 */
#ifndef SOAP_TYPE_ns2__PaySubscriptionRetrieveService
#define SOAP_TYPE_ns2__PaySubscriptionRetrieveService (320)
/* complex XML schema type 'ns2:PaySubscriptionRetrieveService': */
class SOAP_CMAC ns2__PaySubscriptionRetrieveService {
      public:
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaySubscriptionRetrieveService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PaySubscriptionRetrieveService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaySubscriptionRetrieveService, default initialized and not managed by a soap context
        virtual ns2__PaySubscriptionRetrieveService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PaySubscriptionRetrieveService); }
      public:
        /// Constructor with default initializations
        ns2__PaySubscriptionRetrieveService() : run(), soap() { }
        virtual ~ns2__PaySubscriptionRetrieveService() { }
        /// Friend allocator used by soap_new_ns2__PaySubscriptionRetrieveService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaySubscriptionRetrieveService * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionRetrieveService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:252 */
#ifndef SOAP_TYPE_ns2__PaySubscriptionDeleteService
#define SOAP_TYPE_ns2__PaySubscriptionDeleteService (321)
/* complex XML schema type 'ns2:PaySubscriptionDeleteService': */
class SOAP_CMAC ns2__PaySubscriptionDeleteService {
      public:
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaySubscriptionDeleteService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PaySubscriptionDeleteService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaySubscriptionDeleteService, default initialized and not managed by a soap context
        virtual ns2__PaySubscriptionDeleteService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PaySubscriptionDeleteService); }
      public:
        /// Constructor with default initializations
        ns2__PaySubscriptionDeleteService() : run(), soap() { }
        virtual ~ns2__PaySubscriptionDeleteService() { }
        /// Friend allocator used by soap_new_ns2__PaySubscriptionDeleteService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaySubscriptionDeleteService * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionDeleteService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:254 */
#ifndef SOAP_TYPE_ns2__PayPalPaymentService
#define SOAP_TYPE_ns2__PayPalPaymentService (322)
/* complex XML schema type 'ns2:PayPalPaymentService': */
class SOAP_CMAC ns2__PayPalPaymentService {
      public:
        /// Optional element 'ns2:cancelURL' of XML schema type 'xsd:string'
        std::string *cancelURL;
        /// Optional element 'ns2:successURL' of XML schema type 'xsd:string'
        std::string *successURL;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalPaymentService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalPaymentService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalPaymentService, default initialized and not managed by a soap context
        virtual ns2__PayPalPaymentService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalPaymentService); }
      public:
        /// Constructor with default initializations
        ns2__PayPalPaymentService() : cancelURL(), successURL(), reconciliationID(), run(), soap() { }
        virtual ~ns2__PayPalPaymentService() { }
        /// Friend allocator used by soap_new_ns2__PayPalPaymentService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalPaymentService * SOAP_FMAC2 soap_instantiate_ns2__PayPalPaymentService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:256 */
#ifndef SOAP_TYPE_ns2__PayPalCreditService
#define SOAP_TYPE_ns2__PayPalCreditService (323)
/* complex XML schema type 'ns2:PayPalCreditService': */
class SOAP_CMAC ns2__PayPalCreditService {
      public:
        /// Optional element 'ns2:payPalPaymentRequestID' of XML schema type 'xsd:string'
        std::string *payPalPaymentRequestID;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:payPalPaymentRequestToken' of XML schema type 'xsd:string'
        std::string *payPalPaymentRequestToken;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalCreditService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalCreditService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalCreditService, default initialized and not managed by a soap context
        virtual ns2__PayPalCreditService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalCreditService); }
      public:
        /// Constructor with default initializations
        ns2__PayPalCreditService() : payPalPaymentRequestID(), reconciliationID(), payPalPaymentRequestToken(), run(), soap() { }
        virtual ~ns2__PayPalCreditService() { }
        /// Friend allocator used by soap_new_ns2__PayPalCreditService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalCreditService * SOAP_FMAC2 soap_instantiate_ns2__PayPalCreditService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:258 */
#ifndef SOAP_TYPE_ns2__PayPalEcSetService
#define SOAP_TYPE_ns2__PayPalEcSetService (324)
/* complex XML schema type 'ns2:PayPalEcSetService': */
class SOAP_CMAC ns2__PayPalEcSetService {
      public:
        /// Optional element 'ns2:paypalReturn' of XML schema type 'xsd:string'
        std::string *paypalReturn;
        /// Optional element 'ns2:paypalCancelReturn' of XML schema type 'xsd:string'
        std::string *paypalCancelReturn;
        /// Optional element 'ns2:paypalMaxamt' of XML schema type 'xsd:string'
        std::string *paypalMaxamt;
        /// Optional element 'ns2:paypalCustomerEmail' of XML schema type 'xsd:string'
        std::string *paypalCustomerEmail;
        /// Optional element 'ns2:paypalDesc' of XML schema type 'xsd:string'
        std::string *paypalDesc;
        /// Optional element 'ns2:paypalReqconfirmshipping' of XML schema type 'xsd:string'
        std::string *paypalReqconfirmshipping;
        /// Optional element 'ns2:paypalNoshipping' of XML schema type 'xsd:string'
        std::string *paypalNoshipping;
        /// Optional element 'ns2:paypalAddressOverride' of XML schema type 'xsd:string'
        std::string *paypalAddressOverride;
        /// Optional element 'ns2:paypalToken' of XML schema type 'xsd:string'
        std::string *paypalToken;
        /// Optional element 'ns2:paypalLc' of XML schema type 'xsd:string'
        std::string *paypalLc;
        /// Optional element 'ns2:paypalPagestyle' of XML schema type 'xsd:string'
        std::string *paypalPagestyle;
        /// Optional element 'ns2:paypalHdrimg' of XML schema type 'xsd:string'
        std::string *paypalHdrimg;
        /// Optional element 'ns2:paypalHdrbordercolor' of XML schema type 'xsd:string'
        std::string *paypalHdrbordercolor;
        /// Optional element 'ns2:paypalHdrbackcolor' of XML schema type 'xsd:string'
        std::string *paypalHdrbackcolor;
        /// Optional element 'ns2:paypalPayflowcolor' of XML schema type 'xsd:string'
        std::string *paypalPayflowcolor;
        /// Optional element 'ns2:paypalEcSetRequestID' of XML schema type 'xsd:string'
        std::string *paypalEcSetRequestID;
        /// Optional element 'ns2:paypalEcSetRequestToken' of XML schema type 'xsd:string'
        std::string *paypalEcSetRequestToken;
        /// Optional element 'ns2:promoCode0' of XML schema type 'xsd:string'
        std::string *promoCode0;
        /// Optional element 'ns2:requestBillingAddress' of XML schema type 'xsd:string'
        std::string *requestBillingAddress;
        /// Optional element 'ns2:invoiceNumber' of XML schema type 'xsd:string'
        std::string *invoiceNumber;
        /// Optional element 'ns2:paypalBillingType' of XML schema type 'xsd:string'
        std::string *paypalBillingType;
        /// Optional element 'ns2:paypalBillingAgreementDesc' of XML schema type 'xsd:string'
        std::string *paypalBillingAgreementDesc;
        /// Optional element 'ns2:paypalPaymentType' of XML schema type 'xsd:string'
        std::string *paypalPaymentType;
        /// Optional element 'ns2:paypalBillingAgreementCustom' of XML schema type 'xsd:string'
        std::string *paypalBillingAgreementCustom;
        /// Optional element 'ns2:paypalLogoimg' of XML schema type 'xsd:string'
        std::string *paypalLogoimg;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalEcSetService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalEcSetService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalEcSetService, default initialized and not managed by a soap context
        virtual ns2__PayPalEcSetService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalEcSetService); }
      public:
        /// Constructor with default initializations
        ns2__PayPalEcSetService() : paypalReturn(), paypalCancelReturn(), paypalMaxamt(), paypalCustomerEmail(), paypalDesc(), paypalReqconfirmshipping(), paypalNoshipping(), paypalAddressOverride(), paypalToken(), paypalLc(), paypalPagestyle(), paypalHdrimg(), paypalHdrbordercolor(), paypalHdrbackcolor(), paypalPayflowcolor(), paypalEcSetRequestID(), paypalEcSetRequestToken(), promoCode0(), requestBillingAddress(), invoiceNumber(), paypalBillingType(), paypalBillingAgreementDesc(), paypalPaymentType(), paypalBillingAgreementCustom(), paypalLogoimg(), run(), soap() { }
        virtual ~ns2__PayPalEcSetService() { }
        /// Friend allocator used by soap_new_ns2__PayPalEcSetService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalEcSetService * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcSetService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:260 */
#ifndef SOAP_TYPE_ns2__PayPalEcGetDetailsService
#define SOAP_TYPE_ns2__PayPalEcGetDetailsService (325)
/* complex XML schema type 'ns2:PayPalEcGetDetailsService': */
class SOAP_CMAC ns2__PayPalEcGetDetailsService {
      public:
        /// Optional element 'ns2:paypalToken' of XML schema type 'xsd:string'
        std::string *paypalToken;
        /// Optional element 'ns2:paypalEcSetRequestID' of XML schema type 'xsd:string'
        std::string *paypalEcSetRequestID;
        /// Optional element 'ns2:paypalEcSetRequestToken' of XML schema type 'xsd:string'
        std::string *paypalEcSetRequestToken;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalEcGetDetailsService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalEcGetDetailsService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalEcGetDetailsService, default initialized and not managed by a soap context
        virtual ns2__PayPalEcGetDetailsService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalEcGetDetailsService); }
      public:
        /// Constructor with default initializations
        ns2__PayPalEcGetDetailsService() : paypalToken(), paypalEcSetRequestID(), paypalEcSetRequestToken(), run(), soap() { }
        virtual ~ns2__PayPalEcGetDetailsService() { }
        /// Friend allocator used by soap_new_ns2__PayPalEcGetDetailsService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalEcGetDetailsService * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcGetDetailsService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:262 */
#ifndef SOAP_TYPE_ns2__PayPalEcDoPaymentService
#define SOAP_TYPE_ns2__PayPalEcDoPaymentService (326)
/* complex XML schema type 'ns2:PayPalEcDoPaymentService': */
class SOAP_CMAC ns2__PayPalEcDoPaymentService {
      public:
        /// Optional element 'ns2:paypalToken' of XML schema type 'xsd:string'
        std::string *paypalToken;
        /// Optional element 'ns2:paypalPayerId' of XML schema type 'xsd:string'
        std::string *paypalPayerId;
        /// Optional element 'ns2:paypalCustomerEmail' of XML schema type 'xsd:string'
        std::string *paypalCustomerEmail;
        /// Optional element 'ns2:paypalDesc' of XML schema type 'xsd:string'
        std::string *paypalDesc;
        /// Optional element 'ns2:paypalEcSetRequestID' of XML schema type 'xsd:string'
        std::string *paypalEcSetRequestID;
        /// Optional element 'ns2:paypalEcSetRequestToken' of XML schema type 'xsd:string'
        std::string *paypalEcSetRequestToken;
        /// Optional element 'ns2:promoCode0' of XML schema type 'xsd:string'
        std::string *promoCode0;
        /// Optional element 'ns2:invoiceNumber' of XML schema type 'xsd:string'
        std::string *invoiceNumber;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalEcDoPaymentService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalEcDoPaymentService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalEcDoPaymentService, default initialized and not managed by a soap context
        virtual ns2__PayPalEcDoPaymentService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalEcDoPaymentService); }
      public:
        /// Constructor with default initializations
        ns2__PayPalEcDoPaymentService() : paypalToken(), paypalPayerId(), paypalCustomerEmail(), paypalDesc(), paypalEcSetRequestID(), paypalEcSetRequestToken(), promoCode0(), invoiceNumber(), run(), soap() { }
        virtual ~ns2__PayPalEcDoPaymentService() { }
        /// Friend allocator used by soap_new_ns2__PayPalEcDoPaymentService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalEcDoPaymentService * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcDoPaymentService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:264 */
#ifndef SOAP_TYPE_ns2__PayPalDoCaptureService
#define SOAP_TYPE_ns2__PayPalDoCaptureService (327)
/* complex XML schema type 'ns2:PayPalDoCaptureService': */
class SOAP_CMAC ns2__PayPalDoCaptureService {
      public:
        /// Optional element 'ns2:paypalAuthorizationId' of XML schema type 'xsd:string'
        std::string *paypalAuthorizationId;
        /// Optional element 'ns2:completeType' of XML schema type 'xsd:string'
        std::string *completeType;
        /// Optional element 'ns2:paypalEcDoPaymentRequestID' of XML schema type 'xsd:string'
        std::string *paypalEcDoPaymentRequestID;
        /// Optional element 'ns2:paypalEcDoPaymentRequestToken' of XML schema type 'xsd:string'
        std::string *paypalEcDoPaymentRequestToken;
        /// Optional element 'ns2:paypalAuthorizationRequestID' of XML schema type 'xsd:string'
        std::string *paypalAuthorizationRequestID;
        /// Optional element 'ns2:paypalAuthorizationRequestToken' of XML schema type 'xsd:string'
        std::string *paypalAuthorizationRequestToken;
        /// Optional element 'ns2:invoiceNumber' of XML schema type 'xsd:string'
        std::string *invoiceNumber;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalDoCaptureService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalDoCaptureService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalDoCaptureService, default initialized and not managed by a soap context
        virtual ns2__PayPalDoCaptureService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalDoCaptureService); }
      public:
        /// Constructor with default initializations
        ns2__PayPalDoCaptureService() : paypalAuthorizationId(), completeType(), paypalEcDoPaymentRequestID(), paypalEcDoPaymentRequestToken(), paypalAuthorizationRequestID(), paypalAuthorizationRequestToken(), invoiceNumber(), run(), soap() { }
        virtual ~ns2__PayPalDoCaptureService() { }
        /// Friend allocator used by soap_new_ns2__PayPalDoCaptureService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalDoCaptureService * SOAP_FMAC2 soap_instantiate_ns2__PayPalDoCaptureService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:266 */
#ifndef SOAP_TYPE_ns2__PayPalAuthReversalService
#define SOAP_TYPE_ns2__PayPalAuthReversalService (328)
/* complex XML schema type 'ns2:PayPalAuthReversalService': */
class SOAP_CMAC ns2__PayPalAuthReversalService {
      public:
        /// Optional element 'ns2:paypalAuthorizationId' of XML schema type 'xsd:string'
        std::string *paypalAuthorizationId;
        /// Optional element 'ns2:paypalEcDoPaymentRequestID' of XML schema type 'xsd:string'
        std::string *paypalEcDoPaymentRequestID;
        /// Optional element 'ns2:paypalEcDoPaymentRequestToken' of XML schema type 'xsd:string'
        std::string *paypalEcDoPaymentRequestToken;
        /// Optional element 'ns2:paypalAuthorizationRequestID' of XML schema type 'xsd:string'
        std::string *paypalAuthorizationRequestID;
        /// Optional element 'ns2:paypalAuthorizationRequestToken' of XML schema type 'xsd:string'
        std::string *paypalAuthorizationRequestToken;
        /// Optional element 'ns2:paypalEcOrderSetupRequestID' of XML schema type 'xsd:string'
        std::string *paypalEcOrderSetupRequestID;
        /// Optional element 'ns2:paypalEcOrderSetupRequestToken' of XML schema type 'xsd:string'
        std::string *paypalEcOrderSetupRequestToken;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalAuthReversalService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalAuthReversalService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalAuthReversalService, default initialized and not managed by a soap context
        virtual ns2__PayPalAuthReversalService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalAuthReversalService); }
      public:
        /// Constructor with default initializations
        ns2__PayPalAuthReversalService() : paypalAuthorizationId(), paypalEcDoPaymentRequestID(), paypalEcDoPaymentRequestToken(), paypalAuthorizationRequestID(), paypalAuthorizationRequestToken(), paypalEcOrderSetupRequestID(), paypalEcOrderSetupRequestToken(), run(), soap() { }
        virtual ~ns2__PayPalAuthReversalService() { }
        /// Friend allocator used by soap_new_ns2__PayPalAuthReversalService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalAuthReversalService * SOAP_FMAC2 soap_instantiate_ns2__PayPalAuthReversalService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:268 */
#ifndef SOAP_TYPE_ns2__PayPalRefundService
#define SOAP_TYPE_ns2__PayPalRefundService (329)
/* complex XML schema type 'ns2:PayPalRefundService': */
class SOAP_CMAC ns2__PayPalRefundService {
      public:
        /// Optional element 'ns2:paypalDoCaptureRequestID' of XML schema type 'xsd:string'
        std::string *paypalDoCaptureRequestID;
        /// Optional element 'ns2:paypalDoCaptureRequestToken' of XML schema type 'xsd:string'
        std::string *paypalDoCaptureRequestToken;
        /// Optional element 'ns2:paypalCaptureId' of XML schema type 'xsd:string'
        std::string *paypalCaptureId;
        /// Optional element 'ns2:paypalNote' of XML schema type 'xsd:string'
        std::string *paypalNote;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalRefundService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalRefundService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalRefundService, default initialized and not managed by a soap context
        virtual ns2__PayPalRefundService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalRefundService); }
      public:
        /// Constructor with default initializations
        ns2__PayPalRefundService() : paypalDoCaptureRequestID(), paypalDoCaptureRequestToken(), paypalCaptureId(), paypalNote(), run(), soap() { }
        virtual ~ns2__PayPalRefundService() { }
        /// Friend allocator used by soap_new_ns2__PayPalRefundService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalRefundService * SOAP_FMAC2 soap_instantiate_ns2__PayPalRefundService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:270 */
#ifndef SOAP_TYPE_ns2__PayPalEcOrderSetupService
#define SOAP_TYPE_ns2__PayPalEcOrderSetupService (330)
/* complex XML schema type 'ns2:PayPalEcOrderSetupService': */
class SOAP_CMAC ns2__PayPalEcOrderSetupService {
      public:
        /// Optional element 'ns2:paypalToken' of XML schema type 'xsd:string'
        std::string *paypalToken;
        /// Optional element 'ns2:paypalPayerId' of XML schema type 'xsd:string'
        std::string *paypalPayerId;
        /// Optional element 'ns2:paypalCustomerEmail' of XML schema type 'xsd:string'
        std::string *paypalCustomerEmail;
        /// Optional element 'ns2:paypalDesc' of XML schema type 'xsd:string'
        std::string *paypalDesc;
        /// Optional element 'ns2:paypalEcSetRequestID' of XML schema type 'xsd:string'
        std::string *paypalEcSetRequestID;
        /// Optional element 'ns2:paypalEcSetRequestToken' of XML schema type 'xsd:string'
        std::string *paypalEcSetRequestToken;
        /// Optional element 'ns2:promoCode0' of XML schema type 'xsd:string'
        std::string *promoCode0;
        /// Optional element 'ns2:invoiceNumber' of XML schema type 'xsd:string'
        std::string *invoiceNumber;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalEcOrderSetupService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalEcOrderSetupService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalEcOrderSetupService, default initialized and not managed by a soap context
        virtual ns2__PayPalEcOrderSetupService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalEcOrderSetupService); }
      public:
        /// Constructor with default initializations
        ns2__PayPalEcOrderSetupService() : paypalToken(), paypalPayerId(), paypalCustomerEmail(), paypalDesc(), paypalEcSetRequestID(), paypalEcSetRequestToken(), promoCode0(), invoiceNumber(), run(), soap() { }
        virtual ~ns2__PayPalEcOrderSetupService() { }
        /// Friend allocator used by soap_new_ns2__PayPalEcOrderSetupService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalEcOrderSetupService * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcOrderSetupService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:272 */
#ifndef SOAP_TYPE_ns2__PayPalAuthorizationService
#define SOAP_TYPE_ns2__PayPalAuthorizationService (331)
/* complex XML schema type 'ns2:PayPalAuthorizationService': */
class SOAP_CMAC ns2__PayPalAuthorizationService {
      public:
        /// Optional element 'ns2:paypalOrderId' of XML schema type 'xsd:string'
        std::string *paypalOrderId;
        /// Optional element 'ns2:paypalEcOrderSetupRequestID' of XML schema type 'xsd:string'
        std::string *paypalEcOrderSetupRequestID;
        /// Optional element 'ns2:paypalEcOrderSetupRequestToken' of XML schema type 'xsd:string'
        std::string *paypalEcOrderSetupRequestToken;
        /// Optional element 'ns2:paypalDoRefTransactionRequestID' of XML schema type 'xsd:string'
        std::string *paypalDoRefTransactionRequestID;
        /// Optional element 'ns2:paypalDoRefTransactionRequestToken' of XML schema type 'xsd:string'
        std::string *paypalDoRefTransactionRequestToken;
        /// Optional element 'ns2:paypalCustomerEmail' of XML schema type 'xsd:string'
        std::string *paypalCustomerEmail;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalAuthorizationService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalAuthorizationService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalAuthorizationService, default initialized and not managed by a soap context
        virtual ns2__PayPalAuthorizationService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalAuthorizationService); }
      public:
        /// Constructor with default initializations
        ns2__PayPalAuthorizationService() : paypalOrderId(), paypalEcOrderSetupRequestID(), paypalEcOrderSetupRequestToken(), paypalDoRefTransactionRequestID(), paypalDoRefTransactionRequestToken(), paypalCustomerEmail(), run(), soap() { }
        virtual ~ns2__PayPalAuthorizationService() { }
        /// Friend allocator used by soap_new_ns2__PayPalAuthorizationService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalAuthorizationService * SOAP_FMAC2 soap_instantiate_ns2__PayPalAuthorizationService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:274 */
#ifndef SOAP_TYPE_ns2__PayPalUpdateAgreementService
#define SOAP_TYPE_ns2__PayPalUpdateAgreementService (332)
/* complex XML schema type 'ns2:PayPalUpdateAgreementService': */
class SOAP_CMAC ns2__PayPalUpdateAgreementService {
      public:
        /// Optional element 'ns2:paypalBillingAgreementId' of XML schema type 'xsd:string'
        std::string *paypalBillingAgreementId;
        /// Optional element 'ns2:paypalBillingAgreementStatus' of XML schema type 'xsd:string'
        std::string *paypalBillingAgreementStatus;
        /// Optional element 'ns2:paypalBillingAgreementDesc' of XML schema type 'xsd:string'
        std::string *paypalBillingAgreementDesc;
        /// Optional element 'ns2:paypalBillingAgreementCustom' of XML schema type 'xsd:string'
        std::string *paypalBillingAgreementCustom;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalUpdateAgreementService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalUpdateAgreementService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalUpdateAgreementService, default initialized and not managed by a soap context
        virtual ns2__PayPalUpdateAgreementService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalUpdateAgreementService); }
      public:
        /// Constructor with default initializations
        ns2__PayPalUpdateAgreementService() : paypalBillingAgreementId(), paypalBillingAgreementStatus(), paypalBillingAgreementDesc(), paypalBillingAgreementCustom(), run(), soap() { }
        virtual ~ns2__PayPalUpdateAgreementService() { }
        /// Friend allocator used by soap_new_ns2__PayPalUpdateAgreementService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalUpdateAgreementService * SOAP_FMAC2 soap_instantiate_ns2__PayPalUpdateAgreementService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:276 */
#ifndef SOAP_TYPE_ns2__PayPalCreateAgreementService
#define SOAP_TYPE_ns2__PayPalCreateAgreementService (333)
/* complex XML schema type 'ns2:PayPalCreateAgreementService': */
class SOAP_CMAC ns2__PayPalCreateAgreementService {
      public:
        /// Optional element 'ns2:paypalToken' of XML schema type 'xsd:string'
        std::string *paypalToken;
        /// Optional element 'ns2:paypalEcSetRequestID' of XML schema type 'xsd:string'
        std::string *paypalEcSetRequestID;
        /// Optional element 'ns2:paypalEcSetRequestToken' of XML schema type 'xsd:string'
        std::string *paypalEcSetRequestToken;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalCreateAgreementService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalCreateAgreementService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalCreateAgreementService, default initialized and not managed by a soap context
        virtual ns2__PayPalCreateAgreementService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalCreateAgreementService); }
      public:
        /// Constructor with default initializations
        ns2__PayPalCreateAgreementService() : paypalToken(), paypalEcSetRequestID(), paypalEcSetRequestToken(), run(), soap() { }
        virtual ~ns2__PayPalCreateAgreementService() { }
        /// Friend allocator used by soap_new_ns2__PayPalCreateAgreementService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalCreateAgreementService * SOAP_FMAC2 soap_instantiate_ns2__PayPalCreateAgreementService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:278 */
#ifndef SOAP_TYPE_ns2__PayPalDoRefTransactionService
#define SOAP_TYPE_ns2__PayPalDoRefTransactionService (334)
/* complex XML schema type 'ns2:PayPalDoRefTransactionService': */
class SOAP_CMAC ns2__PayPalDoRefTransactionService {
      public:
        /// Optional element 'ns2:paypalBillingAgreementId' of XML schema type 'xsd:string'
        std::string *paypalBillingAgreementId;
        /// Optional element 'ns2:paypalPaymentType' of XML schema type 'xsd:string'
        std::string *paypalPaymentType;
        /// Optional element 'ns2:paypalReqconfirmshipping' of XML schema type 'xsd:string'
        std::string *paypalReqconfirmshipping;
        /// Optional element 'ns2:paypalReturnFmfDetails' of XML schema type 'xsd:string'
        std::string *paypalReturnFmfDetails;
        /// Optional element 'ns2:paypalSoftDescriptor' of XML schema type 'xsd:string'
        std::string *paypalSoftDescriptor;
        /// Optional element 'ns2:paypalShippingdiscount' of XML schema type 'xsd:string'
        std::string *paypalShippingdiscount;
        /// Optional element 'ns2:paypalDesc' of XML schema type 'xsd:string'
        std::string *paypalDesc;
        /// Optional element 'ns2:invoiceNumber' of XML schema type 'xsd:string'
        std::string *invoiceNumber;
        /// Optional element 'ns2:paypalEcNotifyUrl' of XML schema type 'xsd:string'
        std::string *paypalEcNotifyUrl;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalDoRefTransactionService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalDoRefTransactionService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalDoRefTransactionService, default initialized and not managed by a soap context
        virtual ns2__PayPalDoRefTransactionService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalDoRefTransactionService); }
      public:
        /// Constructor with default initializations
        ns2__PayPalDoRefTransactionService() : paypalBillingAgreementId(), paypalPaymentType(), paypalReqconfirmshipping(), paypalReturnFmfDetails(), paypalSoftDescriptor(), paypalShippingdiscount(), paypalDesc(), invoiceNumber(), paypalEcNotifyUrl(), run(), soap() { }
        virtual ~ns2__PayPalDoRefTransactionService() { }
        /// Friend allocator used by soap_new_ns2__PayPalDoRefTransactionService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalDoRefTransactionService * SOAP_FMAC2 soap_instantiate_ns2__PayPalDoRefTransactionService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:280 */
#ifndef SOAP_TYPE_ns2__VoidService
#define SOAP_TYPE_ns2__VoidService (335)
/* complex XML schema type 'ns2:VoidService': */
class SOAP_CMAC ns2__VoidService {
      public:
        /// Optional element 'ns2:voidRequestID' of XML schema type 'xsd:string'
        std::string *voidRequestID;
        /// Optional element 'ns2:voidRequestToken' of XML schema type 'xsd:string'
        std::string *voidRequestToken;
        /// Optional element 'ns2:voidReason' of XML schema type 'xsd:string'
        std::string *voidReason;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VoidService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__VoidService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VoidService, default initialized and not managed by a soap context
        virtual ns2__VoidService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__VoidService); }
      public:
        /// Constructor with default initializations
        ns2__VoidService() : voidRequestID(), voidRequestToken(), voidReason(), run(), soap() { }
        virtual ~ns2__VoidService() { }
        /// Friend allocator used by soap_new_ns2__VoidService(struct soap*, int)
        friend SOAP_FMAC1 ns2__VoidService * SOAP_FMAC2 soap_instantiate_ns2__VoidService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:282 */
#ifndef SOAP_TYPE_ns2__PinlessDebitService
#define SOAP_TYPE_ns2__PinlessDebitService (336)
/* complex XML schema type 'ns2:PinlessDebitService': */
class SOAP_CMAC ns2__PinlessDebitService {
      public:
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:commerceIndicator' of XML schema type 'xsd:string'
        std::string *commerceIndicator;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinlessDebitService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PinlessDebitService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinlessDebitService, default initialized and not managed by a soap context
        virtual ns2__PinlessDebitService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PinlessDebitService); }
      public:
        /// Constructor with default initializations
        ns2__PinlessDebitService() : reconciliationID(), commerceIndicator(), run(), soap() { }
        virtual ~ns2__PinlessDebitService() { }
        /// Friend allocator used by soap_new_ns2__PinlessDebitService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinlessDebitService * SOAP_FMAC2 soap_instantiate_ns2__PinlessDebitService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:284 */
#ifndef SOAP_TYPE_ns2__PinlessDebitValidateService
#define SOAP_TYPE_ns2__PinlessDebitValidateService (337)
/* complex XML schema type 'ns2:PinlessDebitValidateService': */
class SOAP_CMAC ns2__PinlessDebitValidateService {
      public:
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinlessDebitValidateService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PinlessDebitValidateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinlessDebitValidateService, default initialized and not managed by a soap context
        virtual ns2__PinlessDebitValidateService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PinlessDebitValidateService); }
      public:
        /// Constructor with default initializations
        ns2__PinlessDebitValidateService() : run(), soap() { }
        virtual ~ns2__PinlessDebitValidateService() { }
        /// Friend allocator used by soap_new_ns2__PinlessDebitValidateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinlessDebitValidateService * SOAP_FMAC2 soap_instantiate_ns2__PinlessDebitValidateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:286 */
#ifndef SOAP_TYPE_ns2__PinlessDebitReversalService
#define SOAP_TYPE_ns2__PinlessDebitReversalService (338)
/* complex XML schema type 'ns2:PinlessDebitReversalService': */
class SOAP_CMAC ns2__PinlessDebitReversalService {
      public:
        /// Optional element 'ns2:pinlessDebitRequestID' of XML schema type 'xsd:string'
        std::string *pinlessDebitRequestID;
        /// Optional element 'ns2:pinlessDebitRequestToken' of XML schema type 'xsd:string'
        std::string *pinlessDebitRequestToken;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinlessDebitReversalService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PinlessDebitReversalService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinlessDebitReversalService, default initialized and not managed by a soap context
        virtual ns2__PinlessDebitReversalService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PinlessDebitReversalService); }
      public:
        /// Constructor with default initializations
        ns2__PinlessDebitReversalService() : pinlessDebitRequestID(), pinlessDebitRequestToken(), reconciliationID(), run(), soap() { }
        virtual ~ns2__PinlessDebitReversalService() { }
        /// Friend allocator used by soap_new_ns2__PinlessDebitReversalService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinlessDebitReversalService * SOAP_FMAC2 soap_instantiate_ns2__PinlessDebitReversalService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:288 */
#ifndef SOAP_TYPE_ns2__PinDebitPurchaseService
#define SOAP_TYPE_ns2__PinDebitPurchaseService (339)
/* complex XML schema type 'ns2:PinDebitPurchaseService': */
class SOAP_CMAC ns2__PinDebitPurchaseService {
      public:
        /// Optional element 'ns2:networkOrder' of XML schema type 'xsd:string'
        std::string *networkOrder;
        /// Optional element 'ns2:commerceIndicator' of XML schema type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:partialAuthIndicator' of XML schema type 'ns2:boolean'
        std::string *partialAuthIndicator;
        /// Optional element 'ns2:overridePaymentMethod' of XML schema type 'xsd:string'
        std::string *overridePaymentMethod;
        /// Optional element 'ns2:paymentType' of XML schema type 'xsd:string'
        std::string *paymentType;
        /// Optional element 'ns2:ebtCategory' of XML schema type 'xsd:string'
        std::string *ebtCategory;
        /// Optional element 'ns2:transactionType' of XML schema type 'xsd:string'
        std::string *transactionType;
        /// Optional element 'ns2:ebtVoucherSerialNumber' of XML schema type 'xsd:string'
        std::string *ebtVoucherSerialNumber;
        /// Optional element 'ns2:authorizationCode' of XML schema type 'xsd:string'
        std::string *authorizationCode;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinDebitPurchaseService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PinDebitPurchaseService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinDebitPurchaseService, default initialized and not managed by a soap context
        virtual ns2__PinDebitPurchaseService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PinDebitPurchaseService); }
      public:
        /// Constructor with default initializations
        ns2__PinDebitPurchaseService() : networkOrder(), commerceIndicator(), reconciliationID(), partialAuthIndicator(), overridePaymentMethod(), paymentType(), ebtCategory(), transactionType(), ebtVoucherSerialNumber(), authorizationCode(), run(), soap() { }
        virtual ~ns2__PinDebitPurchaseService() { }
        /// Friend allocator used by soap_new_ns2__PinDebitPurchaseService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinDebitPurchaseService * SOAP_FMAC2 soap_instantiate_ns2__PinDebitPurchaseService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:290 */
#ifndef SOAP_TYPE_ns2__PinDebitCreditService
#define SOAP_TYPE_ns2__PinDebitCreditService (340)
/* complex XML schema type 'ns2:PinDebitCreditService': */
class SOAP_CMAC ns2__PinDebitCreditService {
      public:
        /// Optional element 'ns2:networkOrder' of XML schema type 'xsd:string'
        std::string *networkOrder;
        /// Optional element 'ns2:commerceIndicator' of XML schema type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:overridePaymentMethod' of XML schema type 'xsd:string'
        std::string *overridePaymentMethod;
        /// Optional element 'ns2:paymentType' of XML schema type 'xsd:string'
        std::string *paymentType;
        /// Optional element 'ns2:ebtCategory' of XML schema type 'xsd:string'
        std::string *ebtCategory;
        /// Optional element 'ns2:transactionType' of XML schema type 'xsd:string'
        std::string *transactionType;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinDebitCreditService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PinDebitCreditService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinDebitCreditService, default initialized and not managed by a soap context
        virtual ns2__PinDebitCreditService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PinDebitCreditService); }
      public:
        /// Constructor with default initializations
        ns2__PinDebitCreditService() : networkOrder(), commerceIndicator(), reconciliationID(), overridePaymentMethod(), paymentType(), ebtCategory(), transactionType(), run(), soap() { }
        virtual ~ns2__PinDebitCreditService() { }
        /// Friend allocator used by soap_new_ns2__PinDebitCreditService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinDebitCreditService * SOAP_FMAC2 soap_instantiate_ns2__PinDebitCreditService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:292 */
#ifndef SOAP_TYPE_ns2__PinDebitReversalService
#define SOAP_TYPE_ns2__PinDebitReversalService (341)
/* complex XML schema type 'ns2:PinDebitReversalService': */
class SOAP_CMAC ns2__PinDebitReversalService {
      public:
        /// Optional element 'ns2:pinDebitRequestID' of XML schema type 'xsd:string'
        std::string *pinDebitRequestID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinDebitReversalService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PinDebitReversalService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinDebitReversalService, default initialized and not managed by a soap context
        virtual ns2__PinDebitReversalService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PinDebitReversalService); }
      public:
        /// Constructor with default initializations
        ns2__PinDebitReversalService() : pinDebitRequestID(), run(), soap() { }
        virtual ~ns2__PinDebitReversalService() { }
        /// Friend allocator used by soap_new_ns2__PinDebitReversalService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinDebitReversalService * SOAP_FMAC2 soap_instantiate_ns2__PinDebitReversalService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:294 */
#ifndef SOAP_TYPE_ns2__PayPalButtonCreateService
#define SOAP_TYPE_ns2__PayPalButtonCreateService (342)
/* complex XML schema type 'ns2:PayPalButtonCreateService': */
class SOAP_CMAC ns2__PayPalButtonCreateService {
      public:
        /// Optional element 'ns2:buttonType' of XML schema type 'xsd:string'
        std::string *buttonType;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalButtonCreateService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalButtonCreateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalButtonCreateService, default initialized and not managed by a soap context
        virtual ns2__PayPalButtonCreateService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalButtonCreateService); }
      public:
        /// Constructor with default initializations
        ns2__PayPalButtonCreateService() : buttonType(), reconciliationID(), run(), soap() { }
        virtual ~ns2__PayPalButtonCreateService() { }
        /// Friend allocator used by soap_new_ns2__PayPalButtonCreateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalButtonCreateService * SOAP_FMAC2 soap_instantiate_ns2__PayPalButtonCreateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:296 */
#ifndef SOAP_TYPE_ns2__PayPalPreapprovedPaymentService
#define SOAP_TYPE_ns2__PayPalPreapprovedPaymentService (343)
/* complex XML schema type 'ns2:PayPalPreapprovedPaymentService': */
class SOAP_CMAC ns2__PayPalPreapprovedPaymentService {
      public:
        /// Optional element 'ns2:mpID' of XML schema type 'xsd:string'
        std::string *mpID;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalPreapprovedPaymentService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalPreapprovedPaymentService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalPreapprovedPaymentService, default initialized and not managed by a soap context
        virtual ns2__PayPalPreapprovedPaymentService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalPreapprovedPaymentService); }
      public:
        /// Constructor with default initializations
        ns2__PayPalPreapprovedPaymentService() : mpID(), reconciliationID(), run(), soap() { }
        virtual ~ns2__PayPalPreapprovedPaymentService() { }
        /// Friend allocator used by soap_new_ns2__PayPalPreapprovedPaymentService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalPreapprovedPaymentService * SOAP_FMAC2 soap_instantiate_ns2__PayPalPreapprovedPaymentService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:298 */
#ifndef SOAP_TYPE_ns2__PayPalPreapprovedUpdateService
#define SOAP_TYPE_ns2__PayPalPreapprovedUpdateService (344)
/* complex XML schema type 'ns2:PayPalPreapprovedUpdateService': */
class SOAP_CMAC ns2__PayPalPreapprovedUpdateService {
      public:
        /// Optional element 'ns2:mpID' of XML schema type 'xsd:string'
        std::string *mpID;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalPreapprovedUpdateService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalPreapprovedUpdateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalPreapprovedUpdateService, default initialized and not managed by a soap context
        virtual ns2__PayPalPreapprovedUpdateService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalPreapprovedUpdateService); }
      public:
        /// Constructor with default initializations
        ns2__PayPalPreapprovedUpdateService() : mpID(), reconciliationID(), run(), soap() { }
        virtual ~ns2__PayPalPreapprovedUpdateService() { }
        /// Friend allocator used by soap_new_ns2__PayPalPreapprovedUpdateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalPreapprovedUpdateService * SOAP_FMAC2 soap_instantiate_ns2__PayPalPreapprovedUpdateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:300 */
#ifndef SOAP_TYPE_ns2__ChinaPaymentService
#define SOAP_TYPE_ns2__ChinaPaymentService (345)
/* complex XML schema type 'ns2:ChinaPaymentService': */
class SOAP_CMAC ns2__ChinaPaymentService {
      public:
        /// Optional element 'ns2:paymentMode' of XML schema type 'xsd:string'
        std::string *paymentMode;
        /// Optional element 'ns2:returnURL' of XML schema type 'xsd:string'
        std::string *returnURL;
        /// Optional element 'ns2:pickUpAddress' of XML schema type 'xsd:string'
        std::string *pickUpAddress;
        /// Optional element 'ns2:pickUpPhoneNumber' of XML schema type 'xsd:string'
        std::string *pickUpPhoneNumber;
        /// Optional element 'ns2:pickUpPostalCode' of XML schema type 'xsd:string'
        std::string *pickUpPostalCode;
        /// Optional element 'ns2:pickUpName' of XML schema type 'xsd:string'
        std::string *pickUpName;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ChinaPaymentService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ChinaPaymentService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ChinaPaymentService, default initialized and not managed by a soap context
        virtual ns2__ChinaPaymentService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ChinaPaymentService); }
      public:
        /// Constructor with default initializations
        ns2__ChinaPaymentService() : paymentMode(), returnURL(), pickUpAddress(), pickUpPhoneNumber(), pickUpPostalCode(), pickUpName(), run(), soap() { }
        virtual ~ns2__ChinaPaymentService() { }
        /// Friend allocator used by soap_new_ns2__ChinaPaymentService(struct soap*, int)
        friend SOAP_FMAC1 ns2__ChinaPaymentService * SOAP_FMAC2 soap_instantiate_ns2__ChinaPaymentService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:302 */
#ifndef SOAP_TYPE_ns2__ChinaRefundService
#define SOAP_TYPE_ns2__ChinaRefundService (346)
/* complex XML schema type 'ns2:ChinaRefundService': */
class SOAP_CMAC ns2__ChinaRefundService {
      public:
        /// Optional element 'ns2:chinaPaymentRequestID' of XML schema type 'xsd:string'
        std::string *chinaPaymentRequestID;
        /// Optional element 'ns2:chinaPaymentRequestToken' of XML schema type 'xsd:string'
        std::string *chinaPaymentRequestToken;
        /// Optional element 'ns2:refundReason' of XML schema type 'xsd:string'
        std::string *refundReason;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ChinaRefundService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ChinaRefundService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ChinaRefundService, default initialized and not managed by a soap context
        virtual ns2__ChinaRefundService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ChinaRefundService); }
      public:
        /// Constructor with default initializations
        ns2__ChinaRefundService() : chinaPaymentRequestID(), chinaPaymentRequestToken(), refundReason(), run(), soap() { }
        virtual ~ns2__ChinaRefundService() { }
        /// Friend allocator used by soap_new_ns2__ChinaRefundService(struct soap*, int)
        friend SOAP_FMAC1 ns2__ChinaRefundService * SOAP_FMAC2 soap_instantiate_ns2__ChinaRefundService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:304 */
#ifndef SOAP_TYPE_ns2__BoletoPaymentService
#define SOAP_TYPE_ns2__BoletoPaymentService (347)
/* complex XML schema type 'ns2:BoletoPaymentService': */
class SOAP_CMAC ns2__BoletoPaymentService {
      public:
        /// Optional element 'ns2:instruction' of XML schema type 'xsd:string'
        std::string *instruction;
        /// Optional element 'ns2:expirationDate' of XML schema type 'xsd:string'
        std::string *expirationDate;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BoletoPaymentService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__BoletoPaymentService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BoletoPaymentService, default initialized and not managed by a soap context
        virtual ns2__BoletoPaymentService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__BoletoPaymentService); }
      public:
        /// Constructor with default initializations
        ns2__BoletoPaymentService() : instruction(), expirationDate(), reconciliationID(), run(), soap() { }
        virtual ~ns2__BoletoPaymentService() { }
        /// Friend allocator used by soap_new_ns2__BoletoPaymentService(struct soap*, int)
        friend SOAP_FMAC1 ns2__BoletoPaymentService * SOAP_FMAC2 soap_instantiate_ns2__BoletoPaymentService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:306 */
#ifndef SOAP_TYPE_ns2__PersonalID
#define SOAP_TYPE_ns2__PersonalID (348)
/* complex XML schema type 'ns2:PersonalID': */
class SOAP_CMAC ns2__PersonalID {
      public:
        /// Optional element 'ns2:number' of XML schema type 'xsd:string'
        std::string *number;
        /// Optional element 'ns2:type' of XML schema type 'xsd:string'
        std::string *type;
        /// Optional element 'ns2:name' of XML schema type 'xsd:string'
        std::string *name;
        /// Optional element 'ns2:country' of XML schema type 'xsd:string'
        std::string *country;
        /// Optional element 'ns2:address' of XML schema type 'xsd:string'
        std::string *address;
        /// Optional element 'ns2:issuedBy' of XML schema type 'xsd:string'
        std::string *issuedBy;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PersonalID
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PersonalID; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PersonalID, default initialized and not managed by a soap context
        virtual ns2__PersonalID *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PersonalID); }
      public:
        /// Constructor with default initializations
        ns2__PersonalID() : number(), type(), name(), country(), address(), issuedBy(), soap() { }
        virtual ~ns2__PersonalID() { }
        /// Friend allocator used by soap_new_ns2__PersonalID(struct soap*, int)
        friend SOAP_FMAC1 ns2__PersonalID * SOAP_FMAC2 soap_instantiate_ns2__PersonalID(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:308 */
#ifndef SOAP_TYPE_ns2__Routing
#define SOAP_TYPE_ns2__Routing (349)
/* complex XML schema type 'ns2:Routing': */
class SOAP_CMAC ns2__Routing {
      public:
        /// Optional element 'ns2:networkType' of XML schema type 'xsd:string'
        std::string *networkType;
        /// Optional element 'ns2:networkLabel' of XML schema type 'xsd:string'
        std::string *networkLabel;
        /// Optional element 'ns2:signatureCVMRequired' of XML schema type 'xsd:string'
        std::string *signatureCVMRequired;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Routing
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Routing; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Routing, default initialized and not managed by a soap context
        virtual ns2__Routing *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Routing); }
      public:
        /// Constructor with default initializations
        ns2__Routing() : networkType(), networkLabel(), signatureCVMRequired(), soap() { }
        virtual ~ns2__Routing() { }
        /// Friend allocator used by soap_new_ns2__Routing(struct soap*, int)
        friend SOAP_FMAC1 ns2__Routing * SOAP_FMAC2 soap_instantiate_ns2__Routing(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:310 */
#ifndef SOAP_TYPE_ns2__Address
#define SOAP_TYPE_ns2__Address (350)
/* complex XML schema type 'ns2:Address': */
class SOAP_CMAC ns2__Address {
      public:
        /// Optional element 'ns2:street1' of XML schema type 'xsd:string'
        std::string *street1;
        /// Optional element 'ns2:street2' of XML schema type 'xsd:string'
        std::string *street2;
        /// Optional element 'ns2:city' of XML schema type 'xsd:string'
        std::string *city;
        /// Optional element 'ns2:state' of XML schema type 'xsd:string'
        std::string *state;
        /// Optional element 'ns2:postalCode' of XML schema type 'xsd:string'
        std::string *postalCode;
        /// Optional element 'ns2:country' of XML schema type 'xsd:string'
        std::string *country;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Address
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Address; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Address, default initialized and not managed by a soap context
        virtual ns2__Address *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Address); }
      public:
        /// Constructor with default initializations
        ns2__Address() : street1(), street2(), city(), state(), postalCode(), country(), soap() { }
        virtual ~ns2__Address() { }
        /// Friend allocator used by soap_new_ns2__Address(struct soap*, int)
        friend SOAP_FMAC1 ns2__Address * SOAP_FMAC2 soap_instantiate_ns2__Address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:312 */
#ifndef SOAP_TYPE_ns2__APInitiateService
#define SOAP_TYPE_ns2__APInitiateService (351)
/* complex XML schema type 'ns2:APInitiateService': */
class SOAP_CMAC ns2__APInitiateService {
      public:
        /// Optional element 'ns2:returnURL' of XML schema type 'xsd:string'
        std::string *returnURL;
        /// Optional element 'ns2:productName' of XML schema type 'xsd:string'
        std::string *productName;
        /// Optional element 'ns2:productDescription' of XML schema type 'xsd:string'
        std::string *productDescription;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:bankID' of XML schema type 'xsd:string'
        std::string *bankID;
        /// Optional element 'ns2:countryCode' of XML schema type 'xsd:string'
        std::string *countryCode;
        /// Optional element 'ns2:escrowAgreement' of XML schema type 'xsd:string'
        std::string *escrowAgreement;
        /// Optional element 'ns2:languageInterface' of XML schema type 'xsd:string'
        std::string *languageInterface;
        /// Optional element 'ns2:intent' of XML schema type 'xsd:string'
        std::string *intent;
        /// Optional element 'ns2:successURL' of XML schema type 'xsd:string'
        std::string *successURL;
        /// Optional element 'ns2:cancelURL' of XML schema type 'xsd:string'
        std::string *cancelURL;
        /// Optional element 'ns2:failureURL' of XML schema type 'xsd:string'
        std::string *failureURL;
        /// Optional element 'ns2:overridePaymentMethod' of XML schema type 'xsd:string'
        std::string *overridePaymentMethod;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APInitiateService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APInitiateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APInitiateService, default initialized and not managed by a soap context
        virtual ns2__APInitiateService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APInitiateService); }
      public:
        /// Constructor with default initializations
        ns2__APInitiateService() : returnURL(), productName(), productDescription(), reconciliationID(), bankID(), countryCode(), escrowAgreement(), languageInterface(), intent(), successURL(), cancelURL(), failureURL(), overridePaymentMethod(), run(), soap() { }
        virtual ~ns2__APInitiateService() { }
        /// Friend allocator used by soap_new_ns2__APInitiateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APInitiateService * SOAP_FMAC2 soap_instantiate_ns2__APInitiateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:314 */
#ifndef SOAP_TYPE_ns2__APCheckStatusService
#define SOAP_TYPE_ns2__APCheckStatusService (352)
/* complex XML schema type 'ns2:APCheckStatusService': */
class SOAP_CMAC ns2__APCheckStatusService {
      public:
        /// Optional element 'ns2:apInitiateRequestID' of XML schema type 'xsd:string'
        std::string *apInitiateRequestID;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:checkStatusRequestID' of XML schema type 'xsd:string'
        std::string *checkStatusRequestID;
        /// Optional element 'ns2:sessionsRequestID' of XML schema type 'xsd:string'
        std::string *sessionsRequestID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APCheckStatusService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APCheckStatusService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APCheckStatusService, default initialized and not managed by a soap context
        virtual ns2__APCheckStatusService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APCheckStatusService); }
      public:
        /// Constructor with default initializations
        ns2__APCheckStatusService() : apInitiateRequestID(), reconciliationID(), checkStatusRequestID(), sessionsRequestID(), run(), soap() { }
        virtual ~ns2__APCheckStatusService() { }
        /// Friend allocator used by soap_new_ns2__APCheckStatusService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APCheckStatusService * SOAP_FMAC2 soap_instantiate_ns2__APCheckStatusService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:316 */
#ifndef SOAP_TYPE_ns2__RiskUpdateService
#define SOAP_TYPE_ns2__RiskUpdateService (353)
/* complex XML schema type 'ns2:RiskUpdateService': */
class SOAP_CMAC ns2__RiskUpdateService {
      public:
        /// Optional element 'ns2:actionCode' of XML schema type 'xsd:string'
        std::string *actionCode;
        /// Optional element 'ns2:recordID' of XML schema type 'xsd:string'
        std::string *recordID;
        /// Optional element 'ns2:recordName' of XML schema type 'xsd:string'
        std::string *recordName;
        /// Optional element 'ns2:negativeAddress' of XML schema type 'ns2:Address'
        ns2__Address *negativeAddress;
        /// Optional element 'ns2:markingReason' of XML schema type 'xsd:string'
        std::string *markingReason;
        /// Optional element 'ns2:markingNotes' of XML schema type 'xsd:string'
        std::string *markingNotes;
        /// Optional element 'ns2:markingRequestID' of XML schema type 'xsd:string'
        std::string *markingRequestID;
        /// Optional element 'ns2:deviceFingerprintSmartID' of XML schema type 'xsd:string'
        std::string *deviceFingerprintSmartID;
        /// Optional element 'ns2:deviceFingerprintTrueIPAddress' of XML schema type 'xsd:string'
        std::string *deviceFingerprintTrueIPAddress;
        /// Optional element 'ns2:deviceFingerprintProxyIPAddress' of XML schema type 'xsd:string'
        std::string *deviceFingerprintProxyIPAddress;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RiskUpdateService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__RiskUpdateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RiskUpdateService, default initialized and not managed by a soap context
        virtual ns2__RiskUpdateService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__RiskUpdateService); }
      public:
        /// Constructor with default initializations
        ns2__RiskUpdateService() : actionCode(), recordID(), recordName(), negativeAddress(), markingReason(), markingNotes(), markingRequestID(), deviceFingerprintSmartID(), deviceFingerprintTrueIPAddress(), deviceFingerprintProxyIPAddress(), run(), soap() { }
        virtual ~ns2__RiskUpdateService() { }
        /// Friend allocator used by soap_new_ns2__RiskUpdateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__RiskUpdateService * SOAP_FMAC2 soap_instantiate_ns2__RiskUpdateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:318 */
#ifndef SOAP_TYPE_ns2__FraudUpdateService
#define SOAP_TYPE_ns2__FraudUpdateService (354)
/* complex XML schema type 'ns2:FraudUpdateService': */
class SOAP_CMAC ns2__FraudUpdateService {
      public:
        /// Optional element 'ns2:actionCode' of XML schema type 'xsd:string'
        std::string *actionCode;
        /// Optional element 'ns2:markedData' of XML schema type 'xsd:string'
        std::string *markedData;
        /// Optional element 'ns2:markingReason' of XML schema type 'xsd:string'
        std::string *markingReason;
        /// Optional element 'ns2:markingNotes' of XML schema type 'xsd:string'
        std::string *markingNotes;
        /// Optional element 'ns2:markingRequestID' of XML schema type 'xsd:string'
        std::string *markingRequestID;
        /// Optional element 'ns2:markingTransactionDate' of XML schema type 'xsd:string'
        std::string *markingTransactionDate;
        /// Optional element 'ns2:markingAmount' of XML schema type 'ns2:amount'
        std::string *markingAmount;
        /// Optional element 'ns2:markingCurrency' of XML schema type 'xsd:string'
        std::string *markingCurrency;
        /// Optional element 'ns2:markingIndicator' of XML schema type 'xsd:string'
        std::string *markingIndicator;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FraudUpdateService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__FraudUpdateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FraudUpdateService, default initialized and not managed by a soap context
        virtual ns2__FraudUpdateService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__FraudUpdateService); }
      public:
        /// Constructor with default initializations
        ns2__FraudUpdateService() : actionCode(), markedData(), markingReason(), markingNotes(), markingRequestID(), markingTransactionDate(), markingAmount(), markingCurrency(), markingIndicator(), run(), soap() { }
        virtual ~ns2__FraudUpdateService() { }
        /// Friend allocator used by soap_new_ns2__FraudUpdateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__FraudUpdateService * SOAP_FMAC2 soap_instantiate_ns2__FraudUpdateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:320 */
#ifndef SOAP_TYPE_ns2__CaseManagementActionService
#define SOAP_TYPE_ns2__CaseManagementActionService (355)
/* complex XML schema type 'ns2:CaseManagementActionService': */
class SOAP_CMAC ns2__CaseManagementActionService {
      public:
        /// Optional element 'ns2:actionCode' of XML schema type 'xsd:string'
        std::string *actionCode;
        /// Optional element 'ns2:requestID' of XML schema type 'xsd:string'
        std::string *requestID;
        /// Optional element 'ns2:comments' of XML schema type 'xsd:string'
        std::string *comments;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CaseManagementActionService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CaseManagementActionService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CaseManagementActionService, default initialized and not managed by a soap context
        virtual ns2__CaseManagementActionService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CaseManagementActionService); }
      public:
        /// Constructor with default initializations
        ns2__CaseManagementActionService() : actionCode(), requestID(), comments(), run(), soap() { }
        virtual ~ns2__CaseManagementActionService() { }
        /// Friend allocator used by soap_new_ns2__CaseManagementActionService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CaseManagementActionService * SOAP_FMAC2 soap_instantiate_ns2__CaseManagementActionService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:322 */
#ifndef SOAP_TYPE_ns2__EncryptPaymentDataService
#define SOAP_TYPE_ns2__EncryptPaymentDataService (356)
/* complex XML schema type 'ns2:EncryptPaymentDataService': */
class SOAP_CMAC ns2__EncryptPaymentDataService {
      public:
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__EncryptPaymentDataService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__EncryptPaymentDataService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__EncryptPaymentDataService, default initialized and not managed by a soap context
        virtual ns2__EncryptPaymentDataService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__EncryptPaymentDataService); }
      public:
        /// Constructor with default initializations
        ns2__EncryptPaymentDataService() : run(), soap() { }
        virtual ~ns2__EncryptPaymentDataService() { }
        /// Friend allocator used by soap_new_ns2__EncryptPaymentDataService(struct soap*, int)
        friend SOAP_FMAC1 ns2__EncryptPaymentDataService * SOAP_FMAC2 soap_instantiate_ns2__EncryptPaymentDataService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:324 */
#ifndef SOAP_TYPE_ns2__InvoiceHeader
#define SOAP_TYPE_ns2__InvoiceHeader (357)
/* complex XML schema type 'ns2:InvoiceHeader': */
class SOAP_CMAC ns2__InvoiceHeader {
      public:
        /// Optional element 'ns2:merchantDescriptor' of XML schema type 'xsd:string'
        std::string *merchantDescriptor;
        /// Optional element 'ns2:merchantDescriptorContact' of XML schema type 'xsd:string'
        std::string *merchantDescriptorContact;
        /// Optional element 'ns2:merchantDescriptorAlternate' of XML schema type 'xsd:string'
        std::string *merchantDescriptorAlternate;
        /// Optional element 'ns2:merchantDescriptorStreet' of XML schema type 'xsd:string'
        std::string *merchantDescriptorStreet;
        /// Optional element 'ns2:merchantDescriptorCity' of XML schema type 'xsd:string'
        std::string *merchantDescriptorCity;
        /// Optional element 'ns2:merchantDescriptorState' of XML schema type 'xsd:string'
        std::string *merchantDescriptorState;
        /// Optional element 'ns2:merchantDescriptorPostalCode' of XML schema type 'xsd:string'
        std::string *merchantDescriptorPostalCode;
        /// Optional element 'ns2:merchantDescriptorCountry' of XML schema type 'xsd:string'
        std::string *merchantDescriptorCountry;
        /// Optional element 'ns2:isGift' of XML schema type 'ns2:boolean'
        std::string *isGift;
        /// Optional element 'ns2:returnsAccepted' of XML schema type 'ns2:boolean'
        std::string *returnsAccepted;
        /// Optional element 'ns2:tenderType' of XML schema type 'xsd:string'
        std::string *tenderType;
        /// Optional element 'ns2:merchantVATRegistrationNumber' of XML schema type 'xsd:string'
        std::string *merchantVATRegistrationNumber;
        /// Optional element 'ns2:purchaserOrderDate' of XML schema type 'xsd:string'
        std::string *purchaserOrderDate;
        /// Optional element 'ns2:purchaserVATRegistrationNumber' of XML schema type 'xsd:string'
        std::string *purchaserVATRegistrationNumber;
        /// Optional element 'ns2:vatInvoiceReferenceNumber' of XML schema type 'xsd:string'
        std::string *vatInvoiceReferenceNumber;
        /// Optional element 'ns2:summaryCommodityCode' of XML schema type 'xsd:string'
        std::string *summaryCommodityCode;
        /// Optional element 'ns2:supplierOrderReference' of XML schema type 'xsd:string'
        std::string *supplierOrderReference;
        /// Optional element 'ns2:userPO' of XML schema type 'xsd:string'
        std::string *userPO;
        /// Optional element 'ns2:costCenter' of XML schema type 'xsd:string'
        std::string *costCenter;
        /// Optional element 'ns2:purchaserCode' of XML schema type 'xsd:string'
        std::string *purchaserCode;
        /// Optional element 'ns2:taxable' of XML schema type 'ns2:boolean'
        std::string *taxable;
        /// Optional element 'ns2:amexDataTAA1' of XML schema type 'xsd:string'
        std::string *amexDataTAA1;
        /// Optional element 'ns2:amexDataTAA2' of XML schema type 'xsd:string'
        std::string *amexDataTAA2;
        /// Optional element 'ns2:amexDataTAA3' of XML schema type 'xsd:string'
        std::string *amexDataTAA3;
        /// Optional element 'ns2:amexDataTAA4' of XML schema type 'xsd:string'
        std::string *amexDataTAA4;
        /// Optional element 'ns2:invoiceDate' of XML schema type 'xsd:string'
        std::string *invoiceDate;
        /// Optional element 'ns2:totalTaxTypeCode' of XML schema type 'xsd:string'
        std::string *totalTaxTypeCode;
        /// Optional element 'ns2:cardAcceptorRefNumber' of XML schema type 'xsd:string'
        std::string *cardAcceptorRefNumber;
        /// Optional element 'ns2:authorizedContactName' of XML schema type 'xsd:string'
        std::string *authorizedContactName;
        /// Optional element 'ns2:businessApplicationID' of XML schema type 'xsd:string'
        std::string *businessApplicationID;
        /// Optional element 'ns2:salesOrganizationID' of XML schema type 'xsd:integer'
        std::string *salesOrganizationID;
        /// Optional element 'ns2:submerchantID' of XML schema type 'xsd:string'
        std::string *submerchantID;
        /// Optional element 'ns2:submerchantName' of XML schema type 'xsd:string'
        std::string *submerchantName;
        /// Optional element 'ns2:submerchantStreet' of XML schema type 'xsd:string'
        std::string *submerchantStreet;
        /// Optional element 'ns2:submerchantCity' of XML schema type 'xsd:string'
        std::string *submerchantCity;
        /// Optional element 'ns2:submerchantPostalCode' of XML schema type 'xsd:string'
        std::string *submerchantPostalCode;
        /// Optional element 'ns2:submerchantState' of XML schema type 'xsd:string'
        std::string *submerchantState;
        /// Optional element 'ns2:submerchantCountry' of XML schema type 'xsd:string'
        std::string *submerchantCountry;
        /// Optional element 'ns2:submerchantEmail' of XML schema type 'xsd:string'
        std::string *submerchantEmail;
        /// Optional element 'ns2:submerchantTelephoneNumber' of XML schema type 'xsd:string'
        std::string *submerchantTelephoneNumber;
        /// Optional element 'ns2:submerchantRegion' of XML schema type 'xsd:string'
        std::string *submerchantRegion;
        /// Optional element 'ns2:submerchantMerchantID' of XML schema type 'xsd:string'
        std::string *submerchantMerchantID;
        /// Optional element 'ns2:merchantDescriptorCounty' of XML schema type 'xsd:string'
        std::string *merchantDescriptorCounty;
        /// Optional element 'ns2:referenceDataCode' of XML schema type 'xsd:string'
        std::string *referenceDataCode;
        /// Optional element 'ns2:referenceDataNumber' of XML schema type 'xsd:string'
        std::string *referenceDataNumber;
        /// Optional element 'ns2:merchantDescriptorStoreID' of XML schema type 'xsd:string'
        std::string *merchantDescriptorStoreID;
        /// Optional element 'ns2:clerkID' of XML schema type 'xsd:string'
        std::string *clerkID;
        /// Optional element 'ns2:customData_1' of XML schema type 'xsd:string'
        std::string *customData_USCORE1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__InvoiceHeader
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__InvoiceHeader; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__InvoiceHeader, default initialized and not managed by a soap context
        virtual ns2__InvoiceHeader *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__InvoiceHeader); }
      public:
        /// Constructor with default initializations
        ns2__InvoiceHeader() : merchantDescriptor(), merchantDescriptorContact(), merchantDescriptorAlternate(), merchantDescriptorStreet(), merchantDescriptorCity(), merchantDescriptorState(), merchantDescriptorPostalCode(), merchantDescriptorCountry(), isGift(), returnsAccepted(), tenderType(), merchantVATRegistrationNumber(), purchaserOrderDate(), purchaserVATRegistrationNumber(), vatInvoiceReferenceNumber(), summaryCommodityCode(), supplierOrderReference(), userPO(), costCenter(), purchaserCode(), taxable(), amexDataTAA1(), amexDataTAA2(), amexDataTAA3(), amexDataTAA4(), invoiceDate(), totalTaxTypeCode(), cardAcceptorRefNumber(), authorizedContactName(), businessApplicationID(), salesOrganizationID(), submerchantID(), submerchantName(), submerchantStreet(), submerchantCity(), submerchantPostalCode(), submerchantState(), submerchantCountry(), submerchantEmail(), submerchantTelephoneNumber(), submerchantRegion(), submerchantMerchantID(), merchantDescriptorCounty(), referenceDataCode(), referenceDataNumber(), merchantDescriptorStoreID(), clerkID(), customData_USCORE1(), soap() { }
        virtual ~ns2__InvoiceHeader() { }
        /// Friend allocator used by soap_new_ns2__InvoiceHeader(struct soap*, int)
        friend SOAP_FMAC1 ns2__InvoiceHeader * SOAP_FMAC2 soap_instantiate_ns2__InvoiceHeader(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:326 */
#ifndef SOAP_TYPE_ns2__BusinessRules
#define SOAP_TYPE_ns2__BusinessRules (358)
/* complex XML schema type 'ns2:BusinessRules': */
class SOAP_CMAC ns2__BusinessRules {
      public:
        /// Optional element 'ns2:ignoreAVSResult' of XML schema type 'ns2:boolean'
        std::string *ignoreAVSResult;
        /// Optional element 'ns2:ignoreCVResult' of XML schema type 'ns2:boolean'
        std::string *ignoreCVResult;
        /// Optional element 'ns2:ignoreDAVResult' of XML schema type 'ns2:boolean'
        std::string *ignoreDAVResult;
        /// Optional element 'ns2:ignoreExportResult' of XML schema type 'ns2:boolean'
        std::string *ignoreExportResult;
        /// Optional element 'ns2:ignoreValidateResult' of XML schema type 'ns2:boolean'
        std::string *ignoreValidateResult;
        /// Optional element 'ns2:declineAVSFlags' of XML schema type 'xsd:string'
        std::string *declineAVSFlags;
        /// Optional element 'ns2:scoreThreshold' of XML schema type 'xsd:integer'
        std::string *scoreThreshold;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BusinessRules
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__BusinessRules; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BusinessRules, default initialized and not managed by a soap context
        virtual ns2__BusinessRules *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__BusinessRules); }
      public:
        /// Constructor with default initializations
        ns2__BusinessRules() : ignoreAVSResult(), ignoreCVResult(), ignoreDAVResult(), ignoreExportResult(), ignoreValidateResult(), declineAVSFlags(), scoreThreshold(), soap() { }
        virtual ~ns2__BusinessRules() { }
        /// Friend allocator used by soap_new_ns2__BusinessRules(struct soap*, int)
        friend SOAP_FMAC1 ns2__BusinessRules * SOAP_FMAC2 soap_instantiate_ns2__BusinessRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:328 */
#ifndef SOAP_TYPE_ns2__BillTo
#define SOAP_TYPE_ns2__BillTo (359)
/* complex XML schema type 'ns2:BillTo': */
class SOAP_CMAC ns2__BillTo {
      public:
        /// Optional element 'ns2:title' of XML schema type 'xsd:string'
        std::string *title;
        /// Optional element 'ns2:firstName' of XML schema type 'xsd:string'
        std::string *firstName;
        /// Optional element 'ns2:middleName' of XML schema type 'xsd:string'
        std::string *middleName;
        /// Optional element 'ns2:lastName' of XML schema type 'xsd:string'
        std::string *lastName;
        /// Optional element 'ns2:suffix' of XML schema type 'xsd:string'
        std::string *suffix;
        /// Optional element 'ns2:buildingNumber' of XML schema type 'xsd:string'
        std::string *buildingNumber;
        /// Optional element 'ns2:street1' of XML schema type 'xsd:string'
        std::string *street1;
        /// Optional element 'ns2:street2' of XML schema type 'xsd:string'
        std::string *street2;
        /// Optional element 'ns2:street3' of XML schema type 'xsd:string'
        std::string *street3;
        /// Optional element 'ns2:street4' of XML schema type 'xsd:string'
        std::string *street4;
        /// Optional element 'ns2:street5' of XML schema type 'xsd:string'
        std::string *street5;
        /// Optional element 'ns2:city' of XML schema type 'xsd:string'
        std::string *city;
        /// Optional element 'ns2:district' of XML schema type 'xsd:string'
        std::string *district;
        /// Optional element 'ns2:county' of XML schema type 'xsd:string'
        std::string *county;
        /// Optional element 'ns2:state' of XML schema type 'xsd:string'
        std::string *state;
        /// Optional element 'ns2:postalCode' of XML schema type 'xsd:string'
        std::string *postalCode;
        /// Optional element 'ns2:country' of XML schema type 'xsd:string'
        std::string *country;
        /// Optional element 'ns2:company' of XML schema type 'xsd:string'
        std::string *company;
        /// Optional element 'ns2:companyTaxID' of XML schema type 'xsd:string'
        std::string *companyTaxID;
        /// Optional element 'ns2:phoneNumber' of XML schema type 'xsd:string'
        std::string *phoneNumber;
        /// Optional element 'ns2:email' of XML schema type 'xsd:string'
        std::string *email;
        /// Optional element 'ns2:ipAddress' of XML schema type 'xsd:string'
        std::string *ipAddress;
        /// Optional element 'ns2:customerUserName' of XML schema type 'xsd:string'
        std::string *customerUserName;
        /// Optional element 'ns2:customerPassword' of XML schema type 'xsd:string'
        std::string *customerPassword;
        /// Optional element 'ns2:ipNetworkAddress' of XML schema type 'xsd:string'
        std::string *ipNetworkAddress;
        /// Optional element 'ns2:hostname' of XML schema type 'xsd:string'
        std::string *hostname;
        /// Optional element 'ns2:domainName' of XML schema type 'xsd:string'
        std::string *domainName;
        /// Optional element 'ns2:dateOfBirth' of XML schema type 'xsd:string'
        std::string *dateOfBirth;
        /// Optional element 'ns2:driversLicenseNumber' of XML schema type 'xsd:string'
        std::string *driversLicenseNumber;
        /// Optional element 'ns2:driversLicenseState' of XML schema type 'xsd:string'
        std::string *driversLicenseState;
        /// Optional element 'ns2:ssn' of XML schema type 'xsd:string'
        std::string *ssn;
        /// Optional element 'ns2:customerID' of XML schema type 'xsd:string'
        std::string *customerID;
        /// Optional element 'ns2:httpBrowserType' of XML schema type 'xsd:string'
        std::string *httpBrowserType;
        /// Optional element 'ns2:httpBrowserEmail' of XML schema type 'xsd:string'
        std::string *httpBrowserEmail;
        /// Optional element 'ns2:httpBrowserCookiesAccepted' of XML schema type 'ns2:boolean'
        std::string *httpBrowserCookiesAccepted;
        /// Optional element 'ns2:nif' of XML schema type 'xsd:string'
        std::string *nif;
        /// Optional element 'ns2:personalID' of XML schema type 'xsd:string'
        std::string *personalID;
        /// Optional element 'ns2:language' of XML schema type 'xsd:string'
        std::string *language;
        /// Optional element 'ns2:name' of XML schema type 'xsd:string'
        std::string *name;
        /// Optional element 'ns2:gender' of XML schema type 'xsd:string'
        std::string *gender;
        /// Optional element 'ns2:merchantTaxID' of XML schema type 'xsd:string'
        std::string *merchantTaxID;
        /// Optional element 'ns2:passportNumber' of XML schema type 'xsd:string'
        std::string *passportNumber;
        /// Optional element 'ns2:passportCountry' of XML schema type 'xsd:string'
        std::string *passportCountry;
        /// Optional element 'ns2:customerAccountCreateDate' of XML schema type 'xsd:string'
        std::string *customerAccountCreateDate;
        /// Optional element 'ns2:customerAccountChangeDate' of XML schema type 'xsd:string'
        std::string *customerAccountChangeDate;
        /// Optional element 'ns2:customerAccountPasswordChangeDate' of XML schema type 'xsd:string'
        std::string *customerAccountPasswordChangeDate;
        /// Optional element 'ns2:pointOfReference' of XML schema type 'ns2:boolean'
        std::string *pointOfReference;
        /// Optional element 'ns2:defaultIndicator' of XML schema type 'ns2:boolean'
        std::string *defaultIndicator;
        /// Optional element 'ns2:companyStreet1' of XML schema type 'xsd:string'
        std::string *companyStreet1;
        /// Optional element 'ns2:companyStreet2' of XML schema type 'xsd:string'
        std::string *companyStreet2;
        /// Optional element 'ns2:companyCity' of XML schema type 'xsd:string'
        std::string *companyCity;
        /// Optional element 'ns2:companyCountry' of XML schema type 'xsd:string'
        std::string *companyCountry;
        /// Optional element 'ns2:companyState' of XML schema type 'xsd:string'
        std::string *companyState;
        /// Optional element 'ns2:companyPostalCode' of XML schema type 'xsd:string'
        std::string *companyPostalCode;
        /// Optional element 'ns2:prefix' of XML schema type 'xsd:string'
        std::string *prefix;
        /// Optional element 'ns2:companyPhoneNumber' of XML schema type 'xsd:string'
        std::string *companyPhoneNumber;
        /// Optional element 'ns2:httpBrowserColorDepth' of XML schema type 'xsd:string'
        std::string *httpBrowserColorDepth;
        /// Optional element 'ns2:httpBrowserJavaEnabled' of XML schema type 'ns2:boolean'
        std::string *httpBrowserJavaEnabled;
        /// Optional element 'ns2:httpBrowserJavaScriptEnabled' of XML schema type 'ns2:boolean'
        std::string *httpBrowserJavaScriptEnabled;
        /// Optional element 'ns2:httpBrowserLanguage' of XML schema type 'xsd:string'
        std::string *httpBrowserLanguage;
        /// Optional element 'ns2:httpBrowserScreenHeight' of XML schema type 'xsd:string'
        std::string *httpBrowserScreenHeight;
        /// Optional element 'ns2:httpBrowserScreenWidth' of XML schema type 'xsd:string'
        std::string *httpBrowserScreenWidth;
        /// Optional element 'ns2:httpBrowserTimeDifference' of XML schema type 'xsd:string'
        std::string *httpBrowserTimeDifference;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BillTo
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__BillTo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BillTo, default initialized and not managed by a soap context
        virtual ns2__BillTo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__BillTo); }
      public:
        /// Constructor with default initializations
        ns2__BillTo() : title(), firstName(), middleName(), lastName(), suffix(), buildingNumber(), street1(), street2(), street3(), street4(), street5(), city(), district(), county(), state(), postalCode(), country(), company(), companyTaxID(), phoneNumber(), email(), ipAddress(), customerUserName(), customerPassword(), ipNetworkAddress(), hostname(), domainName(), dateOfBirth(), driversLicenseNumber(), driversLicenseState(), ssn(), customerID(), httpBrowserType(), httpBrowserEmail(), httpBrowserCookiesAccepted(), nif(), personalID(), language(), name(), gender(), merchantTaxID(), passportNumber(), passportCountry(), customerAccountCreateDate(), customerAccountChangeDate(), customerAccountPasswordChangeDate(), pointOfReference(), defaultIndicator(), companyStreet1(), companyStreet2(), companyCity(), companyCountry(), companyState(), companyPostalCode(), prefix(), companyPhoneNumber(), httpBrowserColorDepth(), httpBrowserJavaEnabled(), httpBrowserJavaScriptEnabled(), httpBrowserLanguage(), httpBrowserScreenHeight(), httpBrowserScreenWidth(), httpBrowserTimeDifference(), soap() { }
        virtual ~ns2__BillTo() { }
        /// Friend allocator used by soap_new_ns2__BillTo(struct soap*, int)
        friend SOAP_FMAC1 ns2__BillTo * SOAP_FMAC2 soap_instantiate_ns2__BillTo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:330 */
#ifndef SOAP_TYPE_ns2__ShipTo
#define SOAP_TYPE_ns2__ShipTo (360)
/* complex XML schema type 'ns2:ShipTo': */
class SOAP_CMAC ns2__ShipTo {
      public:
        /// Optional element 'ns2:title' of XML schema type 'xsd:string'
        std::string *title;
        /// Optional element 'ns2:firstName' of XML schema type 'xsd:string'
        std::string *firstName;
        /// Optional element 'ns2:middleName' of XML schema type 'xsd:string'
        std::string *middleName;
        /// Optional element 'ns2:lastName' of XML schema type 'xsd:string'
        std::string *lastName;
        /// Optional element 'ns2:suffix' of XML schema type 'xsd:string'
        std::string *suffix;
        /// Optional element 'ns2:street1' of XML schema type 'xsd:string'
        std::string *street1;
        /// Optional element 'ns2:street2' of XML schema type 'xsd:string'
        std::string *street2;
        /// Optional element 'ns2:street3' of XML schema type 'xsd:string'
        std::string *street3;
        /// Optional element 'ns2:street4' of XML schema type 'xsd:string'
        std::string *street4;
        /// Optional element 'ns2:street5' of XML schema type 'xsd:string'
        std::string *street5;
        /// Optional element 'ns2:city' of XML schema type 'xsd:string'
        std::string *city;
        /// Optional element 'ns2:county' of XML schema type 'xsd:string'
        std::string *county;
        /// Optional element 'ns2:state' of XML schema type 'xsd:string'
        std::string *state;
        /// Optional element 'ns2:buildingNumber' of XML schema type 'xsd:string'
        std::string *buildingNumber;
        /// Optional element 'ns2:district' of XML schema type 'xsd:string'
        std::string *district;
        /// Optional element 'ns2:postalCode' of XML schema type 'xsd:string'
        std::string *postalCode;
        /// Optional element 'ns2:country' of XML schema type 'xsd:string'
        std::string *country;
        /// Optional element 'ns2:company' of XML schema type 'xsd:string'
        std::string *company;
        /// Optional element 'ns2:phoneNumber' of XML schema type 'xsd:string'
        std::string *phoneNumber;
        /// Optional element 'ns2:email' of XML schema type 'xsd:string'
        std::string *email;
        /// Optional element 'ns2:shippingMethod' of XML schema type 'xsd:string'
        std::string *shippingMethod;
        /// Optional element 'ns2:name' of XML schema type 'xsd:string'
        std::string *name;
        /// Optional element 'ns2:id' of XML schema type 'xsd:string'
        std::string *id;
        /// Optional element 'ns2:addressVerificationStatus' of XML schema type 'xsd:string'
        std::string *addressVerificationStatus;
        /// Optional element 'ns2:notApplicable' of XML schema type 'ns2:boolean'
        std::string *notApplicable;
        /// Optional element 'ns2:immutable' of XML schema type 'ns2:boolean'
        std::string *immutable;
        /// Optional element 'ns2:destinationCode' of XML schema type 'xsd:string'
        std::string *destinationCode;
        /// Optional element 'ns2:pointOfReference' of XML schema type 'ns2:boolean'
        std::string *pointOfReference;
        /// Optional element 'ns2:default' of XML schema type 'ns2:boolean'
        std::string *default_;
        /// Optional element 'ns2:destinationTypes' of XML schema type 'xsd:string'
        std::string *destinationTypes;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ShipTo
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ShipTo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ShipTo, default initialized and not managed by a soap context
        virtual ns2__ShipTo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ShipTo); }
      public:
        /// Constructor with default initializations
        ns2__ShipTo() : title(), firstName(), middleName(), lastName(), suffix(), street1(), street2(), street3(), street4(), street5(), city(), county(), state(), buildingNumber(), district(), postalCode(), country(), company(), phoneNumber(), email(), shippingMethod(), name(), id(), addressVerificationStatus(), notApplicable(), immutable(), destinationCode(), pointOfReference(), default_(), destinationTypes(), soap() { }
        virtual ~ns2__ShipTo() { }
        /// Friend allocator used by soap_new_ns2__ShipTo(struct soap*, int)
        friend SOAP_FMAC1 ns2__ShipTo * SOAP_FMAC2 soap_instantiate_ns2__ShipTo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:332 */
#ifndef SOAP_TYPE_ns2__ShipFrom
#define SOAP_TYPE_ns2__ShipFrom (361)
/* complex XML schema type 'ns2:ShipFrom': */
class SOAP_CMAC ns2__ShipFrom {
      public:
        /// Optional element 'ns2:title' of XML schema type 'xsd:string'
        std::string *title;
        /// Optional element 'ns2:firstName' of XML schema type 'xsd:string'
        std::string *firstName;
        /// Optional element 'ns2:middleName' of XML schema type 'xsd:string'
        std::string *middleName;
        /// Optional element 'ns2:lastName' of XML schema type 'xsd:string'
        std::string *lastName;
        /// Optional element 'ns2:suffix' of XML schema type 'xsd:string'
        std::string *suffix;
        /// Optional element 'ns2:street1' of XML schema type 'xsd:string'
        std::string *street1;
        /// Optional element 'ns2:street2' of XML schema type 'xsd:string'
        std::string *street2;
        /// Optional element 'ns2:street3' of XML schema type 'xsd:string'
        std::string *street3;
        /// Optional element 'ns2:street4' of XML schema type 'xsd:string'
        std::string *street4;
        /// Optional element 'ns2:city' of XML schema type 'xsd:string'
        std::string *city;
        /// Optional element 'ns2:county' of XML schema type 'xsd:string'
        std::string *county;
        /// Optional element 'ns2:state' of XML schema type 'xsd:string'
        std::string *state;
        /// Optional element 'ns2:postalCode' of XML schema type 'xsd:string'
        std::string *postalCode;
        /// Optional element 'ns2:country' of XML schema type 'xsd:string'
        std::string *country;
        /// Optional element 'ns2:company' of XML schema type 'xsd:string'
        std::string *company;
        /// Optional element 'ns2:phoneNumber' of XML schema type 'xsd:string'
        std::string *phoneNumber;
        /// Optional element 'ns2:email' of XML schema type 'xsd:string'
        std::string *email;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ShipFrom
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ShipFrom; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ShipFrom, default initialized and not managed by a soap context
        virtual ns2__ShipFrom *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ShipFrom); }
      public:
        /// Constructor with default initializations
        ns2__ShipFrom() : title(), firstName(), middleName(), lastName(), suffix(), street1(), street2(), street3(), street4(), city(), county(), state(), postalCode(), country(), company(), phoneNumber(), email(), soap() { }
        virtual ~ns2__ShipFrom() { }
        /// Friend allocator used by soap_new_ns2__ShipFrom(struct soap*, int)
        friend SOAP_FMAC1 ns2__ShipFrom * SOAP_FMAC2 soap_instantiate_ns2__ShipFrom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:334 */
#ifndef SOAP_TYPE_ns2__Card
#define SOAP_TYPE_ns2__Card (362)
/* complex XML schema type 'ns2:Card': */
class SOAP_CMAC ns2__Card {
      public:
        /// Optional element 'ns2:fullName' of XML schema type 'xsd:string'
        std::string *fullName;
        /// Optional element 'ns2:accountNumber' of XML schema type 'xsd:string'
        std::string *accountNumber;
        /// Optional element 'ns2:expirationMonth' of XML schema type 'xsd:integer'
        std::string *expirationMonth;
        /// Optional element 'ns2:expirationYear' of XML schema type 'xsd:integer'
        std::string *expirationYear;
        /// Optional element 'ns2:cvIndicator' of XML schema type 'xsd:string'
        std::string *cvIndicator;
        /// Optional element 'ns2:cvNumber' of XML schema type 'xsd:string'
        std::string *cvNumber;
        /// Optional element 'ns2:cardType' of XML schema type 'xsd:string'
        std::string *cardType;
        /// Optional element 'ns2:issueNumber' of XML schema type 'xsd:string'
        std::string *issueNumber;
        /// Optional element 'ns2:startMonth' of XML schema type 'xsd:integer'
        std::string *startMonth;
        /// Optional element 'ns2:startYear' of XML schema type 'xsd:integer'
        std::string *startYear;
        /// Optional element 'ns2:pin' of XML schema type 'xsd:string'
        std::string *pin;
        /// Optional element 'ns2:accountEncoderID' of XML schema type 'xsd:string'
        std::string *accountEncoderID;
        /// Optional element 'ns2:bin' of XML schema type 'xsd:string'
        std::string *bin;
        /// Optional element 'ns2:encryptedData' of XML schema type 'xsd:string'
        std::string *encryptedData;
        /// Optional element 'ns2:suffix' of XML schema type 'xsd:string'
        std::string *suffix;
        /// Optional element 'ns2:virtual' of XML schema type 'ns2:boolean'
        std::string *virtual_;
        /// Optional element 'ns2:prefix' of XML schema type 'xsd:string'
        std::string *prefix;
        /// Optional element 'ns2:cardTypeName' of XML schema type 'xsd:string'
        std::string *cardTypeName;
        /// Optional element 'ns2:cardSubType' of XML schema type 'xsd:string'
        std::string *cardSubType;
        /// Optional element 'ns2:level2Eligible' of XML schema type 'xsd:string'
        std::string *level2Eligible;
        /// Optional element 'ns2:level3Eligible' of XML schema type 'xsd:string'
        std::string *level3Eligible;
        /// Optional element 'ns2:productCategory' of XML schema type 'xsd:string'
        std::string *productCategory;
        /// Optional element 'ns2:billingCurrency' of XML schema type 'xsd:string'
        std::string *billingCurrency;
        /// Optional element 'ns2:billingCurrencyNumericCode' of XML schema type 'xsd:string'
        std::string *billingCurrencyNumericCode;
        /// Optional element 'ns2:billingCurrencyMinorDigits' of XML schema type 'xsd:string'
        std::string *billingCurrencyMinorDigits;
        /// Optional element 'ns2:productName' of XML schema type 'xsd:string'
        std::string *productName;
        /// Optional element 'ns2:usage' of XML schema type 'xsd:string'
        std::string *usage;
        /// Optional element 'ns2:prepaidReloadable' of XML schema type 'xsd:string'
        std::string *prepaidReloadable;
        /// Optional element 'ns2:prepaidType' of XML schema type 'xsd:string'
        std::string *prepaidType;
        /// Sequence of 0 to 5 elements 'ns2:brands' of XML schema type 'ns2:Brands'
        std::vector<ns2__Brands> brands;
        /// Optional element 'ns2:fastFundsBusinessFundedTransferDomestic' of XML schema type 'xsd:string'
        std::string *fastFundsBusinessFundedTransferDomestic;
        /// Optional element 'ns2:fastFundsBusinessFundedTransferCrossBorder' of XML schema type 'xsd:string'
        std::string *fastFundsBusinessFundedTransferCrossBorder;
        /// Optional element 'ns2:fastFundsConsumerFundedTransferDomestic' of XML schema type 'xsd:string'
        std::string *fastFundsConsumerFundedTransferDomestic;
        /// Optional element 'ns2:fastFundsConsumerFundedTransferCrossBorder' of XML schema type 'xsd:string'
        std::string *fastFundsConsumerFundedTransferCrossBorder;
        /// Optional element 'ns2:octBusinessFundedTransferDomestic' of XML schema type 'xsd:string'
        std::string *octBusinessFundedTransferDomestic;
        /// Optional element 'ns2:octBusinessFundedTransferCrossBorder' of XML schema type 'xsd:string'
        std::string *octBusinessFundedTransferCrossBorder;
        /// Optional element 'ns2:octConsumerFundedTransferDomestic' of XML schema type 'xsd:string'
        std::string *octConsumerFundedTransferDomestic;
        /// Optional element 'ns2:octConsumerFundedTransferCrossBorder' of XML schema type 'xsd:string'
        std::string *octConsumerFundedTransferCrossBorder;
        /// Optional element 'ns2:octGamblingDomestic' of XML schema type 'xsd:string'
        std::string *octGamblingDomestic;
        /// Optional element 'ns2:octGamblingCrossBorder' of XML schema type 'xsd:string'
        std::string *octGamblingCrossBorder;
        /// Optional element 'ns2:fastFundsGamblingDomestic' of XML schema type 'xsd:string'
        std::string *fastFundsGamblingDomestic;
        /// Optional element 'ns2:fastFundsGamblingCrossBorder' of XML schema type 'xsd:string'
        std::string *fastFundsGamblingCrossBorder;
        /// Optional element 'ns2:octGeoRestrictionIndicator' of XML schema type 'xsd:string'
        std::string *octGeoRestrictionIndicator;
        /// Optional element 'ns2:comboCardType' of XML schema type 'xsd:string'
        std::string *comboCardType;
        /// Optional element 'ns2:prepaidIndicator' of XML schema type 'xsd:string'
        std::string *prepaidIndicator;
        /// Optional element 'ns2:passPhrase' of XML schema type 'xsd:string'
        std::string *passPhrase;
        /// Optional element 'ns2:personalData' of XML schema type 'xsd:string'
        std::string *personalData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Card
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Card; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Card, default initialized and not managed by a soap context
        virtual ns2__Card *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Card); }
      public:
        /// Constructor with default initializations
        ns2__Card() : fullName(), accountNumber(), expirationMonth(), expirationYear(), cvIndicator(), cvNumber(), cardType(), issueNumber(), startMonth(), startYear(), pin(), accountEncoderID(), bin(), encryptedData(), suffix(), virtual_(), prefix(), cardTypeName(), cardSubType(), level2Eligible(), level3Eligible(), productCategory(), billingCurrency(), billingCurrencyNumericCode(), billingCurrencyMinorDigits(), productName(), usage(), prepaidReloadable(), prepaidType(), brands(), fastFundsBusinessFundedTransferDomestic(), fastFundsBusinessFundedTransferCrossBorder(), fastFundsConsumerFundedTransferDomestic(), fastFundsConsumerFundedTransferCrossBorder(), octBusinessFundedTransferDomestic(), octBusinessFundedTransferCrossBorder(), octConsumerFundedTransferDomestic(), octConsumerFundedTransferCrossBorder(), octGamblingDomestic(), octGamblingCrossBorder(), fastFundsGamblingDomestic(), fastFundsGamblingCrossBorder(), octGeoRestrictionIndicator(), comboCardType(), prepaidIndicator(), passPhrase(), personalData(), soap() { }
        virtual ~ns2__Card() { }
        /// Friend allocator used by soap_new_ns2__Card(struct soap*, int)
        friend SOAP_FMAC1 ns2__Card * SOAP_FMAC2 soap_instantiate_ns2__Card(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:336 */
#ifndef SOAP_TYPE_ns2__Check
#define SOAP_TYPE_ns2__Check (363)
/* complex XML schema type 'ns2:Check': */
class SOAP_CMAC ns2__Check {
      public:
        /// Optional element 'ns2:fullName' of XML schema type 'xsd:string'
        std::string *fullName;
        /// Optional element 'ns2:accountNumber' of XML schema type 'xsd:string'
        std::string *accountNumber;
        /// Optional element 'ns2:accountType' of XML schema type 'xsd:string'
        std::string *accountType;
        /// Optional element 'ns2:bankTransitNumber' of XML schema type 'xsd:string'
        std::string *bankTransitNumber;
        /// Optional element 'ns2:checkNumber' of XML schema type 'xsd:string'
        std::string *checkNumber;
        /// Optional element 'ns2:secCode' of XML schema type 'xsd:string'
        std::string *secCode;
        /// Optional element 'ns2:accountEncoderID' of XML schema type 'xsd:string'
        std::string *accountEncoderID;
        /// Optional element 'ns2:authenticateID' of XML schema type 'xsd:string'
        std::string *authenticateID;
        /// Optional element 'ns2:paymentInfo' of XML schema type 'xsd:string'
        std::string *paymentInfo;
        /// Optional element 'ns2:imageReferenceNumber' of XML schema type 'xsd:string'
        std::string *imageReferenceNumber;
        /// Optional element 'ns2:terminalCity' of XML schema type 'xsd:string'
        std::string *terminalCity;
        /// Optional element 'ns2:terminalState' of XML schema type 'xsd:string'
        std::string *terminalState;
        /// Optional element 'ns2:customerPresent' of XML schema type 'xsd:string'
        std::string *customerPresent;
        /// Optional element 'ns2:checkTransactionCode' of XML schema type 'xsd:string'
        std::string *checkTransactionCode;
        /// Optional element 'ns2:disableAccountValidation' of XML schema type 'ns2:boolean'
        std::string *disableAccountValidation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Check
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Check; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Check, default initialized and not managed by a soap context
        virtual ns2__Check *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Check); }
      public:
        /// Constructor with default initializations
        ns2__Check() : fullName(), accountNumber(), accountType(), bankTransitNumber(), checkNumber(), secCode(), accountEncoderID(), authenticateID(), paymentInfo(), imageReferenceNumber(), terminalCity(), terminalState(), customerPresent(), checkTransactionCode(), disableAccountValidation(), soap() { }
        virtual ~ns2__Check() { }
        /// Friend allocator used by soap_new_ns2__Check(struct soap*, int)
        friend SOAP_FMAC1 ns2__Check * SOAP_FMAC2 soap_instantiate_ns2__Check(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:338 */
#ifndef SOAP_TYPE_ns2__BML
#define SOAP_TYPE_ns2__BML (364)
/* complex XML schema type 'ns2:BML': */
class SOAP_CMAC ns2__BML {
      public:
        /// Optional element 'ns2:customerBillingAddressChange' of XML schema type 'ns2:boolean'
        std::string *customerBillingAddressChange;
        /// Optional element 'ns2:customerEmailChange' of XML schema type 'ns2:boolean'
        std::string *customerEmailChange;
        /// Optional element 'ns2:customerHasCheckingAccount' of XML schema type 'ns2:boolean'
        std::string *customerHasCheckingAccount;
        /// Optional element 'ns2:customerHasSavingsAccount' of XML schema type 'ns2:boolean'
        std::string *customerHasSavingsAccount;
        /// Optional element 'ns2:customerPasswordChange' of XML schema type 'ns2:boolean'
        std::string *customerPasswordChange;
        /// Optional element 'ns2:customerPhoneChange' of XML schema type 'ns2:boolean'
        std::string *customerPhoneChange;
        /// Optional element 'ns2:customerRegistrationDate' of XML schema type 'xsd:string'
        std::string *customerRegistrationDate;
        /// Optional element 'ns2:customerTypeFlag' of XML schema type 'xsd:string'
        std::string *customerTypeFlag;
        /// Optional element 'ns2:grossHouseholdIncome' of XML schema type 'ns2:amount'
        std::string *grossHouseholdIncome;
        /// Optional element 'ns2:householdIncomeCurrency' of XML schema type 'xsd:string'
        std::string *householdIncomeCurrency;
        /// Optional element 'ns2:itemCategory' of XML schema type 'xsd:string'
        std::string *itemCategory;
        /// Optional element 'ns2:merchantPromotionCode' of XML schema type 'xsd:string'
        std::string *merchantPromotionCode;
        /// Optional element 'ns2:preapprovalNumber' of XML schema type 'xsd:string'
        std::string *preapprovalNumber;
        /// Optional element 'ns2:productDeliveryTypeIndicator' of XML schema type 'xsd:string'
        std::string *productDeliveryTypeIndicator;
        /// Optional element 'ns2:residenceStatus' of XML schema type 'xsd:string'
        std::string *residenceStatus;
        /// Optional element 'ns2:tcVersion' of XML schema type 'xsd:string'
        std::string *tcVersion;
        /// Optional element 'ns2:yearsAtCurrentResidence' of XML schema type 'xsd:integer'
        std::string *yearsAtCurrentResidence;
        /// Optional element 'ns2:yearsWithCurrentEmployer' of XML schema type 'xsd:integer'
        std::string *yearsWithCurrentEmployer;
        /// Optional element 'ns2:employerStreet1' of XML schema type 'xsd:string'
        std::string *employerStreet1;
        /// Optional element 'ns2:employerStreet2' of XML schema type 'xsd:string'
        std::string *employerStreet2;
        /// Optional element 'ns2:employerCity' of XML schema type 'xsd:string'
        std::string *employerCity;
        /// Optional element 'ns2:employerCompanyName' of XML schema type 'xsd:string'
        std::string *employerCompanyName;
        /// Optional element 'ns2:employerCountry' of XML schema type 'xsd:string'
        std::string *employerCountry;
        /// Optional element 'ns2:employerPhoneNumber' of XML schema type 'xsd:string'
        std::string *employerPhoneNumber;
        /// Optional element 'ns2:employerPhoneType' of XML schema type 'xsd:string'
        std::string *employerPhoneType;
        /// Optional element 'ns2:employerState' of XML schema type 'xsd:string'
        std::string *employerState;
        /// Optional element 'ns2:employerPostalCode' of XML schema type 'xsd:string'
        std::string *employerPostalCode;
        /// Optional element 'ns2:shipToPhoneType' of XML schema type 'xsd:string'
        std::string *shipToPhoneType;
        /// Optional element 'ns2:billToPhoneType' of XML schema type 'xsd:string'
        std::string *billToPhoneType;
        /// Optional element 'ns2:methodOfPayment' of XML schema type 'xsd:string'
        std::string *methodOfPayment;
        /// Optional element 'ns2:productType' of XML schema type 'xsd:string'
        std::string *productType;
        /// Optional element 'ns2:customerAuthenticatedByMerchant' of XML schema type 'xsd:string'
        std::string *customerAuthenticatedByMerchant;
        /// Optional element 'ns2:backOfficeIndicator' of XML schema type 'xsd:string'
        std::string *backOfficeIndicator;
        /// Optional element 'ns2:shipToEqualsBillToNameIndicator' of XML schema type 'xsd:string'
        std::string *shipToEqualsBillToNameIndicator;
        /// Optional element 'ns2:shipToEqualsBillToAddressIndicator' of XML schema type 'xsd:string'
        std::string *shipToEqualsBillToAddressIndicator;
        /// Optional element 'ns2:alternateIPAddress' of XML schema type 'xsd:string'
        std::string *alternateIPAddress;
        /// Optional element 'ns2:businessLegalName' of XML schema type 'xsd:string'
        std::string *businessLegalName;
        /// Optional element 'ns2:dbaName' of XML schema type 'xsd:string'
        std::string *dbaName;
        /// Optional element 'ns2:businessAddress1' of XML schema type 'xsd:string'
        std::string *businessAddress1;
        /// Optional element 'ns2:businessAddress2' of XML schema type 'xsd:string'
        std::string *businessAddress2;
        /// Optional element 'ns2:businessCity' of XML schema type 'xsd:string'
        std::string *businessCity;
        /// Optional element 'ns2:businessState' of XML schema type 'xsd:string'
        std::string *businessState;
        /// Optional element 'ns2:businessPostalCode' of XML schema type 'xsd:string'
        std::string *businessPostalCode;
        /// Optional element 'ns2:businessCountry' of XML schema type 'xsd:string'
        std::string *businessCountry;
        /// Optional element 'ns2:businessMainPhone' of XML schema type 'xsd:string'
        std::string *businessMainPhone;
        /// Optional element 'ns2:userID' of XML schema type 'xsd:string'
        std::string *userID;
        /// Optional element 'ns2:pin' of XML schema type 'xsd:string'
        std::string *pin;
        /// Optional element 'ns2:adminLastName' of XML schema type 'xsd:string'
        std::string *adminLastName;
        /// Optional element 'ns2:adminFirstName' of XML schema type 'xsd:string'
        std::string *adminFirstName;
        /// Optional element 'ns2:adminPhone' of XML schema type 'xsd:string'
        std::string *adminPhone;
        /// Optional element 'ns2:adminFax' of XML schema type 'xsd:string'
        std::string *adminFax;
        /// Optional element 'ns2:adminEmailAddress' of XML schema type 'xsd:string'
        std::string *adminEmailAddress;
        /// Optional element 'ns2:adminTitle' of XML schema type 'xsd:string'
        std::string *adminTitle;
        /// Optional element 'ns2:supervisorLastName' of XML schema type 'xsd:string'
        std::string *supervisorLastName;
        /// Optional element 'ns2:supervisorFirstName' of XML schema type 'xsd:string'
        std::string *supervisorFirstName;
        /// Optional element 'ns2:supervisorEmailAddress' of XML schema type 'xsd:string'
        std::string *supervisorEmailAddress;
        /// Optional element 'ns2:businessDAndBNumber' of XML schema type 'xsd:string'
        std::string *businessDAndBNumber;
        /// Optional element 'ns2:businessTaxID' of XML schema type 'xsd:string'
        std::string *businessTaxID;
        /// Optional element 'ns2:businessNAICSCode' of XML schema type 'xsd:string'
        std::string *businessNAICSCode;
        /// Optional element 'ns2:businessType' of XML schema type 'xsd:string'
        std::string *businessType;
        /// Optional element 'ns2:businessYearsInBusiness' of XML schema type 'xsd:string'
        std::string *businessYearsInBusiness;
        /// Optional element 'ns2:businessNumberOfEmployees' of XML schema type 'xsd:string'
        std::string *businessNumberOfEmployees;
        /// Optional element 'ns2:businessPONumber' of XML schema type 'xsd:string'
        std::string *businessPONumber;
        /// Optional element 'ns2:businessLoanType' of XML schema type 'xsd:string'
        std::string *businessLoanType;
        /// Optional element 'ns2:businessApplicationID' of XML schema type 'xsd:string'
        std::string *businessApplicationID;
        /// Optional element 'ns2:businessProductCode' of XML schema type 'xsd:string'
        std::string *businessProductCode;
        /// Optional element 'ns2:pgLastName' of XML schema type 'xsd:string'
        std::string *pgLastName;
        /// Optional element 'ns2:pgFirstName' of XML schema type 'xsd:string'
        std::string *pgFirstName;
        /// Optional element 'ns2:pgSSN' of XML schema type 'xsd:string'
        std::string *pgSSN;
        /// Optional element 'ns2:pgDateOfBirth' of XML schema type 'xsd:string'
        std::string *pgDateOfBirth;
        /// Optional element 'ns2:pgAnnualIncome' of XML schema type 'xsd:string'
        std::string *pgAnnualIncome;
        /// Optional element 'ns2:pgIncomeCurrencyType' of XML schema type 'xsd:string'
        std::string *pgIncomeCurrencyType;
        /// Optional element 'ns2:pgResidenceStatus' of XML schema type 'xsd:string'
        std::string *pgResidenceStatus;
        /// Optional element 'ns2:pgCheckingAccountIndicator' of XML schema type 'xsd:string'
        std::string *pgCheckingAccountIndicator;
        /// Optional element 'ns2:pgSavingsAccountIndicator' of XML schema type 'xsd:string'
        std::string *pgSavingsAccountIndicator;
        /// Optional element 'ns2:pgYearsAtEmployer' of XML schema type 'xsd:string'
        std::string *pgYearsAtEmployer;
        /// Optional element 'ns2:pgYearsAtResidence' of XML schema type 'xsd:string'
        std::string *pgYearsAtResidence;
        /// Optional element 'ns2:pgHomeAddress1' of XML schema type 'xsd:string'
        std::string *pgHomeAddress1;
        /// Optional element 'ns2:pgHomeAddress2' of XML schema type 'xsd:string'
        std::string *pgHomeAddress2;
        /// Optional element 'ns2:pgHomeCity' of XML schema type 'xsd:string'
        std::string *pgHomeCity;
        /// Optional element 'ns2:pgHomeState' of XML schema type 'xsd:string'
        std::string *pgHomeState;
        /// Optional element 'ns2:pgHomePostalCode' of XML schema type 'xsd:string'
        std::string *pgHomePostalCode;
        /// Optional element 'ns2:pgHomeCountry' of XML schema type 'xsd:string'
        std::string *pgHomeCountry;
        /// Optional element 'ns2:pgEmailAddress' of XML schema type 'xsd:string'
        std::string *pgEmailAddress;
        /// Optional element 'ns2:pgHomePhone' of XML schema type 'xsd:string'
        std::string *pgHomePhone;
        /// Optional element 'ns2:pgTitle' of XML schema type 'xsd:string'
        std::string *pgTitle;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BML
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__BML; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BML, default initialized and not managed by a soap context
        virtual ns2__BML *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__BML); }
      public:
        /// Constructor with default initializations
        ns2__BML() : customerBillingAddressChange(), customerEmailChange(), customerHasCheckingAccount(), customerHasSavingsAccount(), customerPasswordChange(), customerPhoneChange(), customerRegistrationDate(), customerTypeFlag(), grossHouseholdIncome(), householdIncomeCurrency(), itemCategory(), merchantPromotionCode(), preapprovalNumber(), productDeliveryTypeIndicator(), residenceStatus(), tcVersion(), yearsAtCurrentResidence(), yearsWithCurrentEmployer(), employerStreet1(), employerStreet2(), employerCity(), employerCompanyName(), employerCountry(), employerPhoneNumber(), employerPhoneType(), employerState(), employerPostalCode(), shipToPhoneType(), billToPhoneType(), methodOfPayment(), productType(), customerAuthenticatedByMerchant(), backOfficeIndicator(), shipToEqualsBillToNameIndicator(), shipToEqualsBillToAddressIndicator(), alternateIPAddress(), businessLegalName(), dbaName(), businessAddress1(), businessAddress2(), businessCity(), businessState(), businessPostalCode(), businessCountry(), businessMainPhone(), userID(), pin(), adminLastName(), adminFirstName(), adminPhone(), adminFax(), adminEmailAddress(), adminTitle(), supervisorLastName(), supervisorFirstName(), supervisorEmailAddress(), businessDAndBNumber(), businessTaxID(), businessNAICSCode(), businessType(), businessYearsInBusiness(), businessNumberOfEmployees(), businessPONumber(), businessLoanType(), businessApplicationID(), businessProductCode(), pgLastName(), pgFirstName(), pgSSN(), pgDateOfBirth(), pgAnnualIncome(), pgIncomeCurrencyType(), pgResidenceStatus(), pgCheckingAccountIndicator(), pgSavingsAccountIndicator(), pgYearsAtEmployer(), pgYearsAtResidence(), pgHomeAddress1(), pgHomeAddress2(), pgHomeCity(), pgHomeState(), pgHomePostalCode(), pgHomeCountry(), pgEmailAddress(), pgHomePhone(), pgTitle(), soap() { }
        virtual ~ns2__BML() { }
        /// Friend allocator used by soap_new_ns2__BML(struct soap*, int)
        friend SOAP_FMAC1 ns2__BML * SOAP_FMAC2 soap_instantiate_ns2__BML(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:340 */
#ifndef SOAP_TYPE_ns2__OtherTax
#define SOAP_TYPE_ns2__OtherTax (365)
/* complex XML schema type 'ns2:OtherTax': */
class SOAP_CMAC ns2__OtherTax {
      public:
        /// Optional element 'ns2:vatTaxAmount' of XML schema type 'ns2:amount'
        std::string *vatTaxAmount;
        /// Optional element 'ns2:vatTaxRate' of XML schema type 'ns2:amount'
        std::string *vatTaxRate;
        /// Optional element 'ns2:vatTaxAmountSign' of XML schema type 'xsd:string'
        std::string *vatTaxAmountSign;
        /// Optional element 'ns2:alternateTaxAmount' of XML schema type 'ns2:amount'
        std::string *alternateTaxAmount;
        /// Optional element 'ns2:alternateTaxIndicator' of XML schema type 'xsd:string'
        std::string *alternateTaxIndicator;
        /// Optional element 'ns2:alternateTaxID' of XML schema type 'xsd:string'
        std::string *alternateTaxID;
        /// Optional element 'ns2:localTaxAmount' of XML schema type 'ns2:amount'
        std::string *localTaxAmount;
        /// Optional element 'ns2:localTaxIndicator' of XML schema type 'xsd:integer'
        std::string *localTaxIndicator;
        /// Optional element 'ns2:nationalTaxAmount' of XML schema type 'ns2:amount'
        std::string *nationalTaxAmount;
        /// Optional element 'ns2:nationalTaxIndicator' of XML schema type 'xsd:integer'
        std::string *nationalTaxIndicator;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OtherTax
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__OtherTax; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OtherTax, default initialized and not managed by a soap context
        virtual ns2__OtherTax *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__OtherTax); }
      public:
        /// Constructor with default initializations
        ns2__OtherTax() : vatTaxAmount(), vatTaxRate(), vatTaxAmountSign(), alternateTaxAmount(), alternateTaxIndicator(), alternateTaxID(), localTaxAmount(), localTaxIndicator(), nationalTaxAmount(), nationalTaxIndicator(), soap() { }
        virtual ~ns2__OtherTax() { }
        /// Friend allocator used by soap_new_ns2__OtherTax(struct soap*, int)
        friend SOAP_FMAC1 ns2__OtherTax * SOAP_FMAC2 soap_instantiate_ns2__OtherTax(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:342 */
#ifndef SOAP_TYPE_ns2__Aft
#define SOAP_TYPE_ns2__Aft (366)
/* complex XML schema type 'ns2:Aft': */
class SOAP_CMAC ns2__Aft {
      public:
        /// Optional element 'ns2:indicator' of XML schema type 'xsd:string'
        std::string *indicator;
        /// Optional element 'ns2:serviceFee' of XML schema type 'xsd:string'
        std::string *serviceFee;
        /// Optional element 'ns2:foreignExchangeFee' of XML schema type 'xsd:string'
        std::string *foreignExchangeFee;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Aft
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Aft; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Aft, default initialized and not managed by a soap context
        virtual ns2__Aft *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Aft); }
      public:
        /// Constructor with default initializations
        ns2__Aft() : indicator(), serviceFee(), foreignExchangeFee(), soap() { }
        virtual ~ns2__Aft() { }
        /// Friend allocator used by soap_new_ns2__Aft(struct soap*, int)
        friend SOAP_FMAC1 ns2__Aft * SOAP_FMAC2 soap_instantiate_ns2__Aft(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:344 */
#ifndef SOAP_TYPE_ns2__Wallet
#define SOAP_TYPE_ns2__Wallet (367)
/* complex XML schema type 'ns2:Wallet': */
class SOAP_CMAC ns2__Wallet {
      public:
        /// Optional element 'ns2:type' of XML schema type 'xsd:string'
        std::string *type;
        /// Optional element 'ns2:orderID' of XML schema type 'xsd:string'
        std::string *orderID;
        /// Optional element 'ns2:merchantReferenceID' of XML schema type 'xsd:string'
        std::string *merchantReferenceID;
        /// Optional element 'ns2:userPhone' of XML schema type 'xsd:string'
        std::string *userPhone;
        /// Optional element 'ns2:avv' of XML schema type 'xsd:string'
        std::string *avv;
        /// Optional element 'ns2:eciRaw' of XML schema type 'xsd:string'
        std::string *eciRaw;
        /// Optional element 'ns2:authenticatonMethod' of XML schema type 'xsd:string'
        std::string *authenticatonMethod;
        /// Optional element 'ns2:cardEnrollmentMethod' of XML schema type 'xsd:string'
        std::string *cardEnrollmentMethod;
        /// Optional element 'ns2:paresStatus' of XML schema type 'xsd:string'
        std::string *paresStatus;
        /// Optional element 'ns2:veresEnrolled' of XML schema type 'xsd:string'
        std::string *veresEnrolled;
        /// Optional element 'ns2:xid' of XML schema type 'xsd:string'
        std::string *xid;
        /// Optional element 'ns2:totalPurchaseAmount' of XML schema type 'xsd:string'
        std::string *totalPurchaseAmount;
        /// Optional element 'ns2:subtotalAmount' of XML schema type 'xsd:string'
        std::string *subtotalAmount;
        /// Optional element 'ns2:discountAmount' of XML schema type 'xsd:string'
        std::string *discountAmount;
        /// Optional element 'ns2:giftWrapAmount' of XML schema type 'xsd:string'
        std::string *giftWrapAmount;
        /// Optional element 'ns2:eventType' of XML schema type 'xsd:string'
        std::string *eventType;
        /// Optional element 'ns2:promotionCode' of XML schema type 'xsd:string'
        std::string *promotionCode;
        /// Optional element 'ns2:enrollmentID' of XML schema type 'xsd:string'
        std::string *enrollmentID;
        /// Optional element 'ns2:staySignedInIndicator' of XML schema type 'xsd:string'
        std::string *staySignedInIndicator;
        /// Optional element 'ns2:authenticationData' of XML schema type 'xsd:string'
        std::string *authenticationData;
        /// Optional element 'ns2:deviceID' of XML schema type 'xsd:string'
        std::string *deviceID;
        /// Optional element 'ns2:httpResponse' of XML schema type 'xsd:string'
        std::string *httpResponse;
        /// Optional element 'ns2:errorCode' of XML schema type 'xsd:string'
        std::string *errorCode;
        /// Optional element 'ns2:errorDescription' of XML schema type 'xsd:string'
        std::string *errorDescription;
        /// Optional element 'ns2:pinURL' of XML schema type 'xsd:string'
        std::string *pinURL;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Wallet
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Wallet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Wallet, default initialized and not managed by a soap context
        virtual ns2__Wallet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Wallet); }
      public:
        /// Constructor with default initializations
        ns2__Wallet() : type(), orderID(), merchantReferenceID(), userPhone(), avv(), eciRaw(), authenticatonMethod(), cardEnrollmentMethod(), paresStatus(), veresEnrolled(), xid(), totalPurchaseAmount(), subtotalAmount(), discountAmount(), giftWrapAmount(), eventType(), promotionCode(), enrollmentID(), staySignedInIndicator(), authenticationData(), deviceID(), httpResponse(), errorCode(), errorDescription(), pinURL(), soap() { }
        virtual ~ns2__Wallet() { }
        /// Friend allocator used by soap_new_ns2__Wallet(struct soap*, int)
        friend SOAP_FMAC1 ns2__Wallet * SOAP_FMAC2 soap_instantiate_ns2__Wallet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:346 */
#ifndef SOAP_TYPE_ns2__PurchaseTotals
#define SOAP_TYPE_ns2__PurchaseTotals (368)
/* complex XML schema type 'ns2:PurchaseTotals': */
class SOAP_CMAC ns2__PurchaseTotals {
      public:
        /// Optional element 'ns2:currency' of XML schema type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:discountAmount' of XML schema type 'ns2:amount'
        std::string *discountAmount;
        /// Optional element 'ns2:discountAmountSign' of XML schema type 'xsd:string'
        std::string *discountAmountSign;
        /// Optional element 'ns2:discountManagementIndicator' of XML schema type 'xsd:string'
        std::string *discountManagementIndicator;
        /// Optional element 'ns2:taxAmount' of XML schema type 'ns2:amount'
        std::string *taxAmount;
        /// Optional element 'ns2:dutyAmount' of XML schema type 'ns2:amount'
        std::string *dutyAmount;
        /// Optional element 'ns2:dutyAmountSign' of XML schema type 'xsd:string'
        std::string *dutyAmountSign;
        /// Optional element 'ns2:grandTotalAmount' of XML schema type 'ns2:amount'
        std::string *grandTotalAmount;
        /// Optional element 'ns2:freightAmount' of XML schema type 'ns2:amount'
        std::string *freightAmount;
        /// Optional element 'ns2:freightAmountSign' of XML schema type 'xsd:string'
        std::string *freightAmountSign;
        /// Optional element 'ns2:foreignAmount' of XML schema type 'ns2:amount'
        std::string *foreignAmount;
        /// Optional element 'ns2:foreignCurrency' of XML schema type 'xsd:string'
        std::string *foreignCurrency;
        /// Optional element 'ns2:originalAmount' of XML schema type 'ns2:amount'
        std::string *originalAmount;
        /// Optional element 'ns2:originalCurrency' of XML schema type 'xsd:string'
        std::string *originalCurrency;
        /// Optional element 'ns2:exchangeRate' of XML schema type 'ns2:amount'
        std::string *exchangeRate;
        /// Optional element 'ns2:exchangeRateTimeStamp' of XML schema type 'xsd:string'
        std::string *exchangeRateTimeStamp;
        /// Optional element 'ns2:exchangeRateType' of XML schema type 'xsd:string'
        std::string *exchangeRateType;
        /// Optional element 'ns2:additionalAmountType0' of XML schema type 'xsd:string'
        std::string *additionalAmountType0;
        /// Optional element 'ns2:additionalAmount0' of XML schema type 'xsd:string'
        std::string *additionalAmount0;
        /// Optional element 'ns2:additionalAmountType1' of XML schema type 'xsd:string'
        std::string *additionalAmountType1;
        /// Optional element 'ns2:additionalAmount1' of XML schema type 'xsd:string'
        std::string *additionalAmount1;
        /// Optional element 'ns2:additionalAmountType2' of XML schema type 'xsd:string'
        std::string *additionalAmountType2;
        /// Optional element 'ns2:additionalAmount2' of XML schema type 'xsd:string'
        std::string *additionalAmount2;
        /// Optional element 'ns2:additionalAmountType3' of XML schema type 'xsd:string'
        std::string *additionalAmountType3;
        /// Optional element 'ns2:additionalAmount3' of XML schema type 'xsd:string'
        std::string *additionalAmount3;
        /// Optional element 'ns2:additionalAmountType4' of XML schema type 'xsd:string'
        std::string *additionalAmountType4;
        /// Optional element 'ns2:additionalAmount4' of XML schema type 'xsd:string'
        std::string *additionalAmount4;
        /// Optional element 'ns2:serviceFeeAmount' of XML schema type 'ns2:amount'
        std::string *serviceFeeAmount;
        /// Optional element 'ns2:subtotalAmount' of XML schema type 'ns2:amount'
        std::string *subtotalAmount;
        /// Optional element 'ns2:shippingAmount' of XML schema type 'ns2:amount'
        std::string *shippingAmount;
        /// Optional element 'ns2:handlingAmount' of XML schema type 'ns2:amount'
        std::string *handlingAmount;
        /// Optional element 'ns2:shippingHandlingAmount' of XML schema type 'ns2:amount'
        std::string *shippingHandlingAmount;
        /// Optional element 'ns2:shippingDiscountAmount' of XML schema type 'ns2:amount'
        std::string *shippingDiscountAmount;
        /// Optional element 'ns2:giftWrapAmount' of XML schema type 'ns2:amount'
        std::string *giftWrapAmount;
        /// Optional element 'ns2:insuranceAmount' of XML schema type 'ns2:amount'
        std::string *insuranceAmount;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PurchaseTotals
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PurchaseTotals; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PurchaseTotals, default initialized and not managed by a soap context
        virtual ns2__PurchaseTotals *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PurchaseTotals); }
      public:
        /// Constructor with default initializations
        ns2__PurchaseTotals() : currency(), discountAmount(), discountAmountSign(), discountManagementIndicator(), taxAmount(), dutyAmount(), dutyAmountSign(), grandTotalAmount(), freightAmount(), freightAmountSign(), foreignAmount(), foreignCurrency(), originalAmount(), originalCurrency(), exchangeRate(), exchangeRateTimeStamp(), exchangeRateType(), additionalAmountType0(), additionalAmount0(), additionalAmountType1(), additionalAmount1(), additionalAmountType2(), additionalAmount2(), additionalAmountType3(), additionalAmount3(), additionalAmountType4(), additionalAmount4(), serviceFeeAmount(), subtotalAmount(), shippingAmount(), handlingAmount(), shippingHandlingAmount(), shippingDiscountAmount(), giftWrapAmount(), insuranceAmount(), soap() { }
        virtual ~ns2__PurchaseTotals() { }
        /// Friend allocator used by soap_new_ns2__PurchaseTotals(struct soap*, int)
        friend SOAP_FMAC1 ns2__PurchaseTotals * SOAP_FMAC2 soap_instantiate_ns2__PurchaseTotals(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:348 */
#ifndef SOAP_TYPE_ns2__FundingTotals
#define SOAP_TYPE_ns2__FundingTotals (369)
/* complex XML schema type 'ns2:FundingTotals': */
class SOAP_CMAC ns2__FundingTotals {
      public:
        /// Optional element 'ns2:currency' of XML schema type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:grandTotalAmount' of XML schema type 'ns2:amount'
        std::string *grandTotalAmount;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FundingTotals
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__FundingTotals; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FundingTotals, default initialized and not managed by a soap context
        virtual ns2__FundingTotals *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__FundingTotals); }
      public:
        /// Constructor with default initializations
        ns2__FundingTotals() : currency(), grandTotalAmount(), soap() { }
        virtual ~ns2__FundingTotals() { }
        /// Friend allocator used by soap_new_ns2__FundingTotals(struct soap*, int)
        friend SOAP_FMAC1 ns2__FundingTotals * SOAP_FMAC2 soap_instantiate_ns2__FundingTotals(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:350 */
#ifndef SOAP_TYPE_ns2__GECC
#define SOAP_TYPE_ns2__GECC (370)
/* complex XML schema type 'ns2:GECC': */
class SOAP_CMAC ns2__GECC {
      public:
        /// Optional element 'ns2:saleType' of XML schema type 'xsd:string'
        std::string *saleType;
        /// Optional element 'ns2:planNumber' of XML schema type 'xsd:string'
        std::string *planNumber;
        /// Optional element 'ns2:sequenceNumber' of XML schema type 'xsd:string'
        std::string *sequenceNumber;
        /// Optional element 'ns2:promotionEndDate' of XML schema type 'xsd:string'
        std::string *promotionEndDate;
        /// Optional element 'ns2:promotionPlan' of XML schema type 'xsd:string'
        std::string *promotionPlan;
        /// Sequence of 0 to 7 elements 'ns2:line' of XML schema type 'xsd:string'
        std::vector<std::string> line;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GECC
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__GECC; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GECC, default initialized and not managed by a soap context
        virtual ns2__GECC *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__GECC); }
      public:
        /// Constructor with default initializations
        ns2__GECC() : saleType(), planNumber(), sequenceNumber(), promotionEndDate(), promotionPlan(), line(), soap() { }
        virtual ~ns2__GECC() { }
        /// Friend allocator used by soap_new_ns2__GECC(struct soap*, int)
        friend SOAP_FMAC1 ns2__GECC * SOAP_FMAC2 soap_instantiate_ns2__GECC(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:352 */
#ifndef SOAP_TYPE_ns2__UCAF
#define SOAP_TYPE_ns2__UCAF (371)
/* complex XML schema type 'ns2:UCAF': */
class SOAP_CMAC ns2__UCAF {
      public:
        /// Optional element 'ns2:authenticationData' of XML schema type 'xsd:string'
        std::string *authenticationData;
        /// Optional element 'ns2:collectionIndicator' of XML schema type 'xsd:string'
        std::string *collectionIndicator;
        /// Optional element 'ns2:downgradeReasonCode' of XML schema type 'xsd:string'
        std::string *downgradeReasonCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__UCAF
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__UCAF; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__UCAF, default initialized and not managed by a soap context
        virtual ns2__UCAF *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__UCAF); }
      public:
        /// Constructor with default initializations
        ns2__UCAF() : authenticationData(), collectionIndicator(), downgradeReasonCode(), soap() { }
        virtual ~ns2__UCAF() { }
        /// Friend allocator used by soap_new_ns2__UCAF(struct soap*, int)
        friend SOAP_FMAC1 ns2__UCAF * SOAP_FMAC2 soap_instantiate_ns2__UCAF(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:354 */
#ifndef SOAP_TYPE_ns2__Network
#define SOAP_TYPE_ns2__Network (372)
/* complex XML schema type 'ns2:Network': */
class SOAP_CMAC ns2__Network {
      public:
        /// Optional element 'ns2:octDomesticIndicator' of XML schema type 'xsd:string'
        std::string *octDomesticIndicator;
        /// Optional element 'ns2:octCrossBorderIndicator' of XML schema type 'xsd:string'
        std::string *octCrossBorderIndicator;
        /// Optional element 'ns2:aftDomesticIndicator' of XML schema type 'xsd:string'
        std::string *aftDomesticIndicator;
        /// Optional element 'ns2:aftCrossBorderIndicator' of XML schema type 'xsd:string'
        std::string *aftCrossBorderIndicator;
        /// Optional element 'ns2:networkID' of XML schema type 'xsd:string'
        std::string *networkID;
        /// Optional element 'ns2:networkOrder' of XML schema type 'xsd:string'
        std::string *networkOrder;
        /// Optional attribute 'id' of XML schema type 'xsd:integer'
        std::string *id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Network
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Network; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Network, default initialized and not managed by a soap context
        virtual ns2__Network *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Network); }
      public:
        /// Constructor with default initializations
        ns2__Network() : octDomesticIndicator(), octCrossBorderIndicator(), aftDomesticIndicator(), aftCrossBorderIndicator(), networkID(), networkOrder(), id(), soap() { }
        virtual ~ns2__Network() { }
        /// Friend allocator used by soap_new_ns2__Network(struct soap*, int)
        friend SOAP_FMAC1 ns2__Network * SOAP_FMAC2 soap_instantiate_ns2__Network(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:356 */
#ifndef SOAP_TYPE_ns2__Brands
#define SOAP_TYPE_ns2__Brands (373)
/* complex XML schema type 'ns2:Brands': */
class SOAP_CMAC ns2__Brands {
      public:
        /// Optional element 'ns2:name' of XML schema type 'xsd:string'
        std::string *name;
        /// Optional element 'ns2:type' of XML schema type 'xsd:string'
        std::string *type;
        /// Optional attribute 'id' of XML schema type 'xsd:integer'
        std::string *id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Brands
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Brands; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Brands, default initialized and not managed by a soap context
        virtual ns2__Brands *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Brands); }
      public:
        /// Constructor with default initializations
        ns2__Brands() : name(), type(), id(), soap() { }
        virtual ~ns2__Brands() { }
        /// Friend allocator used by soap_new_ns2__Brands(struct soap*, int)
        friend SOAP_FMAC1 ns2__Brands * SOAP_FMAC2 soap_instantiate_ns2__Brands(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:358 */
#ifndef SOAP_TYPE_ns2__FundTransfer
#define SOAP_TYPE_ns2__FundTransfer (374)
/* complex XML schema type 'ns2:FundTransfer': */
class SOAP_CMAC ns2__FundTransfer {
      public:
        /// Optional element 'ns2:accountNumber' of XML schema type 'xsd:string'
        std::string *accountNumber;
        /// Optional element 'ns2:accountName' of XML schema type 'xsd:string'
        std::string *accountName;
        /// Optional element 'ns2:bankCheckDigit' of XML schema type 'xsd:string'
        std::string *bankCheckDigit;
        /// Optional element 'ns2:iban' of XML schema type 'xsd:string'
        std::string *iban;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FundTransfer
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__FundTransfer; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FundTransfer, default initialized and not managed by a soap context
        virtual ns2__FundTransfer *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__FundTransfer); }
      public:
        /// Constructor with default initializations
        ns2__FundTransfer() : accountNumber(), accountName(), bankCheckDigit(), iban(), soap() { }
        virtual ~ns2__FundTransfer() { }
        /// Friend allocator used by soap_new_ns2__FundTransfer(struct soap*, int)
        friend SOAP_FMAC1 ns2__FundTransfer * SOAP_FMAC2 soap_instantiate_ns2__FundTransfer(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:360 */
#ifndef SOAP_TYPE_ns2__BankInfo
#define SOAP_TYPE_ns2__BankInfo (375)
/* complex XML schema type 'ns2:BankInfo': */
class SOAP_CMAC ns2__BankInfo {
      public:
        /// Optional element 'ns2:bankCode' of XML schema type 'xsd:string'
        std::string *bankCode;
        /// Optional element 'ns2:name' of XML schema type 'xsd:string'
        std::string *name;
        /// Optional element 'ns2:address' of XML schema type 'xsd:string'
        std::string *address;
        /// Optional element 'ns2:city' of XML schema type 'xsd:string'
        std::string *city;
        /// Optional element 'ns2:country' of XML schema type 'xsd:string'
        std::string *country;
        /// Optional element 'ns2:branchCode' of XML schema type 'xsd:string'
        std::string *branchCode;
        /// Optional element 'ns2:swiftCode' of XML schema type 'xsd:string'
        std::string *swiftCode;
        /// Optional element 'ns2:sortCode' of XML schema type 'xsd:string'
        std::string *sortCode;
        /// Optional element 'ns2:issuerID' of XML schema type 'xsd:string'
        std::string *issuerID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BankInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__BankInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BankInfo, default initialized and not managed by a soap context
        virtual ns2__BankInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__BankInfo); }
      public:
        /// Constructor with default initializations
        ns2__BankInfo() : bankCode(), name(), address(), city(), country(), branchCode(), swiftCode(), sortCode(), issuerID(), soap() { }
        virtual ~ns2__BankInfo() { }
        /// Friend allocator used by soap_new_ns2__BankInfo(struct soap*, int)
        friend SOAP_FMAC1 ns2__BankInfo * SOAP_FMAC2 soap_instantiate_ns2__BankInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:362 */
#ifndef SOAP_TYPE_ns2__RecurringSubscriptionInfo
#define SOAP_TYPE_ns2__RecurringSubscriptionInfo (376)
/* complex XML schema type 'ns2:RecurringSubscriptionInfo': */
class SOAP_CMAC ns2__RecurringSubscriptionInfo {
      public:
        /// Optional element 'ns2:subscriptionID' of XML schema type 'xsd:string'
        std::string *subscriptionID;
        /// Optional element 'ns2:status' of XML schema type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:numberOfPayments' of XML schema type 'xsd:integer'
        std::string *numberOfPayments;
        /// Optional element 'ns2:numberOfPaymentsToAdd' of XML schema type 'xsd:integer'
        std::string *numberOfPaymentsToAdd;
        /// Optional element 'ns2:sequenceNumber' of XML schema type 'xsd:integer'
        std::string *sequenceNumber;
        /// Optional element 'ns2:automaticRenew' of XML schema type 'ns2:boolean'
        std::string *automaticRenew;
        /// Optional element 'ns2:frequency' of XML schema type 'xsd:string'
        std::string *frequency;
        /// Optional element 'ns2:startDate' of XML schema type 'xsd:string'
        std::string *startDate;
        /// Optional element 'ns2:endDate' of XML schema type 'xsd:string'
        std::string *endDate;
        /// Optional element 'ns2:approvalRequired' of XML schema type 'ns2:boolean'
        std::string *approvalRequired;
        /// Optional element 'ns2:event' of XML schema type 'ns2:PaySubscriptionEvent'
        ns2__PaySubscriptionEvent *event;
        /// Optional element 'ns2:billPayment' of XML schema type 'ns2:boolean'
        std::string *billPayment;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RecurringSubscriptionInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__RecurringSubscriptionInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RecurringSubscriptionInfo, default initialized and not managed by a soap context
        virtual ns2__RecurringSubscriptionInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__RecurringSubscriptionInfo); }
      public:
        /// Constructor with default initializations
        ns2__RecurringSubscriptionInfo() : subscriptionID(), status(), amount(), numberOfPayments(), numberOfPaymentsToAdd(), sequenceNumber(), automaticRenew(), frequency(), startDate(), endDate(), approvalRequired(), event(), billPayment(), soap() { }
        virtual ~ns2__RecurringSubscriptionInfo() { }
        /// Friend allocator used by soap_new_ns2__RecurringSubscriptionInfo(struct soap*, int)
        friend SOAP_FMAC1 ns2__RecurringSubscriptionInfo * SOAP_FMAC2 soap_instantiate_ns2__RecurringSubscriptionInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:364 */
#ifndef SOAP_TYPE_ns2__PaySubscriptionEvent
#define SOAP_TYPE_ns2__PaySubscriptionEvent (377)
/* complex XML schema type 'ns2:PaySubscriptionEvent': */
class SOAP_CMAC ns2__PaySubscriptionEvent {
      public:
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:approvedBy' of XML schema type 'xsd:string'
        std::string *approvedBy;
        /// Optional element 'ns2:number' of XML schema type 'xsd:integer'
        std::string *number;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaySubscriptionEvent
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PaySubscriptionEvent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaySubscriptionEvent, default initialized and not managed by a soap context
        virtual ns2__PaySubscriptionEvent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PaySubscriptionEvent); }
      public:
        /// Constructor with default initializations
        ns2__PaySubscriptionEvent() : amount(), approvedBy(), number(), soap() { }
        virtual ~ns2__PaySubscriptionEvent() { }
        /// Friend allocator used by soap_new_ns2__PaySubscriptionEvent(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaySubscriptionEvent * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionEvent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:366 */
#ifndef SOAP_TYPE_ns2__Subscription
#define SOAP_TYPE_ns2__Subscription (378)
/* complex XML schema type 'ns2:Subscription': */
class SOAP_CMAC ns2__Subscription {
      public:
        /// Optional element 'ns2:title' of XML schema type 'xsd:string'
        std::string *title;
        /// Optional element 'ns2:paymentMethod' of XML schema type 'xsd:string'
        std::string *paymentMethod;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Subscription
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Subscription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Subscription, default initialized and not managed by a soap context
        virtual ns2__Subscription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Subscription); }
      public:
        /// Constructor with default initializations
        ns2__Subscription() : title(), paymentMethod(), soap() { }
        virtual ~ns2__Subscription() { }
        /// Friend allocator used by soap_new_ns2__Subscription(struct soap*, int)
        friend SOAP_FMAC1 ns2__Subscription * SOAP_FMAC2 soap_instantiate_ns2__Subscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:368 */
#ifndef SOAP_TYPE_ns2__TokenSource
#define SOAP_TYPE_ns2__TokenSource (379)
/* complex XML schema type 'ns2:TokenSource': */
class SOAP_CMAC ns2__TokenSource {
      public:
        /// Optional element 'ns2:transientToken' of XML schema type 'xsd:string'
        std::string *transientToken;
        /// Optional element 'ns2:networkTokenOption' of XML schema type 'xsd:string'
        std::string *networkTokenOption;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__TokenSource
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__TokenSource; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__TokenSource, default initialized and not managed by a soap context
        virtual ns2__TokenSource *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__TokenSource); }
      public:
        /// Constructor with default initializations
        ns2__TokenSource() : transientToken(), networkTokenOption(), soap() { }
        virtual ~ns2__TokenSource() { }
        /// Friend allocator used by soap_new_ns2__TokenSource(struct soap*, int)
        friend SOAP_FMAC1 ns2__TokenSource * SOAP_FMAC2 soap_instantiate_ns2__TokenSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:370 */
#ifndef SOAP_TYPE_ns2__PaymentNetworkToken
#define SOAP_TYPE_ns2__PaymentNetworkToken (380)
/* complex XML schema type 'ns2:PaymentNetworkToken': */
class SOAP_CMAC ns2__PaymentNetworkToken {
      public:
        /// Optional element 'ns2:requestorID' of XML schema type 'xsd:string'
        std::string *requestorID;
        /// Optional element 'ns2:transactionType' of XML schema type 'xsd:string'
        std::string *transactionType;
        /// Optional element 'ns2:assuranceLevel' of XML schema type 'xsd:string'
        std::string *assuranceLevel;
        /// Optional element 'ns2:accountStatus' of XML schema type 'xsd:string'
        std::string *accountStatus;
        /// Optional element 'ns2:originalCardCategory' of XML schema type 'xsd:string'
        std::string *originalCardCategory;
        /// Optional element 'ns2:deviceTechType' of XML schema type 'xsd:string'
        std::string *deviceTechType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaymentNetworkToken
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PaymentNetworkToken; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaymentNetworkToken, default initialized and not managed by a soap context
        virtual ns2__PaymentNetworkToken *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PaymentNetworkToken); }
      public:
        /// Constructor with default initializations
        ns2__PaymentNetworkToken() : requestorID(), transactionType(), assuranceLevel(), accountStatus(), originalCardCategory(), deviceTechType(), soap() { }
        virtual ~ns2__PaymentNetworkToken() { }
        /// Friend allocator used by soap_new_ns2__PaymentNetworkToken(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaymentNetworkToken * SOAP_FMAC2 soap_instantiate_ns2__PaymentNetworkToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:372 */
#ifndef SOAP_TYPE_ns2__DecisionManager
#define SOAP_TYPE_ns2__DecisionManager (381)
/* complex XML schema type 'ns2:DecisionManager': */
class SOAP_CMAC ns2__DecisionManager {
      public:
        /// Optional element 'ns2:enabled' of XML schema type 'ns2:boolean'
        std::string *enabled;
        /// Optional element 'ns2:profile' of XML schema type 'xsd:string'
        std::string *profile;
        /// Optional element 'ns2:pausedRequestID' of XML schema type 'xsd:string'
        std::string *pausedRequestID;
        /// Optional element 'ns2:authentication' of XML schema type 'ns2:Authentication'
        ns2__Authentication *authentication;
        /// Optional element 'ns2:travelData' of XML schema type 'ns2:DecisionManagerTravelData'
        ns2__DecisionManagerTravelData *travelData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DecisionManager
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DecisionManager; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DecisionManager, default initialized and not managed by a soap context
        virtual ns2__DecisionManager *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DecisionManager); }
      public:
        /// Constructor with default initializations
        ns2__DecisionManager() : enabled(), profile(), pausedRequestID(), authentication(), travelData(), soap() { }
        virtual ~ns2__DecisionManager() { }
        /// Friend allocator used by soap_new_ns2__DecisionManager(struct soap*, int)
        friend SOAP_FMAC1 ns2__DecisionManager * SOAP_FMAC2 soap_instantiate_ns2__DecisionManager(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:374 */
#ifndef SOAP_TYPE_ns2__Authentication
#define SOAP_TYPE_ns2__Authentication (382)
/* complex XML schema type 'ns2:Authentication': */
class SOAP_CMAC ns2__Authentication {
      public:
        /// Optional element 'ns2:outOfScope' of XML schema type 'xsd:string'
        std::string *outOfScope;
        /// Optional element 'ns2:exemption' of XML schema type 'xsd:string'
        std::string *exemption;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Authentication
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Authentication; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Authentication, default initialized and not managed by a soap context
        virtual ns2__Authentication *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Authentication); }
      public:
        /// Constructor with default initializations
        ns2__Authentication() : outOfScope(), exemption(), soap() { }
        virtual ~ns2__Authentication() { }
        /// Friend allocator used by soap_new_ns2__Authentication(struct soap*, int)
        friend SOAP_FMAC1 ns2__Authentication * SOAP_FMAC2 soap_instantiate_ns2__Authentication(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:376 */
#ifndef SOAP_TYPE_ns2__DecisionManagerTravelData
#define SOAP_TYPE_ns2__DecisionManagerTravelData (383)
/* complex XML schema type 'ns2:DecisionManagerTravelData': */
class SOAP_CMAC ns2__DecisionManagerTravelData {
      public:
        /// Sequence of 0 to 100 elements 'ns2:leg' of XML schema type 'ns2:DecisionManagerTravelLeg'
        std::vector<ns2__DecisionManagerTravelLeg> leg;
        /// Optional element 'ns2:departureDateTime' of XML schema type 'ns2:dateTime'
        std::string *departureDateTime;
        /// Optional element 'ns2:completeRoute' of XML schema type 'xsd:string'
        std::string *completeRoute;
        /// Optional element 'ns2:journeyType' of XML schema type 'xsd:string'
        std::string *journeyType;
        /// Optional element 'ns2:actualFinalDestination' of XML schema type 'xsd:string'
        std::string *actualFinalDestination;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DecisionManagerTravelData
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DecisionManagerTravelData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DecisionManagerTravelData, default initialized and not managed by a soap context
        virtual ns2__DecisionManagerTravelData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DecisionManagerTravelData); }
      public:
        /// Constructor with default initializations
        ns2__DecisionManagerTravelData() : leg(), departureDateTime(), completeRoute(), journeyType(), actualFinalDestination(), soap() { }
        virtual ~ns2__DecisionManagerTravelData() { }
        /// Friend allocator used by soap_new_ns2__DecisionManagerTravelData(struct soap*, int)
        friend SOAP_FMAC1 ns2__DecisionManagerTravelData * SOAP_FMAC2 soap_instantiate_ns2__DecisionManagerTravelData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:378 */
#ifndef SOAP_TYPE_ns2__DecisionManagerTravelLeg
#define SOAP_TYPE_ns2__DecisionManagerTravelLeg (384)
/* complex XML schema type 'ns2:DecisionManagerTravelLeg': */
class SOAP_CMAC ns2__DecisionManagerTravelLeg {
      public:
        /// Optional element 'ns2:origin' of XML schema type 'xsd:string'
        std::string *origin;
        /// Optional element 'ns2:destination' of XML schema type 'xsd:string'
        std::string *destination;
        /// Optional element 'ns2:departureDateTime' of XML schema type 'ns2:dateTime'
        std::string *departureDateTime;
        /// Optional attribute 'id' of XML schema type 'xsd:integer'
        std::string *id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DecisionManagerTravelLeg
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DecisionManagerTravelLeg; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DecisionManagerTravelLeg, default initialized and not managed by a soap context
        virtual ns2__DecisionManagerTravelLeg *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DecisionManagerTravelLeg); }
      public:
        /// Constructor with default initializations
        ns2__DecisionManagerTravelLeg() : origin(), destination(), departureDateTime(), id(), soap() { }
        virtual ~ns2__DecisionManagerTravelLeg() { }
        /// Friend allocator used by soap_new_ns2__DecisionManagerTravelLeg(struct soap*, int)
        friend SOAP_FMAC1 ns2__DecisionManagerTravelLeg * SOAP_FMAC2 soap_instantiate_ns2__DecisionManagerTravelLeg(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:380 */
#ifndef SOAP_TYPE_ns2__Batch
#define SOAP_TYPE_ns2__Batch (385)
/* complex XML schema type 'ns2:Batch': */
class SOAP_CMAC ns2__Batch {
      public:
        /// Optional element 'ns2:batchID' of XML schema type 'xsd:string'
        std::string *batchID;
        /// Optional element 'ns2:recordID' of XML schema type 'xsd:string'
        std::string *recordID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Batch
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Batch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Batch, default initialized and not managed by a soap context
        virtual ns2__Batch *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Batch); }
      public:
        /// Constructor with default initializations
        ns2__Batch() : batchID(), recordID(), soap() { }
        virtual ~ns2__Batch() { }
        /// Friend allocator used by soap_new_ns2__Batch(struct soap*, int)
        friend SOAP_FMAC1 ns2__Batch * SOAP_FMAC2 soap_instantiate_ns2__Batch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:382 */
#ifndef SOAP_TYPE_ns2__PayPal
#define SOAP_TYPE_ns2__PayPal (386)
/* complex XML schema type 'ns2:PayPal': */
class SOAP_CMAC ns2__PayPal {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPal
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPal; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPal, default initialized and not managed by a soap context
        virtual ns2__PayPal *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPal); }
      public:
        /// Constructor with default initializations
        ns2__PayPal() : __any(), soap() { }
        virtual ~ns2__PayPal() { }
        /// Friend allocator used by soap_new_ns2__PayPal(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPal * SOAP_FMAC2 soap_instantiate_ns2__PayPal(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:384 */
#ifndef SOAP_TYPE_ns2__JPO
#define SOAP_TYPE_ns2__JPO (387)
/* complex XML schema type 'ns2:JPO': */
class SOAP_CMAC ns2__JPO {
      public:
        /// Optional element 'ns2:paymentMethod' of XML schema type 'xsd:integer'
        std::string *paymentMethod;
        /// Optional element 'ns2:bonusAmount' of XML schema type 'ns2:amount'
        std::string *bonusAmount;
        /// Optional element 'ns2:bonuses' of XML schema type 'xsd:integer'
        std::string *bonuses;
        /// Optional element 'ns2:installments' of XML schema type 'xsd:integer'
        std::string *installments;
        /// Optional element 'ns2:firstBillingMonth' of XML schema type 'xsd:integer'
        std::string *firstBillingMonth;
        /// Optional element 'ns2:jccaTerminalID' of XML schema type 'xsd:integer'
        std::string *jccaTerminalID;
        /// Optional element 'ns2:issuerMessage' of XML schema type 'xsd:integer'
        std::string *issuerMessage;
        /// Optional element 'ns2:jis2TrackData' of XML schema type 'xsd:string'
        std::string *jis2TrackData;
        /// Optional element 'ns2:businessNameAlphanumeric' of XML schema type 'xsd:string'
        std::string *businessNameAlphanumeric;
        /// Optional element 'ns2:businessNameJapanese' of XML schema type 'xsd:string'
        std::string *businessNameJapanese;
        /// Optional element 'ns2:businessNameKatakana' of XML schema type 'xsd:string'
        std::string *businessNameKatakana;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__JPO
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__JPO; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__JPO, default initialized and not managed by a soap context
        virtual ns2__JPO *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__JPO); }
      public:
        /// Constructor with default initializations
        ns2__JPO() : paymentMethod(), bonusAmount(), bonuses(), installments(), firstBillingMonth(), jccaTerminalID(), issuerMessage(), jis2TrackData(), businessNameAlphanumeric(), businessNameJapanese(), businessNameKatakana(), soap() { }
        virtual ~ns2__JPO() { }
        /// Friend allocator used by soap_new_ns2__JPO(struct soap*, int)
        friend SOAP_FMAC1 ns2__JPO * SOAP_FMAC2 soap_instantiate_ns2__JPO(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:386 */
#ifndef SOAP_TYPE_ns2__Token
#define SOAP_TYPE_ns2__Token (388)
/* complex XML schema type 'ns2:Token': */
class SOAP_CMAC ns2__Token {
      public:
        /// Optional element 'ns2:prefix' of XML schema type 'xsd:string'
        std::string *prefix;
        /// Optional element 'ns2:suffix' of XML schema type 'xsd:string'
        std::string *suffix;
        /// Optional element 'ns2:expirationMonth' of XML schema type 'xsd:string'
        std::string *expirationMonth;
        /// Optional element 'ns2:expirationYear' of XML schema type 'xsd:string'
        std::string *expirationYear;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Token
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Token; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Token, default initialized and not managed by a soap context
        virtual ns2__Token *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Token); }
      public:
        /// Constructor with default initializations
        ns2__Token() : prefix(), suffix(), expirationMonth(), expirationYear(), soap() { }
        virtual ~ns2__Token() { }
        /// Friend allocator used by soap_new_ns2__Token(struct soap*, int)
        friend SOAP_FMAC1 ns2__Token * SOAP_FMAC2 soap_instantiate_ns2__Token(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:388 */
#ifndef SOAP_TYPE_ns2__AP
#define SOAP_TYPE_ns2__AP (389)
/* complex XML schema type 'ns2:AP': */
class SOAP_CMAC ns2__AP {
      public:
        /// Optional element 'ns2:orderID' of XML schema type 'xsd:string'
        std::string *orderID;
        /// Optional element 'ns2:pspBarcodeID' of XML schema type 'xsd:string'
        std::string *pspBarcodeID;
        /// Optional element 'ns2:customerRepresentativeID' of XML schema type 'xsd:string'
        std::string *customerRepresentativeID;
        /// Optional element 'ns2:productDescription' of XML schema type 'xsd:string'
        std::string *productDescription;
        /// Optional element 'ns2:settlementCurrency' of XML schema type 'xsd:string'
        std::string *settlementCurrency;
        /// Optional element 'ns2:subtotalAmount' of XML schema type 'xsd:string'
        std::string *subtotalAmount;
        /// Optional element 'ns2:shippingAmount' of XML schema type 'xsd:string'
        std::string *shippingAmount;
        /// Optional element 'ns2:handlingAmount' of XML schema type 'xsd:string'
        std::string *handlingAmount;
        /// Optional element 'ns2:shippingHandlingAmount' of XML schema type 'xsd:string'
        std::string *shippingHandlingAmount;
        /// Optional element 'ns2:additionalAmount' of XML schema type 'xsd:string'
        std::string *additionalAmount;
        /// Optional element 'ns2:taxAmount' of XML schema type 'xsd:string'
        std::string *taxAmount;
        /// Optional element 'ns2:giftWrapAmount' of XML schema type 'xsd:string'
        std::string *giftWrapAmount;
        /// Optional element 'ns2:discountAmount' of XML schema type 'xsd:string'
        std::string *discountAmount;
        /// Optional element 'ns2:purchaseID' of XML schema type 'xsd:string'
        std::string *purchaseID;
        /// Optional element 'ns2:productID' of XML schema type 'xsd:string'
        std::string *productID;
        /// Optional element 'ns2:device' of XML schema type 'ns2:APDevice'
        ns2__APDevice *device;
        /// Optional element 'ns2:apiKey' of XML schema type 'xsd:string'
        std::string *apiKey;
        /// Optional element 'ns2:insuranceAmount' of XML schema type 'xsd:string'
        std::string *insuranceAmount;
        /// Optional element 'ns2:billingAgreementIndicator' of XML schema type 'ns2:boolean'
        std::string *billingAgreementIndicator;
        /// Optional element 'ns2:billingAgreementID' of XML schema type 'xsd:string'
        std::string *billingAgreementID;
        /// Optional element 'ns2:billingAgreementDescription' of XML schema type 'xsd:string'
        std::string *billingAgreementDescription;
        /// Optional element 'ns2:payerID' of XML schema type 'xsd:string'
        std::string *payerID;
        /// Optional element 'ns2:fundingSource' of XML schema type 'xsd:string'
        std::string *fundingSource;
        /// Optional element 'ns2:shippingAddressImmutable' of XML schema type 'xsd:string'
        std::string *shippingAddressImmutable;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AP
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__AP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AP, default initialized and not managed by a soap context
        virtual ns2__AP *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__AP); }
      public:
        /// Constructor with default initializations
        ns2__AP() : orderID(), pspBarcodeID(), customerRepresentativeID(), productDescription(), settlementCurrency(), subtotalAmount(), shippingAmount(), handlingAmount(), shippingHandlingAmount(), additionalAmount(), taxAmount(), giftWrapAmount(), discountAmount(), purchaseID(), productID(), device(), apiKey(), insuranceAmount(), billingAgreementIndicator(), billingAgreementID(), billingAgreementDescription(), payerID(), fundingSource(), shippingAddressImmutable(), soap() { }
        virtual ~ns2__AP() { }
        /// Friend allocator used by soap_new_ns2__AP(struct soap*, int)
        friend SOAP_FMAC1 ns2__AP * SOAP_FMAC2 soap_instantiate_ns2__AP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:390 */
#ifndef SOAP_TYPE_ns2__APDevice
#define SOAP_TYPE_ns2__APDevice (390)
/* complex XML schema type 'ns2:APDevice': */
class SOAP_CMAC ns2__APDevice {
      public:
        /// Optional element 'ns2:id' of XML schema type 'xsd:string'
        std::string *id;
        /// Optional element 'ns2:type' of XML schema type 'xsd:string'
        std::string *type;
        /// Optional element 'ns2:userAgent' of XML schema type 'xsd:string'
        std::string *userAgent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APDevice
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APDevice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APDevice, default initialized and not managed by a soap context
        virtual ns2__APDevice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APDevice); }
      public:
        /// Constructor with default initializations
        ns2__APDevice() : id(), type(), userAgent(), soap() { }
        virtual ~ns2__APDevice() { }
        /// Friend allocator used by soap_new_ns2__APDevice(struct soap*, int)
        friend SOAP_FMAC1 ns2__APDevice * SOAP_FMAC2 soap_instantiate_ns2__APDevice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:392 */
#ifndef SOAP_TYPE_ns2__APAuthService
#define SOAP_TYPE_ns2__APAuthService (391)
/* complex XML schema type 'ns2:APAuthService': */
class SOAP_CMAC ns2__APAuthService {
      public:
        /// Optional element 'ns2:cancelURL' of XML schema type 'xsd:string'
        std::string *cancelURL;
        /// Optional element 'ns2:successURL' of XML schema type 'xsd:string'
        std::string *successURL;
        /// Optional element 'ns2:failureURL' of XML schema type 'xsd:string'
        std::string *failureURL;
        /// Optional element 'ns2:overridePaymentMethod' of XML schema type 'xsd:string'
        std::string *overridePaymentMethod;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:preapprovalToken' of XML schema type 'xsd:string'
        std::string *preapprovalToken;
        /// Optional element 'ns2:orderRequestID' of XML schema type 'xsd:string'
        std::string *orderRequestID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APAuthService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APAuthService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APAuthService, default initialized and not managed by a soap context
        virtual ns2__APAuthService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APAuthService); }
      public:
        /// Constructor with default initializations
        ns2__APAuthService() : cancelURL(), successURL(), failureURL(), overridePaymentMethod(), reconciliationID(), preapprovalToken(), orderRequestID(), run(), soap() { }
        virtual ~ns2__APAuthService() { }
        /// Friend allocator used by soap_new_ns2__APAuthService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APAuthService * SOAP_FMAC2 soap_instantiate_ns2__APAuthService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:394 */
#ifndef SOAP_TYPE_ns2__APImportMandateService
#define SOAP_TYPE_ns2__APImportMandateService (392)
/* complex XML schema type 'ns2:APImportMandateService': */
class SOAP_CMAC ns2__APImportMandateService {
      public:
        /// Optional element 'ns2:dateSigned' of XML schema type 'xsd:string'
        std::string *dateSigned;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APImportMandateService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APImportMandateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APImportMandateService, default initialized and not managed by a soap context
        virtual ns2__APImportMandateService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APImportMandateService); }
      public:
        /// Constructor with default initializations
        ns2__APImportMandateService() : dateSigned(), run(), soap() { }
        virtual ~ns2__APImportMandateService() { }
        /// Friend allocator used by soap_new_ns2__APImportMandateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APImportMandateService * SOAP_FMAC2 soap_instantiate_ns2__APImportMandateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:396 */
#ifndef SOAP_TYPE_ns2__APAuthReversalService
#define SOAP_TYPE_ns2__APAuthReversalService (393)
/* complex XML schema type 'ns2:APAuthReversalService': */
class SOAP_CMAC ns2__APAuthReversalService {
      public:
        /// Optional element 'ns2:authRequestID' of XML schema type 'xsd:string'
        std::string *authRequestID;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APAuthReversalService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APAuthReversalService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APAuthReversalService, default initialized and not managed by a soap context
        virtual ns2__APAuthReversalService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APAuthReversalService); }
      public:
        /// Constructor with default initializations
        ns2__APAuthReversalService() : authRequestID(), reconciliationID(), run(), soap() { }
        virtual ~ns2__APAuthReversalService() { }
        /// Friend allocator used by soap_new_ns2__APAuthReversalService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APAuthReversalService * SOAP_FMAC2 soap_instantiate_ns2__APAuthReversalService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:398 */
#ifndef SOAP_TYPE_ns2__APCaptureService
#define SOAP_TYPE_ns2__APCaptureService (394)
/* complex XML schema type 'ns2:APCaptureService': */
class SOAP_CMAC ns2__APCaptureService {
      public:
        /// Optional element 'ns2:authRequestID' of XML schema type 'xsd:string'
        std::string *authRequestID;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:isFinal' of XML schema type 'ns2:boolean'
        std::string *isFinal;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APCaptureService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APCaptureService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APCaptureService, default initialized and not managed by a soap context
        virtual ns2__APCaptureService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APCaptureService); }
      public:
        /// Constructor with default initializations
        ns2__APCaptureService() : authRequestID(), reconciliationID(), isFinal(), run(), soap() { }
        virtual ~ns2__APCaptureService() { }
        /// Friend allocator used by soap_new_ns2__APCaptureService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APCaptureService * SOAP_FMAC2 soap_instantiate_ns2__APCaptureService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:400 */
#ifndef SOAP_TYPE_ns2__APOptionsService
#define SOAP_TYPE_ns2__APOptionsService (395)
/* complex XML schema type 'ns2:APOptionsService': */
class SOAP_CMAC ns2__APOptionsService {
      public:
        /// Optional element 'ns2:limit' of XML schema type 'xsd:string'
        std::string *limit;
        /// Optional element 'ns2:offset' of XML schema type 'xsd:string'
        std::string *offset;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APOptionsService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APOptionsService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APOptionsService, default initialized and not managed by a soap context
        virtual ns2__APOptionsService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APOptionsService); }
      public:
        /// Constructor with default initializations
        ns2__APOptionsService() : limit(), offset(), run(), soap() { }
        virtual ~ns2__APOptionsService() { }
        /// Friend allocator used by soap_new_ns2__APOptionsService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APOptionsService * SOAP_FMAC2 soap_instantiate_ns2__APOptionsService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:402 */
#ifndef SOAP_TYPE_ns2__APRefundService
#define SOAP_TYPE_ns2__APRefundService (396)
/* complex XML schema type 'ns2:APRefundService': */
class SOAP_CMAC ns2__APRefundService {
      public:
        /// Optional element 'ns2:captureRequestID' of XML schema type 'xsd:string'
        std::string *captureRequestID;
        /// Optional element 'ns2:refundRequestID' of XML schema type 'xsd:string'
        std::string *refundRequestID;
        /// Optional element 'ns2:reason' of XML schema type 'xsd:string'
        std::string *reason;
        /// Optional element 'ns2:instant' of XML schema type 'xsd:string'
        std::string *instant;
        /// Optional element 'ns2:note' of XML schema type 'xsd:string'
        std::string *note;
        /// Optional element 'ns2:apInitiateRequestID' of XML schema type 'xsd:string'
        std::string *apInitiateRequestID;
        /// Optional element 'ns2:returnRef' of XML schema type 'xsd:string'
        std::string *returnRef;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:saleRequestID' of XML schema type 'xsd:string'
        std::string *saleRequestID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APRefundService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APRefundService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APRefundService, default initialized and not managed by a soap context
        virtual ns2__APRefundService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APRefundService); }
      public:
        /// Constructor with default initializations
        ns2__APRefundService() : captureRequestID(), refundRequestID(), reason(), instant(), note(), apInitiateRequestID(), returnRef(), reconciliationID(), saleRequestID(), run(), soap() { }
        virtual ~ns2__APRefundService() { }
        /// Friend allocator used by soap_new_ns2__APRefundService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APRefundService * SOAP_FMAC2 soap_instantiate_ns2__APRefundService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:404 */
#ifndef SOAP_TYPE_ns2__APSaleService
#define SOAP_TYPE_ns2__APSaleService (397)
/* complex XML schema type 'ns2:APSaleService': */
class SOAP_CMAC ns2__APSaleService {
      public:
        /// Optional element 'ns2:cancelURL' of XML schema type 'xsd:string'
        std::string *cancelURL;
        /// Optional element 'ns2:successURL' of XML schema type 'xsd:string'
        std::string *successURL;
        /// Optional element 'ns2:failureURL' of XML schema type 'xsd:string'
        std::string *failureURL;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:overridePaymentMethod' of XML schema type 'xsd:string'
        std::string *overridePaymentMethod;
        /// Optional element 'ns2:paymentOptionID' of XML schema type 'xsd:string'
        std::string *paymentOptionID;
        /// Optional element 'ns2:transactionTimeout' of XML schema type 'xsd:string'
        std::string *transactionTimeout;
        /// Optional element 'ns2:orderRequestID' of XML schema type 'xsd:string'
        std::string *orderRequestID;
        /// Optional element 'ns2:billingAgreementID' of XML schema type 'xsd:string'
        std::string *billingAgreementID;
        /// Optional element 'ns2:mandateID' of XML schema type 'xsd:string'
        std::string *mandateID;
        /// Optional element 'ns2:dateCollect' of XML schema type 'xsd:string'
        std::string *dateCollect;
        /// Optional element 'ns2:preapprovalToken' of XML schema type 'xsd:string'
        std::string *preapprovalToken;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APSaleService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APSaleService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APSaleService, default initialized and not managed by a soap context
        virtual ns2__APSaleService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APSaleService); }
      public:
        /// Constructor with default initializations
        ns2__APSaleService() : cancelURL(), successURL(), failureURL(), reconciliationID(), overridePaymentMethod(), paymentOptionID(), transactionTimeout(), orderRequestID(), billingAgreementID(), mandateID(), dateCollect(), preapprovalToken(), run(), soap() { }
        virtual ~ns2__APSaleService() { }
        /// Friend allocator used by soap_new_ns2__APSaleService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APSaleService * SOAP_FMAC2 soap_instantiate_ns2__APSaleService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:406 */
#ifndef SOAP_TYPE_ns2__APCheckOutDetailsService
#define SOAP_TYPE_ns2__APCheckOutDetailsService (398)
/* complex XML schema type 'ns2:APCheckOutDetailsService': */
class SOAP_CMAC ns2__APCheckOutDetailsService {
      public:
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APCheckOutDetailsService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APCheckOutDetailsService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APCheckOutDetailsService, default initialized and not managed by a soap context
        virtual ns2__APCheckOutDetailsService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APCheckOutDetailsService); }
      public:
        /// Constructor with default initializations
        ns2__APCheckOutDetailsService() : run(), soap() { }
        virtual ~ns2__APCheckOutDetailsService() { }
        /// Friend allocator used by soap_new_ns2__APCheckOutDetailsService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APCheckOutDetailsService * SOAP_FMAC2 soap_instantiate_ns2__APCheckOutDetailsService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:408 */
#ifndef SOAP_TYPE_ns2__APTransactionDetailsService
#define SOAP_TYPE_ns2__APTransactionDetailsService (399)
/* complex XML schema type 'ns2:APTransactionDetailsService': */
class SOAP_CMAC ns2__APTransactionDetailsService {
      public:
        /// Optional element 'ns2:transactionDetailsRequestID' of XML schema type 'xsd:string'
        std::string *transactionDetailsRequestID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APTransactionDetailsService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APTransactionDetailsService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APTransactionDetailsService, default initialized and not managed by a soap context
        virtual ns2__APTransactionDetailsService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APTransactionDetailsService); }
      public:
        /// Constructor with default initializations
        ns2__APTransactionDetailsService() : transactionDetailsRequestID(), run(), soap() { }
        virtual ~ns2__APTransactionDetailsService() { }
        /// Friend allocator used by soap_new_ns2__APTransactionDetailsService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APTransactionDetailsService * SOAP_FMAC2 soap_instantiate_ns2__APTransactionDetailsService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:410 */
#ifndef SOAP_TYPE_ns2__APConfirmPurchaseService
#define SOAP_TYPE_ns2__APConfirmPurchaseService (400)
/* complex XML schema type 'ns2:APConfirmPurchaseService': */
class SOAP_CMAC ns2__APConfirmPurchaseService {
      public:
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APConfirmPurchaseService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APConfirmPurchaseService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APConfirmPurchaseService, default initialized and not managed by a soap context
        virtual ns2__APConfirmPurchaseService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APConfirmPurchaseService); }
      public:
        /// Constructor with default initializations
        ns2__APConfirmPurchaseService() : run(), soap() { }
        virtual ~ns2__APConfirmPurchaseService() { }
        /// Friend allocator used by soap_new_ns2__APConfirmPurchaseService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APConfirmPurchaseService * SOAP_FMAC2 soap_instantiate_ns2__APConfirmPurchaseService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:412 */
#ifndef SOAP_TYPE_ns2__APSessionsService
#define SOAP_TYPE_ns2__APSessionsService (401)
/* complex XML schema type 'ns2:APSessionsService': */
class SOAP_CMAC ns2__APSessionsService {
      public:
        /// Optional element 'ns2:cancelURL' of XML schema type 'xsd:string'
        std::string *cancelURL;
        /// Optional element 'ns2:successURL' of XML schema type 'xsd:string'
        std::string *successURL;
        /// Optional element 'ns2:failureURL' of XML schema type 'xsd:string'
        std::string *failureURL;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:overridePaymentMethod' of XML schema type 'xsd:string'
        std::string *overridePaymentMethod;
        /// Optional element 'ns2:paymentOptionID' of XML schema type 'xsd:string'
        std::string *paymentOptionID;
        /// Optional element 'ns2:sessionsType' of XML schema type 'xsd:string'
        std::string *sessionsType;
        /// Optional element 'ns2:sessionsRequestID' of XML schema type 'xsd:string'
        std::string *sessionsRequestID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APSessionsService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APSessionsService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APSessionsService, default initialized and not managed by a soap context
        virtual ns2__APSessionsService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APSessionsService); }
      public:
        /// Constructor with default initializations
        ns2__APSessionsService() : cancelURL(), successURL(), failureURL(), reconciliationID(), overridePaymentMethod(), paymentOptionID(), sessionsType(), sessionsRequestID(), run(), soap() { }
        virtual ~ns2__APSessionsService() { }
        /// Friend allocator used by soap_new_ns2__APSessionsService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APSessionsService * SOAP_FMAC2 soap_instantiate_ns2__APSessionsService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:414 */
#ifndef SOAP_TYPE_ns2__APUI
#define SOAP_TYPE_ns2__APUI (402)
/* complex XML schema type 'ns2:APUI': */
class SOAP_CMAC ns2__APUI {
      public:
        /// Optional element 'ns2:colorBorder' of XML schema type 'xsd:string'
        std::string *colorBorder;
        /// Optional element 'ns2:colorBorderSelected' of XML schema type 'xsd:string'
        std::string *colorBorderSelected;
        /// Optional element 'ns2:colorButton' of XML schema type 'xsd:string'
        std::string *colorButton;
        /// Optional element 'ns2:colorButtonText' of XML schema type 'xsd:string'
        std::string *colorButtonText;
        /// Optional element 'ns2:colorCheckbox' of XML schema type 'xsd:string'
        std::string *colorCheckbox;
        /// Optional element 'ns2:colorCheckboxCheckMark' of XML schema type 'xsd:string'
        std::string *colorCheckboxCheckMark;
        /// Optional element 'ns2:colorHeader' of XML schema type 'xsd:string'
        std::string *colorHeader;
        /// Optional element 'ns2:colorLink' of XML schema type 'xsd:string'
        std::string *colorLink;
        /// Optional element 'ns2:colorText' of XML schema type 'xsd:string'
        std::string *colorText;
        /// Optional element 'ns2:borderRadius' of XML schema type 'xsd:string'
        std::string *borderRadius;
        /// Optional element 'ns2:theme' of XML schema type 'xsd:string'
        std::string *theme;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APUI
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APUI; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APUI, default initialized and not managed by a soap context
        virtual ns2__APUI *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APUI); }
      public:
        /// Constructor with default initializations
        ns2__APUI() : colorBorder(), colorBorderSelected(), colorButton(), colorButtonText(), colorCheckbox(), colorCheckboxCheckMark(), colorHeader(), colorLink(), colorText(), borderRadius(), theme(), soap() { }
        virtual ~ns2__APUI() { }
        /// Friend allocator used by soap_new_ns2__APUI(struct soap*, int)
        friend SOAP_FMAC1 ns2__APUI * SOAP_FMAC2 soap_instantiate_ns2__APUI(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:416 */
#ifndef SOAP_TYPE_ns2__PayPalGetTxnDetailsService
#define SOAP_TYPE_ns2__PayPalGetTxnDetailsService (403)
/* complex XML schema type 'ns2:PayPalGetTxnDetailsService': */
class SOAP_CMAC ns2__PayPalGetTxnDetailsService {
      public:
        /// Optional element 'ns2:transactionID' of XML schema type 'xsd:string'
        std::string *transactionID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalGetTxnDetailsService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalGetTxnDetailsService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalGetTxnDetailsService, default initialized and not managed by a soap context
        virtual ns2__PayPalGetTxnDetailsService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalGetTxnDetailsService); }
      public:
        /// Constructor with default initializations
        ns2__PayPalGetTxnDetailsService() : transactionID(), run(), soap() { }
        virtual ~ns2__PayPalGetTxnDetailsService() { }
        /// Friend allocator used by soap_new_ns2__PayPalGetTxnDetailsService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalGetTxnDetailsService * SOAP_FMAC2 soap_instantiate_ns2__PayPalGetTxnDetailsService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:418 */
#ifndef SOAP_TYPE_ns2__PayPalTransactionSearchService
#define SOAP_TYPE_ns2__PayPalTransactionSearchService (404)
/* complex XML schema type 'ns2:PayPalTransactionSearchService': */
class SOAP_CMAC ns2__PayPalTransactionSearchService {
      public:
        /// Optional element 'ns2:startDate' of XML schema type 'xsd:string'
        std::string *startDate;
        /// Optional element 'ns2:endDate' of XML schema type 'xsd:string'
        std::string *endDate;
        /// Optional element 'ns2:paypalCustomerEmail' of XML schema type 'xsd:string'
        std::string *paypalCustomerEmail;
        /// Optional element 'ns2:paypalReceiptId' of XML schema type 'xsd:string'
        std::string *paypalReceiptId;
        /// Optional element 'ns2:transactionID' of XML schema type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:invoiceNumber' of XML schema type 'xsd:string'
        std::string *invoiceNumber;
        /// Optional element 'ns2:grandTotalAmount' of XML schema type 'ns2:amount'
        std::string *grandTotalAmount;
        /// Optional element 'ns2:currency' of XML schema type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:paymentStatus' of XML schema type 'xsd:string'
        std::string *paymentStatus;
        /// Optional element 'ns2:payerSalutation' of XML schema type 'xsd:string'
        std::string *payerSalutation;
        /// Optional element 'ns2:payerFirstname' of XML schema type 'xsd:string'
        std::string *payerFirstname;
        /// Optional element 'ns2:payerMiddlename' of XML schema type 'xsd:string'
        std::string *payerMiddlename;
        /// Optional element 'ns2:payerLastname' of XML schema type 'xsd:string'
        std::string *payerLastname;
        /// Optional element 'ns2:payerSuffix' of XML schema type 'xsd:string'
        std::string *payerSuffix;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalTransactionSearchService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalTransactionSearchService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalTransactionSearchService, default initialized and not managed by a soap context
        virtual ns2__PayPalTransactionSearchService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalTransactionSearchService); }
      public:
        /// Constructor with default initializations
        ns2__PayPalTransactionSearchService() : startDate(), endDate(), paypalCustomerEmail(), paypalReceiptId(), transactionID(), invoiceNumber(), grandTotalAmount(), currency(), paymentStatus(), payerSalutation(), payerFirstname(), payerMiddlename(), payerLastname(), payerSuffix(), run(), soap() { }
        virtual ~ns2__PayPalTransactionSearchService() { }
        /// Friend allocator used by soap_new_ns2__PayPalTransactionSearchService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalTransactionSearchService * SOAP_FMAC2 soap_instantiate_ns2__PayPalTransactionSearchService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:420 */
#ifndef SOAP_TYPE_ns2__Recipient
#define SOAP_TYPE_ns2__Recipient (405)
/* complex XML schema type 'ns2:Recipient': */
class SOAP_CMAC ns2__Recipient {
      public:
        /// Optional element 'ns2:dateOfBirth' of XML schema type 'xsd:string'
        std::string *dateOfBirth;
        /// Optional element 'ns2:postalCode' of XML schema type 'xsd:string'
        std::string *postalCode;
        /// Optional element 'ns2:accountID' of XML schema type 'xsd:string'
        std::string *accountID;
        /// Optional element 'ns2:lastName' of XML schema type 'xsd:string'
        std::string *lastName;
        /// Optional element 'ns2:name' of XML schema type 'xsd:string'
        std::string *name;
        /// Optional element 'ns2:billingAmount' of XML schema type 'ns2:amount'
        std::string *billingAmount;
        /// Optional element 'ns2:billingCurrency' of XML schema type 'xsd:string'
        std::string *billingCurrency;
        /// Optional element 'ns2:billingConversionRate' of XML schema type 'ns2:amount'
        std::string *billingConversionRate;
        /// Optional element 'ns2:firstName' of XML schema type 'xsd:string'
        std::string *firstName;
        /// Optional element 'ns2:middleName' of XML schema type 'xsd:string'
        std::string *middleName;
        /// Optional element 'ns2:middleInitial' of XML schema type 'xsd:string'
        std::string *middleInitial;
        /// Optional element 'ns2:address' of XML schema type 'xsd:string'
        std::string *address;
        /// Optional element 'ns2:city' of XML schema type 'xsd:string'
        std::string *city;
        /// Optional element 'ns2:state' of XML schema type 'xsd:string'
        std::string *state;
        /// Optional element 'ns2:country' of XML schema type 'xsd:string'
        std::string *country;
        /// Optional element 'ns2:phoneNumber' of XML schema type 'xsd:string'
        std::string *phoneNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Recipient
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Recipient; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Recipient, default initialized and not managed by a soap context
        virtual ns2__Recipient *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Recipient); }
      public:
        /// Constructor with default initializations
        ns2__Recipient() : dateOfBirth(), postalCode(), accountID(), lastName(), name(), billingAmount(), billingCurrency(), billingConversionRate(), firstName(), middleName(), middleInitial(), address(), city(), state(), country(), phoneNumber(), soap() { }
        virtual ~ns2__Recipient() { }
        /// Friend allocator used by soap_new_ns2__Recipient(struct soap*, int)
        friend SOAP_FMAC1 ns2__Recipient * SOAP_FMAC2 soap_instantiate_ns2__Recipient(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:422 */
#ifndef SOAP_TYPE_ns2__Sender
#define SOAP_TYPE_ns2__Sender (406)
/* complex XML schema type 'ns2:Sender': */
class SOAP_CMAC ns2__Sender {
      public:
        /// Optional element 'ns2:referenceNumber' of XML schema type 'xsd:string'
        std::string *referenceNumber;
        /// Optional element 'ns2:sourceOfFunds' of XML schema type 'xsd:string'
        std::string *sourceOfFunds;
        /// Optional element 'ns2:name' of XML schema type 'xsd:string'
        std::string *name;
        /// Optional element 'ns2:address' of XML schema type 'xsd:string'
        std::string *address;
        /// Optional element 'ns2:city' of XML schema type 'xsd:string'
        std::string *city;
        /// Optional element 'ns2:state' of XML schema type 'xsd:string'
        std::string *state;
        /// Optional element 'ns2:postalCode' of XML schema type 'xsd:string'
        std::string *postalCode;
        /// Optional element 'ns2:country' of XML schema type 'xsd:string'
        std::string *country;
        /// Optional element 'ns2:accountNumber' of XML schema type 'xsd:string'
        std::string *accountNumber;
        /// Optional element 'ns2:dateOfBirth' of XML schema type 'xsd:string'
        std::string *dateOfBirth;
        /// Optional element 'ns2:firstName' of XML schema type 'xsd:string'
        std::string *firstName;
        /// Optional element 'ns2:middleName' of XML schema type 'xsd:string'
        std::string *middleName;
        /// Optional element 'ns2:middleInitial' of XML schema type 'xsd:string'
        std::string *middleInitial;
        /// Optional element 'ns2:lastName' of XML schema type 'xsd:string'
        std::string *lastName;
        /// Optional element 'ns2:phoneNumber' of XML schema type 'xsd:string'
        std::string *phoneNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Sender
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Sender; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Sender, default initialized and not managed by a soap context
        virtual ns2__Sender *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Sender); }
      public:
        /// Constructor with default initializations
        ns2__Sender() : referenceNumber(), sourceOfFunds(), name(), address(), city(), state(), postalCode(), country(), accountNumber(), dateOfBirth(), firstName(), middleName(), middleInitial(), lastName(), phoneNumber(), soap() { }
        virtual ~ns2__Sender() { }
        /// Friend allocator used by soap_new_ns2__Sender(struct soap*, int)
        friend SOAP_FMAC1 ns2__Sender * SOAP_FMAC2 soap_instantiate_ns2__Sender(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:424 */
#ifndef SOAP_TYPE_ns2__CCCheckStatusService
#define SOAP_TYPE_ns2__CCCheckStatusService (407)
/* complex XML schema type 'ns2:CCCheckStatusService': */
class SOAP_CMAC ns2__CCCheckStatusService {
      public:
        /// Optional element 'ns2:authRequestID' of XML schema type 'xsd:string'
        std::string *authRequestID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCCheckStatusService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCCheckStatusService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCCheckStatusService, default initialized and not managed by a soap context
        virtual ns2__CCCheckStatusService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCCheckStatusService); }
      public:
        /// Constructor with default initializations
        ns2__CCCheckStatusService() : authRequestID(), run(), soap() { }
        virtual ~ns2__CCCheckStatusService() { }
        /// Friend allocator used by soap_new_ns2__CCCheckStatusService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCCheckStatusService * SOAP_FMAC2 soap_instantiate_ns2__CCCheckStatusService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:426 */
#ifndef SOAP_TYPE_ns2__RequestMessage
#define SOAP_TYPE_ns2__RequestMessage (408)
/* complex XML schema type 'ns2:RequestMessage': */
class SOAP_CMAC ns2__RequestMessage {
      public:
        /// Optional element 'ns2:merchantID' of XML schema type 'xsd:string'
        std::string *merchantID;
        /// Optional element 'ns2:merchantReferenceCode' of XML schema type 'xsd:string'
        std::string *merchantReferenceCode;
        /// Optional element 'ns2:debtIndicator' of XML schema type 'ns2:boolean'
        std::string *debtIndicator;
        /// Optional element 'ns2:clientLibrary' of XML schema type 'xsd:string'
        std::string *clientLibrary;
        /// Optional element 'ns2:clientLibraryVersion' of XML schema type 'xsd:string'
        std::string *clientLibraryVersion;
        /// Optional element 'ns2:clientEnvironment' of XML schema type 'xsd:string'
        std::string *clientEnvironment;
        /// Optional element 'ns2:clientSecurityLibraryVersion' of XML schema type 'xsd:string'
        std::string *clientSecurityLibraryVersion;
        /// Optional element 'ns2:clientApplication' of XML schema type 'xsd:string'
        std::string *clientApplication;
        /// Optional element 'ns2:clientApplicationVersion' of XML schema type 'xsd:string'
        std::string *clientApplicationVersion;
        /// Optional element 'ns2:clientApplicationUser' of XML schema type 'xsd:string'
        std::string *clientApplicationUser;
        /// Optional element 'ns2:routingCode' of XML schema type 'xsd:string'
        std::string *routingCode;
        /// Optional element 'ns2:comments' of XML schema type 'xsd:string'
        std::string *comments;
        /// Optional element 'ns2:returnURL' of XML schema type 'xsd:string'
        std::string *returnURL;
        /// Optional element 'ns2:invoiceHeader' of XML schema type 'ns2:InvoiceHeader'
        ns2__InvoiceHeader *invoiceHeader;
        /// Optional element 'ns2:paymentScheme' of XML schema type 'xsd:string'
        std::string *paymentScheme;
        /// Optional element 'ns2:mandateID' of XML schema type 'xsd:string'
        std::string *mandateID;
        /// Optional element 'ns2:aggregatorMerchantIdentifier' of XML schema type 'xsd:string'
        std::string *aggregatorMerchantIdentifier;
        /// Optional element 'ns2:customerID' of XML schema type 'xsd:string'
        std::string *customerID;
        /// Optional element 'ns2:customerFirstName' of XML schema type 'xsd:string'
        std::string *customerFirstName;
        /// Optional element 'ns2:customerLastName' of XML schema type 'xsd:string'
        std::string *customerLastName;
        /// Optional element 'ns2:billTo' of XML schema type 'ns2:BillTo'
        ns2__BillTo *billTo;
        /// Optional element 'ns2:shipTo' of XML schema type 'ns2:ShipTo'
        ns2__ShipTo *shipTo;
        /// Optional element 'ns2:personalID' of XML schema type 'ns2:PersonalID'
        ns2__PersonalID *personalID;
        /// Optional element 'ns2:shipFrom' of XML schema type 'ns2:ShipFrom'
        ns2__ShipFrom *shipFrom;
        /// Sequence of 0 to 1000 elements 'ns2:item' of XML schema type 'ns2:Item'
        std::vector<ns2__Item> item;
        /// Optional element 'ns2:purchaseTotals' of XML schema type 'ns2:PurchaseTotals'
        ns2__PurchaseTotals *purchaseTotals;
        /// Optional element 'ns2:fundingTotals' of XML schema type 'ns2:FundingTotals'
        ns2__FundingTotals *fundingTotals;
        /// Optional element 'ns2:dcc' of XML schema type 'ns2:DCC'
        ns2__DCC *dcc;
        /// Optional element 'ns2:pos' of XML schema type 'ns2:Pos'
        ns2__Pos *pos;
        /// Optional element 'ns2:pin' of XML schema type 'ns2:Pin'
        ns2__Pin *pin;
        /// Optional element 'ns2:encryptedPayment' of XML schema type 'ns2:EncryptedPayment'
        ns2__EncryptedPayment *encryptedPayment;
        /// Optional element 'ns2:installment' of XML schema type 'ns2:Installment'
        ns2__Installment *installment;
        /// Optional element 'ns2:card' of XML schema type 'ns2:Card'
        ns2__Card *card;
        /// Optional element 'ns2:category' of XML schema type 'ns2:Category'
        ns2__Category *category;
        /// Optional element 'ns2:check' of XML schema type 'ns2:Check'
        ns2__Check *check;
        /// Optional element 'ns2:bml' of XML schema type 'ns2:BML'
        ns2__BML *bml;
        /// Optional element 'ns2:gecc' of XML schema type 'ns2:GECC'
        ns2__GECC *gecc;
        /// Optional element 'ns2:ucaf' of XML schema type 'ns2:UCAF'
        ns2__UCAF *ucaf;
        /// Optional element 'ns2:fundTransfer' of XML schema type 'ns2:FundTransfer'
        ns2__FundTransfer *fundTransfer;
        /// Optional element 'ns2:bankInfo' of XML schema type 'ns2:BankInfo'
        ns2__BankInfo *bankInfo;
        /// Optional element 'ns2:subscription' of XML schema type 'ns2:Subscription'
        ns2__Subscription *subscription;
        /// Optional element 'ns2:recurringSubscriptionInfo' of XML schema type 'ns2:RecurringSubscriptionInfo'
        ns2__RecurringSubscriptionInfo *recurringSubscriptionInfo;
        /// Optional element 'ns2:tokenSource' of XML schema type 'ns2:TokenSource'
        ns2__TokenSource *tokenSource;
        /// Optional element 'ns2:decisionManager' of XML schema type 'ns2:DecisionManager'
        ns2__DecisionManager *decisionManager;
        /// Optional element 'ns2:otherTax' of XML schema type 'ns2:OtherTax'
        ns2__OtherTax *otherTax;
        /// Optional element 'ns2:paypal' of XML schema type 'ns2:PayPal'
        ns2__PayPal *paypal;
        /// Optional element 'ns2:merchantDefinedData' of XML schema type 'ns2:MerchantDefinedData'
        ns2__MerchantDefinedData *merchantDefinedData;
        /// Optional element 'ns2:auxiliaryData' of XML schema type 'ns2:AuxiliaryData'
        ns2__AuxiliaryData *auxiliaryData;
        /// Optional element 'ns2:merchantSecureData' of XML schema type 'ns2:MerchantSecureData'
        ns2__MerchantSecureData *merchantSecureData;
        /// Optional element 'ns2:jpo' of XML schema type 'ns2:JPO'
        ns2__JPO *jpo;
        /// Optional element 'ns2:orderRequestToken' of XML schema type 'xsd:string'
        std::string *orderRequestToken;
        /// Optional element 'ns2:linkToRequest' of XML schema type 'xsd:string'
        std::string *linkToRequest;
        /// Optional element 'ns2:serviceFee' of XML schema type 'ns2:ServiceFee'
        ns2__ServiceFee *serviceFee;
        /// Optional element 'ns2:giftCard' of XML schema type 'ns2:GiftCard'
        ns2__GiftCard *giftCard;
        /// Optional element 'ns2:ccAuthService' of XML schema type 'ns2:CCAuthService'
        ns2__CCAuthService *ccAuthService;
        /// Optional element 'ns2:octService' of XML schema type 'ns2:OCTService'
        ns2__OCTService *octService;
        /// Optional element 'ns2:ecAVSService' of XML schema type 'ns2:ECAVSService'
        ns2__ECAVSService *ecAVSService;
        /// Optional element 'ns2:giftCardActivationService' of XML schema type 'ns2:GiftCardActivationService'
        ns2__GiftCardActivationService *giftCardActivationService;
        /// Optional element 'ns2:giftCardBalanceInquiryService' of XML schema type 'ns2:GiftCardBalanceInquiryService'
        ns2__GiftCardBalanceInquiryService *giftCardBalanceInquiryService;
        /// Optional element 'ns2:giftCardRedemptionService' of XML schema type 'ns2:GiftCardRedemptionService'
        ns2__GiftCardRedemptionService *giftCardRedemptionService;
        /// Optional element 'ns2:giftCardVoidService' of XML schema type 'ns2:GiftCardVoidService'
        ns2__GiftCardVoidService *giftCardVoidService;
        /// Optional element 'ns2:giftCardReversalService' of XML schema type 'ns2:GiftCardReversalService'
        ns2__GiftCardReversalService *giftCardReversalService;
        /// Optional element 'ns2:giftCardReloadService' of XML schema type 'ns2:GiftCardReloadService'
        ns2__GiftCardReloadService *giftCardReloadService;
        /// Optional element 'ns2:giftCardRefundService' of XML schema type 'ns2:GiftCardRefundService'
        ns2__GiftCardRefundService *giftCardRefundService;
        /// Optional element 'ns2:verificationService' of XML schema type 'ns2:VerificationService'
        ns2__VerificationService *verificationService;
        /// Optional element 'ns2:ccSaleService' of XML schema type 'ns2:CCSaleService'
        ns2__CCSaleService *ccSaleService;
        /// Optional element 'ns2:ccSaleCreditService' of XML schema type 'ns2:CCSaleCreditService'
        ns2__CCSaleCreditService *ccSaleCreditService;
        /// Optional element 'ns2:ccSaleReversalService' of XML schema type 'ns2:CCSaleReversalService'
        ns2__CCSaleReversalService *ccSaleReversalService;
        /// Optional element 'ns2:ccIncrementalAuthService' of XML schema type 'ns2:CCIncrementalAuthService'
        ns2__CCIncrementalAuthService *ccIncrementalAuthService;
        /// Optional element 'ns2:ccCaptureService' of XML schema type 'ns2:CCCaptureService'
        ns2__CCCaptureService *ccCaptureService;
        /// Optional element 'ns2:ccCreditService' of XML schema type 'ns2:CCCreditService'
        ns2__CCCreditService *ccCreditService;
        /// Optional element 'ns2:ccAuthReversalService' of XML schema type 'ns2:CCAuthReversalService'
        ns2__CCAuthReversalService *ccAuthReversalService;
        /// Optional element 'ns2:ccAutoAuthReversalService' of XML schema type 'ns2:CCAutoAuthReversalService'
        ns2__CCAutoAuthReversalService *ccAutoAuthReversalService;
        /// Optional element 'ns2:ccDCCService' of XML schema type 'ns2:CCDCCService'
        ns2__CCDCCService *ccDCCService;
        /// Optional element 'ns2:serviceFeeCalculateService' of XML schema type 'ns2:ServiceFeeCalculateService'
        ns2__ServiceFeeCalculateService *serviceFeeCalculateService;
        /// Optional element 'ns2:ecDebitService' of XML schema type 'ns2:ECDebitService'
        ns2__ECDebitService *ecDebitService;
        /// Optional element 'ns2:ecCreditService' of XML schema type 'ns2:ECCreditService'
        ns2__ECCreditService *ecCreditService;
        /// Optional element 'ns2:ecAuthenticateService' of XML schema type 'ns2:ECAuthenticateService'
        ns2__ECAuthenticateService *ecAuthenticateService;
        /// Optional element 'ns2:payerAuthSetupService' of XML schema type 'ns2:PayerAuthSetupService'
        ns2__PayerAuthSetupService *payerAuthSetupService;
        /// Optional element 'ns2:payerAuthEnrollService' of XML schema type 'ns2:PayerAuthEnrollService'
        ns2__PayerAuthEnrollService *payerAuthEnrollService;
        /// Optional element 'ns2:payerAuthValidateService' of XML schema type 'ns2:PayerAuthValidateService'
        ns2__PayerAuthValidateService *payerAuthValidateService;
        /// Optional element 'ns2:taxService' of XML schema type 'ns2:TaxService'
        ns2__TaxService *taxService;
        /// Optional element 'ns2:dmeService' of XML schema type 'ns2:DMEService'
        ns2__DMEService *dmeService;
        /// Optional element 'ns2:afsService' of XML schema type 'ns2:AFSService'
        ns2__AFSService *afsService;
        /// Optional element 'ns2:davService' of XML schema type 'ns2:DAVService'
        ns2__DAVService *davService;
        /// Optional element 'ns2:exportService' of XML schema type 'ns2:ExportService'
        ns2__ExportService *exportService;
        /// Optional element 'ns2:fxRatesService' of XML schema type 'ns2:FXRatesService'
        ns2__FXRatesService *fxRatesService;
        /// Optional element 'ns2:bankTransferService' of XML schema type 'ns2:BankTransferService'
        ns2__BankTransferService *bankTransferService;
        /// Optional element 'ns2:bankTransferRefundService' of XML schema type 'ns2:BankTransferRefundService'
        ns2__BankTransferRefundService *bankTransferRefundService;
        /// Optional element 'ns2:bankTransferRealTimeService' of XML schema type 'ns2:BankTransferRealTimeService'
        ns2__BankTransferRealTimeService *bankTransferRealTimeService;
        /// Optional element 'ns2:directDebitMandateService' of XML schema type 'ns2:DirectDebitMandateService'
        ns2__DirectDebitMandateService *directDebitMandateService;
        /// Optional element 'ns2:directDebitService' of XML schema type 'ns2:DirectDebitService'
        ns2__DirectDebitService *directDebitService;
        /// Optional element 'ns2:directDebitRefundService' of XML schema type 'ns2:DirectDebitRefundService'
        ns2__DirectDebitRefundService *directDebitRefundService;
        /// Optional element 'ns2:directDebitValidateService' of XML schema type 'ns2:DirectDebitValidateService'
        ns2__DirectDebitValidateService *directDebitValidateService;
        /// Sequence of 0 to 10 elements 'ns2:deviceFingerprintData' of XML schema type 'ns2:DeviceFingerprintData'
        std::vector<ns2__DeviceFingerprintData> deviceFingerprintData;
        /// Optional element 'ns2:paySubscriptionCreateService' of XML schema type 'ns2:PaySubscriptionCreateService'
        ns2__PaySubscriptionCreateService *paySubscriptionCreateService;
        /// Optional element 'ns2:paySubscriptionUpdateService' of XML schema type 'ns2:PaySubscriptionUpdateService'
        ns2__PaySubscriptionUpdateService *paySubscriptionUpdateService;
        /// Optional element 'ns2:paySubscriptionEventUpdateService' of XML schema type 'ns2:PaySubscriptionEventUpdateService'
        ns2__PaySubscriptionEventUpdateService *paySubscriptionEventUpdateService;
        /// Optional element 'ns2:paySubscriptionRetrieveService' of XML schema type 'ns2:PaySubscriptionRetrieveService'
        ns2__PaySubscriptionRetrieveService *paySubscriptionRetrieveService;
        /// Optional element 'ns2:paySubscriptionDeleteService' of XML schema type 'ns2:PaySubscriptionDeleteService'
        ns2__PaySubscriptionDeleteService *paySubscriptionDeleteService;
        /// Optional element 'ns2:payPalPaymentService' of XML schema type 'ns2:PayPalPaymentService'
        ns2__PayPalPaymentService *payPalPaymentService;
        /// Optional element 'ns2:payPalCreditService' of XML schema type 'ns2:PayPalCreditService'
        ns2__PayPalCreditService *payPalCreditService;
        /// Optional element 'ns2:voidService' of XML schema type 'ns2:VoidService'
        ns2__VoidService *voidService;
        /// Optional element 'ns2:businessRules' of XML schema type 'ns2:BusinessRules'
        ns2__BusinessRules *businessRules;
        /// Optional element 'ns2:pinlessDebitService' of XML schema type 'ns2:PinlessDebitService'
        ns2__PinlessDebitService *pinlessDebitService;
        /// Optional element 'ns2:pinlessDebitValidateService' of XML schema type 'ns2:PinlessDebitValidateService'
        ns2__PinlessDebitValidateService *pinlessDebitValidateService;
        /// Optional element 'ns2:pinlessDebitReversalService' of XML schema type 'ns2:PinlessDebitReversalService'
        ns2__PinlessDebitReversalService *pinlessDebitReversalService;
        /// Optional element 'ns2:batch' of XML schema type 'ns2:Batch'
        ns2__Batch *batch;
        /// Optional element 'ns2:airlineData' of XML schema type 'ns2:AirlineData'
        ns2__AirlineData *airlineData;
        /// Optional element 'ns2:ancillaryData' of XML schema type 'ns2:AncillaryData'
        ns2__AncillaryData *ancillaryData;
        /// Optional element 'ns2:lodgingData' of XML schema type 'ns2:LodgingData'
        ns2__LodgingData *lodgingData;
        /// Optional element 'ns2:payPalButtonCreateService' of XML schema type 'ns2:PayPalButtonCreateService'
        ns2__PayPalButtonCreateService *payPalButtonCreateService;
        /// Optional element 'ns2:payPalPreapprovedPaymentService' of XML schema type 'ns2:PayPalPreapprovedPaymentService'
        ns2__PayPalPreapprovedPaymentService *payPalPreapprovedPaymentService;
        /// Optional element 'ns2:payPalPreapprovedUpdateService' of XML schema type 'ns2:PayPalPreapprovedUpdateService'
        ns2__PayPalPreapprovedUpdateService *payPalPreapprovedUpdateService;
        /// Optional element 'ns2:riskUpdateService' of XML schema type 'ns2:RiskUpdateService'
        ns2__RiskUpdateService *riskUpdateService;
        /// Optional element 'ns2:fraudUpdateService' of XML schema type 'ns2:FraudUpdateService'
        ns2__FraudUpdateService *fraudUpdateService;
        /// Optional element 'ns2:caseManagementActionService' of XML schema type 'ns2:CaseManagementActionService'
        ns2__CaseManagementActionService *caseManagementActionService;
        /// Sequence of 0 to 999 elements 'ns2:reserved' of XML schema type 'ns2:RequestReserved'
        std::vector<ns2__RequestReserved> reserved;
        /// Optional element 'ns2:deviceFingerprintID' of XML schema type 'xsd:string'
        std::string *deviceFingerprintID;
        /// Optional element 'ns2:deviceFingerprintRaw' of XML schema type 'ns2:boolean'
        std::string *deviceFingerprintRaw;
        /// Optional element 'ns2:deviceFingerprintHash' of XML schema type 'xsd:string'
        std::string *deviceFingerprintHash;
        /// Optional element 'ns2:payPalRefundService' of XML schema type 'ns2:PayPalRefundService'
        ns2__PayPalRefundService *payPalRefundService;
        /// Optional element 'ns2:payPalAuthReversalService' of XML schema type 'ns2:PayPalAuthReversalService'
        ns2__PayPalAuthReversalService *payPalAuthReversalService;
        /// Optional element 'ns2:payPalDoCaptureService' of XML schema type 'ns2:PayPalDoCaptureService'
        ns2__PayPalDoCaptureService *payPalDoCaptureService;
        /// Optional element 'ns2:payPalEcDoPaymentService' of XML schema type 'ns2:PayPalEcDoPaymentService'
        ns2__PayPalEcDoPaymentService *payPalEcDoPaymentService;
        /// Optional element 'ns2:payPalEcGetDetailsService' of XML schema type 'ns2:PayPalEcGetDetailsService'
        ns2__PayPalEcGetDetailsService *payPalEcGetDetailsService;
        /// Optional element 'ns2:payPalEcSetService' of XML schema type 'ns2:PayPalEcSetService'
        ns2__PayPalEcSetService *payPalEcSetService;
        /// Optional element 'ns2:payPalEcOrderSetupService' of XML schema type 'ns2:PayPalEcOrderSetupService'
        ns2__PayPalEcOrderSetupService *payPalEcOrderSetupService;
        /// Optional element 'ns2:payPalAuthorizationService' of XML schema type 'ns2:PayPalAuthorizationService'
        ns2__PayPalAuthorizationService *payPalAuthorizationService;
        /// Optional element 'ns2:payPalUpdateAgreementService' of XML schema type 'ns2:PayPalUpdateAgreementService'
        ns2__PayPalUpdateAgreementService *payPalUpdateAgreementService;
        /// Optional element 'ns2:payPalCreateAgreementService' of XML schema type 'ns2:PayPalCreateAgreementService'
        ns2__PayPalCreateAgreementService *payPalCreateAgreementService;
        /// Optional element 'ns2:payPalDoRefTransactionService' of XML schema type 'ns2:PayPalDoRefTransactionService'
        ns2__PayPalDoRefTransactionService *payPalDoRefTransactionService;
        /// Optional element 'ns2:chinaPaymentService' of XML schema type 'ns2:ChinaPaymentService'
        ns2__ChinaPaymentService *chinaPaymentService;
        /// Optional element 'ns2:chinaRefundService' of XML schema type 'ns2:ChinaRefundService'
        ns2__ChinaRefundService *chinaRefundService;
        /// Optional element 'ns2:boletoPaymentService' of XML schema type 'ns2:BoletoPaymentService'
        ns2__BoletoPaymentService *boletoPaymentService;
        /// Optional element 'ns2:apPaymentType' of XML schema type 'xsd:string'
        std::string *apPaymentType;
        /// Optional element 'ns2:apInitiateService' of XML schema type 'ns2:APInitiateService'
        ns2__APInitiateService *apInitiateService;
        /// Optional element 'ns2:apCheckStatusService' of XML schema type 'ns2:APCheckStatusService'
        ns2__APCheckStatusService *apCheckStatusService;
        /// Optional element 'ns2:ignoreCardExpiration' of XML schema type 'ns2:boolean'
        std::string *ignoreCardExpiration;
        /// Optional element 'ns2:reportGroup' of XML schema type 'xsd:string'
        std::string *reportGroup;
        /// Optional element 'ns2:processorID' of XML schema type 'xsd:string'
        std::string *processorID;
        /// Optional element 'ns2:thirdPartyCertificationNumber' of XML schema type 'xsd:string'
        std::string *thirdPartyCertificationNumber;
        /// Optional element 'ns2:transactionLocalDateTime' of XML schema type 'ns2:dateTime'
        std::string *transactionLocalDateTime;
        /// Optional element 'ns2:solutionProviderTransactionID' of XML schema type 'xsd:string'
        std::string *solutionProviderTransactionID;
        /// Optional element 'ns2:surchargeAmount' of XML schema type 'ns2:amount'
        std::string *surchargeAmount;
        /// Optional element 'ns2:surchargeSign' of XML schema type 'xsd:string'
        std::string *surchargeSign;
        /// Optional element 'ns2:pinDataEncryptedPIN' of XML schema type 'xsd:string'
        std::string *pinDataEncryptedPIN;
        /// Optional element 'ns2:pinDataKeySerialNumber' of XML schema type 'xsd:string'
        std::string *pinDataKeySerialNumber;
        /// Optional element 'ns2:pinDataPinBlockEncodingFormat' of XML schema type 'xsd:integer'
        std::string *pinDataPinBlockEncodingFormat;
        /// Optional element 'ns2:cashbackAmount' of XML schema type 'ns2:amount'
        std::string *cashbackAmount;
        /// Optional element 'ns2:pinDebitPurchaseService' of XML schema type 'ns2:PinDebitPurchaseService'
        ns2__PinDebitPurchaseService *pinDebitPurchaseService;
        /// Optional element 'ns2:pinDebitCreditService' of XML schema type 'ns2:PinDebitCreditService'
        ns2__PinDebitCreditService *pinDebitCreditService;
        /// Optional element 'ns2:pinDebitReversalService' of XML schema type 'ns2:PinDebitReversalService'
        ns2__PinDebitReversalService *pinDebitReversalService;
        /// Optional element 'ns2:ap' of XML schema type 'ns2:AP'
        ns2__AP *ap;
        /// Optional element 'ns2:apAuthService' of XML schema type 'ns2:APAuthService'
        ns2__APAuthService *apAuthService;
        /// Optional element 'ns2:apAuthReversalService' of XML schema type 'ns2:APAuthReversalService'
        ns2__APAuthReversalService *apAuthReversalService;
        /// Optional element 'ns2:apCaptureService' of XML schema type 'ns2:APCaptureService'
        ns2__APCaptureService *apCaptureService;
        /// Optional element 'ns2:apOptionsService' of XML schema type 'ns2:APOptionsService'
        ns2__APOptionsService *apOptionsService;
        /// Optional element 'ns2:apRefundService' of XML schema type 'ns2:APRefundService'
        ns2__APRefundService *apRefundService;
        /// Optional element 'ns2:apSaleService' of XML schema type 'ns2:APSaleService'
        ns2__APSaleService *apSaleService;
        /// Optional element 'ns2:apCheckoutDetailsService' of XML schema type 'ns2:APCheckOutDetailsService'
        ns2__APCheckOutDetailsService *apCheckoutDetailsService;
        /// Optional element 'ns2:apSessionsService' of XML schema type 'ns2:APSessionsService'
        ns2__APSessionsService *apSessionsService;
        /// Optional element 'ns2:apUI' of XML schema type 'ns2:APUI'
        ns2__APUI *apUI;
        /// Optional element 'ns2:apTransactionDetailsService' of XML schema type 'ns2:APTransactionDetailsService'
        ns2__APTransactionDetailsService *apTransactionDetailsService;
        /// Optional element 'ns2:apConfirmPurchaseService' of XML schema type 'ns2:APConfirmPurchaseService'
        ns2__APConfirmPurchaseService *apConfirmPurchaseService;
        /// Optional element 'ns2:payPalGetTxnDetailsService' of XML schema type 'ns2:PayPalGetTxnDetailsService'
        ns2__PayPalGetTxnDetailsService *payPalGetTxnDetailsService;
        /// Optional element 'ns2:payPalTransactionSearchService' of XML schema type 'ns2:PayPalTransactionSearchService'
        ns2__PayPalTransactionSearchService *payPalTransactionSearchService;
        /// Optional element 'ns2:ccDCCUpdateService' of XML schema type 'ns2:CCDCCUpdateService'
        ns2__CCDCCUpdateService *ccDCCUpdateService;
        /// Optional element 'ns2:emvRequest' of XML schema type 'ns2:EmvRequest'
        ns2__EmvRequest *emvRequest;
        /// Optional element 'ns2:merchant' of XML schema type 'ns2:merchant'
        ns2__merchant *merchant;
        /// Optional element 'ns2:merchantTransactionIdentifier' of XML schema type 'xsd:string'
        std::string *merchantTransactionIdentifier;
        /// Optional element 'ns2:hostedDataCreateService' of XML schema type 'ns2:HostedDataCreateService'
        ns2__HostedDataCreateService *hostedDataCreateService;
        /// Optional element 'ns2:hostedDataRetrieveService' of XML schema type 'ns2:HostedDataRetrieveService'
        ns2__HostedDataRetrieveService *hostedDataRetrieveService;
        /// Optional element 'ns2:merchantDomainName' of XML schema type 'xsd:string'
        std::string *merchantDomainName;
        /// Optional element 'ns2:merchantCategoryCode' of XML schema type 'xsd:string'
        std::string *merchantCategoryCode;
        /// Optional element 'ns2:merchantCategoryCodeDomestic' of XML schema type 'xsd:string'
        std::string *merchantCategoryCodeDomestic;
        /// Optional element 'ns2:salesSlipNumber' of XML schema type 'xsd:string'
        std::string *salesSlipNumber;
        /// Optional element 'ns2:merchandiseCode' of XML schema type 'xsd:string'
        std::string *merchandiseCode;
        /// Optional element 'ns2:merchandiseDescription' of XML schema type 'xsd:string'
        std::string *merchandiseDescription;
        /// Optional element 'ns2:paymentInitiationChannel' of XML schema type 'xsd:string'
        std::string *paymentInitiationChannel;
        /// Optional element 'ns2:extendedCreditTotalCount' of XML schema type 'xsd:string'
        std::string *extendedCreditTotalCount;
        /// Optional element 'ns2:authIndicator' of XML schema type 'xsd:string'
        std::string *authIndicator;
        /// Optional element 'ns2:paymentNetworkToken' of XML schema type 'ns2:PaymentNetworkToken'
        ns2__PaymentNetworkToken *paymentNetworkToken;
        /// Optional element 'ns2:recipient' of XML schema type 'ns2:Recipient'
        ns2__Recipient *recipient;
        /// Optional element 'ns2:sender' of XML schema type 'ns2:Sender'
        ns2__Sender *sender;
        /// Optional element 'ns2:autoRentalData' of XML schema type 'ns2:AutoRentalData'
        ns2__AutoRentalData *autoRentalData;
        /// Optional element 'ns2:paymentSolution' of XML schema type 'xsd:string'
        std::string *paymentSolution;
        /// Optional element 'ns2:vc' of XML schema type 'ns2:VC'
        ns2__VC *vc;
        /// Optional element 'ns2:decryptVisaCheckoutDataService' of XML schema type 'ns2:DecryptVisaCheckoutDataService'
        ns2__DecryptVisaCheckoutDataService *decryptVisaCheckoutDataService;
        /// Optional element 'ns2:taxManagementIndicator' of XML schema type 'xsd:string'
        std::string *taxManagementIndicator;
        /// Sequence of 0 to 100 elements 'ns2:promotionGroup' of XML schema type 'ns2:PromotionGroup'
        std::vector<ns2__PromotionGroup> promotionGroup;
        /// Optional element 'ns2:wallet' of XML schema type 'ns2:Wallet'
        ns2__Wallet *wallet;
        /// Optional element 'ns2:aft' of XML schema type 'ns2:Aft'
        ns2__Aft *aft;
        /// Optional element 'ns2:balanceInquiry' of XML schema type 'ns2:boolean'
        std::string *balanceInquiry;
        /// Optional element 'ns2:prenoteTransaction' of XML schema type 'ns2:boolean'
        std::string *prenoteTransaction;
        /// Optional element 'ns2:encryptPaymentDataService' of XML schema type 'ns2:EncryptPaymentDataService'
        ns2__EncryptPaymentDataService *encryptPaymentDataService;
        /// Optional element 'ns2:nationalNetDomesticData' of XML schema type 'xsd:string'
        std::string *nationalNetDomesticData;
        /// Optional element 'ns2:subsequentAuth' of XML schema type 'xsd:string'
        std::string *subsequentAuth;
        /// Optional element 'ns2:subsequentAuthOriginalAmount' of XML schema type 'ns2:amount'
        std::string *subsequentAuthOriginalAmount;
        /// Optional element 'ns2:binLookupService' of XML schema type 'ns2:BinLookupService'
        ns2__BinLookupService *binLookupService;
        /// Optional element 'ns2:verificationCode' of XML schema type 'xsd:string'
        std::string *verificationCode;
        /// Optional element 'ns2:mobileNumber' of XML schema type 'xsd:string'
        std::string *mobileNumber;
        /// Optional element 'ns2:issuer' of XML schema type 'ns2:issuer'
        ns2__issuer *issuer;
        /// Optional element 'ns2:partnerSolutionID' of XML schema type 'xsd:string'
        std::string *partnerSolutionID;
        /// Optional element 'ns2:developerID' of XML schema type 'xsd:string'
        std::string *developerID;
        /// Optional element 'ns2:getVisaCheckoutDataService' of XML schema type 'ns2:GETVisaCheckoutDataService'
        ns2__GETVisaCheckoutDataService *getVisaCheckoutDataService;
        /// Optional element 'ns2:customerSignatureImage' of XML schema type 'xsd:string'
        std::string *customerSignatureImage;
        /// Optional element 'ns2:transactionMetadataService' of XML schema type 'ns2:TransactionMetadataService'
        ns2__TransactionMetadataService *transactionMetadataService;
        /// Optional element 'ns2:subsequentAuthFirst' of XML schema type 'xsd:string'
        std::string *subsequentAuthFirst;
        /// Optional element 'ns2:subsequentAuthReason' of XML schema type 'xsd:string'
        std::string *subsequentAuthReason;
        /// Optional element 'ns2:subsequentAuthTransactionID' of XML schema type 'xsd:string'
        std::string *subsequentAuthTransactionID;
        /// Optional element 'ns2:subsequentAuthStoredCredential' of XML schema type 'xsd:string'
        std::string *subsequentAuthStoredCredential;
        /// Optional element 'ns2:subsequentAuthCumulativeAuthAmount' of XML schema type 'ns2:amount'
        std::string *subsequentAuthCumulativeAuthAmount;
        /// Optional element 'ns2:subsequentAuthCITAuthenticationData' of XML schema type 'xsd:string'
        std::string *subsequentAuthCITAuthenticationData;
        /// Optional element 'ns2:loan' of XML schema type 'ns2:Loan'
        ns2__Loan *loan;
        /// Optional element 'ns2:eligibilityInquiry' of XML schema type 'xsd:string'
        std::string *eligibilityInquiry;
        /// Optional element 'ns2:redemptionInquiry' of XML schema type 'xsd:string'
        std::string *redemptionInquiry;
        /// Optional element 'ns2:feeProgramIndicator' of XML schema type 'xsd:string'
        std::string *feeProgramIndicator;
        /// Optional element 'ns2:apOrderService' of XML schema type 'ns2:APOrderService'
        ns2__APOrderService *apOrderService;
        /// Optional element 'ns2:apCancelService' of XML schema type 'ns2:APCancelService'
        ns2__APCancelService *apCancelService;
        /// Optional element 'ns2:apBillingAgreementService' of XML schema type 'ns2:APBillingAgreementService'
        ns2__APBillingAgreementService *apBillingAgreementService;
        /// Optional element 'ns2:note_toPayee' of XML schema type 'xsd:string'
        std::string *note_USCOREtoPayee;
        /// Optional element 'ns2:note_toPayer' of XML schema type 'xsd:string'
        std::string *note_USCOREtoPayer;
        /// Optional element 'ns2:clientMetadataID' of XML schema type 'xsd:string'
        std::string *clientMetadataID;
        /// Optional element 'ns2:partnerSDKversion' of XML schema type 'xsd:string'
        std::string *partnerSDKversion;
        /// Optional element 'ns2:partnerOriginalTransactionID' of XML schema type 'xsd:string'
        std::string *partnerOriginalTransactionID;
        /// Optional element 'ns2:cardTypeSelectionIndicator' of XML schema type 'xsd:string'
        std::string *cardTypeSelectionIndicator;
        /// Optional element 'ns2:apCreateMandateService' of XML schema type 'ns2:APCreateMandateService'
        ns2__APCreateMandateService *apCreateMandateService;
        /// Optional element 'ns2:apMandateStatusService' of XML schema type 'ns2:APMandateStatusService'
        ns2__APMandateStatusService *apMandateStatusService;
        /// Optional element 'ns2:apUpdateMandateService' of XML schema type 'ns2:APUpdateMandateService'
        ns2__APUpdateMandateService *apUpdateMandateService;
        /// Optional element 'ns2:apImportMandateService' of XML schema type 'ns2:APImportMandateService'
        ns2__APImportMandateService *apImportMandateService;
        /// Optional element 'ns2:apRevokeMandateService' of XML schema type 'ns2:APRevokeMandateService'
        ns2__APRevokeMandateService *apRevokeMandateService;
        /// Optional element 'ns2:billPaymentType' of XML schema type 'xsd:string'
        std::string *billPaymentType;
        /// Optional element 'ns2:postdatedTransaction' of XML schema type 'ns2:PostdatedTransaction'
        ns2__PostdatedTransaction *postdatedTransaction;
        /// Optional element 'ns2:getMasterpassDataService' of XML schema type 'ns2:GetMasterpassDataService'
        ns2__GetMasterpassDataService *getMasterpassDataService;
        /// Optional element 'ns2:ccCheckStatusService' of XML schema type 'ns2:CCCheckStatusService'
        ns2__CCCheckStatusService *ccCheckStatusService;
        /// Optional element 'ns2:mPOS' of XML schema type 'ns2:mPOS'
        ns2__mPOS *mPOS;
        /// Optional element 'ns2:abortService' of XML schema type 'ns2:AbortService'
        ns2__AbortService *abortService;
        /// Optional element 'ns2:ignoreRelaxAVS' of XML schema type 'ns2:boolean'
        std::string *ignoreRelaxAVS;
        /// Optional element 'ns2:agencyInformation' of XML schema type 'ns2:AgencyInformation'
        ns2__AgencyInformation *agencyInformation;
        /// Optional element 'ns2:autoRental' of XML schema type 'ns2:AutoRental'
        ns2__AutoRental *autoRental;
        /// Sequence of 0 to 10 elements 'ns2:healthCare' of XML schema type 'ns2:HealthCare'
        std::vector<ns2__HealthCare> healthCare;
        /// Optional element 'ns2:payByPoints' of XML schema type 'ns2:payByPoints'
        ns2__payByPoints *payByPoints;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RequestMessage
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__RequestMessage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RequestMessage, default initialized and not managed by a soap context
        virtual ns2__RequestMessage *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__RequestMessage); }
      public:
        /// Constructor with default initializations
        ns2__RequestMessage() : merchantID(), merchantReferenceCode(), debtIndicator(), clientLibrary(), clientLibraryVersion(), clientEnvironment(), clientSecurityLibraryVersion(), clientApplication(), clientApplicationVersion(), clientApplicationUser(), routingCode(), comments(), returnURL(), invoiceHeader(), paymentScheme(), mandateID(), aggregatorMerchantIdentifier(), customerID(), customerFirstName(), customerLastName(), billTo(), shipTo(), personalID(), shipFrom(), item(), purchaseTotals(), fundingTotals(), dcc(), pos(), pin(), encryptedPayment(), installment(), card(), category(), check(), bml(), gecc(), ucaf(), fundTransfer(), bankInfo(), subscription(), recurringSubscriptionInfo(), tokenSource(), decisionManager(), otherTax(), paypal(), merchantDefinedData(), auxiliaryData(), merchantSecureData(), jpo(), orderRequestToken(), linkToRequest(), serviceFee(), giftCard(), ccAuthService(), octService(), ecAVSService(), giftCardActivationService(), giftCardBalanceInquiryService(), giftCardRedemptionService(), giftCardVoidService(), giftCardReversalService(), giftCardReloadService(), giftCardRefundService(), verificationService(), ccSaleService(), ccSaleCreditService(), ccSaleReversalService(), ccIncrementalAuthService(), ccCaptureService(), ccCreditService(), ccAuthReversalService(), ccAutoAuthReversalService(), ccDCCService(), serviceFeeCalculateService(), ecDebitService(), ecCreditService(), ecAuthenticateService(), payerAuthSetupService(), payerAuthEnrollService(), payerAuthValidateService(), taxService(), dmeService(), afsService(), davService(), exportService(), fxRatesService(), bankTransferService(), bankTransferRefundService(), bankTransferRealTimeService(), directDebitMandateService(), directDebitService(), directDebitRefundService(), directDebitValidateService(), deviceFingerprintData(), paySubscriptionCreateService(), paySubscriptionUpdateService(), paySubscriptionEventUpdateService(), paySubscriptionRetrieveService(), paySubscriptionDeleteService(), payPalPaymentService(), payPalCreditService(), voidService(), businessRules(), pinlessDebitService(), pinlessDebitValidateService(), pinlessDebitReversalService(), batch(), airlineData(), ancillaryData(), lodgingData(), payPalButtonCreateService(), payPalPreapprovedPaymentService(), payPalPreapprovedUpdateService(), riskUpdateService(), fraudUpdateService(), caseManagementActionService(), reserved(), deviceFingerprintID(), deviceFingerprintRaw(), deviceFingerprintHash(), payPalRefundService(), payPalAuthReversalService(), payPalDoCaptureService(), payPalEcDoPaymentService(), payPalEcGetDetailsService(), payPalEcSetService(), payPalEcOrderSetupService(), payPalAuthorizationService(), payPalUpdateAgreementService(), payPalCreateAgreementService(), payPalDoRefTransactionService(), chinaPaymentService(), chinaRefundService(), boletoPaymentService(), apPaymentType(), apInitiateService(), apCheckStatusService(), ignoreCardExpiration(), reportGroup(), processorID(), thirdPartyCertificationNumber(), transactionLocalDateTime(), solutionProviderTransactionID(), surchargeAmount(), surchargeSign(), pinDataEncryptedPIN(), pinDataKeySerialNumber(), pinDataPinBlockEncodingFormat(), cashbackAmount(), pinDebitPurchaseService(), pinDebitCreditService(), pinDebitReversalService(), ap(), apAuthService(), apAuthReversalService(), apCaptureService(), apOptionsService(), apRefundService(), apSaleService(), apCheckoutDetailsService(), apSessionsService(), apUI(), apTransactionDetailsService(), apConfirmPurchaseService(), payPalGetTxnDetailsService(), payPalTransactionSearchService(), ccDCCUpdateService(), emvRequest(), merchant(), merchantTransactionIdentifier(), hostedDataCreateService(), hostedDataRetrieveService(), merchantDomainName(), merchantCategoryCode(), merchantCategoryCodeDomestic(), salesSlipNumber(), merchandiseCode(), merchandiseDescription(), paymentInitiationChannel(), extendedCreditTotalCount(), authIndicator(), paymentNetworkToken(), recipient(), sender(), autoRentalData(), paymentSolution(), vc(), decryptVisaCheckoutDataService(), taxManagementIndicator(), promotionGroup(), wallet(), aft(), balanceInquiry(), prenoteTransaction(), encryptPaymentDataService(), nationalNetDomesticData(), subsequentAuth(), subsequentAuthOriginalAmount(), binLookupService(), verificationCode(), mobileNumber(), issuer(), partnerSolutionID(), developerID(), getVisaCheckoutDataService(), customerSignatureImage(), transactionMetadataService(), subsequentAuthFirst(), subsequentAuthReason(), subsequentAuthTransactionID(), subsequentAuthStoredCredential(), subsequentAuthCumulativeAuthAmount(), subsequentAuthCITAuthenticationData(), loan(), eligibilityInquiry(), redemptionInquiry(), feeProgramIndicator(), apOrderService(), apCancelService(), apBillingAgreementService(), note_USCOREtoPayee(), note_USCOREtoPayer(), clientMetadataID(), partnerSDKversion(), partnerOriginalTransactionID(), cardTypeSelectionIndicator(), apCreateMandateService(), apMandateStatusService(), apUpdateMandateService(), apImportMandateService(), apRevokeMandateService(), billPaymentType(), postdatedTransaction(), getMasterpassDataService(), ccCheckStatusService(), mPOS(), abortService(), ignoreRelaxAVS(), agencyInformation(), autoRental(), healthCare(), payByPoints(), soap() { }
        virtual ~ns2__RequestMessage() { }
        /// Friend allocator used by soap_new_ns2__RequestMessage(struct soap*, int)
        friend SOAP_FMAC1 ns2__RequestMessage * SOAP_FMAC2 soap_instantiate_ns2__RequestMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:428 */
#ifndef SOAP_TYPE_ns2__VC
#define SOAP_TYPE_ns2__VC (409)
/* complex XML schema type 'ns2:VC': */
class SOAP_CMAC ns2__VC {
      public:
        /// Optional element 'ns2:orderID' of XML schema type 'xsd:string'
        std::string *orderID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VC
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__VC; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VC, default initialized and not managed by a soap context
        virtual ns2__VC *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__VC); }
      public:
        /// Constructor with default initializations
        ns2__VC() : orderID(), soap() { }
        virtual ~ns2__VC() { }
        /// Friend allocator used by soap_new_ns2__VC(struct soap*, int)
        friend SOAP_FMAC1 ns2__VC * SOAP_FMAC2 soap_instantiate_ns2__VC(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:430 */
#ifndef SOAP_TYPE_ns2__DecryptVisaCheckoutDataService
#define SOAP_TYPE_ns2__DecryptVisaCheckoutDataService (410)
/* complex XML schema type 'ns2:DecryptVisaCheckoutDataService': */
class SOAP_CMAC ns2__DecryptVisaCheckoutDataService {
      public:
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DecryptVisaCheckoutDataService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DecryptVisaCheckoutDataService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DecryptVisaCheckoutDataService, default initialized and not managed by a soap context
        virtual ns2__DecryptVisaCheckoutDataService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DecryptVisaCheckoutDataService); }
      public:
        /// Constructor with default initializations
        ns2__DecryptVisaCheckoutDataService() : run(), soap() { }
        virtual ~ns2__DecryptVisaCheckoutDataService() { }
        /// Friend allocator used by soap_new_ns2__DecryptVisaCheckoutDataService(struct soap*, int)
        friend SOAP_FMAC1 ns2__DecryptVisaCheckoutDataService * SOAP_FMAC2 soap_instantiate_ns2__DecryptVisaCheckoutDataService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:432 */
#ifndef SOAP_TYPE_ns2__DCC
#define SOAP_TYPE_ns2__DCC (411)
/* complex XML schema type 'ns2:DCC': */
class SOAP_CMAC ns2__DCC {
      public:
        /// Optional element 'ns2:dccIndicator' of XML schema type 'xsd:integer'
        std::string *dccIndicator;
        /// Optional element 'ns2:referenceNumber' of XML schema type 'xsd:string'
        std::string *referenceNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DCC
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DCC; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DCC, default initialized and not managed by a soap context
        virtual ns2__DCC *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DCC); }
      public:
        /// Constructor with default initializations
        ns2__DCC() : dccIndicator(), referenceNumber(), soap() { }
        virtual ~ns2__DCC() { }
        /// Friend allocator used by soap_new_ns2__DCC(struct soap*, int)
        friend SOAP_FMAC1 ns2__DCC * SOAP_FMAC2 soap_instantiate_ns2__DCC(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:434 */
#ifndef SOAP_TYPE_ns2__Promotion
#define SOAP_TYPE_ns2__Promotion (412)
/* complex XML schema type 'ns2:Promotion': */
class SOAP_CMAC ns2__Promotion {
      public:
        /// Optional element 'ns2:discountedAmount' of XML schema type 'ns2:amount'
        std::string *discountedAmount;
        /// Optional element 'ns2:type' of XML schema type 'xsd:string'
        std::string *type;
        /// Optional element 'ns2:code' of XML schema type 'xsd:string'
        std::string *code;
        /// Optional element 'ns2:receiptData' of XML schema type 'xsd:string'
        std::string *receiptData;
        /// Optional element 'ns2:discountApplied' of XML schema type 'ns2:amount'
        std::string *discountApplied;
        /// Optional element 'ns2:description' of XML schema type 'xsd:string'
        std::string *description;
        /// Optional element 'ns2:additionalCode' of XML schema type 'xsd:string'
        std::string *additionalCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Promotion
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Promotion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Promotion, default initialized and not managed by a soap context
        virtual ns2__Promotion *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Promotion); }
      public:
        /// Constructor with default initializations
        ns2__Promotion() : discountedAmount(), type(), code(), receiptData(), discountApplied(), description(), additionalCode(), soap() { }
        virtual ~ns2__Promotion() { }
        /// Friend allocator used by soap_new_ns2__Promotion(struct soap*, int)
        friend SOAP_FMAC1 ns2__Promotion * SOAP_FMAC2 soap_instantiate_ns2__Promotion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:436 */
#ifndef SOAP_TYPE_ns2__PromotionGroup
#define SOAP_TYPE_ns2__PromotionGroup (413)
/* complex XML schema type 'ns2:PromotionGroup': */
class SOAP_CMAC ns2__PromotionGroup {
      public:
        /// Optional element 'ns2:subtotalAmount' of XML schema type 'ns2:amount'
        std::string *subtotalAmount;
        /// Optional element 'ns2:taxRate' of XML schema type 'ns2:amount'
        std::string *taxRate;
        /// Optional element 'ns2:prohibitDiscount' of XML schema type 'xsd:string'
        std::string *prohibitDiscount;
        /// Optional attribute 'id' of XML schema type 'xsd:integer'
        std::string *id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PromotionGroup
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PromotionGroup; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PromotionGroup, default initialized and not managed by a soap context
        virtual ns2__PromotionGroup *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PromotionGroup); }
      public:
        /// Constructor with default initializations
        ns2__PromotionGroup() : subtotalAmount(), taxRate(), prohibitDiscount(), id(), soap() { }
        virtual ~ns2__PromotionGroup() { }
        /// Friend allocator used by soap_new_ns2__PromotionGroup(struct soap*, int)
        friend SOAP_FMAC1 ns2__PromotionGroup * SOAP_FMAC2 soap_instantiate_ns2__PromotionGroup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:438 */
#ifndef SOAP_TYPE_ns2__PromotionGroupReply
#define SOAP_TYPE_ns2__PromotionGroupReply (414)
/* complex XML schema type 'ns2:PromotionGroupReply': */
class SOAP_CMAC ns2__PromotionGroupReply {
      public:
        /// Optional element 'ns2:discountApplied' of XML schema type 'ns2:amount'
        std::string *discountApplied;
        /// Optional attribute 'id' of XML schema type 'xsd:integer'
        std::string *id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PromotionGroupReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PromotionGroupReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PromotionGroupReply, default initialized and not managed by a soap context
        virtual ns2__PromotionGroupReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PromotionGroupReply); }
      public:
        /// Constructor with default initializations
        ns2__PromotionGroupReply() : discountApplied(), id(), soap() { }
        virtual ~ns2__PromotionGroupReply() { }
        /// Friend allocator used by soap_new_ns2__PromotionGroupReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PromotionGroupReply * SOAP_FMAC2 soap_instantiate_ns2__PromotionGroupReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:440 */
#ifndef SOAP_TYPE_ns2__BalanceInfo
#define SOAP_TYPE_ns2__BalanceInfo (415)
/* complex XML schema type 'ns2:BalanceInfo': */
class SOAP_CMAC ns2__BalanceInfo {
      public:
        /// Optional element 'ns2:accountType' of XML schema type 'xsd:string'
        std::string *accountType;
        /// Optional element 'ns2:amount' of XML schema type 'xsd:string'
        std::string *amount;
        /// Optional element 'ns2:amountType' of XML schema type 'xsd:string'
        std::string *amountType;
        /// Optional element 'ns2:currency' of XML schema type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:sign' of XML schema type 'xsd:string'
        std::string *sign;
        /// Optional attribute 'id' of XML schema type 'xsd:integer'
        std::string *id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BalanceInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__BalanceInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BalanceInfo, default initialized and not managed by a soap context
        virtual ns2__BalanceInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__BalanceInfo); }
      public:
        /// Constructor with default initializations
        ns2__BalanceInfo() : accountType(), amount(), amountType(), currency(), sign(), id(), soap() { }
        virtual ~ns2__BalanceInfo() { }
        /// Friend allocator used by soap_new_ns2__BalanceInfo(struct soap*, int)
        friend SOAP_FMAC1 ns2__BalanceInfo * SOAP_FMAC2 soap_instantiate_ns2__BalanceInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:442 */
#ifndef SOAP_TYPE_ns2__CCAuthReply
#define SOAP_TYPE_ns2__CCAuthReply (416)
/* complex XML schema type 'ns2:CCAuthReply': */
class SOAP_CMAC ns2__CCAuthReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:authorizationCode' of XML schema type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:avsCode' of XML schema type 'xsd:string'
        std::string *avsCode;
        /// Optional element 'ns2:avsCodeRaw' of XML schema type 'xsd:string'
        std::string *avsCodeRaw;
        /// Optional element 'ns2:cvCode' of XML schema type 'xsd:string'
        std::string *cvCode;
        /// Optional element 'ns2:cvCodeRaw' of XML schema type 'xsd:string'
        std::string *cvCodeRaw;
        /// Optional element 'ns2:personalIDCode' of XML schema type 'xsd:string'
        std::string *personalIDCode;
        /// Optional element 'ns2:authorizedDateTime' of XML schema type 'ns2:dateTime'
        std::string *authorizedDateTime;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:bmlAccountNumber' of XML schema type 'xsd:string'
        std::string *bmlAccountNumber;
        /// Optional element 'ns2:authFactorCode' of XML schema type 'xsd:string'
        std::string *authFactorCode;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:fundingTotals' of XML schema type 'ns2:FundingTotals'
        ns2__FundingTotals *fundingTotals;
        /// Optional element 'ns2:fxQuoteID' of XML schema type 'xsd:string'
        std::string *fxQuoteID;
        /// Optional element 'ns2:fxQuoteRate' of XML schema type 'ns2:dateTime'
        std::string *fxQuoteRate;
        /// Optional element 'ns2:fxQuoteType' of XML schema type 'xsd:string'
        std::string *fxQuoteType;
        /// Optional element 'ns2:fxQuoteExpirationDateTime' of XML schema type 'ns2:dateTime'
        std::string *fxQuoteExpirationDateTime;
        /// Optional element 'ns2:authRecord' of XML schema type 'xsd:string'
        std::string *authRecord;
        /// Optional element 'ns2:merchantAdviceCode' of XML schema type 'xsd:string'
        std::string *merchantAdviceCode;
        /// Optional element 'ns2:merchantAdviceCodeRaw' of XML schema type 'xsd:string'
        std::string *merchantAdviceCodeRaw;
        /// Optional element 'ns2:cavvResponseCode' of XML schema type 'xsd:string'
        std::string *cavvResponseCode;
        /// Optional element 'ns2:cavvResponseCodeRaw' of XML schema type 'xsd:string'
        std::string *cavvResponseCodeRaw;
        /// Optional element 'ns2:authenticationXID' of XML schema type 'xsd:string'
        std::string *authenticationXID;
        /// Optional element 'ns2:authorizationXID' of XML schema type 'xsd:string'
        std::string *authorizationXID;
        /// Optional element 'ns2:processorCardType' of XML schema type 'xsd:string'
        std::string *processorCardType;
        /// Optional element 'ns2:accountBalance' of XML schema type 'ns2:amount'
        std::string *accountBalance;
        /// Optional element 'ns2:forwardCode' of XML schema type 'xsd:string'
        std::string *forwardCode;
        /// Optional element 'ns2:enhancedDataEnabled' of XML schema type 'xsd:string'
        std::string *enhancedDataEnabled;
        /// Optional element 'ns2:referralResponseNumber' of XML schema type 'xsd:string'
        std::string *referralResponseNumber;
        /// Optional element 'ns2:subResponseCode' of XML schema type 'xsd:string'
        std::string *subResponseCode;
        /// Optional element 'ns2:approvedAmount' of XML schema type 'xsd:string'
        std::string *approvedAmount;
        /// Optional element 'ns2:creditLine' of XML schema type 'xsd:string'
        std::string *creditLine;
        /// Optional element 'ns2:approvedTerms' of XML schema type 'xsd:string'
        std::string *approvedTerms;
        /// Optional element 'ns2:paymentNetworkTransactionID' of XML schema type 'xsd:string'
        std::string *paymentNetworkTransactionID;
        /// Optional element 'ns2:cardCategory' of XML schema type 'xsd:string'
        std::string *cardCategory;
        /// Optional element 'ns2:ownerMerchantID' of XML schema type 'xsd:string'
        std::string *ownerMerchantID;
        /// Optional element 'ns2:requestAmount' of XML schema type 'ns2:amount'
        std::string *requestAmount;
        /// Optional element 'ns2:requestCurrency' of XML schema type 'xsd:string'
        std::string *requestCurrency;
        /// Optional element 'ns2:accountBalanceCurrency' of XML schema type 'xsd:string'
        std::string *accountBalanceCurrency;
        /// Optional element 'ns2:accountBalanceSign' of XML schema type 'xsd:string'
        std::string *accountBalanceSign;
        /// Optional element 'ns2:amountType' of XML schema type 'xsd:string'
        std::string *amountType;
        /// Optional element 'ns2:accountType' of XML schema type 'xsd:string'
        std::string *accountType;
        /// Optional element 'ns2:affluenceIndicator' of XML schema type 'xsd:string'
        std::string *affluenceIndicator;
        /// Optional element 'ns2:evEmail' of XML schema type 'xsd:string'
        std::string *evEmail;
        /// Optional element 'ns2:evPhoneNumber' of XML schema type 'xsd:string'
        std::string *evPhoneNumber;
        /// Optional element 'ns2:evPostalCode' of XML schema type 'xsd:string'
        std::string *evPostalCode;
        /// Optional element 'ns2:evName' of XML schema type 'xsd:string'
        std::string *evName;
        /// Optional element 'ns2:evStreet' of XML schema type 'xsd:string'
        std::string *evStreet;
        /// Optional element 'ns2:evEmailRaw' of XML schema type 'xsd:string'
        std::string *evEmailRaw;
        /// Optional element 'ns2:evPhoneNumberRaw' of XML schema type 'xsd:string'
        std::string *evPhoneNumberRaw;
        /// Optional element 'ns2:evPostalCodeRaw' of XML schema type 'xsd:string'
        std::string *evPostalCodeRaw;
        /// Optional element 'ns2:evNameRaw' of XML schema type 'xsd:string'
        std::string *evNameRaw;
        /// Optional element 'ns2:evStreetRaw' of XML schema type 'xsd:string'
        std::string *evStreetRaw;
        /// Optional element 'ns2:cardGroup' of XML schema type 'xsd:string'
        std::string *cardGroup;
        /// Optional element 'ns2:posData' of XML schema type 'xsd:string'
        std::string *posData;
        /// Optional element 'ns2:transactionID' of XML schema type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:cardIssuerCountry' of XML schema type 'xsd:string'
        std::string *cardIssuerCountry;
        /// Optional element 'ns2:cardRegulated' of XML schema type 'xsd:string'
        std::string *cardRegulated;
        /// Optional element 'ns2:cardCommercial' of XML schema type 'xsd:string'
        std::string *cardCommercial;
        /// Optional element 'ns2:cardPrepaid' of XML schema type 'xsd:string'
        std::string *cardPrepaid;
        /// Optional element 'ns2:cardPayroll' of XML schema type 'xsd:string'
        std::string *cardPayroll;
        /// Optional element 'ns2:cardHealthcare' of XML schema type 'xsd:string'
        std::string *cardHealthcare;
        /// Optional element 'ns2:cardSignatureDebit' of XML schema type 'xsd:string'
        std::string *cardSignatureDebit;
        /// Optional element 'ns2:cardPINlessDebit' of XML schema type 'xsd:string'
        std::string *cardPINlessDebit;
        /// Optional element 'ns2:cardLevel3Eligible' of XML schema type 'xsd:string'
        std::string *cardLevel3Eligible;
        /// Optional element 'ns2:processorTransactionID' of XML schema type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:providerReasonCode' of XML schema type 'xsd:string'
        std::string *providerReasonCode;
        /// Optional element 'ns2:providerReasonDescription' of XML schema type 'xsd:string'
        std::string *providerReasonDescription;
        /// Optional element 'ns2:providerPassThroughData' of XML schema type 'xsd:string'
        std::string *providerPassThroughData;
        /// Optional element 'ns2:providerCVNResponseCode' of XML schema type 'xsd:string'
        std::string *providerCVNResponseCode;
        /// Optional element 'ns2:providerAVSResponseCode' of XML schema type 'xsd:string'
        std::string *providerAVSResponseCode;
        /// Optional element 'ns2:providerAcquirerBankCode' of XML schema type 'xsd:string'
        std::string *providerAcquirerBankCode;
        /// Optional element 'ns2:paymentCardService' of XML schema type 'xsd:string'
        std::string *paymentCardService;
        /// Optional element 'ns2:paymentCardServiceResult' of XML schema type 'xsd:string'
        std::string *paymentCardServiceResult;
        /// Optional element 'ns2:transactionQualification' of XML schema type 'xsd:string'
        std::string *transactionQualification;
        /// Optional element 'ns2:transactionIntegrity' of XML schema type 'xsd:string'
        std::string *transactionIntegrity;
        /// Optional element 'ns2:emsTransactionRiskScore' of XML schema type 'xsd:string'
        std::string *emsTransactionRiskScore;
        /// Optional element 'ns2:reconciliationReferenceNumber' of XML schema type 'xsd:string'
        std::string *reconciliationReferenceNumber;
        /// Optional element 'ns2:cardReferenceData' of XML schema type 'xsd:string'
        std::string *cardReferenceData;
        /// Optional element 'ns2:partialPANandIBAN' of XML schema type 'xsd:string'
        std::string *partialPANandIBAN;
        /// Optional element 'ns2:issuerPINrequest' of XML schema type 'xsd:string'
        std::string *issuerPINrequest;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCAuthReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCAuthReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCAuthReply, default initialized and not managed by a soap context
        virtual ns2__CCAuthReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCAuthReply); }
      public:
        /// Constructor with default initializations
        ns2__CCAuthReply() : reasonCode(), amount(), authorizationCode(), avsCode(), avsCodeRaw(), cvCode(), cvCodeRaw(), personalIDCode(), authorizedDateTime(), processorResponse(), bmlAccountNumber(), authFactorCode(), reconciliationID(), fundingTotals(), fxQuoteID(), fxQuoteRate(), fxQuoteType(), fxQuoteExpirationDateTime(), authRecord(), merchantAdviceCode(), merchantAdviceCodeRaw(), cavvResponseCode(), cavvResponseCodeRaw(), authenticationXID(), authorizationXID(), processorCardType(), accountBalance(), forwardCode(), enhancedDataEnabled(), referralResponseNumber(), subResponseCode(), approvedAmount(), creditLine(), approvedTerms(), paymentNetworkTransactionID(), cardCategory(), ownerMerchantID(), requestAmount(), requestCurrency(), accountBalanceCurrency(), accountBalanceSign(), amountType(), accountType(), affluenceIndicator(), evEmail(), evPhoneNumber(), evPostalCode(), evName(), evStreet(), evEmailRaw(), evPhoneNumberRaw(), evPostalCodeRaw(), evNameRaw(), evStreetRaw(), cardGroup(), posData(), transactionID(), cardIssuerCountry(), cardRegulated(), cardCommercial(), cardPrepaid(), cardPayroll(), cardHealthcare(), cardSignatureDebit(), cardPINlessDebit(), cardLevel3Eligible(), processorTransactionID(), providerReasonCode(), providerReasonDescription(), providerPassThroughData(), providerCVNResponseCode(), providerAVSResponseCode(), providerAcquirerBankCode(), paymentCardService(), paymentCardServiceResult(), transactionQualification(), transactionIntegrity(), emsTransactionRiskScore(), reconciliationReferenceNumber(), cardReferenceData(), partialPANandIBAN(), issuerPINrequest(), soap() { }
        virtual ~ns2__CCAuthReply() { }
        /// Friend allocator used by soap_new_ns2__CCAuthReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCAuthReply * SOAP_FMAC2 soap_instantiate_ns2__CCAuthReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:444 */
#ifndef SOAP_TYPE_ns2__OCTReply
#define SOAP_TYPE_ns2__OCTReply (417)
/* complex XML schema type 'ns2:OCTReply': */
class SOAP_CMAC ns2__OCTReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:approvalCode' of XML schema type 'xsd:string'
        std::string *approvalCode;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:paymentNetworkTransactionID' of XML schema type 'xsd:string'
        std::string *paymentNetworkTransactionID;
        /// Optional element 'ns2:prepaidBalanceCurrency' of XML schema type 'xsd:string'
        std::string *prepaidBalanceCurrency;
        /// Optional element 'ns2:prepaidBalanceAmount' of XML schema type 'xsd:string'
        std::string *prepaidBalanceAmount;
        /// Optional element 'ns2:processorResponseSource' of XML schema type 'xsd:string'
        std::string *processorResponseSource;
        /// Optional element 'ns2:reconciliationIdType' of XML schema type 'xsd:string'
        std::string *reconciliationIdType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OCTReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__OCTReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OCTReply, default initialized and not managed by a soap context
        virtual ns2__OCTReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__OCTReply); }
      public:
        /// Constructor with default initializations
        ns2__OCTReply() : reasonCode(), requestDateTime(), reconciliationID(), processorResponse(), approvalCode(), amount(), paymentNetworkTransactionID(), prepaidBalanceCurrency(), prepaidBalanceAmount(), processorResponseSource(), reconciliationIdType(), soap() { }
        virtual ~ns2__OCTReply() { }
        /// Friend allocator used by soap_new_ns2__OCTReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__OCTReply * SOAP_FMAC2 soap_instantiate_ns2__OCTReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:446 */
#ifndef SOAP_TYPE_ns2__VerificationReply
#define SOAP_TYPE_ns2__VerificationReply (418)
/* complex XML schema type 'ns2:VerificationReply': */
class SOAP_CMAC ns2__VerificationReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:processorTransactionID' of XML schema type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:verifiedDateTime' of XML schema type 'xsd:string'
        std::string *verifiedDateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VerificationReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__VerificationReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VerificationReply, default initialized and not managed by a soap context
        virtual ns2__VerificationReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__VerificationReply); }
      public:
        /// Constructor with default initializations
        ns2__VerificationReply() : reasonCode(), processorTransactionID(), processorResponse(), verifiedDateTime(), reconciliationID(), soap() { }
        virtual ~ns2__VerificationReply() { }
        /// Friend allocator used by soap_new_ns2__VerificationReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__VerificationReply * SOAP_FMAC2 soap_instantiate_ns2__VerificationReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:448 */
#ifndef SOAP_TYPE_ns2__CCSaleReply
#define SOAP_TYPE_ns2__CCSaleReply (419)
/* complex XML schema type 'ns2:CCSaleReply': */
class SOAP_CMAC ns2__CCSaleReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:authorizationCode' of XML schema type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:avsCode' of XML schema type 'xsd:string'
        std::string *avsCode;
        /// Optional element 'ns2:avsCodeRaw' of XML schema type 'xsd:string'
        std::string *avsCodeRaw;
        /// Optional element 'ns2:cvCode' of XML schema type 'xsd:string'
        std::string *cvCode;
        /// Optional element 'ns2:cvCodeRaw' of XML schema type 'xsd:string'
        std::string *cvCodeRaw;
        /// Optional element 'ns2:cavvResponseCode' of XML schema type 'xsd:string'
        std::string *cavvResponseCode;
        /// Optional element 'ns2:cavvResponseCodeRaw' of XML schema type 'xsd:string'
        std::string *cavvResponseCodeRaw;
        /// Optional element 'ns2:cardGroup' of XML schema type 'xsd:string'
        std::string *cardGroup;
        /// Optional element 'ns2:paymentNetworkTransactionID' of XML schema type 'xsd:string'
        std::string *paymentNetworkTransactionID;
        /// Optional element 'ns2:cardCategory' of XML schema type 'xsd:string'
        std::string *cardCategory;
        /// Optional element 'ns2:accountBalance' of XML schema type 'ns2:amount'
        std::string *accountBalance;
        /// Optional element 'ns2:authorizedDateTime' of XML schema type 'ns2:dateTime'
        std::string *authorizedDateTime;
        /// Optional element 'ns2:requestAmount' of XML schema type 'ns2:amount'
        std::string *requestAmount;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:accountBalanceCurrency' of XML schema type 'xsd:string'
        std::string *accountBalanceCurrency;
        /// Optional element 'ns2:accountBalanceSign' of XML schema type 'xsd:string'
        std::string *accountBalanceSign;
        /// Optional element 'ns2:cardReferenceData' of XML schema type 'xsd:string'
        std::string *cardReferenceData;
        /// Optional element 'ns2:partialPANandIBAN' of XML schema type 'xsd:string'
        std::string *partialPANandIBAN;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCSaleReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCSaleReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCSaleReply, default initialized and not managed by a soap context
        virtual ns2__CCSaleReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCSaleReply); }
      public:
        /// Constructor with default initializations
        ns2__CCSaleReply() : reasonCode(), amount(), authorizationCode(), processorResponse(), avsCode(), avsCodeRaw(), cvCode(), cvCodeRaw(), cavvResponseCode(), cavvResponseCodeRaw(), cardGroup(), paymentNetworkTransactionID(), cardCategory(), accountBalance(), authorizedDateTime(), requestAmount(), reconciliationID(), accountBalanceCurrency(), accountBalanceSign(), cardReferenceData(), partialPANandIBAN(), soap() { }
        virtual ~ns2__CCSaleReply() { }
        /// Friend allocator used by soap_new_ns2__CCSaleReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCSaleReply * SOAP_FMAC2 soap_instantiate_ns2__CCSaleReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:450 */
#ifndef SOAP_TYPE_ns2__CCSaleCreditReply
#define SOAP_TYPE_ns2__CCSaleCreditReply (420)
/* complex XML schema type 'ns2:CCSaleCreditReply': */
class SOAP_CMAC ns2__CCSaleCreditReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:authorizationCode' of XML schema type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:authorizedDateTime' of XML schema type 'ns2:dateTime'
        std::string *authorizedDateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:paymentNetworkTransactionID' of XML schema type 'xsd:string'
        std::string *paymentNetworkTransactionID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCSaleCreditReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCSaleCreditReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCSaleCreditReply, default initialized and not managed by a soap context
        virtual ns2__CCSaleCreditReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCSaleCreditReply); }
      public:
        /// Constructor with default initializations
        ns2__CCSaleCreditReply() : reasonCode(), amount(), authorizationCode(), processorResponse(), authorizedDateTime(), reconciliationID(), paymentNetworkTransactionID(), soap() { }
        virtual ~ns2__CCSaleCreditReply() { }
        /// Friend allocator used by soap_new_ns2__CCSaleCreditReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCSaleCreditReply * SOAP_FMAC2 soap_instantiate_ns2__CCSaleCreditReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:452 */
#ifndef SOAP_TYPE_ns2__CCSaleReversalReply
#define SOAP_TYPE_ns2__CCSaleReversalReply (421)
/* complex XML schema type 'ns2:CCSaleReversalReply': */
class SOAP_CMAC ns2__CCSaleReversalReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:authorizationCode' of XML schema type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCSaleReversalReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCSaleReversalReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCSaleReversalReply, default initialized and not managed by a soap context
        virtual ns2__CCSaleReversalReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCSaleReversalReply); }
      public:
        /// Constructor with default initializations
        ns2__CCSaleReversalReply() : reasonCode(), amount(), authorizationCode(), processorResponse(), reconciliationID(), requestDateTime(), soap() { }
        virtual ~ns2__CCSaleReversalReply() { }
        /// Friend allocator used by soap_new_ns2__CCSaleReversalReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCSaleReversalReply * SOAP_FMAC2 soap_instantiate_ns2__CCSaleReversalReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:454 */
#ifndef SOAP_TYPE_ns2__CCIncrementalAuthReply
#define SOAP_TYPE_ns2__CCIncrementalAuthReply (422)
/* complex XML schema type 'ns2:CCIncrementalAuthReply': */
class SOAP_CMAC ns2__CCIncrementalAuthReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:authorizationCode' of XML schema type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:authorizedDateTime' of XML schema type 'ns2:dateTime'
        std::string *authorizedDateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:paymentNetworkTransactionID' of XML schema type 'xsd:string'
        std::string *paymentNetworkTransactionID;
        /// Optional element 'ns2:cardCategory' of XML schema type 'xsd:string'
        std::string *cardCategory;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCIncrementalAuthReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCIncrementalAuthReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCIncrementalAuthReply, default initialized and not managed by a soap context
        virtual ns2__CCIncrementalAuthReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCIncrementalAuthReply); }
      public:
        /// Constructor with default initializations
        ns2__CCIncrementalAuthReply() : reasonCode(), amount(), authorizationCode(), processorResponse(), authorizedDateTime(), reconciliationID(), paymentNetworkTransactionID(), cardCategory(), soap() { }
        virtual ~ns2__CCIncrementalAuthReply() { }
        /// Friend allocator used by soap_new_ns2__CCIncrementalAuthReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCIncrementalAuthReply * SOAP_FMAC2 soap_instantiate_ns2__CCIncrementalAuthReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:456 */
#ifndef SOAP_TYPE_ns2__CCCaptureReply
#define SOAP_TYPE_ns2__CCCaptureReply (423)
/* complex XML schema type 'ns2:CCCaptureReply': */
class SOAP_CMAC ns2__CCCaptureReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:fundingTotals' of XML schema type 'ns2:FundingTotals'
        ns2__FundingTotals *fundingTotals;
        /// Optional element 'ns2:fxQuoteID' of XML schema type 'xsd:string'
        std::string *fxQuoteID;
        /// Optional element 'ns2:fxQuoteRate' of XML schema type 'ns2:dateTime'
        std::string *fxQuoteRate;
        /// Optional element 'ns2:fxQuoteType' of XML schema type 'xsd:string'
        std::string *fxQuoteType;
        /// Optional element 'ns2:fxQuoteExpirationDateTime' of XML schema type 'ns2:dateTime'
        std::string *fxQuoteExpirationDateTime;
        /// Optional element 'ns2:purchasingLevel3Enabled' of XML schema type 'xsd:string'
        std::string *purchasingLevel3Enabled;
        /// Optional element 'ns2:enhancedDataEnabled' of XML schema type 'xsd:string'
        std::string *enhancedDataEnabled;
        /// Optional element 'ns2:reconciliationReferenceNumber' of XML schema type 'xsd:string'
        std::string *reconciliationReferenceNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCCaptureReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCCaptureReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCCaptureReply, default initialized and not managed by a soap context
        virtual ns2__CCCaptureReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCCaptureReply); }
      public:
        /// Constructor with default initializations
        ns2__CCCaptureReply() : reasonCode(), requestDateTime(), amount(), reconciliationID(), fundingTotals(), fxQuoteID(), fxQuoteRate(), fxQuoteType(), fxQuoteExpirationDateTime(), purchasingLevel3Enabled(), enhancedDataEnabled(), reconciliationReferenceNumber(), soap() { }
        virtual ~ns2__CCCaptureReply() { }
        /// Friend allocator used by soap_new_ns2__CCCaptureReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCCaptureReply * SOAP_FMAC2 soap_instantiate_ns2__CCCaptureReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:458 */
#ifndef SOAP_TYPE_ns2__ServiceFeeCalculateReply
#define SOAP_TYPE_ns2__ServiceFeeCalculateReply (424)
/* complex XML schema type 'ns2:ServiceFeeCalculateReply': */
class SOAP_CMAC ns2__ServiceFeeCalculateReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ServiceFeeCalculateReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ServiceFeeCalculateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ServiceFeeCalculateReply, default initialized and not managed by a soap context
        virtual ns2__ServiceFeeCalculateReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ServiceFeeCalculateReply); }
      public:
        /// Constructor with default initializations
        ns2__ServiceFeeCalculateReply() : reasonCode(), amount(), requestDateTime(), soap() { }
        virtual ~ns2__ServiceFeeCalculateReply() { }
        /// Friend allocator used by soap_new_ns2__ServiceFeeCalculateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__ServiceFeeCalculateReply * SOAP_FMAC2 soap_instantiate_ns2__ServiceFeeCalculateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:460 */
#ifndef SOAP_TYPE_ns2__CCCreditReply
#define SOAP_TYPE_ns2__CCCreditReply (425)
/* complex XML schema type 'ns2:CCCreditReply': */
class SOAP_CMAC ns2__CCCreditReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:purchasingLevel3Enabled' of XML schema type 'xsd:string'
        std::string *purchasingLevel3Enabled;
        /// Optional element 'ns2:enhancedDataEnabled' of XML schema type 'xsd:string'
        std::string *enhancedDataEnabled;
        /// Optional element 'ns2:authorizationXID' of XML schema type 'xsd:string'
        std::string *authorizationXID;
        /// Optional element 'ns2:forwardCode' of XML schema type 'xsd:string'
        std::string *forwardCode;
        /// Optional element 'ns2:ownerMerchantID' of XML schema type 'xsd:string'
        std::string *ownerMerchantID;
        /// Optional element 'ns2:reconciliationReferenceNumber' of XML schema type 'xsd:string'
        std::string *reconciliationReferenceNumber;
        /// Optional element 'ns2:authorizationCode' of XML schema type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:paymentNetworkTransactionID' of XML schema type 'xsd:string'
        std::string *paymentNetworkTransactionID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCCreditReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCCreditReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCCreditReply, default initialized and not managed by a soap context
        virtual ns2__CCCreditReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCCreditReply); }
      public:
        /// Constructor with default initializations
        ns2__CCCreditReply() : reasonCode(), requestDateTime(), amount(), reconciliationID(), purchasingLevel3Enabled(), enhancedDataEnabled(), authorizationXID(), forwardCode(), ownerMerchantID(), reconciliationReferenceNumber(), authorizationCode(), processorResponse(), paymentNetworkTransactionID(), soap() { }
        virtual ~ns2__CCCreditReply() { }
        /// Friend allocator used by soap_new_ns2__CCCreditReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCCreditReply * SOAP_FMAC2 soap_instantiate_ns2__CCCreditReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:462 */
#ifndef SOAP_TYPE_ns2__PinDebitPurchaseReply
#define SOAP_TYPE_ns2__PinDebitPurchaseReply (426)
/* complex XML schema type 'ns2:PinDebitPurchaseReply': */
class SOAP_CMAC ns2__PinDebitPurchaseReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:authorizationCode' of XML schema type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:networkCode' of XML schema type 'xsd:string'
        std::string *networkCode;
        /// Optional element 'ns2:transactionID' of XML schema type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:requestAmount' of XML schema type 'ns2:amount'
        std::string *requestAmount;
        /// Optional element 'ns2:requestCurrency' of XML schema type 'xsd:string'
        std::string *requestCurrency;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:dateTime' of XML schema type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:accountType' of XML schema type 'xsd:string'
        std::string *accountType;
        /// Optional element 'ns2:amountType' of XML schema type 'xsd:string'
        std::string *amountType;
        /// Optional element 'ns2:accountBalance' of XML schema type 'xsd:string'
        std::string *accountBalance;
        /// Optional element 'ns2:accountBalanceCurrency' of XML schema type 'xsd:string'
        std::string *accountBalanceCurrency;
        /// Optional element 'ns2:accountBalanceSign' of XML schema type 'xsd:string'
        std::string *accountBalanceSign;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinDebitPurchaseReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PinDebitPurchaseReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinDebitPurchaseReply, default initialized and not managed by a soap context
        virtual ns2__PinDebitPurchaseReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PinDebitPurchaseReply); }
      public:
        /// Constructor with default initializations
        ns2__PinDebitPurchaseReply() : reasonCode(), processorResponse(), authorizationCode(), reconciliationID(), networkCode(), transactionID(), requestAmount(), requestCurrency(), amount(), dateTime(), accountType(), amountType(), accountBalance(), accountBalanceCurrency(), accountBalanceSign(), soap() { }
        virtual ~ns2__PinDebitPurchaseReply() { }
        /// Friend allocator used by soap_new_ns2__PinDebitPurchaseReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinDebitPurchaseReply * SOAP_FMAC2 soap_instantiate_ns2__PinDebitPurchaseReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:464 */
#ifndef SOAP_TYPE_ns2__PinDebitCreditReply
#define SOAP_TYPE_ns2__PinDebitCreditReply (427)
/* complex XML schema type 'ns2:PinDebitCreditReply': */
class SOAP_CMAC ns2__PinDebitCreditReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:authorizationCode' of XML schema type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:networkCode' of XML schema type 'xsd:string'
        std::string *networkCode;
        /// Optional element 'ns2:transactionID' of XML schema type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:dateTime' of XML schema type 'ns2:dateTime'
        std::string *dateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinDebitCreditReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PinDebitCreditReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinDebitCreditReply, default initialized and not managed by a soap context
        virtual ns2__PinDebitCreditReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PinDebitCreditReply); }
      public:
        /// Constructor with default initializations
        ns2__PinDebitCreditReply() : reasonCode(), processorResponse(), authorizationCode(), reconciliationID(), networkCode(), transactionID(), amount(), dateTime(), soap() { }
        virtual ~ns2__PinDebitCreditReply() { }
        /// Friend allocator used by soap_new_ns2__PinDebitCreditReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinDebitCreditReply * SOAP_FMAC2 soap_instantiate_ns2__PinDebitCreditReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:466 */
#ifndef SOAP_TYPE_ns2__PinDebitReversalReply
#define SOAP_TYPE_ns2__PinDebitReversalReply (428)
/* complex XML schema type 'ns2:PinDebitReversalReply': */
class SOAP_CMAC ns2__PinDebitReversalReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:dateTime' of XML schema type 'ns2:dateTime'
        std::string *dateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinDebitReversalReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PinDebitReversalReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinDebitReversalReply, default initialized and not managed by a soap context
        virtual ns2__PinDebitReversalReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PinDebitReversalReply); }
      public:
        /// Constructor with default initializations
        ns2__PinDebitReversalReply() : reasonCode(), processorResponse(), reconciliationID(), amount(), dateTime(), soap() { }
        virtual ~ns2__PinDebitReversalReply() { }
        /// Friend allocator used by soap_new_ns2__PinDebitReversalReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinDebitReversalReply * SOAP_FMAC2 soap_instantiate_ns2__PinDebitReversalReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:468 */
#ifndef SOAP_TYPE_ns2__CCAuthReversalReply
#define SOAP_TYPE_ns2__CCAuthReversalReply (429)
/* complex XML schema type 'ns2:CCAuthReversalReply': */
class SOAP_CMAC ns2__CCAuthReversalReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:authorizationCode' of XML schema type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:forwardCode' of XML schema type 'xsd:string'
        std::string *forwardCode;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorTransactionID' of XML schema type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:paymentCardService' of XML schema type 'xsd:string'
        std::string *paymentCardService;
        /// Optional element 'ns2:paymentCardServiceResult' of XML schema type 'xsd:string'
        std::string *paymentCardServiceResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCAuthReversalReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCAuthReversalReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCAuthReversalReply, default initialized and not managed by a soap context
        virtual ns2__CCAuthReversalReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCAuthReversalReply); }
      public:
        /// Constructor with default initializations
        ns2__CCAuthReversalReply() : reasonCode(), amount(), authorizationCode(), processorResponse(), requestDateTime(), forwardCode(), reconciliationID(), processorTransactionID(), paymentCardService(), paymentCardServiceResult(), soap() { }
        virtual ~ns2__CCAuthReversalReply() { }
        /// Friend allocator used by soap_new_ns2__CCAuthReversalReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCAuthReversalReply * SOAP_FMAC2 soap_instantiate_ns2__CCAuthReversalReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:470 */
#ifndef SOAP_TYPE_ns2__CCAutoAuthReversalReply
#define SOAP_TYPE_ns2__CCAutoAuthReversalReply (430)
/* complex XML schema type 'ns2:CCAutoAuthReversalReply': */
class SOAP_CMAC ns2__CCAutoAuthReversalReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:result' of XML schema type 'xsd:string'
        std::string *result;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCAutoAuthReversalReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCAutoAuthReversalReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCAutoAuthReversalReply, default initialized and not managed by a soap context
        virtual ns2__CCAutoAuthReversalReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCAutoAuthReversalReply); }
      public:
        /// Constructor with default initializations
        ns2__CCAutoAuthReversalReply() : reasonCode(), processorResponse(), result(), soap() { }
        virtual ~ns2__CCAutoAuthReversalReply() { }
        /// Friend allocator used by soap_new_ns2__CCAutoAuthReversalReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCAutoAuthReversalReply * SOAP_FMAC2 soap_instantiate_ns2__CCAutoAuthReversalReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:472 */
#ifndef SOAP_TYPE_ns2__ECAVSReply
#define SOAP_TYPE_ns2__ECAVSReply (431)
/* complex XML schema type 'ns2:ECAVSReply': */
class SOAP_CMAC ns2__ECAVSReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:validationType' of XML schema type 'xsd:string'
        std::string *validationType;
        /// Optional element 'ns2:primaryStatusCode' of XML schema type 'xsd:string'
        std::string *primaryStatusCode;
        /// Optional element 'ns2:secondaryStatusCode' of XML schema type 'xsd:string'
        std::string *secondaryStatusCode;
        /// Optional element 'ns2:additionalStatusCode' of XML schema type 'xsd:string'
        std::string *additionalStatusCode;
        /// Optional element 'ns2:numberOfReturns' of XML schema type 'xsd:string'
        std::string *numberOfReturns;
        /// Optional element 'ns2:lastReturnDate' of XML schema type 'xsd:string'
        std::string *lastReturnDate;
        /// Optional element 'ns2:lastReturnProcessorResponse' of XML schema type 'xsd:string'
        std::string *lastReturnProcessorResponse;
        /// Optional element 'ns2:lastUpdateDate' of XML schema type 'xsd:string'
        std::string *lastUpdateDate;
        /// Optional element 'ns2:addedOrClosedDate' of XML schema type 'xsd:string'
        std::string *addedOrClosedDate;
        /// Optional element 'ns2:previousStatusCode' of XML schema type 'xsd:string'
        std::string *previousStatusCode;
        /// Optional element 'ns2:fcraDisputeCode' of XML schema type 'xsd:string'
        std::string *fcraDisputeCode;
        /// Optional element 'ns2:scoredAccountProcessorResponse1' of XML schema type 'xsd:string'
        std::string *scoredAccountProcessorResponse1;
        /// Optional element 'ns2:scoredAccountProcessorResponse2' of XML schema type 'xsd:string'
        std::string *scoredAccountProcessorResponse2;
        /// Optional element 'ns2:scoredAccountProcessorResponse3' of XML schema type 'xsd:string'
        std::string *scoredAccountProcessorResponse3;
        /// Optional element 'ns2:scoredAccountProcessorResponse5' of XML schema type 'xsd:string'
        std::string *scoredAccountProcessorResponse5;
        /// Optional element 'ns2:customerDataConditionCode' of XML schema type 'xsd:string'
        std::string *customerDataConditionCode;
        /// Optional element 'ns2:matchBillToFullName' of XML schema type 'xsd:string'
        std::string *matchBillToFullName;
        /// Optional element 'ns2:matchBillToPrefix' of XML schema type 'xsd:string'
        std::string *matchBillToPrefix;
        /// Optional element 'ns2:matchBillToFirstName' of XML schema type 'xsd:string'
        std::string *matchBillToFirstName;
        /// Optional element 'ns2:matchBillToMiddleName' of XML schema type 'xsd:string'
        std::string *matchBillToMiddleName;
        /// Optional element 'ns2:matchBillToLastName' of XML schema type 'xsd:string'
        std::string *matchBillToLastName;
        /// Optional element 'ns2:matchBillToSuffix' of XML schema type 'xsd:string'
        std::string *matchBillToSuffix;
        /// Optional element 'ns2:matchBillToCompany' of XML schema type 'xsd:string'
        std::string *matchBillToCompany;
        /// Optional element 'ns2:matchBillToAddress' of XML schema type 'xsd:string'
        std::string *matchBillToAddress;
        /// Optional element 'ns2:matchBillToCity' of XML schema type 'xsd:string'
        std::string *matchBillToCity;
        /// Optional element 'ns2:matchBillToState' of XML schema type 'xsd:string'
        std::string *matchBillToState;
        /// Optional element 'ns2:matchBillToPostalCode' of XML schema type 'xsd:string'
        std::string *matchBillToPostalCode;
        /// Optional element 'ns2:matchBillToPhoneNumber' of XML schema type 'xsd:string'
        std::string *matchBillToPhoneNumber;
        /// Optional element 'ns2:matchBillToCompanyPhoneNumber' of XML schema type 'xsd:string'
        std::string *matchBillToCompanyPhoneNumber;
        /// Optional element 'ns2:matchBillToCompanyTaxID' of XML schema type 'xsd:string'
        std::string *matchBillToCompanyTaxID;
        /// Optional element 'ns2:matchBillToSSN' of XML schema type 'xsd:string'
        std::string *matchBillToSSN;
        /// Optional element 'ns2:matchBillToDateOfBirth' of XML schema type 'xsd:string'
        std::string *matchBillToDateOfBirth;
        /// Optional element 'ns2:matchPersonalIDType' of XML schema type 'xsd:string'
        std::string *matchPersonalIDType;
        /// Optional element 'ns2:matchPersonalID' of XML schema type 'xsd:string'
        std::string *matchPersonalID;
        /// Optional element 'ns2:matchPersonalIDIssuedBy' of XML schema type 'xsd:string'
        std::string *matchPersonalIDIssuedBy;
        /// Optional element 'ns2:overallMatchScore' of XML schema type 'xsd:integer'
        std::string *overallMatchScore;
        /// Optional element 'ns2:calculatedResponse' of XML schema type 'xsd:string'
        std::string *calculatedResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ECAVSReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ECAVSReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ECAVSReply, default initialized and not managed by a soap context
        virtual ns2__ECAVSReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ECAVSReply); }
      public:
        /// Constructor with default initializations
        ns2__ECAVSReply() : reasonCode(), validationType(), primaryStatusCode(), secondaryStatusCode(), additionalStatusCode(), numberOfReturns(), lastReturnDate(), lastReturnProcessorResponse(), lastUpdateDate(), addedOrClosedDate(), previousStatusCode(), fcraDisputeCode(), scoredAccountProcessorResponse1(), scoredAccountProcessorResponse2(), scoredAccountProcessorResponse3(), scoredAccountProcessorResponse5(), customerDataConditionCode(), matchBillToFullName(), matchBillToPrefix(), matchBillToFirstName(), matchBillToMiddleName(), matchBillToLastName(), matchBillToSuffix(), matchBillToCompany(), matchBillToAddress(), matchBillToCity(), matchBillToState(), matchBillToPostalCode(), matchBillToPhoneNumber(), matchBillToCompanyPhoneNumber(), matchBillToCompanyTaxID(), matchBillToSSN(), matchBillToDateOfBirth(), matchPersonalIDType(), matchPersonalID(), matchPersonalIDIssuedBy(), overallMatchScore(), calculatedResponse(), soap() { }
        virtual ~ns2__ECAVSReply() { }
        /// Friend allocator used by soap_new_ns2__ECAVSReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__ECAVSReply * SOAP_FMAC2 soap_instantiate_ns2__ECAVSReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:474 */
#ifndef SOAP_TYPE_ns2__ECDebitReply
#define SOAP_TYPE_ns2__ECDebitReply (432)
/* complex XML schema type 'ns2:ECDebitReply': */
class SOAP_CMAC ns2__ECDebitReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:settlementMethod' of XML schema type 'xsd:string'
        std::string *settlementMethod;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:verificationLevel' of XML schema type 'xsd:integer'
        std::string *verificationLevel;
        /// Optional element 'ns2:processorTransactionID' of XML schema type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:avsCode' of XML schema type 'xsd:string'
        std::string *avsCode;
        /// Optional element 'ns2:avsCodeRaw' of XML schema type 'xsd:string'
        std::string *avsCodeRaw;
        /// Optional element 'ns2:verificationCode' of XML schema type 'xsd:string'
        std::string *verificationCode;
        /// Optional element 'ns2:verificationCodeRaw' of XML schema type 'xsd:string'
        std::string *verificationCodeRaw;
        /// Optional element 'ns2:correctedAccountNumber' of XML schema type 'xsd:string'
        std::string *correctedAccountNumber;
        /// Optional element 'ns2:correctedRoutingNumber' of XML schema type 'xsd:string'
        std::string *correctedRoutingNumber;
        /// Optional element 'ns2:ownerMerchantID' of XML schema type 'xsd:string'
        std::string *ownerMerchantID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ECDebitReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ECDebitReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ECDebitReply, default initialized and not managed by a soap context
        virtual ns2__ECDebitReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ECDebitReply); }
      public:
        /// Constructor with default initializations
        ns2__ECDebitReply() : reasonCode(), settlementMethod(), requestDateTime(), amount(), verificationLevel(), processorTransactionID(), reconciliationID(), processorResponse(), avsCode(), avsCodeRaw(), verificationCode(), verificationCodeRaw(), correctedAccountNumber(), correctedRoutingNumber(), ownerMerchantID(), soap() { }
        virtual ~ns2__ECDebitReply() { }
        /// Friend allocator used by soap_new_ns2__ECDebitReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__ECDebitReply * SOAP_FMAC2 soap_instantiate_ns2__ECDebitReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:476 */
#ifndef SOAP_TYPE_ns2__ECCreditReply
#define SOAP_TYPE_ns2__ECCreditReply (433)
/* complex XML schema type 'ns2:ECCreditReply': */
class SOAP_CMAC ns2__ECCreditReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:settlementMethod' of XML schema type 'xsd:string'
        std::string *settlementMethod;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:processorTransactionID' of XML schema type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:verificationCode' of XML schema type 'xsd:string'
        std::string *verificationCode;
        /// Optional element 'ns2:verificationCodeRaw' of XML schema type 'xsd:string'
        std::string *verificationCodeRaw;
        /// Optional element 'ns2:correctedAccountNumber' of XML schema type 'xsd:string'
        std::string *correctedAccountNumber;
        /// Optional element 'ns2:correctedRoutingNumber' of XML schema type 'xsd:string'
        std::string *correctedRoutingNumber;
        /// Optional element 'ns2:ownerMerchantID' of XML schema type 'xsd:string'
        std::string *ownerMerchantID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ECCreditReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ECCreditReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ECCreditReply, default initialized and not managed by a soap context
        virtual ns2__ECCreditReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ECCreditReply); }
      public:
        /// Constructor with default initializations
        ns2__ECCreditReply() : reasonCode(), settlementMethod(), requestDateTime(), amount(), processorTransactionID(), reconciliationID(), processorResponse(), verificationCode(), verificationCodeRaw(), correctedAccountNumber(), correctedRoutingNumber(), ownerMerchantID(), soap() { }
        virtual ~ns2__ECCreditReply() { }
        /// Friend allocator used by soap_new_ns2__ECCreditReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__ECCreditReply * SOAP_FMAC2 soap_instantiate_ns2__ECCreditReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:478 */
#ifndef SOAP_TYPE_ns2__ECAuthenticateReply
#define SOAP_TYPE_ns2__ECAuthenticateReply (434)
/* complex XML schema type 'ns2:ECAuthenticateReply': */
class SOAP_CMAC ns2__ECAuthenticateReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:checkpointSummary' of XML schema type 'xsd:string'
        std::string *checkpointSummary;
        /// Optional element 'ns2:fraudShieldIndicators' of XML schema type 'xsd:string'
        std::string *fraudShieldIndicators;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ECAuthenticateReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ECAuthenticateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ECAuthenticateReply, default initialized and not managed by a soap context
        virtual ns2__ECAuthenticateReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ECAuthenticateReply); }
      public:
        /// Constructor with default initializations
        ns2__ECAuthenticateReply() : reasonCode(), requestDateTime(), processorResponse(), reconciliationID(), checkpointSummary(), fraudShieldIndicators(), soap() { }
        virtual ~ns2__ECAuthenticateReply() { }
        /// Friend allocator used by soap_new_ns2__ECAuthenticateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__ECAuthenticateReply * SOAP_FMAC2 soap_instantiate_ns2__ECAuthenticateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:480 */
#ifndef SOAP_TYPE_ns2__PayerAuthSetupReply
#define SOAP_TYPE_ns2__PayerAuthSetupReply (435)
/* complex XML schema type 'ns2:PayerAuthSetupReply': */
class SOAP_CMAC ns2__PayerAuthSetupReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:referenceID' of XML schema type 'xsd:string'
        std::string *referenceID;
        /// Optional element 'ns2:deviceDataCollectionURL' of XML schema type 'xsd:string'
        std::string *deviceDataCollectionURL;
        /// Optional element 'ns2:accessToken' of XML schema type 'xsd:string'
        std::string *accessToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayerAuthSetupReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayerAuthSetupReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayerAuthSetupReply, default initialized and not managed by a soap context
        virtual ns2__PayerAuthSetupReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayerAuthSetupReply); }
      public:
        /// Constructor with default initializations
        ns2__PayerAuthSetupReply() : reasonCode(), referenceID(), deviceDataCollectionURL(), accessToken(), soap() { }
        virtual ~ns2__PayerAuthSetupReply() { }
        /// Friend allocator used by soap_new_ns2__PayerAuthSetupReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayerAuthSetupReply * SOAP_FMAC2 soap_instantiate_ns2__PayerAuthSetupReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:482 */
#ifndef SOAP_TYPE_ns2__PayerAuthEnrollReply
#define SOAP_TYPE_ns2__PayerAuthEnrollReply (436)
/* complex XML schema type 'ns2:PayerAuthEnrollReply': */
class SOAP_CMAC ns2__PayerAuthEnrollReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:acsURL' of XML schema type 'xsd:string'
        std::string *acsURL;
        /// Optional element 'ns2:accessToken' of XML schema type 'xsd:string'
        std::string *accessToken;
        /// Optional element 'ns2:authenticationResult' of XML schema type 'xsd:string'
        std::string *authenticationResult;
        /// Optional element 'ns2:authenticationStatusMessage' of XML schema type 'xsd:string'
        std::string *authenticationStatusMessage;
        /// Optional element 'ns2:cavv' of XML schema type 'xsd:string'
        std::string *cavv;
        /// Optional element 'ns2:cavvAlgorithm' of XML schema type 'xsd:string'
        std::string *cavvAlgorithm;
        /// Optional element 'ns2:commerceIndicator' of XML schema type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:eci' of XML schema type 'xsd:string'
        std::string *eci;
        /// Optional element 'ns2:eciRaw' of XML schema type 'xsd:string'
        std::string *eciRaw;
        /// Optional element 'ns2:paReq' of XML schema type 'xsd:string'
        std::string *paReq;
        /// Optional element 'ns2:proxyPAN' of XML schema type 'xsd:string'
        std::string *proxyPAN;
        /// Optional element 'ns2:xid' of XML schema type 'xsd:string'
        std::string *xid;
        /// Optional element 'ns2:proofXML' of XML schema type 'xsd:string'
        std::string *proofXML;
        /// Optional element 'ns2:ucafAuthenticationData' of XML schema type 'xsd:string'
        std::string *ucafAuthenticationData;
        /// Optional element 'ns2:ucafCollectionIndicator' of XML schema type 'xsd:string'
        std::string *ucafCollectionIndicator;
        /// Optional element 'ns2:paresStatus' of XML schema type 'xsd:string'
        std::string *paresStatus;
        /// Optional element 'ns2:veresEnrolled' of XML schema type 'xsd:string'
        std::string *veresEnrolled;
        /// Optional element 'ns2:authenticationPath' of XML schema type 'xsd:string'
        std::string *authenticationPath;
        /// Optional element 'ns2:specificationVersion' of XML schema type 'xsd:string'
        std::string *specificationVersion;
        /// Optional element 'ns2:authenticationTransactionID' of XML schema type 'xsd:string'
        std::string *authenticationTransactionID;
        /// Optional element 'ns2:directoryServerTransactionID' of XML schema type 'xsd:string'
        std::string *directoryServerTransactionID;
        /// Optional element 'ns2:challengeRequired' of XML schema type 'ns2:boolean'
        std::string *challengeRequired;
        /// Optional element 'ns2:threeDSServerTransactionID' of XML schema type 'xsd:string'
        std::string *threeDSServerTransactionID;
        /// Optional element 'ns2:acsRenderingType' of XML schema type 'xsd:string'
        std::string *acsRenderingType;
        /// Optional element 'ns2:acsTransactionID' of XML schema type 'xsd:string'
        std::string *acsTransactionID;
        /// Optional element 'ns2:authenticationType' of XML schema type 'xsd:integer'
        std::string *authenticationType;
        /// Optional element 'ns2:cardholderMessage' of XML schema type 'xsd:string'
        std::string *cardholderMessage;
        /// Optional element 'ns2:directoryServerErrorCode' of XML schema type 'xsd:integer'
        std::string *directoryServerErrorCode;
        /// Optional element 'ns2:directoryServerErrorDescription' of XML schema type 'xsd:string'
        std::string *directoryServerErrorDescription;
        /// Optional element 'ns2:ivrEnabledMessage' of XML schema type 'ns2:boolean'
        std::string *ivrEnabledMessage;
        /// Optional element 'ns2:ivrEncryptionKey' of XML schema type 'xsd:string'
        std::string *ivrEncryptionKey;
        /// Optional element 'ns2:ivrEncryptionMandatory' of XML schema type 'ns2:boolean'
        std::string *ivrEncryptionMandatory;
        /// Optional element 'ns2:ivrEncryptionType' of XML schema type 'xsd:string'
        std::string *ivrEncryptionType;
        /// Optional element 'ns2:ivrLabel' of XML schema type 'xsd:string'
        std::string *ivrLabel;
        /// Optional element 'ns2:ivrPrompt' of XML schema type 'xsd:string'
        std::string *ivrPrompt;
        /// Optional element 'ns2:ivrStatusMessage' of XML schema type 'xsd:string'
        std::string *ivrStatusMessage;
        /// Optional element 'ns2:sdkTransactionID' of XML schema type 'xsd:string'
        std::string *sdkTransactionID;
        /// Optional element 'ns2:stepUpUrl' of XML schema type 'xsd:string'
        std::string *stepUpUrl;
        /// Optional element 'ns2:whiteListStatus' of XML schema type 'xsd:string'
        std::string *whiteListStatus;
        /// Optional element 'ns2:whiteListStatusSource' of XML schema type 'xsd:integer'
        std::string *whiteListStatusSource;
        /// Optional element 'ns2:effectiveAuthenticationType' of XML schema type 'xsd:string'
        std::string *effectiveAuthenticationType;
        /// Optional element 'ns2:authenticationStatusReason' of XML schema type 'xsd:string'
        std::string *authenticationStatusReason;
        /// Optional element 'ns2:networkScore' of XML schema type 'xsd:string'
        std::string *networkScore;
        /// Optional element 'ns2:authorizationPayload' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary *authorizationPayload;
        /// Optional element 'ns2:challengeCancelCode' of XML schema type 'xsd:string'
        std::string *challengeCancelCode;
        /// Optional element 'ns2:decoupledAuthenticationIndicator' of XML schema type 'xsd:string'
        std::string *decoupledAuthenticationIndicator;
        /// Optional element 'ns2:cardBin' of XML schema type 'xsd:string'
        std::string *cardBin;
        /// Optional element 'ns2:cardTypeName' of XML schema type 'xsd:string'
        std::string *cardTypeName;
        /// Optional element 'ns2:transactionIndicator' of XML schema type 'xsd:string'
        std::string *transactionIndicator;
        /// Optional element 'ns2:resendCountRemaining' of XML schema type 'xsd:string'
        std::string *resendCountRemaining;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayerAuthEnrollReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayerAuthEnrollReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayerAuthEnrollReply, default initialized and not managed by a soap context
        virtual ns2__PayerAuthEnrollReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayerAuthEnrollReply); }
      public:
        /// Constructor with default initializations
        ns2__PayerAuthEnrollReply() : reasonCode(), acsURL(), accessToken(), authenticationResult(), authenticationStatusMessage(), cavv(), cavvAlgorithm(), commerceIndicator(), eci(), eciRaw(), paReq(), proxyPAN(), xid(), proofXML(), ucafAuthenticationData(), ucafCollectionIndicator(), paresStatus(), veresEnrolled(), authenticationPath(), specificationVersion(), authenticationTransactionID(), directoryServerTransactionID(), challengeRequired(), threeDSServerTransactionID(), acsRenderingType(), acsTransactionID(), authenticationType(), cardholderMessage(), directoryServerErrorCode(), directoryServerErrorDescription(), ivrEnabledMessage(), ivrEncryptionKey(), ivrEncryptionMandatory(), ivrEncryptionType(), ivrLabel(), ivrPrompt(), ivrStatusMessage(), sdkTransactionID(), stepUpUrl(), whiteListStatus(), whiteListStatusSource(), effectiveAuthenticationType(), authenticationStatusReason(), networkScore(), authorizationPayload(), challengeCancelCode(), decoupledAuthenticationIndicator(), cardBin(), cardTypeName(), transactionIndicator(), resendCountRemaining(), soap() { }
        virtual ~ns2__PayerAuthEnrollReply() { }
        /// Friend allocator used by soap_new_ns2__PayerAuthEnrollReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayerAuthEnrollReply * SOAP_FMAC2 soap_instantiate_ns2__PayerAuthEnrollReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:484 */
#ifndef SOAP_TYPE_ns2__PayerAuthValidateReply
#define SOAP_TYPE_ns2__PayerAuthValidateReply (437)
/* complex XML schema type 'ns2:PayerAuthValidateReply': */
class SOAP_CMAC ns2__PayerAuthValidateReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:authenticationResult' of XML schema type 'xsd:string'
        std::string *authenticationResult;
        /// Optional element 'ns2:authenticationStatusMessage' of XML schema type 'xsd:string'
        std::string *authenticationStatusMessage;
        /// Optional element 'ns2:cavv' of XML schema type 'xsd:string'
        std::string *cavv;
        /// Optional element 'ns2:cavvAlgorithm' of XML schema type 'xsd:string'
        std::string *cavvAlgorithm;
        /// Optional element 'ns2:commerceIndicator' of XML schema type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:eci' of XML schema type 'xsd:string'
        std::string *eci;
        /// Optional element 'ns2:eciRaw' of XML schema type 'xsd:string'
        std::string *eciRaw;
        /// Optional element 'ns2:xid' of XML schema type 'xsd:string'
        std::string *xid;
        /// Optional element 'ns2:ucafAuthenticationData' of XML schema type 'xsd:string'
        std::string *ucafAuthenticationData;
        /// Optional element 'ns2:ucafCollectionIndicator' of XML schema type 'xsd:string'
        std::string *ucafCollectionIndicator;
        /// Optional element 'ns2:paresStatus' of XML schema type 'xsd:string'
        std::string *paresStatus;
        /// Optional element 'ns2:specificationVersion' of XML schema type 'xsd:string'
        std::string *specificationVersion;
        /// Optional element 'ns2:directoryServerTransactionID' of XML schema type 'xsd:string'
        std::string *directoryServerTransactionID;
        /// Optional element 'ns2:threeDSServerTransactionID' of XML schema type 'xsd:string'
        std::string *threeDSServerTransactionID;
        /// Optional element 'ns2:acsRenderingType' of XML schema type 'xsd:string'
        std::string *acsRenderingType;
        /// Optional element 'ns2:acsTransactionID' of XML schema type 'xsd:string'
        std::string *acsTransactionID;
        /// Optional element 'ns2:authenticationType' of XML schema type 'xsd:integer'
        std::string *authenticationType;
        /// Optional element 'ns2:directoryServerErrorCode' of XML schema type 'xsd:integer'
        std::string *directoryServerErrorCode;
        /// Optional element 'ns2:directoryServerErrorDescription' of XML schema type 'xsd:string'
        std::string *directoryServerErrorDescription;
        /// Optional element 'ns2:interactionCounter' of XML schema type 'xsd:integer'
        std::string *interactionCounter;
        /// Optional element 'ns2:sdkTransactionID' of XML schema type 'xsd:string'
        std::string *sdkTransactionID;
        /// Optional element 'ns2:whiteListStatus' of XML schema type 'xsd:string'
        std::string *whiteListStatus;
        /// Optional element 'ns2:whiteListStatusSource' of XML schema type 'xsd:integer'
        std::string *whiteListStatusSource;
        /// Optional element 'ns2:effectiveAuthenticationType' of XML schema type 'xsd:string'
        std::string *effectiveAuthenticationType;
        /// Optional element 'ns2:authenticationStatusReason' of XML schema type 'xsd:string'
        std::string *authenticationStatusReason;
        /// Optional element 'ns2:challengeCancelCode' of XML schema type 'xsd:string'
        std::string *challengeCancelCode;
        /// Optional element 'ns2:authorizationPayload' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary *authorizationPayload;
        /// Optional element 'ns2:cardBin' of XML schema type 'xsd:string'
        std::string *cardBin;
        /// Optional element 'ns2:cardTypeName' of XML schema type 'xsd:string'
        std::string *cardTypeName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayerAuthValidateReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayerAuthValidateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayerAuthValidateReply, default initialized and not managed by a soap context
        virtual ns2__PayerAuthValidateReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayerAuthValidateReply); }
      public:
        /// Constructor with default initializations
        ns2__PayerAuthValidateReply() : reasonCode(), authenticationResult(), authenticationStatusMessage(), cavv(), cavvAlgorithm(), commerceIndicator(), eci(), eciRaw(), xid(), ucafAuthenticationData(), ucafCollectionIndicator(), paresStatus(), specificationVersion(), directoryServerTransactionID(), threeDSServerTransactionID(), acsRenderingType(), acsTransactionID(), authenticationType(), directoryServerErrorCode(), directoryServerErrorDescription(), interactionCounter(), sdkTransactionID(), whiteListStatus(), whiteListStatusSource(), effectiveAuthenticationType(), authenticationStatusReason(), challengeCancelCode(), authorizationPayload(), cardBin(), cardTypeName(), soap() { }
        virtual ~ns2__PayerAuthValidateReply() { }
        /// Friend allocator used by soap_new_ns2__PayerAuthValidateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayerAuthValidateReply * SOAP_FMAC2 soap_instantiate_ns2__PayerAuthValidateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:486 */
#ifndef SOAP_TYPE_ns2__TaxReplyItem
#define SOAP_TYPE_ns2__TaxReplyItem (438)
/* complex XML schema type 'ns2:TaxReplyItem': */
class SOAP_CMAC ns2__TaxReplyItem {
      public:
        /// Optional element 'ns2:taxableAmount' of XML schema type 'ns2:amount'
        std::string *taxableAmount;
        /// Optional element 'ns2:exemptAmount' of XML schema type 'ns2:amount'
        std::string *exemptAmount;
        /// Optional element 'ns2:specialTaxAmount' of XML schema type 'ns2:amount'
        std::string *specialTaxAmount;
        /// Optional element 'ns2:cityTaxAmount' of XML schema type 'ns2:amount'
        std::string *cityTaxAmount;
        /// Optional element 'ns2:countyTaxAmount' of XML schema type 'ns2:amount'
        std::string *countyTaxAmount;
        /// Optional element 'ns2:districtTaxAmount' of XML schema type 'ns2:amount'
        std::string *districtTaxAmount;
        /// Optional element 'ns2:stateTaxAmount' of XML schema type 'ns2:amount'
        std::string *stateTaxAmount;
        /// Optional element 'ns2:countryTaxAmount' of XML schema type 'ns2:amount'
        std::string *countryTaxAmount;
        /// Required element 'ns2:totalTaxAmount' of XML schema type 'ns2:amount'
        std::string totalTaxAmount;
        /// Sequence of 0 to 1000 elements 'ns2:jurisdiction' of XML schema type 'ns2:TaxReplyItemJurisdiction'
        std::vector<ns2__TaxReplyItemJurisdiction> jurisdiction;
        /// Required attribute 'id' of XML schema type 'xsd:integer'
        std::string id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__TaxReplyItem
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__TaxReplyItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__TaxReplyItem, default initialized and not managed by a soap context
        virtual ns2__TaxReplyItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__TaxReplyItem); }
      public:
        /// Constructor with default initializations
        ns2__TaxReplyItem() : taxableAmount(), exemptAmount(), specialTaxAmount(), cityTaxAmount(), countyTaxAmount(), districtTaxAmount(), stateTaxAmount(), countryTaxAmount(), totalTaxAmount(), jurisdiction(), id(), soap() { }
        virtual ~ns2__TaxReplyItem() { }
        /// Friend allocator used by soap_new_ns2__TaxReplyItem(struct soap*, int)
        friend SOAP_FMAC1 ns2__TaxReplyItem * SOAP_FMAC2 soap_instantiate_ns2__TaxReplyItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:488 */
#ifndef SOAP_TYPE_ns2__TaxReplyItemJurisdiction
#define SOAP_TYPE_ns2__TaxReplyItemJurisdiction (439)
/* complex XML schema type 'ns2:TaxReplyItemJurisdiction': */
class SOAP_CMAC ns2__TaxReplyItemJurisdiction {
      public:
        /// Optional element 'ns2:country' of XML schema type 'xsd:string'
        std::string *country;
        /// Optional element 'ns2:region' of XML schema type 'xsd:string'
        std::string *region;
        /// Optional element 'ns2:type' of XML schema type 'xsd:string'
        std::string *type;
        /// Optional element 'ns2:code' of XML schema type 'xsd:string'
        std::string *code;
        /// Optional element 'ns2:taxable' of XML schema type 'ns2:amount'
        std::string *taxable;
        /// Optional element 'ns2:rate' of XML schema type 'ns2:amount'
        std::string *rate;
        /// Optional element 'ns2:taxAmount' of XML schema type 'ns2:amount'
        std::string *taxAmount;
        /// Required element 'ns2:name' of XML schema type 'xsd:string'
        std::string name;
        /// Required element 'ns2:taxName' of XML schema type 'xsd:string'
        std::string taxName;
        /// Required attribute 'jurisId' of XML schema type 'xsd:integer'
        std::string jurisId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__TaxReplyItemJurisdiction
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__TaxReplyItemJurisdiction; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__TaxReplyItemJurisdiction, default initialized and not managed by a soap context
        virtual ns2__TaxReplyItemJurisdiction *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__TaxReplyItemJurisdiction); }
      public:
        /// Constructor with default initializations
        ns2__TaxReplyItemJurisdiction() : country(), region(), type(), code(), taxable(), rate(), taxAmount(), name(), taxName(), jurisId(), soap() { }
        virtual ~ns2__TaxReplyItemJurisdiction() { }
        /// Friend allocator used by soap_new_ns2__TaxReplyItemJurisdiction(struct soap*, int)
        friend SOAP_FMAC1 ns2__TaxReplyItemJurisdiction * SOAP_FMAC2 soap_instantiate_ns2__TaxReplyItemJurisdiction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:490 */
#ifndef SOAP_TYPE_ns2__TaxReply
#define SOAP_TYPE_ns2__TaxReply (440)
/* complex XML schema type 'ns2:TaxReply': */
class SOAP_CMAC ns2__TaxReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:currency' of XML schema type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:grandTotalAmount' of XML schema type 'ns2:amount'
        std::string *grandTotalAmount;
        /// Optional element 'ns2:totalTaxableAmount' of XML schema type 'ns2:amount'
        std::string *totalTaxableAmount;
        /// Optional element 'ns2:totalExemptAmount' of XML schema type 'ns2:amount'
        std::string *totalExemptAmount;
        /// Optional element 'ns2:totalSpecialTaxAmount' of XML schema type 'ns2:amount'
        std::string *totalSpecialTaxAmount;
        /// Optional element 'ns2:totalCityTaxAmount' of XML schema type 'ns2:amount'
        std::string *totalCityTaxAmount;
        /// Optional element 'ns2:city' of XML schema type 'xsd:string'
        std::string *city;
        /// Optional element 'ns2:totalCountyTaxAmount' of XML schema type 'ns2:amount'
        std::string *totalCountyTaxAmount;
        /// Optional element 'ns2:county' of XML schema type 'xsd:string'
        std::string *county;
        /// Optional element 'ns2:totalDistrictTaxAmount' of XML schema type 'ns2:amount'
        std::string *totalDistrictTaxAmount;
        /// Optional element 'ns2:totalStateTaxAmount' of XML schema type 'ns2:amount'
        std::string *totalStateTaxAmount;
        /// Optional element 'ns2:state' of XML schema type 'xsd:string'
        std::string *state;
        /// Optional element 'ns2:totalCountryTaxAmount' of XML schema type 'ns2:amount'
        std::string *totalCountryTaxAmount;
        /// Optional element 'ns2:totalTaxAmount' of XML schema type 'ns2:amount'
        std::string *totalTaxAmount;
        /// Optional element 'ns2:commitIndicator' of XML schema type 'xsd:string'
        std::string *commitIndicator;
        /// Optional element 'ns2:refundIndicator' of XML schema type 'xsd:string'
        std::string *refundIndicator;
        /// Optional element 'ns2:postalCode' of XML schema type 'xsd:string'
        std::string *postalCode;
        /// Optional element 'ns2:geocode' of XML schema type 'xsd:string'
        std::string *geocode;
        /// Sequence of 0 to 1000 elements 'ns2:item' of XML schema type 'ns2:TaxReplyItem'
        std::vector<ns2__TaxReplyItem> item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__TaxReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__TaxReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__TaxReply, default initialized and not managed by a soap context
        virtual ns2__TaxReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__TaxReply); }
      public:
        /// Constructor with default initializations
        ns2__TaxReply() : reasonCode(), currency(), grandTotalAmount(), totalTaxableAmount(), totalExemptAmount(), totalSpecialTaxAmount(), totalCityTaxAmount(), city(), totalCountyTaxAmount(), county(), totalDistrictTaxAmount(), totalStateTaxAmount(), state(), totalCountryTaxAmount(), totalTaxAmount(), commitIndicator(), refundIndicator(), postalCode(), geocode(), item(), soap() { }
        virtual ~ns2__TaxReply() { }
        /// Friend allocator used by soap_new_ns2__TaxReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__TaxReply * SOAP_FMAC2 soap_instantiate_ns2__TaxReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:492 */
#ifndef SOAP_TYPE_ns2__DeviceFingerprint
#define SOAP_TYPE_ns2__DeviceFingerprint (441)
/* complex XML schema type 'ns2:DeviceFingerprint': */
class SOAP_CMAC ns2__DeviceFingerprint {
      public:
        /// Optional element 'ns2:cookiesEnabled' of XML schema type 'ns2:boolean'
        std::string *cookiesEnabled;
        /// Optional element 'ns2:flashEnabled' of XML schema type 'ns2:boolean'
        std::string *flashEnabled;
        /// Optional element 'ns2:hash' of XML schema type 'xsd:string'
        std::string *hash;
        /// Optional element 'ns2:imagesEnabled' of XML schema type 'ns2:boolean'
        std::string *imagesEnabled;
        /// Optional element 'ns2:javascriptEnabled' of XML schema type 'ns2:boolean'
        std::string *javascriptEnabled;
        /// Optional element 'ns2:proxyIPAddress' of XML schema type 'xsd:string'
        std::string *proxyIPAddress;
        /// Optional element 'ns2:proxyIPAddressActivities' of XML schema type 'xsd:string'
        std::string *proxyIPAddressActivities;
        /// Optional element 'ns2:proxyIPAddressAttributes' of XML schema type 'xsd:string'
        std::string *proxyIPAddressAttributes;
        /// Optional element 'ns2:proxyServerType' of XML schema type 'xsd:string'
        std::string *proxyServerType;
        /// Optional element 'ns2:trueIPAddress' of XML schema type 'xsd:string'
        std::string *trueIPAddress;
        /// Optional element 'ns2:trueIPAddressActivities' of XML schema type 'xsd:string'
        std::string *trueIPAddressActivities;
        /// Optional element 'ns2:trueIPAddressAttributes' of XML schema type 'xsd:string'
        std::string *trueIPAddressAttributes;
        /// Optional element 'ns2:trueIPAddressCity' of XML schema type 'xsd:string'
        std::string *trueIPAddressCity;
        /// Optional element 'ns2:trueIPAddressState' of XML schema type 'xsd:string'
        std::string *trueIPAddressState;
        /// Optional element 'ns2:trueIPAddressCountry' of XML schema type 'xsd:string'
        std::string *trueIPAddressCountry;
        /// Optional element 'ns2:smartID' of XML schema type 'xsd:string'
        std::string *smartID;
        /// Optional element 'ns2:smartIDConfidenceLevel' of XML schema type 'xsd:string'
        std::string *smartIDConfidenceLevel;
        /// Optional element 'ns2:screenResolution' of XML schema type 'xsd:string'
        std::string *screenResolution;
        /// Optional element 'ns2:browserLanguage' of XML schema type 'xsd:string'
        std::string *browserLanguage;
        /// Optional element 'ns2:agentType' of XML schema type 'xsd:string'
        std::string *agentType;
        /// Optional element 'ns2:dateTime' of XML schema type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:profileDuration' of XML schema type 'xsd:integer'
        std::string *profileDuration;
        /// Optional element 'ns2:profiledURL' of XML schema type 'xsd:string'
        std::string *profiledURL;
        /// Optional element 'ns2:timeOnPage' of XML schema type 'xsd:integer'
        std::string *timeOnPage;
        /// Optional element 'ns2:deviceMatch' of XML schema type 'xsd:string'
        std::string *deviceMatch;
        /// Optional element 'ns2:firstEncounter' of XML schema type 'xsd:string'
        std::string *firstEncounter;
        /// Optional element 'ns2:flashOS' of XML schema type 'xsd:string'
        std::string *flashOS;
        /// Optional element 'ns2:flashVersion' of XML schema type 'xsd:string'
        std::string *flashVersion;
        /// Optional element 'ns2:deviceLatitude' of XML schema type 'xsd:string'
        std::string *deviceLatitude;
        /// Optional element 'ns2:deviceLongitude' of XML schema type 'xsd:string'
        std::string *deviceLongitude;
        /// Optional element 'ns2:gpsAccuracy' of XML schema type 'xsd:string'
        std::string *gpsAccuracy;
        /// Optional element 'ns2:jbRoot' of XML schema type 'xsd:integer'
        std::string *jbRoot;
        /// Optional element 'ns2:jbRootReason' of XML schema type 'xsd:string'
        std::string *jbRootReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DeviceFingerprint
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DeviceFingerprint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DeviceFingerprint, default initialized and not managed by a soap context
        virtual ns2__DeviceFingerprint *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DeviceFingerprint); }
      public:
        /// Constructor with default initializations
        ns2__DeviceFingerprint() : cookiesEnabled(), flashEnabled(), hash(), imagesEnabled(), javascriptEnabled(), proxyIPAddress(), proxyIPAddressActivities(), proxyIPAddressAttributes(), proxyServerType(), trueIPAddress(), trueIPAddressActivities(), trueIPAddressAttributes(), trueIPAddressCity(), trueIPAddressState(), trueIPAddressCountry(), smartID(), smartIDConfidenceLevel(), screenResolution(), browserLanguage(), agentType(), dateTime(), profileDuration(), profiledURL(), timeOnPage(), deviceMatch(), firstEncounter(), flashOS(), flashVersion(), deviceLatitude(), deviceLongitude(), gpsAccuracy(), jbRoot(), jbRootReason(), soap() { }
        virtual ~ns2__DeviceFingerprint() { }
        /// Friend allocator used by soap_new_ns2__DeviceFingerprint(struct soap*, int)
        friend SOAP_FMAC1 ns2__DeviceFingerprint * SOAP_FMAC2 soap_instantiate_ns2__DeviceFingerprint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:494 */
#ifndef SOAP_TYPE_ns2__AFSReply
#define SOAP_TYPE_ns2__AFSReply (442)
/* complex XML schema type 'ns2:AFSReply': */
class SOAP_CMAC ns2__AFSReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:afsResult' of XML schema type 'xsd:integer'
        std::string *afsResult;
        /// Optional element 'ns2:hostSeverity' of XML schema type 'xsd:integer'
        std::string *hostSeverity;
        /// Optional element 'ns2:consumerLocalTime' of XML schema type 'xsd:string'
        std::string *consumerLocalTime;
        /// Optional element 'ns2:afsFactorCode' of XML schema type 'xsd:string'
        std::string *afsFactorCode;
        /// Optional element 'ns2:addressInfoCode' of XML schema type 'xsd:string'
        std::string *addressInfoCode;
        /// Optional element 'ns2:hotlistInfoCode' of XML schema type 'xsd:string'
        std::string *hotlistInfoCode;
        /// Optional element 'ns2:internetInfoCode' of XML schema type 'xsd:string'
        std::string *internetInfoCode;
        /// Optional element 'ns2:phoneInfoCode' of XML schema type 'xsd:string'
        std::string *phoneInfoCode;
        /// Optional element 'ns2:suspiciousInfoCode' of XML schema type 'xsd:string'
        std::string *suspiciousInfoCode;
        /// Optional element 'ns2:deviceBehaviorInfoCode' of XML schema type 'xsd:string'
        std::string *deviceBehaviorInfoCode;
        /// Optional element 'ns2:velocityInfoCode' of XML schema type 'xsd:string'
        std::string *velocityInfoCode;
        /// Optional element 'ns2:identityInfoCode' of XML schema type 'xsd:string'
        std::string *identityInfoCode;
        /// Optional element 'ns2:ipCountry' of XML schema type 'xsd:string'
        std::string *ipCountry;
        /// Optional element 'ns2:ipState' of XML schema type 'xsd:string'
        std::string *ipState;
        /// Optional element 'ns2:ipCity' of XML schema type 'xsd:string'
        std::string *ipCity;
        /// Optional element 'ns2:ipRoutingMethod' of XML schema type 'xsd:string'
        std::string *ipRoutingMethod;
        /// Optional element 'ns2:ipAnonymizerStatus' of XML schema type 'xsd:string'
        std::string *ipAnonymizerStatus;
        /// Optional element 'ns2:ipCarrier' of XML schema type 'xsd:string'
        std::string *ipCarrier;
        /// Optional element 'ns2:ipOrganization' of XML schema type 'xsd:string'
        std::string *ipOrganization;
        /// Optional element 'ns2:scoreModelUsed' of XML schema type 'xsd:string'
        std::string *scoreModelUsed;
        /// Optional element 'ns2:cardBin' of XML schema type 'xsd:string'
        std::string *cardBin;
        /// Optional element 'ns2:binCountry' of XML schema type 'xsd:string'
        std::string *binCountry;
        /// Optional element 'ns2:cardAccountType' of XML schema type 'xsd:string'
        std::string *cardAccountType;
        /// Optional element 'ns2:cardScheme' of XML schema type 'xsd:string'
        std::string *cardScheme;
        /// Optional element 'ns2:cardIssuer' of XML schema type 'xsd:string'
        std::string *cardIssuer;
        /// Optional element 'ns2:deviceFingerprint' of XML schema type 'ns2:DeviceFingerprint'
        ns2__DeviceFingerprint *deviceFingerprint;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AFSReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__AFSReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AFSReply, default initialized and not managed by a soap context
        virtual ns2__AFSReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__AFSReply); }
      public:
        /// Constructor with default initializations
        ns2__AFSReply() : reasonCode(), afsResult(), hostSeverity(), consumerLocalTime(), afsFactorCode(), addressInfoCode(), hotlistInfoCode(), internetInfoCode(), phoneInfoCode(), suspiciousInfoCode(), deviceBehaviorInfoCode(), velocityInfoCode(), identityInfoCode(), ipCountry(), ipState(), ipCity(), ipRoutingMethod(), ipAnonymizerStatus(), ipCarrier(), ipOrganization(), scoreModelUsed(), cardBin(), binCountry(), cardAccountType(), cardScheme(), cardIssuer(), deviceFingerprint(), soap() { }
        virtual ~ns2__AFSReply() { }
        /// Friend allocator used by soap_new_ns2__AFSReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__AFSReply * SOAP_FMAC2 soap_instantiate_ns2__AFSReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:496 */
#ifndef SOAP_TYPE_ns2__DAVReply
#define SOAP_TYPE_ns2__DAVReply (443)
/* complex XML schema type 'ns2:DAVReply': */
class SOAP_CMAC ns2__DAVReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:addressType' of XML schema type 'xsd:string'
        std::string *addressType;
        /// Optional element 'ns2:apartmentInfo' of XML schema type 'xsd:string'
        std::string *apartmentInfo;
        /// Optional element 'ns2:barCode' of XML schema type 'xsd:string'
        std::string *barCode;
        /// Optional element 'ns2:barCodeCheckDigit' of XML schema type 'xsd:string'
        std::string *barCodeCheckDigit;
        /// Optional element 'ns2:careOf' of XML schema type 'xsd:string'
        std::string *careOf;
        /// Optional element 'ns2:cityInfo' of XML schema type 'xsd:string'
        std::string *cityInfo;
        /// Optional element 'ns2:countryInfo' of XML schema type 'xsd:string'
        std::string *countryInfo;
        /// Optional element 'ns2:directionalInfo' of XML schema type 'xsd:string'
        std::string *directionalInfo;
        /// Optional element 'ns2:lvrInfo' of XML schema type 'xsd:string'
        std::string *lvrInfo;
        /// Optional element 'ns2:matchScore' of XML schema type 'xsd:integer'
        std::string *matchScore;
        /// Optional element 'ns2:standardizedAddress1' of XML schema type 'xsd:string'
        std::string *standardizedAddress1;
        /// Optional element 'ns2:standardizedAddress2' of XML schema type 'xsd:string'
        std::string *standardizedAddress2;
        /// Optional element 'ns2:standardizedAddress3' of XML schema type 'xsd:string'
        std::string *standardizedAddress3;
        /// Optional element 'ns2:standardizedAddress4' of XML schema type 'xsd:string'
        std::string *standardizedAddress4;
        /// Optional element 'ns2:standardizedAddressNoApt' of XML schema type 'xsd:string'
        std::string *standardizedAddressNoApt;
        /// Optional element 'ns2:standardizedCity' of XML schema type 'xsd:string'
        std::string *standardizedCity;
        /// Optional element 'ns2:standardizedCounty' of XML schema type 'xsd:string'
        std::string *standardizedCounty;
        /// Optional element 'ns2:standardizedCSP' of XML schema type 'xsd:string'
        std::string *standardizedCSP;
        /// Optional element 'ns2:standardizedState' of XML schema type 'xsd:string'
        std::string *standardizedState;
        /// Optional element 'ns2:standardizedPostalCode' of XML schema type 'xsd:string'
        std::string *standardizedPostalCode;
        /// Optional element 'ns2:standardizedCountry' of XML schema type 'xsd:string'
        std::string *standardizedCountry;
        /// Optional element 'ns2:standardizedISOCountry' of XML schema type 'xsd:string'
        std::string *standardizedISOCountry;
        /// Optional element 'ns2:stateInfo' of XML schema type 'xsd:string'
        std::string *stateInfo;
        /// Optional element 'ns2:streetInfo' of XML schema type 'xsd:string'
        std::string *streetInfo;
        /// Optional element 'ns2:suffixInfo' of XML schema type 'xsd:string'
        std::string *suffixInfo;
        /// Optional element 'ns2:postalCodeInfo' of XML schema type 'xsd:string'
        std::string *postalCodeInfo;
        /// Optional element 'ns2:overallInfo' of XML schema type 'xsd:string'
        std::string *overallInfo;
        /// Optional element 'ns2:usInfo' of XML schema type 'xsd:string'
        std::string *usInfo;
        /// Optional element 'ns2:caInfo' of XML schema type 'xsd:string'
        std::string *caInfo;
        /// Optional element 'ns2:intlInfo' of XML schema type 'xsd:string'
        std::string *intlInfo;
        /// Optional element 'ns2:usErrorInfo' of XML schema type 'xsd:string'
        std::string *usErrorInfo;
        /// Optional element 'ns2:caErrorInfo' of XML schema type 'xsd:string'
        std::string *caErrorInfo;
        /// Optional element 'ns2:intlErrorInfo' of XML schema type 'xsd:string'
        std::string *intlErrorInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DAVReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DAVReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DAVReply, default initialized and not managed by a soap context
        virtual ns2__DAVReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DAVReply); }
      public:
        /// Constructor with default initializations
        ns2__DAVReply() : reasonCode(), addressType(), apartmentInfo(), barCode(), barCodeCheckDigit(), careOf(), cityInfo(), countryInfo(), directionalInfo(), lvrInfo(), matchScore(), standardizedAddress1(), standardizedAddress2(), standardizedAddress3(), standardizedAddress4(), standardizedAddressNoApt(), standardizedCity(), standardizedCounty(), standardizedCSP(), standardizedState(), standardizedPostalCode(), standardizedCountry(), standardizedISOCountry(), stateInfo(), streetInfo(), suffixInfo(), postalCodeInfo(), overallInfo(), usInfo(), caInfo(), intlInfo(), usErrorInfo(), caErrorInfo(), intlErrorInfo(), soap() { }
        virtual ~ns2__DAVReply() { }
        /// Friend allocator used by soap_new_ns2__DAVReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__DAVReply * SOAP_FMAC2 soap_instantiate_ns2__DAVReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:498 */
#ifndef SOAP_TYPE_ns2__DeniedPartiesMatch
#define SOAP_TYPE_ns2__DeniedPartiesMatch (444)
/* complex XML schema type 'ns2:DeniedPartiesMatch': */
class SOAP_CMAC ns2__DeniedPartiesMatch {
      public:
        /// Optional element 'ns2:list' of XML schema type 'xsd:string'
        std::string *list;
        /// Sequence of 0 to 100 elements 'ns2:name' of XML schema type 'xsd:string'
        std::vector<std::string> name;
        /// Sequence of 0 to 100 elements 'ns2:address' of XML schema type 'xsd:string'
        std::vector<std::string> address;
        /// Sequence of 0 to 100 elements 'ns2:program' of XML schema type 'xsd:string'
        std::vector<std::string> program;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DeniedPartiesMatch
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DeniedPartiesMatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DeniedPartiesMatch, default initialized and not managed by a soap context
        virtual ns2__DeniedPartiesMatch *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DeniedPartiesMatch); }
      public:
        /// Constructor with default initializations
        ns2__DeniedPartiesMatch() : list(), name(), address(), program(), soap() { }
        virtual ~ns2__DeniedPartiesMatch() { }
        /// Friend allocator used by soap_new_ns2__DeniedPartiesMatch(struct soap*, int)
        friend SOAP_FMAC1 ns2__DeniedPartiesMatch * SOAP_FMAC2 soap_instantiate_ns2__DeniedPartiesMatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:500 */
#ifndef SOAP_TYPE_ns2__ExportReply
#define SOAP_TYPE_ns2__ExportReply (445)
/* complex XML schema type 'ns2:ExportReply': */
class SOAP_CMAC ns2__ExportReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:ipCountryConfidence' of XML schema type 'xsd:integer'
        std::string *ipCountryConfidence;
        /// Optional element 'ns2:infoCode' of XML schema type 'xsd:string'
        std::string *infoCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ExportReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ExportReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ExportReply, default initialized and not managed by a soap context
        virtual ns2__ExportReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ExportReply); }
      public:
        /// Constructor with default initializations
        ns2__ExportReply() : reasonCode(), ipCountryConfidence(), infoCode(), soap() { }
        virtual ~ns2__ExportReply() { }
        /// Friend allocator used by soap_new_ns2__ExportReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__ExportReply * SOAP_FMAC2 soap_instantiate_ns2__ExportReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:502 */
#ifndef SOAP_TYPE_ns2__FXQuote
#define SOAP_TYPE_ns2__FXQuote (446)
/* complex XML schema type 'ns2:FXQuote': */
class SOAP_CMAC ns2__FXQuote {
      public:
        /// Optional element 'ns2:id' of XML schema type 'xsd:string'
        std::string *id;
        /// Optional element 'ns2:rate' of XML schema type 'xsd:string'
        std::string *rate;
        /// Optional element 'ns2:type' of XML schema type 'xsd:string'
        std::string *type;
        /// Optional element 'ns2:expirationDateTime' of XML schema type 'ns2:dateTime'
        std::string *expirationDateTime;
        /// Optional element 'ns2:currency' of XML schema type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:fundingCurrency' of XML schema type 'xsd:string'
        std::string *fundingCurrency;
        /// Optional element 'ns2:receivedDateTime' of XML schema type 'ns2:dateTime'
        std::string *receivedDateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FXQuote
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__FXQuote; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FXQuote, default initialized and not managed by a soap context
        virtual ns2__FXQuote *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__FXQuote); }
      public:
        /// Constructor with default initializations
        ns2__FXQuote() : id(), rate(), type(), expirationDateTime(), currency(), fundingCurrency(), receivedDateTime(), soap() { }
        virtual ~ns2__FXQuote() { }
        /// Friend allocator used by soap_new_ns2__FXQuote(struct soap*, int)
        friend SOAP_FMAC1 ns2__FXQuote * SOAP_FMAC2 soap_instantiate_ns2__FXQuote(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:504 */
#ifndef SOAP_TYPE_ns2__FXRatesReply
#define SOAP_TYPE_ns2__FXRatesReply (447)
/* complex XML schema type 'ns2:FXRatesReply': */
class SOAP_CMAC ns2__FXRatesReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Sequence of 0 to 999 elements 'ns2:quote' of XML schema type 'ns2:FXQuote'
        std::vector<ns2__FXQuote> quote;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FXRatesReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__FXRatesReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FXRatesReply, default initialized and not managed by a soap context
        virtual ns2__FXRatesReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__FXRatesReply); }
      public:
        /// Constructor with default initializations
        ns2__FXRatesReply() : reasonCode(), quote(), soap() { }
        virtual ~ns2__FXRatesReply() { }
        /// Friend allocator used by soap_new_ns2__FXRatesReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__FXRatesReply * SOAP_FMAC2 soap_instantiate_ns2__FXRatesReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:506 */
#ifndef SOAP_TYPE_ns2__BankTransferReply
#define SOAP_TYPE_ns2__BankTransferReply (448)
/* complex XML schema type 'ns2:BankTransferReply': */
class SOAP_CMAC ns2__BankTransferReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:accountHolder' of XML schema type 'xsd:string'
        std::string *accountHolder;
        /// Optional element 'ns2:accountNumber' of XML schema type 'xsd:string'
        std::string *accountNumber;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:bankName' of XML schema type 'xsd:string'
        std::string *bankName;
        /// Optional element 'ns2:bankCity' of XML schema type 'xsd:string'
        std::string *bankCity;
        /// Optional element 'ns2:bankCountry' of XML schema type 'xsd:string'
        std::string *bankCountry;
        /// Optional element 'ns2:paymentReference' of XML schema type 'xsd:string'
        std::string *paymentReference;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:bankSwiftCode' of XML schema type 'xsd:string'
        std::string *bankSwiftCode;
        /// Optional element 'ns2:bankSpecialID' of XML schema type 'xsd:string'
        std::string *bankSpecialID;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:iban' of XML schema type 'xsd:string'
        std::string *iban;
        /// Optional element 'ns2:bankCode' of XML schema type 'xsd:string'
        std::string *bankCode;
        /// Optional element 'ns2:branchCode' of XML schema type 'xsd:string'
        std::string *branchCode;
        /// Optional element 'ns2:reconciliationReferenceNumber' of XML schema type 'xsd:string'
        std::string *reconciliationReferenceNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BankTransferReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__BankTransferReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BankTransferReply, default initialized and not managed by a soap context
        virtual ns2__BankTransferReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__BankTransferReply); }
      public:
        /// Constructor with default initializations
        ns2__BankTransferReply() : reasonCode(), accountHolder(), accountNumber(), amount(), bankName(), bankCity(), bankCountry(), paymentReference(), processorResponse(), bankSwiftCode(), bankSpecialID(), requestDateTime(), reconciliationID(), iban(), bankCode(), branchCode(), reconciliationReferenceNumber(), soap() { }
        virtual ~ns2__BankTransferReply() { }
        /// Friend allocator used by soap_new_ns2__BankTransferReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__BankTransferReply * SOAP_FMAC2 soap_instantiate_ns2__BankTransferReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:508 */
#ifndef SOAP_TYPE_ns2__BankTransferRealTimeReply
#define SOAP_TYPE_ns2__BankTransferRealTimeReply (449)
/* complex XML schema type 'ns2:BankTransferRealTimeReply': */
class SOAP_CMAC ns2__BankTransferRealTimeReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:formMethod' of XML schema type 'xsd:string'
        std::string *formMethod;
        /// Optional element 'ns2:formAction' of XML schema type 'xsd:string'
        std::string *formAction;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:paymentReference' of XML schema type 'xsd:string'
        std::string *paymentReference;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:reconciliationReferenceNumber' of XML schema type 'xsd:string'
        std::string *reconciliationReferenceNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BankTransferRealTimeReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__BankTransferRealTimeReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BankTransferRealTimeReply, default initialized and not managed by a soap context
        virtual ns2__BankTransferRealTimeReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__BankTransferRealTimeReply); }
      public:
        /// Constructor with default initializations
        ns2__BankTransferRealTimeReply() : reasonCode(), formMethod(), formAction(), requestDateTime(), reconciliationID(), paymentReference(), amount(), reconciliationReferenceNumber(), soap() { }
        virtual ~ns2__BankTransferRealTimeReply() { }
        /// Friend allocator used by soap_new_ns2__BankTransferRealTimeReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__BankTransferRealTimeReply * SOAP_FMAC2 soap_instantiate_ns2__BankTransferRealTimeReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:510 */
#ifndef SOAP_TYPE_ns2__DirectDebitMandateReply
#define SOAP_TYPE_ns2__DirectDebitMandateReply (450)
/* complex XML schema type 'ns2:DirectDebitMandateReply': */
class SOAP_CMAC ns2__DirectDebitMandateReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:mandateID' of XML schema type 'xsd:string'
        std::string *mandateID;
        /// Optional element 'ns2:mandateMaturationDate' of XML schema type 'xsd:string'
        std::string *mandateMaturationDate;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DirectDebitMandateReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DirectDebitMandateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DirectDebitMandateReply, default initialized and not managed by a soap context
        virtual ns2__DirectDebitMandateReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DirectDebitMandateReply); }
      public:
        /// Constructor with default initializations
        ns2__DirectDebitMandateReply() : reasonCode(), mandateID(), mandateMaturationDate(), requestDateTime(), reconciliationID(), processorResponse(), soap() { }
        virtual ~ns2__DirectDebitMandateReply() { }
        /// Friend allocator used by soap_new_ns2__DirectDebitMandateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__DirectDebitMandateReply * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitMandateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:512 */
#ifndef SOAP_TYPE_ns2__BankTransferRefundReply
#define SOAP_TYPE_ns2__BankTransferRefundReply (451)
/* complex XML schema type 'ns2:BankTransferRefundReply': */
class SOAP_CMAC ns2__BankTransferRefundReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:iban' of XML schema type 'xsd:string'
        std::string *iban;
        /// Optional element 'ns2:reconciliationReferenceNumber' of XML schema type 'xsd:string'
        std::string *reconciliationReferenceNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BankTransferRefundReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__BankTransferRefundReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BankTransferRefundReply, default initialized and not managed by a soap context
        virtual ns2__BankTransferRefundReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__BankTransferRefundReply); }
      public:
        /// Constructor with default initializations
        ns2__BankTransferRefundReply() : reasonCode(), amount(), requestDateTime(), reconciliationID(), processorResponse(), iban(), reconciliationReferenceNumber(), soap() { }
        virtual ~ns2__BankTransferRefundReply() { }
        /// Friend allocator used by soap_new_ns2__BankTransferRefundReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__BankTransferRefundReply * SOAP_FMAC2 soap_instantiate_ns2__BankTransferRefundReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:514 */
#ifndef SOAP_TYPE_ns2__DirectDebitReply
#define SOAP_TYPE_ns2__DirectDebitReply (452)
/* complex XML schema type 'ns2:DirectDebitReply': */
class SOAP_CMAC ns2__DirectDebitReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:processorTransactionID' of XML schema type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:mandateAuthenticationDate' of XML schema type 'xsd:string'
        std::string *mandateAuthenticationDate;
        /// Optional element 'ns2:mandateID' of XML schema type 'xsd:string'
        std::string *mandateID;
        /// Optional element 'ns2:iban' of XML schema type 'xsd:string'
        std::string *iban;
        /// Optional element 'ns2:reconciliationReferenceNumber' of XML schema type 'xsd:string'
        std::string *reconciliationReferenceNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DirectDebitReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DirectDebitReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DirectDebitReply, default initialized and not managed by a soap context
        virtual ns2__DirectDebitReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DirectDebitReply); }
      public:
        /// Constructor with default initializations
        ns2__DirectDebitReply() : reasonCode(), amount(), requestDateTime(), reconciliationID(), processorResponse(), processorTransactionID(), mandateAuthenticationDate(), mandateID(), iban(), reconciliationReferenceNumber(), soap() { }
        virtual ~ns2__DirectDebitReply() { }
        /// Friend allocator used by soap_new_ns2__DirectDebitReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__DirectDebitReply * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:516 */
#ifndef SOAP_TYPE_ns2__DirectDebitValidateReply
#define SOAP_TYPE_ns2__DirectDebitValidateReply (453)
/* complex XML schema type 'ns2:DirectDebitValidateReply': */
class SOAP_CMAC ns2__DirectDebitValidateReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:iban' of XML schema type 'xsd:string'
        std::string *iban;
        /// Optional element 'ns2:bankSwiftCode' of XML schema type 'xsd:string'
        std::string *bankSwiftCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DirectDebitValidateReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DirectDebitValidateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DirectDebitValidateReply, default initialized and not managed by a soap context
        virtual ns2__DirectDebitValidateReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DirectDebitValidateReply); }
      public:
        /// Constructor with default initializations
        ns2__DirectDebitValidateReply() : reasonCode(), amount(), requestDateTime(), reconciliationID(), processorResponse(), iban(), bankSwiftCode(), soap() { }
        virtual ~ns2__DirectDebitValidateReply() { }
        /// Friend allocator used by soap_new_ns2__DirectDebitValidateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__DirectDebitValidateReply * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitValidateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:518 */
#ifndef SOAP_TYPE_ns2__DirectDebitRefundReply
#define SOAP_TYPE_ns2__DirectDebitRefundReply (454)
/* complex XML schema type 'ns2:DirectDebitRefundReply': */
class SOAP_CMAC ns2__DirectDebitRefundReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:processorTransactionID' of XML schema type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:iban' of XML schema type 'xsd:string'
        std::string *iban;
        /// Optional element 'ns2:reconciliationReferenceNumber' of XML schema type 'xsd:string'
        std::string *reconciliationReferenceNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DirectDebitRefundReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DirectDebitRefundReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DirectDebitRefundReply, default initialized and not managed by a soap context
        virtual ns2__DirectDebitRefundReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DirectDebitRefundReply); }
      public:
        /// Constructor with default initializations
        ns2__DirectDebitRefundReply() : reasonCode(), amount(), requestDateTime(), reconciliationID(), processorResponse(), processorTransactionID(), iban(), reconciliationReferenceNumber(), soap() { }
        virtual ~ns2__DirectDebitRefundReply() { }
        /// Friend allocator used by soap_new_ns2__DirectDebitRefundReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__DirectDebitRefundReply * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitRefundReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:520 */
#ifndef SOAP_TYPE_ns2__PaySubscriptionCreateReply
#define SOAP_TYPE_ns2__PaySubscriptionCreateReply (455)
/* complex XML schema type 'ns2:PaySubscriptionCreateReply': */
class SOAP_CMAC ns2__PaySubscriptionCreateReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Required element 'ns2:subscriptionID' of XML schema type 'xsd:string'
        std::string subscriptionID;
        /// Optional element 'ns2:instrumentIdentifierID' of XML schema type 'xsd:string'
        std::string *instrumentIdentifierID;
        /// Optional element 'ns2:instrumentIdentifierStatus' of XML schema type 'xsd:string'
        std::string *instrumentIdentifierStatus;
        /// Optional element 'ns2:instrumentIdentifierNew' of XML schema type 'xsd:string'
        std::string *instrumentIdentifierNew;
        /// Optional element 'ns2:instrumentIdentifierSuccessorID' of XML schema type 'xsd:string'
        std::string *instrumentIdentifierSuccessorID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaySubscriptionCreateReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PaySubscriptionCreateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaySubscriptionCreateReply, default initialized and not managed by a soap context
        virtual ns2__PaySubscriptionCreateReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PaySubscriptionCreateReply); }
      public:
        /// Constructor with default initializations
        ns2__PaySubscriptionCreateReply() : reasonCode(), subscriptionID(), instrumentIdentifierID(), instrumentIdentifierStatus(), instrumentIdentifierNew(), instrumentIdentifierSuccessorID(), soap() { }
        virtual ~ns2__PaySubscriptionCreateReply() { }
        /// Friend allocator used by soap_new_ns2__PaySubscriptionCreateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaySubscriptionCreateReply * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionCreateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:522 */
#ifndef SOAP_TYPE_ns2__PaySubscriptionUpdateReply
#define SOAP_TYPE_ns2__PaySubscriptionUpdateReply (456)
/* complex XML schema type 'ns2:PaySubscriptionUpdateReply': */
class SOAP_CMAC ns2__PaySubscriptionUpdateReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Required element 'ns2:subscriptionID' of XML schema type 'xsd:string'
        std::string subscriptionID;
        /// Optional element 'ns2:subscriptionIDNew' of XML schema type 'xsd:string'
        std::string *subscriptionIDNew;
        /// Optional element 'ns2:ownerMerchantID' of XML schema type 'xsd:string'
        std::string *ownerMerchantID;
        /// Optional element 'ns2:instrumentIdentifierID' of XML schema type 'xsd:string'
        std::string *instrumentIdentifierID;
        /// Optional element 'ns2:instrumentIdentifierStatus' of XML schema type 'xsd:string'
        std::string *instrumentIdentifierStatus;
        /// Optional element 'ns2:instrumentIdentifierNew' of XML schema type 'xsd:string'
        std::string *instrumentIdentifierNew;
        /// Optional element 'ns2:instrumentIdentifierSuccessorID' of XML schema type 'xsd:string'
        std::string *instrumentIdentifierSuccessorID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaySubscriptionUpdateReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PaySubscriptionUpdateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaySubscriptionUpdateReply, default initialized and not managed by a soap context
        virtual ns2__PaySubscriptionUpdateReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PaySubscriptionUpdateReply); }
      public:
        /// Constructor with default initializations
        ns2__PaySubscriptionUpdateReply() : reasonCode(), subscriptionID(), subscriptionIDNew(), ownerMerchantID(), instrumentIdentifierID(), instrumentIdentifierStatus(), instrumentIdentifierNew(), instrumentIdentifierSuccessorID(), soap() { }
        virtual ~ns2__PaySubscriptionUpdateReply() { }
        /// Friend allocator used by soap_new_ns2__PaySubscriptionUpdateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaySubscriptionUpdateReply * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionUpdateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:524 */
#ifndef SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply
#define SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply (457)
/* complex XML schema type 'ns2:PaySubscriptionEventUpdateReply': */
class SOAP_CMAC ns2__PaySubscriptionEventUpdateReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:ownerMerchantID' of XML schema type 'xsd:string'
        std::string *ownerMerchantID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaySubscriptionEventUpdateReply, default initialized and not managed by a soap context
        virtual ns2__PaySubscriptionEventUpdateReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PaySubscriptionEventUpdateReply); }
      public:
        /// Constructor with default initializations
        ns2__PaySubscriptionEventUpdateReply() : reasonCode(), ownerMerchantID(), soap() { }
        virtual ~ns2__PaySubscriptionEventUpdateReply() { }
        /// Friend allocator used by soap_new_ns2__PaySubscriptionEventUpdateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaySubscriptionEventUpdateReply * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionEventUpdateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:526 */
#ifndef SOAP_TYPE_ns2__PaySubscriptionRetrieveReply
#define SOAP_TYPE_ns2__PaySubscriptionRetrieveReply (458)
/* complex XML schema type 'ns2:PaySubscriptionRetrieveReply': */
class SOAP_CMAC ns2__PaySubscriptionRetrieveReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:approvalRequired' of XML schema type 'xsd:string'
        std::string *approvalRequired;
        /// Optional element 'ns2:automaticRenew' of XML schema type 'xsd:string'
        std::string *automaticRenew;
        /// Optional element 'ns2:cardAccountNumber' of XML schema type 'xsd:string'
        std::string *cardAccountNumber;
        /// Optional element 'ns2:cardExpirationMonth' of XML schema type 'xsd:string'
        std::string *cardExpirationMonth;
        /// Optional element 'ns2:cardExpirationYear' of XML schema type 'xsd:string'
        std::string *cardExpirationYear;
        /// Optional element 'ns2:cardIssueNumber' of XML schema type 'xsd:string'
        std::string *cardIssueNumber;
        /// Optional element 'ns2:cardStartMonth' of XML schema type 'xsd:string'
        std::string *cardStartMonth;
        /// Optional element 'ns2:cardStartYear' of XML schema type 'xsd:string'
        std::string *cardStartYear;
        /// Optional element 'ns2:cardType' of XML schema type 'xsd:string'
        std::string *cardType;
        /// Optional element 'ns2:checkAccountNumber' of XML schema type 'xsd:string'
        std::string *checkAccountNumber;
        /// Optional element 'ns2:checkAccountType' of XML schema type 'xsd:string'
        std::string *checkAccountType;
        /// Optional element 'ns2:checkBankTransitNumber' of XML schema type 'xsd:string'
        std::string *checkBankTransitNumber;
        /// Optional element 'ns2:checkSecCode' of XML schema type 'xsd:string'
        std::string *checkSecCode;
        /// Optional element 'ns2:checkAuthenticateID' of XML schema type 'xsd:string'
        std::string *checkAuthenticateID;
        /// Optional element 'ns2:city' of XML schema type 'xsd:string'
        std::string *city;
        /// Optional element 'ns2:comments' of XML schema type 'xsd:string'
        std::string *comments;
        /// Optional element 'ns2:companyName' of XML schema type 'xsd:string'
        std::string *companyName;
        /// Optional element 'ns2:country' of XML schema type 'xsd:string'
        std::string *country;
        /// Optional element 'ns2:currency' of XML schema type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:customerAccountID' of XML schema type 'xsd:string'
        std::string *customerAccountID;
        /// Optional element 'ns2:email' of XML schema type 'xsd:string'
        std::string *email;
        /// Optional element 'ns2:endDate' of XML schema type 'xsd:string'
        std::string *endDate;
        /// Optional element 'ns2:firstName' of XML schema type 'xsd:string'
        std::string *firstName;
        /// Optional element 'ns2:frequency' of XML schema type 'xsd:string'
        std::string *frequency;
        /// Optional element 'ns2:lastName' of XML schema type 'xsd:string'
        std::string *lastName;
        /// Optional element 'ns2:merchantReferenceCode' of XML schema type 'xsd:string'
        std::string *merchantReferenceCode;
        /// Optional element 'ns2:paymentMethod' of XML schema type 'xsd:string'
        std::string *paymentMethod;
        /// Optional element 'ns2:paymentsRemaining' of XML schema type 'xsd:string'
        std::string *paymentsRemaining;
        /// Optional element 'ns2:phoneNumber' of XML schema type 'xsd:string'
        std::string *phoneNumber;
        /// Optional element 'ns2:postalCode' of XML schema type 'xsd:string'
        std::string *postalCode;
        /// Optional element 'ns2:recurringAmount' of XML schema type 'xsd:string'
        std::string *recurringAmount;
        /// Optional element 'ns2:setupAmount' of XML schema type 'xsd:string'
        std::string *setupAmount;
        /// Optional element 'ns2:startDate' of XML schema type 'xsd:string'
        std::string *startDate;
        /// Optional element 'ns2:state' of XML schema type 'xsd:string'
        std::string *state;
        /// Optional element 'ns2:status' of XML schema type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:street1' of XML schema type 'xsd:string'
        std::string *street1;
        /// Optional element 'ns2:street2' of XML schema type 'xsd:string'
        std::string *street2;
        /// Optional element 'ns2:subscriptionID' of XML schema type 'xsd:string'
        std::string *subscriptionID;
        /// Optional element 'ns2:subscriptionIDNew' of XML schema type 'xsd:string'
        std::string *subscriptionIDNew;
        /// Optional element 'ns2:title' of XML schema type 'xsd:string'
        std::string *title;
        /// Optional element 'ns2:totalPayments' of XML schema type 'xsd:string'
        std::string *totalPayments;
        /// Optional element 'ns2:shipToFirstName' of XML schema type 'xsd:string'
        std::string *shipToFirstName;
        /// Optional element 'ns2:shipToLastName' of XML schema type 'xsd:string'
        std::string *shipToLastName;
        /// Optional element 'ns2:shipToStreet1' of XML schema type 'xsd:string'
        std::string *shipToStreet1;
        /// Optional element 'ns2:shipToStreet2' of XML schema type 'xsd:string'
        std::string *shipToStreet2;
        /// Optional element 'ns2:shipToCity' of XML schema type 'xsd:string'
        std::string *shipToCity;
        /// Optional element 'ns2:shipToState' of XML schema type 'xsd:string'
        std::string *shipToState;
        /// Optional element 'ns2:shipToPostalCode' of XML schema type 'xsd:string'
        std::string *shipToPostalCode;
        /// Optional element 'ns2:shipToCompany' of XML schema type 'xsd:string'
        std::string *shipToCompany;
        /// Optional element 'ns2:shipToCountry' of XML schema type 'xsd:string'
        std::string *shipToCountry;
        /// Optional element 'ns2:billPayment' of XML schema type 'xsd:string'
        std::string *billPayment;
        /// Optional element 'ns2:merchantDefinedDataField1' of XML schema type 'xsd:string'
        std::string *merchantDefinedDataField1;
        /// Optional element 'ns2:merchantDefinedDataField2' of XML schema type 'xsd:string'
        std::string *merchantDefinedDataField2;
        /// Optional element 'ns2:merchantDefinedDataField3' of XML schema type 'xsd:string'
        std::string *merchantDefinedDataField3;
        /// Optional element 'ns2:merchantDefinedDataField4' of XML schema type 'xsd:string'
        std::string *merchantDefinedDataField4;
        /// Optional element 'ns2:merchantSecureDataField1' of XML schema type 'xsd:string'
        std::string *merchantSecureDataField1;
        /// Optional element 'ns2:merchantSecureDataField2' of XML schema type 'xsd:string'
        std::string *merchantSecureDataField2;
        /// Optional element 'ns2:merchantSecureDataField3' of XML schema type 'xsd:string'
        std::string *merchantSecureDataField3;
        /// Optional element 'ns2:merchantSecureDataField4' of XML schema type 'xsd:string'
        std::string *merchantSecureDataField4;
        /// Optional element 'ns2:ownerMerchantID' of XML schema type 'xsd:string'
        std::string *ownerMerchantID;
        /// Optional element 'ns2:companyTaxID' of XML schema type 'xsd:string'
        std::string *companyTaxID;
        /// Optional element 'ns2:driversLicenseNumber' of XML schema type 'xsd:string'
        std::string *driversLicenseNumber;
        /// Optional element 'ns2:driversLicenseState' of XML schema type 'xsd:string'
        std::string *driversLicenseState;
        /// Optional element 'ns2:dateOfBirth' of XML schema type 'xsd:string'
        std::string *dateOfBirth;
        /// Optional element 'ns2:instrumentIdentifierID' of XML schema type 'xsd:string'
        std::string *instrumentIdentifierID;
        /// Optional element 'ns2:instrumentIdentifierStatus' of XML schema type 'xsd:string'
        std::string *instrumentIdentifierStatus;
        /// Optional element 'ns2:instrumentIdentifierSuccessorID' of XML schema type 'xsd:string'
        std::string *instrumentIdentifierSuccessorID;
        /// Optional element 'ns2:subsequentAuthTransactionID' of XML schema type 'xsd:string'
        std::string *subsequentAuthTransactionID;
        /// Optional element 'ns2:latestCardSuffix' of XML schema type 'xsd:string'
        std::string *latestCardSuffix;
        /// Optional element 'ns2:latestCardExpirationMonth' of XML schema type 'xsd:string'
        std::string *latestCardExpirationMonth;
        /// Optional element 'ns2:latestCardExpirationYear' of XML schema type 'xsd:string'
        std::string *latestCardExpirationYear;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaySubscriptionRetrieveReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PaySubscriptionRetrieveReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaySubscriptionRetrieveReply, default initialized and not managed by a soap context
        virtual ns2__PaySubscriptionRetrieveReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PaySubscriptionRetrieveReply); }
      public:
        /// Constructor with default initializations
        ns2__PaySubscriptionRetrieveReply() : reasonCode(), approvalRequired(), automaticRenew(), cardAccountNumber(), cardExpirationMonth(), cardExpirationYear(), cardIssueNumber(), cardStartMonth(), cardStartYear(), cardType(), checkAccountNumber(), checkAccountType(), checkBankTransitNumber(), checkSecCode(), checkAuthenticateID(), city(), comments(), companyName(), country(), currency(), customerAccountID(), email(), endDate(), firstName(), frequency(), lastName(), merchantReferenceCode(), paymentMethod(), paymentsRemaining(), phoneNumber(), postalCode(), recurringAmount(), setupAmount(), startDate(), state(), status(), street1(), street2(), subscriptionID(), subscriptionIDNew(), title(), totalPayments(), shipToFirstName(), shipToLastName(), shipToStreet1(), shipToStreet2(), shipToCity(), shipToState(), shipToPostalCode(), shipToCompany(), shipToCountry(), billPayment(), merchantDefinedDataField1(), merchantDefinedDataField2(), merchantDefinedDataField3(), merchantDefinedDataField4(), merchantSecureDataField1(), merchantSecureDataField2(), merchantSecureDataField3(), merchantSecureDataField4(), ownerMerchantID(), companyTaxID(), driversLicenseNumber(), driversLicenseState(), dateOfBirth(), instrumentIdentifierID(), instrumentIdentifierStatus(), instrumentIdentifierSuccessorID(), subsequentAuthTransactionID(), latestCardSuffix(), latestCardExpirationMonth(), latestCardExpirationYear(), soap() { }
        virtual ~ns2__PaySubscriptionRetrieveReply() { }
        /// Friend allocator used by soap_new_ns2__PaySubscriptionRetrieveReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaySubscriptionRetrieveReply * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionRetrieveReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:528 */
#ifndef SOAP_TYPE_ns2__PaySubscriptionDeleteReply
#define SOAP_TYPE_ns2__PaySubscriptionDeleteReply (459)
/* complex XML schema type 'ns2:PaySubscriptionDeleteReply': */
class SOAP_CMAC ns2__PaySubscriptionDeleteReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Required element 'ns2:subscriptionID' of XML schema type 'xsd:string'
        std::string subscriptionID;
        /// Optional element 'ns2:instrumentIdentifierID' of XML schema type 'xsd:string'
        std::string *instrumentIdentifierID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaySubscriptionDeleteReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PaySubscriptionDeleteReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaySubscriptionDeleteReply, default initialized and not managed by a soap context
        virtual ns2__PaySubscriptionDeleteReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PaySubscriptionDeleteReply); }
      public:
        /// Constructor with default initializations
        ns2__PaySubscriptionDeleteReply() : reasonCode(), subscriptionID(), instrumentIdentifierID(), soap() { }
        virtual ~ns2__PaySubscriptionDeleteReply() { }
        /// Friend allocator used by soap_new_ns2__PaySubscriptionDeleteReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaySubscriptionDeleteReply * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionDeleteReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:530 */
#ifndef SOAP_TYPE_ns2__PayPalPaymentReply
#define SOAP_TYPE_ns2__PayPalPaymentReply (460)
/* complex XML schema type 'ns2:PayPalPaymentReply': */
class SOAP_CMAC ns2__PayPalPaymentReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:secureData' of XML schema type 'xsd:string'
        std::string *secureData;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalPaymentReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalPaymentReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalPaymentReply, default initialized and not managed by a soap context
        virtual ns2__PayPalPaymentReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalPaymentReply); }
      public:
        /// Constructor with default initializations
        ns2__PayPalPaymentReply() : reasonCode(), secureData(), amount(), requestDateTime(), reconciliationID(), soap() { }
        virtual ~ns2__PayPalPaymentReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalPaymentReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalPaymentReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalPaymentReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:532 */
#ifndef SOAP_TYPE_ns2__PayPalCreditReply
#define SOAP_TYPE_ns2__PayPalCreditReply (461)
/* complex XML schema type 'ns2:PayPalCreditReply': */
class SOAP_CMAC ns2__PayPalCreditReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalCreditReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalCreditReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalCreditReply, default initialized and not managed by a soap context
        virtual ns2__PayPalCreditReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalCreditReply); }
      public:
        /// Constructor with default initializations
        ns2__PayPalCreditReply() : reasonCode(), amount(), requestDateTime(), reconciliationID(), processorResponse(), soap() { }
        virtual ~ns2__PayPalCreditReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalCreditReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalCreditReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalCreditReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:534 */
#ifndef SOAP_TYPE_ns2__VoidReply
#define SOAP_TYPE_ns2__VoidReply (462)
/* complex XML schema type 'ns2:VoidReply': */
class SOAP_CMAC ns2__VoidReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:currency' of XML schema type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:reversalSubmitted' of XML schema type 'ns2:boolean'
        std::string *reversalSubmitted;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VoidReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__VoidReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VoidReply, default initialized and not managed by a soap context
        virtual ns2__VoidReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__VoidReply); }
      public:
        /// Constructor with default initializations
        ns2__VoidReply() : reasonCode(), requestDateTime(), amount(), currency(), reversalSubmitted(), soap() { }
        virtual ~ns2__VoidReply() { }
        /// Friend allocator used by soap_new_ns2__VoidReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__VoidReply * SOAP_FMAC2 soap_instantiate_ns2__VoidReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:536 */
#ifndef SOAP_TYPE_ns2__PinlessDebitReply
#define SOAP_TYPE_ns2__PinlessDebitReply (463)
/* complex XML schema type 'ns2:PinlessDebitReply': */
class SOAP_CMAC ns2__PinlessDebitReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:authorizationCode' of XML schema type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:receiptNumber' of XML schema type 'xsd:string'
        std::string *receiptNumber;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:ownerMerchantID' of XML schema type 'xsd:string'
        std::string *ownerMerchantID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinlessDebitReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PinlessDebitReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinlessDebitReply, default initialized and not managed by a soap context
        virtual ns2__PinlessDebitReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PinlessDebitReply); }
      public:
        /// Constructor with default initializations
        ns2__PinlessDebitReply() : reasonCode(), amount(), authorizationCode(), requestDateTime(), processorResponse(), receiptNumber(), reconciliationID(), ownerMerchantID(), soap() { }
        virtual ~ns2__PinlessDebitReply() { }
        /// Friend allocator used by soap_new_ns2__PinlessDebitReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinlessDebitReply * SOAP_FMAC2 soap_instantiate_ns2__PinlessDebitReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:538 */
#ifndef SOAP_TYPE_ns2__PinlessDebitValidateReply
#define SOAP_TYPE_ns2__PinlessDebitValidateReply (464)
/* complex XML schema type 'ns2:PinlessDebitValidateReply': */
class SOAP_CMAC ns2__PinlessDebitValidateReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:status' of XML schema type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinlessDebitValidateReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PinlessDebitValidateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinlessDebitValidateReply, default initialized and not managed by a soap context
        virtual ns2__PinlessDebitValidateReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PinlessDebitValidateReply); }
      public:
        /// Constructor with default initializations
        ns2__PinlessDebitValidateReply() : reasonCode(), status(), requestDateTime(), soap() { }
        virtual ~ns2__PinlessDebitValidateReply() { }
        /// Friend allocator used by soap_new_ns2__PinlessDebitValidateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinlessDebitValidateReply * SOAP_FMAC2 soap_instantiate_ns2__PinlessDebitValidateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:540 */
#ifndef SOAP_TYPE_ns2__PinlessDebitReversalReply
#define SOAP_TYPE_ns2__PinlessDebitReversalReply (465)
/* complex XML schema type 'ns2:PinlessDebitReversalReply': */
class SOAP_CMAC ns2__PinlessDebitReversalReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinlessDebitReversalReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PinlessDebitReversalReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinlessDebitReversalReply, default initialized and not managed by a soap context
        virtual ns2__PinlessDebitReversalReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PinlessDebitReversalReply); }
      public:
        /// Constructor with default initializations
        ns2__PinlessDebitReversalReply() : reasonCode(), amount(), requestDateTime(), processorResponse(), reconciliationID(), soap() { }
        virtual ~ns2__PinlessDebitReversalReply() { }
        /// Friend allocator used by soap_new_ns2__PinlessDebitReversalReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinlessDebitReversalReply * SOAP_FMAC2 soap_instantiate_ns2__PinlessDebitReversalReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:542 */
#ifndef SOAP_TYPE_ns2__PayPalButtonCreateReply
#define SOAP_TYPE_ns2__PayPalButtonCreateReply (466)
/* complex XML schema type 'ns2:PayPalButtonCreateReply': */
class SOAP_CMAC ns2__PayPalButtonCreateReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:encryptedFormData' of XML schema type 'xsd:string'
        std::string *encryptedFormData;
        /// Optional element 'ns2:unencryptedFormData' of XML schema type 'xsd:string'
        std::string *unencryptedFormData;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:buttonType' of XML schema type 'xsd:string'
        std::string *buttonType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalButtonCreateReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalButtonCreateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalButtonCreateReply, default initialized and not managed by a soap context
        virtual ns2__PayPalButtonCreateReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalButtonCreateReply); }
      public:
        /// Constructor with default initializations
        ns2__PayPalButtonCreateReply() : reasonCode(), encryptedFormData(), unencryptedFormData(), requestDateTime(), reconciliationID(), buttonType(), soap() { }
        virtual ~ns2__PayPalButtonCreateReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalButtonCreateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalButtonCreateReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalButtonCreateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:544 */
#ifndef SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply
#define SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply (467)
/* complex XML schema type 'ns2:PayPalPreapprovedPaymentReply': */
class SOAP_CMAC ns2__PayPalPreapprovedPaymentReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:payerStatus' of XML schema type 'xsd:string'
        std::string *payerStatus;
        /// Optional element 'ns2:payerName' of XML schema type 'xsd:string'
        std::string *payerName;
        /// Optional element 'ns2:transactionType' of XML schema type 'xsd:string'
        std::string *transactionType;
        /// Optional element 'ns2:feeAmount' of XML schema type 'xsd:string'
        std::string *feeAmount;
        /// Optional element 'ns2:payerCountry' of XML schema type 'xsd:string'
        std::string *payerCountry;
        /// Optional element 'ns2:pendingReason' of XML schema type 'xsd:string'
        std::string *pendingReason;
        /// Optional element 'ns2:paymentStatus' of XML schema type 'xsd:string'
        std::string *paymentStatus;
        /// Optional element 'ns2:mpStatus' of XML schema type 'xsd:string'
        std::string *mpStatus;
        /// Optional element 'ns2:payer' of XML schema type 'xsd:string'
        std::string *payer;
        /// Optional element 'ns2:payerID' of XML schema type 'xsd:string'
        std::string *payerID;
        /// Optional element 'ns2:payerBusiness' of XML schema type 'xsd:string'
        std::string *payerBusiness;
        /// Optional element 'ns2:transactionID' of XML schema type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:desc' of XML schema type 'xsd:string'
        std::string *desc;
        /// Optional element 'ns2:mpMax' of XML schema type 'xsd:string'
        std::string *mpMax;
        /// Optional element 'ns2:paymentType' of XML schema type 'xsd:string'
        std::string *paymentType;
        /// Optional element 'ns2:paymentDate' of XML schema type 'xsd:string'
        std::string *paymentDate;
        /// Optional element 'ns2:paymentGrossAmount' of XML schema type 'xsd:string'
        std::string *paymentGrossAmount;
        /// Optional element 'ns2:settleAmount' of XML schema type 'xsd:string'
        std::string *settleAmount;
        /// Optional element 'ns2:taxAmount' of XML schema type 'xsd:string'
        std::string *taxAmount;
        /// Optional element 'ns2:exchangeRate' of XML schema type 'xsd:string'
        std::string *exchangeRate;
        /// Optional element 'ns2:paymentSourceID' of XML schema type 'xsd:string'
        std::string *paymentSourceID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalPreapprovedPaymentReply, default initialized and not managed by a soap context
        virtual ns2__PayPalPreapprovedPaymentReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalPreapprovedPaymentReply); }
      public:
        /// Constructor with default initializations
        ns2__PayPalPreapprovedPaymentReply() : reasonCode(), requestDateTime(), reconciliationID(), payerStatus(), payerName(), transactionType(), feeAmount(), payerCountry(), pendingReason(), paymentStatus(), mpStatus(), payer(), payerID(), payerBusiness(), transactionID(), desc(), mpMax(), paymentType(), paymentDate(), paymentGrossAmount(), settleAmount(), taxAmount(), exchangeRate(), paymentSourceID(), soap() { }
        virtual ~ns2__PayPalPreapprovedPaymentReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalPreapprovedPaymentReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalPreapprovedPaymentReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalPreapprovedPaymentReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:546 */
#ifndef SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply
#define SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply (468)
/* complex XML schema type 'ns2:PayPalPreapprovedUpdateReply': */
class SOAP_CMAC ns2__PayPalPreapprovedUpdateReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:payerStatus' of XML schema type 'xsd:string'
        std::string *payerStatus;
        /// Optional element 'ns2:payerName' of XML schema type 'xsd:string'
        std::string *payerName;
        /// Optional element 'ns2:payerCountry' of XML schema type 'xsd:string'
        std::string *payerCountry;
        /// Optional element 'ns2:mpStatus' of XML schema type 'xsd:string'
        std::string *mpStatus;
        /// Optional element 'ns2:payer' of XML schema type 'xsd:string'
        std::string *payer;
        /// Optional element 'ns2:payerID' of XML schema type 'xsd:string'
        std::string *payerID;
        /// Optional element 'ns2:payerBusiness' of XML schema type 'xsd:string'
        std::string *payerBusiness;
        /// Optional element 'ns2:desc' of XML schema type 'xsd:string'
        std::string *desc;
        /// Optional element 'ns2:mpMax' of XML schema type 'xsd:string'
        std::string *mpMax;
        /// Optional element 'ns2:paymentSourceID' of XML schema type 'xsd:string'
        std::string *paymentSourceID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalPreapprovedUpdateReply, default initialized and not managed by a soap context
        virtual ns2__PayPalPreapprovedUpdateReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalPreapprovedUpdateReply); }
      public:
        /// Constructor with default initializations
        ns2__PayPalPreapprovedUpdateReply() : reasonCode(), requestDateTime(), reconciliationID(), payerStatus(), payerName(), payerCountry(), mpStatus(), payer(), payerID(), payerBusiness(), desc(), mpMax(), paymentSourceID(), soap() { }
        virtual ~ns2__PayPalPreapprovedUpdateReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalPreapprovedUpdateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalPreapprovedUpdateReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalPreapprovedUpdateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:548 */
#ifndef SOAP_TYPE_ns2__PayPalEcSetReply
#define SOAP_TYPE_ns2__PayPalEcSetReply (469)
/* complex XML schema type 'ns2:PayPalEcSetReply': */
class SOAP_CMAC ns2__PayPalEcSetReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:paypalToken' of XML schema type 'xsd:string'
        std::string *paypalToken;
        /// Optional element 'ns2:amount' of XML schema type 'xsd:string'
        std::string *amount;
        /// Optional element 'ns2:currency' of XML schema type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:correlationID' of XML schema type 'xsd:string'
        std::string *correlationID;
        /// Optional element 'ns2:errorCode' of XML schema type 'xsd:string'
        std::string *errorCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalEcSetReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalEcSetReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalEcSetReply, default initialized and not managed by a soap context
        virtual ns2__PayPalEcSetReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalEcSetReply); }
      public:
        /// Constructor with default initializations
        ns2__PayPalEcSetReply() : reasonCode(), paypalToken(), amount(), currency(), correlationID(), errorCode(), soap() { }
        virtual ~ns2__PayPalEcSetReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalEcSetReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalEcSetReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcSetReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:550 */
#ifndef SOAP_TYPE_ns2__PayPalEcGetDetailsReply
#define SOAP_TYPE_ns2__PayPalEcGetDetailsReply (470)
/* complex XML schema type 'ns2:PayPalEcGetDetailsReply': */
class SOAP_CMAC ns2__PayPalEcGetDetailsReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:paypalToken' of XML schema type 'xsd:string'
        std::string *paypalToken;
        /// Optional element 'ns2:payer' of XML schema type 'xsd:string'
        std::string *payer;
        /// Optional element 'ns2:payerId' of XML schema type 'xsd:string'
        std::string *payerId;
        /// Optional element 'ns2:payerStatus' of XML schema type 'xsd:string'
        std::string *payerStatus;
        /// Optional element 'ns2:payerSalutation' of XML schema type 'xsd:string'
        std::string *payerSalutation;
        /// Optional element 'ns2:payerFirstname' of XML schema type 'xsd:string'
        std::string *payerFirstname;
        /// Optional element 'ns2:payerMiddlename' of XML schema type 'xsd:string'
        std::string *payerMiddlename;
        /// Optional element 'ns2:payerLastname' of XML schema type 'xsd:string'
        std::string *payerLastname;
        /// Optional element 'ns2:payerSuffix' of XML schema type 'xsd:string'
        std::string *payerSuffix;
        /// Optional element 'ns2:payerCountry' of XML schema type 'xsd:string'
        std::string *payerCountry;
        /// Optional element 'ns2:payerBusiness' of XML schema type 'xsd:string'
        std::string *payerBusiness;
        /// Optional element 'ns2:shipToName' of XML schema type 'xsd:string'
        std::string *shipToName;
        /// Optional element 'ns2:shipToAddress1' of XML schema type 'xsd:string'
        std::string *shipToAddress1;
        /// Optional element 'ns2:shipToAddress2' of XML schema type 'xsd:string'
        std::string *shipToAddress2;
        /// Optional element 'ns2:shipToCity' of XML schema type 'xsd:string'
        std::string *shipToCity;
        /// Optional element 'ns2:shipToState' of XML schema type 'xsd:string'
        std::string *shipToState;
        /// Optional element 'ns2:shipToCountry' of XML schema type 'xsd:string'
        std::string *shipToCountry;
        /// Optional element 'ns2:shipToZip' of XML schema type 'xsd:string'
        std::string *shipToZip;
        /// Optional element 'ns2:addressStatus' of XML schema type 'xsd:string'
        std::string *addressStatus;
        /// Optional element 'ns2:payerPhone' of XML schema type 'xsd:string'
        std::string *payerPhone;
        /// Optional element 'ns2:avsCode' of XML schema type 'xsd:string'
        std::string *avsCode;
        /// Optional element 'ns2:street1' of XML schema type 'xsd:string'
        std::string *street1;
        /// Optional element 'ns2:street2' of XML schema type 'xsd:string'
        std::string *street2;
        /// Optional element 'ns2:city' of XML schema type 'xsd:string'
        std::string *city;
        /// Optional element 'ns2:state' of XML schema type 'xsd:string'
        std::string *state;
        /// Optional element 'ns2:postalCode' of XML schema type 'xsd:string'
        std::string *postalCode;
        /// Optional element 'ns2:countryCode' of XML schema type 'xsd:string'
        std::string *countryCode;
        /// Optional element 'ns2:countryName' of XML schema type 'xsd:string'
        std::string *countryName;
        /// Optional element 'ns2:addressID' of XML schema type 'xsd:string'
        std::string *addressID;
        /// Optional element 'ns2:errorCode' of XML schema type 'xsd:string'
        std::string *errorCode;
        /// Optional element 'ns2:correlationID' of XML schema type 'xsd:string'
        std::string *correlationID;
        /// Optional element 'ns2:paypalBillingAgreementAcceptedStatus' of XML schema type 'xsd:string'
        std::string *paypalBillingAgreementAcceptedStatus;
        /// Optional element 'ns2:paypalTaxAmount' of XML schema type 'xsd:string'
        std::string *paypalTaxAmount;
        /// Sequence of 0 to 1000 elements 'ns2:item' of XML schema type 'ns2:Item'
        std::vector<ns2__Item> item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalEcGetDetailsReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalEcGetDetailsReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalEcGetDetailsReply, default initialized and not managed by a soap context
        virtual ns2__PayPalEcGetDetailsReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalEcGetDetailsReply); }
      public:
        /// Constructor with default initializations
        ns2__PayPalEcGetDetailsReply() : reasonCode(), paypalToken(), payer(), payerId(), payerStatus(), payerSalutation(), payerFirstname(), payerMiddlename(), payerLastname(), payerSuffix(), payerCountry(), payerBusiness(), shipToName(), shipToAddress1(), shipToAddress2(), shipToCity(), shipToState(), shipToCountry(), shipToZip(), addressStatus(), payerPhone(), avsCode(), street1(), street2(), city(), state(), postalCode(), countryCode(), countryName(), addressID(), errorCode(), correlationID(), paypalBillingAgreementAcceptedStatus(), paypalTaxAmount(), item(), soap() { }
        virtual ~ns2__PayPalEcGetDetailsReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalEcGetDetailsReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalEcGetDetailsReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcGetDetailsReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:552 */
#ifndef SOAP_TYPE_ns2__PayPalEcDoPaymentReply
#define SOAP_TYPE_ns2__PayPalEcDoPaymentReply (471)
/* complex XML schema type 'ns2:PayPalEcDoPaymentReply': */
class SOAP_CMAC ns2__PayPalEcDoPaymentReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:paypalToken' of XML schema type 'xsd:string'
        std::string *paypalToken;
        /// Optional element 'ns2:transactionId' of XML schema type 'xsd:string'
        std::string *transactionId;
        /// Optional element 'ns2:paypalTransactiontype' of XML schema type 'xsd:string'
        std::string *paypalTransactiontype;
        /// Optional element 'ns2:paymentType' of XML schema type 'xsd:string'
        std::string *paymentType;
        /// Optional element 'ns2:paypalOrderTime' of XML schema type 'xsd:string'
        std::string *paypalOrderTime;
        /// Optional element 'ns2:paypalAmount' of XML schema type 'xsd:string'
        std::string *paypalAmount;
        /// Optional element 'ns2:paypalFeeAmount' of XML schema type 'xsd:string'
        std::string *paypalFeeAmount;
        /// Optional element 'ns2:paypalTaxAmount' of XML schema type 'xsd:string'
        std::string *paypalTaxAmount;
        /// Optional element 'ns2:paypalExchangeRate' of XML schema type 'xsd:string'
        std::string *paypalExchangeRate;
        /// Optional element 'ns2:paypalPaymentStatus' of XML schema type 'xsd:string'
        std::string *paypalPaymentStatus;
        /// Optional element 'ns2:paypalPendingReason' of XML schema type 'xsd:string'
        std::string *paypalPendingReason;
        /// Optional element 'ns2:orderId' of XML schema type 'xsd:string'
        std::string *orderId;
        /// Optional element 'ns2:paypalReasonCode' of XML schema type 'xsd:string'
        std::string *paypalReasonCode;
        /// Optional element 'ns2:amount' of XML schema type 'xsd:string'
        std::string *amount;
        /// Optional element 'ns2:currency' of XML schema type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:correlationID' of XML schema type 'xsd:string'
        std::string *correlationID;
        /// Optional element 'ns2:errorCode' of XML schema type 'xsd:string'
        std::string *errorCode;
        /// Optional element 'ns2:paypalBillingAgreementId' of XML schema type 'xsd:string'
        std::string *paypalBillingAgreementId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalEcDoPaymentReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalEcDoPaymentReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalEcDoPaymentReply, default initialized and not managed by a soap context
        virtual ns2__PayPalEcDoPaymentReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalEcDoPaymentReply); }
      public:
        /// Constructor with default initializations
        ns2__PayPalEcDoPaymentReply() : reasonCode(), paypalToken(), transactionId(), paypalTransactiontype(), paymentType(), paypalOrderTime(), paypalAmount(), paypalFeeAmount(), paypalTaxAmount(), paypalExchangeRate(), paypalPaymentStatus(), paypalPendingReason(), orderId(), paypalReasonCode(), amount(), currency(), correlationID(), errorCode(), paypalBillingAgreementId(), soap() { }
        virtual ~ns2__PayPalEcDoPaymentReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalEcDoPaymentReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalEcDoPaymentReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcDoPaymentReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:554 */
#ifndef SOAP_TYPE_ns2__PayPalDoCaptureReply
#define SOAP_TYPE_ns2__PayPalDoCaptureReply (472)
/* complex XML schema type 'ns2:PayPalDoCaptureReply': */
class SOAP_CMAC ns2__PayPalDoCaptureReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:authorizationId' of XML schema type 'xsd:string'
        std::string *authorizationId;
        /// Optional element 'ns2:transactionId' of XML schema type 'xsd:string'
        std::string *transactionId;
        /// Optional element 'ns2:parentTransactionId' of XML schema type 'xsd:string'
        std::string *parentTransactionId;
        /// Optional element 'ns2:paypalReceiptId' of XML schema type 'xsd:string'
        std::string *paypalReceiptId;
        /// Optional element 'ns2:paypalTransactiontype' of XML schema type 'xsd:string'
        std::string *paypalTransactiontype;
        /// Optional element 'ns2:paypalPaymentType' of XML schema type 'xsd:string'
        std::string *paypalPaymentType;
        /// Optional element 'ns2:paypalOrderTime' of XML schema type 'xsd:string'
        std::string *paypalOrderTime;
        /// Optional element 'ns2:paypalPaymentGrossAmount' of XML schema type 'xsd:string'
        std::string *paypalPaymentGrossAmount;
        /// Optional element 'ns2:paypalFeeAmount' of XML schema type 'xsd:string'
        std::string *paypalFeeAmount;
        /// Optional element 'ns2:paypalTaxAmount' of XML schema type 'xsd:string'
        std::string *paypalTaxAmount;
        /// Optional element 'ns2:paypalExchangeRate' of XML schema type 'xsd:string'
        std::string *paypalExchangeRate;
        /// Optional element 'ns2:paypalPaymentStatus' of XML schema type 'xsd:string'
        std::string *paypalPaymentStatus;
        /// Optional element 'ns2:amount' of XML schema type 'xsd:string'
        std::string *amount;
        /// Optional element 'ns2:currency' of XML schema type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:correlationID' of XML schema type 'xsd:string'
        std::string *correlationID;
        /// Optional element 'ns2:errorCode' of XML schema type 'xsd:string'
        std::string *errorCode;
        /// Optional element 'ns2:paypalPendingReason' of XML schema type 'xsd:string'
        std::string *paypalPendingReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalDoCaptureReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalDoCaptureReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalDoCaptureReply, default initialized and not managed by a soap context
        virtual ns2__PayPalDoCaptureReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalDoCaptureReply); }
      public:
        /// Constructor with default initializations
        ns2__PayPalDoCaptureReply() : reasonCode(), authorizationId(), transactionId(), parentTransactionId(), paypalReceiptId(), paypalTransactiontype(), paypalPaymentType(), paypalOrderTime(), paypalPaymentGrossAmount(), paypalFeeAmount(), paypalTaxAmount(), paypalExchangeRate(), paypalPaymentStatus(), amount(), currency(), correlationID(), errorCode(), paypalPendingReason(), soap() { }
        virtual ~ns2__PayPalDoCaptureReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalDoCaptureReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalDoCaptureReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalDoCaptureReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:556 */
#ifndef SOAP_TYPE_ns2__PayPalAuthReversalReply
#define SOAP_TYPE_ns2__PayPalAuthReversalReply (473)
/* complex XML schema type 'ns2:PayPalAuthReversalReply': */
class SOAP_CMAC ns2__PayPalAuthReversalReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:authorizationId' of XML schema type 'xsd:string'
        std::string *authorizationId;
        /// Optional element 'ns2:correlationID' of XML schema type 'xsd:string'
        std::string *correlationID;
        /// Optional element 'ns2:errorCode' of XML schema type 'xsd:string'
        std::string *errorCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalAuthReversalReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalAuthReversalReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalAuthReversalReply, default initialized and not managed by a soap context
        virtual ns2__PayPalAuthReversalReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalAuthReversalReply); }
      public:
        /// Constructor with default initializations
        ns2__PayPalAuthReversalReply() : reasonCode(), authorizationId(), correlationID(), errorCode(), soap() { }
        virtual ~ns2__PayPalAuthReversalReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalAuthReversalReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalAuthReversalReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalAuthReversalReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:558 */
#ifndef SOAP_TYPE_ns2__PayPalRefundReply
#define SOAP_TYPE_ns2__PayPalRefundReply (474)
/* complex XML schema type 'ns2:PayPalRefundReply': */
class SOAP_CMAC ns2__PayPalRefundReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:transactionId' of XML schema type 'xsd:string'
        std::string *transactionId;
        /// Optional element 'ns2:paypalNetRefundAmount' of XML schema type 'xsd:string'
        std::string *paypalNetRefundAmount;
        /// Optional element 'ns2:paypalFeeRefundAmount' of XML schema type 'xsd:string'
        std::string *paypalFeeRefundAmount;
        /// Optional element 'ns2:paypalGrossRefundAmount' of XML schema type 'xsd:string'
        std::string *paypalGrossRefundAmount;
        /// Optional element 'ns2:correlationID' of XML schema type 'xsd:string'
        std::string *correlationID;
        /// Optional element 'ns2:errorCode' of XML schema type 'xsd:string'
        std::string *errorCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalRefundReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalRefundReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalRefundReply, default initialized and not managed by a soap context
        virtual ns2__PayPalRefundReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalRefundReply); }
      public:
        /// Constructor with default initializations
        ns2__PayPalRefundReply() : reasonCode(), transactionId(), paypalNetRefundAmount(), paypalFeeRefundAmount(), paypalGrossRefundAmount(), correlationID(), errorCode(), soap() { }
        virtual ~ns2__PayPalRefundReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalRefundReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalRefundReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalRefundReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:560 */
#ifndef SOAP_TYPE_ns2__PayPalEcOrderSetupReply
#define SOAP_TYPE_ns2__PayPalEcOrderSetupReply (475)
/* complex XML schema type 'ns2:PayPalEcOrderSetupReply': */
class SOAP_CMAC ns2__PayPalEcOrderSetupReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:paypalToken' of XML schema type 'xsd:string'
        std::string *paypalToken;
        /// Optional element 'ns2:transactionId' of XML schema type 'xsd:string'
        std::string *transactionId;
        /// Optional element 'ns2:paypalTransactiontype' of XML schema type 'xsd:string'
        std::string *paypalTransactiontype;
        /// Optional element 'ns2:paymentType' of XML schema type 'xsd:string'
        std::string *paymentType;
        /// Optional element 'ns2:paypalOrderTime' of XML schema type 'xsd:string'
        std::string *paypalOrderTime;
        /// Optional element 'ns2:paypalAmount' of XML schema type 'xsd:string'
        std::string *paypalAmount;
        /// Optional element 'ns2:paypalFeeAmount' of XML schema type 'xsd:string'
        std::string *paypalFeeAmount;
        /// Optional element 'ns2:paypalTaxAmount' of XML schema type 'xsd:string'
        std::string *paypalTaxAmount;
        /// Optional element 'ns2:paypalExchangeRate' of XML schema type 'xsd:string'
        std::string *paypalExchangeRate;
        /// Optional element 'ns2:paypalPaymentStatus' of XML schema type 'xsd:string'
        std::string *paypalPaymentStatus;
        /// Optional element 'ns2:paypalPendingReason' of XML schema type 'xsd:string'
        std::string *paypalPendingReason;
        /// Optional element 'ns2:paypalReasonCode' of XML schema type 'xsd:string'
        std::string *paypalReasonCode;
        /// Optional element 'ns2:amount' of XML schema type 'xsd:string'
        std::string *amount;
        /// Optional element 'ns2:currency' of XML schema type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:correlationID' of XML schema type 'xsd:string'
        std::string *correlationID;
        /// Optional element 'ns2:errorCode' of XML schema type 'xsd:string'
        std::string *errorCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalEcOrderSetupReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalEcOrderSetupReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalEcOrderSetupReply, default initialized and not managed by a soap context
        virtual ns2__PayPalEcOrderSetupReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalEcOrderSetupReply); }
      public:
        /// Constructor with default initializations
        ns2__PayPalEcOrderSetupReply() : reasonCode(), paypalToken(), transactionId(), paypalTransactiontype(), paymentType(), paypalOrderTime(), paypalAmount(), paypalFeeAmount(), paypalTaxAmount(), paypalExchangeRate(), paypalPaymentStatus(), paypalPendingReason(), paypalReasonCode(), amount(), currency(), correlationID(), errorCode(), soap() { }
        virtual ~ns2__PayPalEcOrderSetupReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalEcOrderSetupReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalEcOrderSetupReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcOrderSetupReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:562 */
#ifndef SOAP_TYPE_ns2__PayPalAuthorizationReply
#define SOAP_TYPE_ns2__PayPalAuthorizationReply (476)
/* complex XML schema type 'ns2:PayPalAuthorizationReply': */
class SOAP_CMAC ns2__PayPalAuthorizationReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:transactionId' of XML schema type 'xsd:string'
        std::string *transactionId;
        /// Optional element 'ns2:paypalAmount' of XML schema type 'xsd:string'
        std::string *paypalAmount;
        /// Optional element 'ns2:amount' of XML schema type 'xsd:string'
        std::string *amount;
        /// Optional element 'ns2:currency' of XML schema type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:correlationID' of XML schema type 'xsd:string'
        std::string *correlationID;
        /// Optional element 'ns2:errorCode' of XML schema type 'xsd:string'
        std::string *errorCode;
        /// Optional element 'ns2:protectionEligibility' of XML schema type 'xsd:string'
        std::string *protectionEligibility;
        /// Optional element 'ns2:protectionEligibilityType' of XML schema type 'xsd:string'
        std::string *protectionEligibilityType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalAuthorizationReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalAuthorizationReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalAuthorizationReply, default initialized and not managed by a soap context
        virtual ns2__PayPalAuthorizationReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalAuthorizationReply); }
      public:
        /// Constructor with default initializations
        ns2__PayPalAuthorizationReply() : reasonCode(), transactionId(), paypalAmount(), amount(), currency(), correlationID(), errorCode(), protectionEligibility(), protectionEligibilityType(), soap() { }
        virtual ~ns2__PayPalAuthorizationReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalAuthorizationReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalAuthorizationReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalAuthorizationReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:564 */
#ifndef SOAP_TYPE_ns2__PayPalUpdateAgreementReply
#define SOAP_TYPE_ns2__PayPalUpdateAgreementReply (477)
/* complex XML schema type 'ns2:PayPalUpdateAgreementReply': */
class SOAP_CMAC ns2__PayPalUpdateAgreementReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:paypalBillingAgreementId' of XML schema type 'xsd:string'
        std::string *paypalBillingAgreementId;
        /// Optional element 'ns2:paypalBillingAgreementDesc' of XML schema type 'xsd:string'
        std::string *paypalBillingAgreementDesc;
        /// Optional element 'ns2:paypalBillingAgreementCustom' of XML schema type 'xsd:string'
        std::string *paypalBillingAgreementCustom;
        /// Optional element 'ns2:paypalBillingAgreementStatus' of XML schema type 'xsd:string'
        std::string *paypalBillingAgreementStatus;
        /// Optional element 'ns2:payer' of XML schema type 'xsd:string'
        std::string *payer;
        /// Optional element 'ns2:payerId' of XML schema type 'xsd:string'
        std::string *payerId;
        /// Optional element 'ns2:payerStatus' of XML schema type 'xsd:string'
        std::string *payerStatus;
        /// Optional element 'ns2:payerCountry' of XML schema type 'xsd:string'
        std::string *payerCountry;
        /// Optional element 'ns2:payerBusiness' of XML schema type 'xsd:string'
        std::string *payerBusiness;
        /// Optional element 'ns2:payerSalutation' of XML schema type 'xsd:string'
        std::string *payerSalutation;
        /// Optional element 'ns2:payerFirstname' of XML schema type 'xsd:string'
        std::string *payerFirstname;
        /// Optional element 'ns2:payerMiddlename' of XML schema type 'xsd:string'
        std::string *payerMiddlename;
        /// Optional element 'ns2:payerLastname' of XML schema type 'xsd:string'
        std::string *payerLastname;
        /// Optional element 'ns2:payerSuffix' of XML schema type 'xsd:string'
        std::string *payerSuffix;
        /// Optional element 'ns2:addressStatus' of XML schema type 'xsd:string'
        std::string *addressStatus;
        /// Optional element 'ns2:errorCode' of XML schema type 'xsd:string'
        std::string *errorCode;
        /// Optional element 'ns2:correlationID' of XML schema type 'xsd:string'
        std::string *correlationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalUpdateAgreementReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalUpdateAgreementReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalUpdateAgreementReply, default initialized and not managed by a soap context
        virtual ns2__PayPalUpdateAgreementReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalUpdateAgreementReply); }
      public:
        /// Constructor with default initializations
        ns2__PayPalUpdateAgreementReply() : reasonCode(), paypalBillingAgreementId(), paypalBillingAgreementDesc(), paypalBillingAgreementCustom(), paypalBillingAgreementStatus(), payer(), payerId(), payerStatus(), payerCountry(), payerBusiness(), payerSalutation(), payerFirstname(), payerMiddlename(), payerLastname(), payerSuffix(), addressStatus(), errorCode(), correlationID(), soap() { }
        virtual ~ns2__PayPalUpdateAgreementReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalUpdateAgreementReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalUpdateAgreementReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalUpdateAgreementReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:566 */
#ifndef SOAP_TYPE_ns2__PayPalCreateAgreementReply
#define SOAP_TYPE_ns2__PayPalCreateAgreementReply (478)
/* complex XML schema type 'ns2:PayPalCreateAgreementReply': */
class SOAP_CMAC ns2__PayPalCreateAgreementReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:paypalBillingAgreementId' of XML schema type 'xsd:string'
        std::string *paypalBillingAgreementId;
        /// Optional element 'ns2:errorCode' of XML schema type 'xsd:string'
        std::string *errorCode;
        /// Optional element 'ns2:correlationID' of XML schema type 'xsd:string'
        std::string *correlationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalCreateAgreementReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalCreateAgreementReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalCreateAgreementReply, default initialized and not managed by a soap context
        virtual ns2__PayPalCreateAgreementReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalCreateAgreementReply); }
      public:
        /// Constructor with default initializations
        ns2__PayPalCreateAgreementReply() : reasonCode(), paypalBillingAgreementId(), errorCode(), correlationID(), soap() { }
        virtual ~ns2__PayPalCreateAgreementReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalCreateAgreementReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalCreateAgreementReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalCreateAgreementReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:568 */
#ifndef SOAP_TYPE_ns2__PayPalDoRefTransactionReply
#define SOAP_TYPE_ns2__PayPalDoRefTransactionReply (479)
/* complex XML schema type 'ns2:PayPalDoRefTransactionReply': */
class SOAP_CMAC ns2__PayPalDoRefTransactionReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:paypalBillingAgreementId' of XML schema type 'xsd:string'
        std::string *paypalBillingAgreementId;
        /// Optional element 'ns2:transactionId' of XML schema type 'xsd:string'
        std::string *transactionId;
        /// Optional element 'ns2:paypalTransactionType' of XML schema type 'xsd:string'
        std::string *paypalTransactionType;
        /// Optional element 'ns2:paypalPaymentType' of XML schema type 'xsd:string'
        std::string *paypalPaymentType;
        /// Optional element 'ns2:paypalOrderTime' of XML schema type 'xsd:string'
        std::string *paypalOrderTime;
        /// Optional element 'ns2:paypalAmount' of XML schema type 'xsd:string'
        std::string *paypalAmount;
        /// Optional element 'ns2:currency' of XML schema type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:paypalTaxAmount' of XML schema type 'xsd:string'
        std::string *paypalTaxAmount;
        /// Optional element 'ns2:paypalExchangeRate' of XML schema type 'xsd:string'
        std::string *paypalExchangeRate;
        /// Optional element 'ns2:paypalPaymentStatus' of XML schema type 'xsd:string'
        std::string *paypalPaymentStatus;
        /// Optional element 'ns2:paypalPendingReason' of XML schema type 'xsd:string'
        std::string *paypalPendingReason;
        /// Optional element 'ns2:paypalReasonCode' of XML schema type 'xsd:string'
        std::string *paypalReasonCode;
        /// Optional element 'ns2:errorCode' of XML schema type 'xsd:string'
        std::string *errorCode;
        /// Optional element 'ns2:correlationID' of XML schema type 'xsd:string'
        std::string *correlationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalDoRefTransactionReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalDoRefTransactionReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalDoRefTransactionReply, default initialized and not managed by a soap context
        virtual ns2__PayPalDoRefTransactionReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalDoRefTransactionReply); }
      public:
        /// Constructor with default initializations
        ns2__PayPalDoRefTransactionReply() : reasonCode(), paypalBillingAgreementId(), transactionId(), paypalTransactionType(), paypalPaymentType(), paypalOrderTime(), paypalAmount(), currency(), paypalTaxAmount(), paypalExchangeRate(), paypalPaymentStatus(), paypalPendingReason(), paypalReasonCode(), errorCode(), correlationID(), soap() { }
        virtual ~ns2__PayPalDoRefTransactionReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalDoRefTransactionReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalDoRefTransactionReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalDoRefTransactionReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:570 */
#ifndef SOAP_TYPE_ns2__RiskUpdateReply
#define SOAP_TYPE_ns2__RiskUpdateReply (480)
/* complex XML schema type 'ns2:RiskUpdateReply': */
class SOAP_CMAC ns2__RiskUpdateReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RiskUpdateReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__RiskUpdateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RiskUpdateReply, default initialized and not managed by a soap context
        virtual ns2__RiskUpdateReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__RiskUpdateReply); }
      public:
        /// Constructor with default initializations
        ns2__RiskUpdateReply() : reasonCode(), soap() { }
        virtual ~ns2__RiskUpdateReply() { }
        /// Friend allocator used by soap_new_ns2__RiskUpdateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__RiskUpdateReply * SOAP_FMAC2 soap_instantiate_ns2__RiskUpdateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:572 */
#ifndef SOAP_TYPE_ns2__FraudUpdateReply
#define SOAP_TYPE_ns2__FraudUpdateReply (481)
/* complex XML schema type 'ns2:FraudUpdateReply': */
class SOAP_CMAC ns2__FraudUpdateReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FraudUpdateReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__FraudUpdateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FraudUpdateReply, default initialized and not managed by a soap context
        virtual ns2__FraudUpdateReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__FraudUpdateReply); }
      public:
        /// Constructor with default initializations
        ns2__FraudUpdateReply() : reasonCode(), soap() { }
        virtual ~ns2__FraudUpdateReply() { }
        /// Friend allocator used by soap_new_ns2__FraudUpdateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__FraudUpdateReply * SOAP_FMAC2 soap_instantiate_ns2__FraudUpdateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:574 */
#ifndef SOAP_TYPE_ns2__CaseManagementActionReply
#define SOAP_TYPE_ns2__CaseManagementActionReply (482)
/* complex XML schema type 'ns2:CaseManagementActionReply': */
class SOAP_CMAC ns2__CaseManagementActionReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CaseManagementActionReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CaseManagementActionReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CaseManagementActionReply, default initialized and not managed by a soap context
        virtual ns2__CaseManagementActionReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CaseManagementActionReply); }
      public:
        /// Constructor with default initializations
        ns2__CaseManagementActionReply() : reasonCode(), soap() { }
        virtual ~ns2__CaseManagementActionReply() { }
        /// Friend allocator used by soap_new_ns2__CaseManagementActionReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CaseManagementActionReply * SOAP_FMAC2 soap_instantiate_ns2__CaseManagementActionReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:576 */
#ifndef SOAP_TYPE_ns2__RuleResultItem
#define SOAP_TYPE_ns2__RuleResultItem (483)
/* complex XML schema type 'ns2:RuleResultItem': */
class SOAP_CMAC ns2__RuleResultItem {
      public:
        /// Optional element 'ns2:name' of XML schema type 'xsd:string'
        std::string *name;
        /// Optional element 'ns2:decision' of XML schema type 'xsd:string'
        std::string *decision;
        /// Optional element 'ns2:evaluation' of XML schema type 'xsd:string'
        std::string *evaluation;
        /// Optional element 'ns2:ruleID' of XML schema type 'xsd:integer'
        std::string *ruleID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RuleResultItem
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__RuleResultItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RuleResultItem, default initialized and not managed by a soap context
        virtual ns2__RuleResultItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__RuleResultItem); }
      public:
        /// Constructor with default initializations
        ns2__RuleResultItem() : name(), decision(), evaluation(), ruleID(), soap() { }
        virtual ~ns2__RuleResultItem() { }
        /// Friend allocator used by soap_new_ns2__RuleResultItem(struct soap*, int)
        friend SOAP_FMAC1 ns2__RuleResultItem * SOAP_FMAC2 soap_instantiate_ns2__RuleResultItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:578 */
#ifndef SOAP_TYPE_ns2__RuleResultItems
#define SOAP_TYPE_ns2__RuleResultItems (484)
/* complex XML schema type 'ns2:RuleResultItems': */
class SOAP_CMAC ns2__RuleResultItems {
      public:
        /// Sequence of 0 to 1000 elements 'ns2:ruleResultItem' of XML schema type 'ns2:RuleResultItem'
        std::vector<ns2__RuleResultItem> ruleResultItem;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RuleResultItems
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__RuleResultItems; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RuleResultItems, default initialized and not managed by a soap context
        virtual ns2__RuleResultItems *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__RuleResultItems); }
      public:
        /// Constructor with default initializations
        ns2__RuleResultItems() : ruleResultItem(), soap() { }
        virtual ~ns2__RuleResultItems() { }
        /// Friend allocator used by soap_new_ns2__RuleResultItems(struct soap*, int)
        friend SOAP_FMAC1 ns2__RuleResultItems * SOAP_FMAC2 soap_instantiate_ns2__RuleResultItems(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:580 */
#ifndef SOAP_TYPE_ns2__DecisionReply
#define SOAP_TYPE_ns2__DecisionReply (485)
/* complex XML schema type 'ns2:DecisionReply': */
class SOAP_CMAC ns2__DecisionReply {
      public:
        /// Optional element 'ns2:casePriority' of XML schema type 'xsd:integer'
        std::string *casePriority;
        /// Optional element 'ns2:activeProfileReply' of XML schema type 'ns2:ProfileReply'
        ns2__ProfileReply *activeProfileReply;
        /// Optional element 'ns2:velocityInfoCode' of XML schema type 'xsd:string'
        std::string *velocityInfoCode;
        /// Optional element 'ns2:additionalFields' of XML schema type 'ns2:AdditionalFields'
        ns2__AdditionalFields *additionalFields;
        /// Optional element 'ns2:morphingElement' of XML schema type 'ns2:MorphingElement'
        ns2__MorphingElement *morphingElement;
        /// Optional element 'ns2:providerFields' of XML schema type 'ns2:ProviderFields'
        ns2__ProviderFields *providerFields;
        /// Optional element 'ns2:travel' of XML schema type 'ns2:Travel'
        ns2__Travel *travel;
        /// Optional element 'ns2:unavailableInfoCode' of XML schema type 'xsd:string'
        std::string *unavailableInfoCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DecisionReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DecisionReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DecisionReply, default initialized and not managed by a soap context
        virtual ns2__DecisionReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DecisionReply); }
      public:
        /// Constructor with default initializations
        ns2__DecisionReply() : casePriority(), activeProfileReply(), velocityInfoCode(), additionalFields(), morphingElement(), providerFields(), travel(), unavailableInfoCode(), soap() { }
        virtual ~ns2__DecisionReply() { }
        /// Friend allocator used by soap_new_ns2__DecisionReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__DecisionReply * SOAP_FMAC2 soap_instantiate_ns2__DecisionReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:582 */
#ifndef SOAP_TYPE_ns2__ProviderFields
#define SOAP_TYPE_ns2__ProviderFields (486)
/* complex XML schema type 'ns2:ProviderFields': */
class SOAP_CMAC ns2__ProviderFields {
      public:
        /// Sequence of 0 to 30 elements 'ns2:provider' of XML schema type 'ns2:Provider'
        std::vector<ns2__Provider> provider;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ProviderFields
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ProviderFields; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ProviderFields, default initialized and not managed by a soap context
        virtual ns2__ProviderFields *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ProviderFields); }
      public:
        /// Constructor with default initializations
        ns2__ProviderFields() : provider(), soap() { }
        virtual ~ns2__ProviderFields() { }
        /// Friend allocator used by soap_new_ns2__ProviderFields(struct soap*, int)
        friend SOAP_FMAC1 ns2__ProviderFields * SOAP_FMAC2 soap_instantiate_ns2__ProviderFields(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:584 */
#ifndef SOAP_TYPE_ns2__Provider
#define SOAP_TYPE_ns2__Provider (487)
/* complex XML schema type 'ns2:Provider': */
class SOAP_CMAC ns2__Provider {
      public:
        /// Required element 'ns2:name' of XML schema type 'xsd:string'
        std::string name;
        /// Sequence of 0 to 500 elements 'ns2:field' of XML schema type 'ns2:ProviderField'
        std::vector<ns2__ProviderField> field;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Provider
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Provider; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Provider, default initialized and not managed by a soap context
        virtual ns2__Provider *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Provider); }
      public:
        /// Constructor with default initializations
        ns2__Provider() : name(), field(), soap() { }
        virtual ~ns2__Provider() { }
        /// Friend allocator used by soap_new_ns2__Provider(struct soap*, int)
        friend SOAP_FMAC1 ns2__Provider * SOAP_FMAC2 soap_instantiate_ns2__Provider(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:586 */
#ifndef SOAP_TYPE_ns2__ProviderField
#define SOAP_TYPE_ns2__ProviderField (488)
/* complex XML schema type 'ns2:ProviderField': */
class SOAP_CMAC ns2__ProviderField {
      public:
        /// Required element 'ns2:name' of XML schema type 'xsd:string'
        std::string name;
        /// Required element 'ns2:value' of XML schema type 'xsd:string'
        std::string value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ProviderField
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ProviderField; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ProviderField, default initialized and not managed by a soap context
        virtual ns2__ProviderField *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ProviderField); }
      public:
        /// Constructor with default initializations
        ns2__ProviderField() : name(), value(), soap() { }
        virtual ~ns2__ProviderField() { }
        /// Friend allocator used by soap_new_ns2__ProviderField(struct soap*, int)
        friend SOAP_FMAC1 ns2__ProviderField * SOAP_FMAC2 soap_instantiate_ns2__ProviderField(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:588 */
#ifndef SOAP_TYPE_ns2__AdditionalFields
#define SOAP_TYPE_ns2__AdditionalFields (489)
/* complex XML schema type 'ns2:AdditionalFields': */
class SOAP_CMAC ns2__AdditionalFields {
      public:
        /// Sequence of 0 to 3000 elements 'ns2:field' of XML schema type 'ns2:Field'
        std::vector<ns2__Field> field;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AdditionalFields
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__AdditionalFields; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AdditionalFields, default initialized and not managed by a soap context
        virtual ns2__AdditionalFields *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__AdditionalFields); }
      public:
        /// Constructor with default initializations
        ns2__AdditionalFields() : field(), soap() { }
        virtual ~ns2__AdditionalFields() { }
        /// Friend allocator used by soap_new_ns2__AdditionalFields(struct soap*, int)
        friend SOAP_FMAC1 ns2__AdditionalFields * SOAP_FMAC2 soap_instantiate_ns2__AdditionalFields(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:590 */
#ifndef SOAP_TYPE_ns2__Field
#define SOAP_TYPE_ns2__Field (490)
/* complex XML schema type 'ns2:Field': */
class SOAP_CMAC ns2__Field {
      public:
        /// Required element 'ns2:provider' of XML schema type 'xsd:string'
        std::string provider;
        /// Required element 'ns2:name' of XML schema type 'xsd:string'
        std::string name;
        /// Required element 'ns2:value' of XML schema type 'xsd:string'
        std::string value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Field
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Field; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Field, default initialized and not managed by a soap context
        virtual ns2__Field *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Field); }
      public:
        /// Constructor with default initializations
        ns2__Field() : provider(), name(), value(), soap() { }
        virtual ~ns2__Field() { }
        /// Friend allocator used by soap_new_ns2__Field(struct soap*, int)
        friend SOAP_FMAC1 ns2__Field * SOAP_FMAC2 soap_instantiate_ns2__Field(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:592 */
#ifndef SOAP_TYPE_ns2__MorphingElement
#define SOAP_TYPE_ns2__MorphingElement (491)
/* complex XML schema type 'ns2:MorphingElement': */
class SOAP_CMAC ns2__MorphingElement {
      public:
        /// Sequence of 0 to 1000 elements 'ns2:element' of XML schema type 'ns2:Element'
        std::vector<ns2__Element> element;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MorphingElement
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__MorphingElement; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MorphingElement, default initialized and not managed by a soap context
        virtual ns2__MorphingElement *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__MorphingElement); }
      public:
        /// Constructor with default initializations
        ns2__MorphingElement() : element(), soap() { }
        virtual ~ns2__MorphingElement() { }
        /// Friend allocator used by soap_new_ns2__MorphingElement(struct soap*, int)
        friend SOAP_FMAC1 ns2__MorphingElement * SOAP_FMAC2 soap_instantiate_ns2__MorphingElement(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:594 */
#ifndef SOAP_TYPE_ns2__Element
#define SOAP_TYPE_ns2__Element (492)
/* complex XML schema type 'ns2:Element': */
class SOAP_CMAC ns2__Element {
      public:
        /// Required element 'ns2:infoCode' of XML schema type 'xsd:string'
        std::string infoCode;
        /// Required element 'ns2:fieldName' of XML schema type 'xsd:string'
        std::string fieldName;
        /// Required element 'ns2:count' of XML schema type 'xsd:integer'
        std::string count;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Element
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Element; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Element, default initialized and not managed by a soap context
        virtual ns2__Element *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Element); }
      public:
        /// Constructor with default initializations
        ns2__Element() : infoCode(), fieldName(), count(), soap() { }
        virtual ~ns2__Element() { }
        /// Friend allocator used by soap_new_ns2__Element(struct soap*, int)
        friend SOAP_FMAC1 ns2__Element * SOAP_FMAC2 soap_instantiate_ns2__Element(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:596 */
#ifndef SOAP_TYPE_ns2__Travel
#define SOAP_TYPE_ns2__Travel (493)
/* complex XML schema type 'ns2:Travel': */
class SOAP_CMAC ns2__Travel {
      public:
        /// Optional element 'ns2:actualFinalDestinationCountry' of XML schema type 'ns2:RestrictedString'
        std::string *actualFinalDestinationCountry;
        /// Optional element 'ns2:actualFinalDestinationCity' of XML schema type 'ns2:RestrictedString'
        std::string *actualFinalDestinationCity;
        /// Optional element 'ns2:actualFinalDestinationLatitude' of XML schema type 'ns2:RestrictedDecimal'
        std::string *actualFinalDestinationLatitude;
        /// Optional element 'ns2:actualFinalDestinationLongitude' of XML schema type 'ns2:RestrictedDecimal'
        std::string *actualFinalDestinationLongitude;
        /// Optional element 'ns2:firstDepartureCountry' of XML schema type 'ns2:RestrictedString'
        std::string *firstDepartureCountry;
        /// Optional element 'ns2:firstDepartureCity' of XML schema type 'ns2:RestrictedString'
        std::string *firstDepartureCity;
        /// Optional element 'ns2:firstDepartureLatitude' of XML schema type 'ns2:RestrictedDecimal'
        std::string *firstDepartureLatitude;
        /// Optional element 'ns2:firstDepartureLongitude' of XML schema type 'ns2:RestrictedDecimal'
        std::string *firstDepartureLongitude;
        /// Optional element 'ns2:firstDestinationCountry' of XML schema type 'ns2:RestrictedString'
        std::string *firstDestinationCountry;
        /// Optional element 'ns2:firstDestinationCity' of XML schema type 'ns2:RestrictedString'
        std::string *firstDestinationCity;
        /// Optional element 'ns2:firstDestinationLatitude' of XML schema type 'ns2:RestrictedDecimal'
        std::string *firstDestinationLatitude;
        /// Optional element 'ns2:firstDestinationLongitude' of XML schema type 'ns2:RestrictedDecimal'
        std::string *firstDestinationLongitude;
        /// Optional element 'ns2:lastDestinationCountry' of XML schema type 'ns2:RestrictedString'
        std::string *lastDestinationCountry;
        /// Optional element 'ns2:lastDestinationCity' of XML schema type 'ns2:RestrictedString'
        std::string *lastDestinationCity;
        /// Optional element 'ns2:lastDestinationLatitude' of XML schema type 'ns2:RestrictedDecimal'
        std::string *lastDestinationLatitude;
        /// Optional element 'ns2:lastDestinationLongitude' of XML schema type 'ns2:RestrictedDecimal'
        std::string *lastDestinationLongitude;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Travel
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Travel; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Travel, default initialized and not managed by a soap context
        virtual ns2__Travel *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Travel); }
      public:
        /// Constructor with default initializations
        ns2__Travel() : actualFinalDestinationCountry(), actualFinalDestinationCity(), actualFinalDestinationLatitude(), actualFinalDestinationLongitude(), firstDepartureCountry(), firstDepartureCity(), firstDepartureLatitude(), firstDepartureLongitude(), firstDestinationCountry(), firstDestinationCity(), firstDestinationLatitude(), firstDestinationLongitude(), lastDestinationCountry(), lastDestinationCity(), lastDestinationLatitude(), lastDestinationLongitude(), soap() { }
        virtual ~ns2__Travel() { }
        /// Friend allocator used by soap_new_ns2__Travel(struct soap*, int)
        friend SOAP_FMAC1 ns2__Travel * SOAP_FMAC2 soap_instantiate_ns2__Travel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:598 */
#ifndef SOAP_TYPE_ns2__DMEReply
#define SOAP_TYPE_ns2__DMEReply (494)
/* complex XML schema type 'ns2:DMEReply': */
class SOAP_CMAC ns2__DMEReply {
      public:
        /// Optional element 'ns2:eventType' of XML schema type 'xsd:string'
        std::string *eventType;
        /// Optional element 'ns2:eventInfo' of XML schema type 'xsd:string'
        std::string *eventInfo;
        /// Optional element 'ns2:eventDeviceBehaviorInfo' of XML schema type 'xsd:string'
        std::string *eventDeviceBehaviorInfo;
        /// Optional element 'ns2:eventHotlistInfo' of XML schema type 'xsd:string'
        std::string *eventHotlistInfo;
        /// Optional element 'ns2:eventPolicy' of XML schema type 'xsd:string'
        std::string *eventPolicy;
        /// Optional element 'ns2:eventVelocityInfoCode' of XML schema type 'xsd:string'
        std::string *eventVelocityInfoCode;
        /// Optional element 'ns2:additionalFields' of XML schema type 'ns2:AdditionalFields'
        ns2__AdditionalFields *additionalFields;
        /// Optional element 'ns2:morphingElement' of XML schema type 'ns2:MorphingElement'
        ns2__MorphingElement *morphingElement;
        /// Optional element 'ns2:cardBin' of XML schema type 'xsd:string'
        std::string *cardBin;
        /// Optional element 'ns2:binCountry' of XML schema type 'xsd:string'
        std::string *binCountry;
        /// Optional element 'ns2:cardAccountType' of XML schema type 'xsd:string'
        std::string *cardAccountType;
        /// Optional element 'ns2:cardScheme' of XML schema type 'xsd:string'
        std::string *cardScheme;
        /// Optional element 'ns2:cardIssuer' of XML schema type 'xsd:string'
        std::string *cardIssuer;
        /// Optional element 'ns2:providerFields' of XML schema type 'ns2:ProviderFields'
        ns2__ProviderFields *providerFields;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DMEReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DMEReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DMEReply, default initialized and not managed by a soap context
        virtual ns2__DMEReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DMEReply); }
      public:
        /// Constructor with default initializations
        ns2__DMEReply() : eventType(), eventInfo(), eventDeviceBehaviorInfo(), eventHotlistInfo(), eventPolicy(), eventVelocityInfoCode(), additionalFields(), morphingElement(), cardBin(), binCountry(), cardAccountType(), cardScheme(), cardIssuer(), providerFields(), soap() { }
        virtual ~ns2__DMEReply() { }
        /// Friend allocator used by soap_new_ns2__DMEReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__DMEReply * SOAP_FMAC2 soap_instantiate_ns2__DMEReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:600 */
#ifndef SOAP_TYPE_ns2__ProfileReply
#define SOAP_TYPE_ns2__ProfileReply (495)
/* complex XML schema type 'ns2:ProfileReply': */
class SOAP_CMAC ns2__ProfileReply {
      public:
        /// Optional element 'ns2:selectedBy' of XML schema type 'xsd:string'
        std::string *selectedBy;
        /// Optional element 'ns2:name' of XML schema type 'xsd:string'
        std::string *name;
        /// Optional element 'ns2:destinationQueue' of XML schema type 'xsd:string'
        std::string *destinationQueue;
        /// Optional element 'ns2:profileScore' of XML schema type 'xsd:string'
        std::string *profileScore;
        /// Optional element 'ns2:rulesTriggered' of XML schema type 'ns2:RuleResultItems'
        ns2__RuleResultItems *rulesTriggered;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ProfileReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ProfileReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ProfileReply, default initialized and not managed by a soap context
        virtual ns2__ProfileReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ProfileReply); }
      public:
        /// Constructor with default initializations
        ns2__ProfileReply() : selectedBy(), name(), destinationQueue(), profileScore(), rulesTriggered(), soap() { }
        virtual ~ns2__ProfileReply() { }
        /// Friend allocator used by soap_new_ns2__ProfileReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__ProfileReply * SOAP_FMAC2 soap_instantiate_ns2__ProfileReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:602 */
#ifndef SOAP_TYPE_ns2__CCDCCReply
#define SOAP_TYPE_ns2__CCDCCReply (496)
/* complex XML schema type 'ns2:CCDCCReply': */
class SOAP_CMAC ns2__CCDCCReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:dccSupported' of XML schema type 'ns2:boolean'
        std::string *dccSupported;
        /// Optional element 'ns2:validHours' of XML schema type 'xsd:string'
        std::string *validHours;
        /// Optional element 'ns2:marginRatePercentage' of XML schema type 'xsd:string'
        std::string *marginRatePercentage;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Sequence of 0 to 150 elements 'ns2:paymentCurrencyOffer' of XML schema type 'ns2:paymentCurrencyOffer'
        std::vector<ns2__paymentCurrencyOffer> paymentCurrencyOffer;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCDCCReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCDCCReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCDCCReply, default initialized and not managed by a soap context
        virtual ns2__CCDCCReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCDCCReply); }
      public:
        /// Constructor with default initializations
        ns2__CCDCCReply() : reasonCode(), dccSupported(), validHours(), marginRatePercentage(), reconciliationID(), paymentCurrencyOffer(), soap() { }
        virtual ~ns2__CCDCCReply() { }
        /// Friend allocator used by soap_new_ns2__CCDCCReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCDCCReply * SOAP_FMAC2 soap_instantiate_ns2__CCDCCReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:604 */
#ifndef SOAP_TYPE_ns2__paymentCurrencyOffer
#define SOAP_TYPE_ns2__paymentCurrencyOffer (497)
/* complex XML schema type 'ns2:paymentCurrencyOffer': */
class SOAP_CMAC ns2__paymentCurrencyOffer {
      public:
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:currency' of XML schema type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:exchangeRate' of XML schema type 'xsd:string'
        std::string *exchangeRate;
        /// Optional element 'ns2:marginRatePercentage' of XML schema type 'xsd:string'
        std::string *marginRatePercentage;
        /// Required attribute 'id' of XML schema type 'xsd:integer'
        std::string id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__paymentCurrencyOffer
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__paymentCurrencyOffer; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__paymentCurrencyOffer, default initialized and not managed by a soap context
        virtual ns2__paymentCurrencyOffer *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__paymentCurrencyOffer); }
      public:
        /// Constructor with default initializations
        ns2__paymentCurrencyOffer() : amount(), currency(), exchangeRate(), marginRatePercentage(), id(), soap() { }
        virtual ~ns2__paymentCurrencyOffer() { }
        /// Friend allocator used by soap_new_ns2__paymentCurrencyOffer(struct soap*, int)
        friend SOAP_FMAC1 ns2__paymentCurrencyOffer * SOAP_FMAC2 soap_instantiate_ns2__paymentCurrencyOffer(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:606 */
#ifndef SOAP_TYPE_ns2__CCDCCUpdateReply
#define SOAP_TYPE_ns2__CCDCCUpdateReply (498)
/* complex XML schema type 'ns2:CCDCCUpdateReply': */
class SOAP_CMAC ns2__CCDCCUpdateReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCDCCUpdateReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCDCCUpdateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCDCCUpdateReply, default initialized and not managed by a soap context
        virtual ns2__CCDCCUpdateReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCDCCUpdateReply); }
      public:
        /// Constructor with default initializations
        ns2__CCDCCUpdateReply() : reasonCode(), soap() { }
        virtual ~ns2__CCDCCUpdateReply() { }
        /// Friend allocator used by soap_new_ns2__CCDCCUpdateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCDCCUpdateReply * SOAP_FMAC2 soap_instantiate_ns2__CCDCCUpdateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:608 */
#ifndef SOAP_TYPE_ns2__ChinaPaymentReply
#define SOAP_TYPE_ns2__ChinaPaymentReply (499)
/* complex XML schema type 'ns2:ChinaPaymentReply': */
class SOAP_CMAC ns2__ChinaPaymentReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:currency' of XML schema type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:formData' of XML schema type 'xsd:string'
        std::string *formData;
        /// Optional element 'ns2:verifyFailure' of XML schema type 'xsd:string'
        std::string *verifyFailure;
        /// Optional element 'ns2:verifyInProcess' of XML schema type 'xsd:string'
        std::string *verifyInProcess;
        /// Optional element 'ns2:verifySuccess' of XML schema type 'xsd:string'
        std::string *verifySuccess;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ChinaPaymentReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ChinaPaymentReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ChinaPaymentReply, default initialized and not managed by a soap context
        virtual ns2__ChinaPaymentReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ChinaPaymentReply); }
      public:
        /// Constructor with default initializations
        ns2__ChinaPaymentReply() : reasonCode(), requestDateTime(), amount(), currency(), reconciliationID(), formData(), verifyFailure(), verifyInProcess(), verifySuccess(), soap() { }
        virtual ~ns2__ChinaPaymentReply() { }
        /// Friend allocator used by soap_new_ns2__ChinaPaymentReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__ChinaPaymentReply * SOAP_FMAC2 soap_instantiate_ns2__ChinaPaymentReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:610 */
#ifndef SOAP_TYPE_ns2__ChinaRefundReply
#define SOAP_TYPE_ns2__ChinaRefundReply (500)
/* complex XML schema type 'ns2:ChinaRefundReply': */
class SOAP_CMAC ns2__ChinaRefundReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:currency' of XML schema type 'xsd:string'
        std::string *currency;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ChinaRefundReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ChinaRefundReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ChinaRefundReply, default initialized and not managed by a soap context
        virtual ns2__ChinaRefundReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ChinaRefundReply); }
      public:
        /// Constructor with default initializations
        ns2__ChinaRefundReply() : reasonCode(), requestDateTime(), amount(), currency(), soap() { }
        virtual ~ns2__ChinaRefundReply() { }
        /// Friend allocator used by soap_new_ns2__ChinaRefundReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__ChinaRefundReply * SOAP_FMAC2 soap_instantiate_ns2__ChinaRefundReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:612 */
#ifndef SOAP_TYPE_ns2__BoletoPaymentReply
#define SOAP_TYPE_ns2__BoletoPaymentReply (501)
/* complex XML schema type 'ns2:BoletoPaymentReply': */
class SOAP_CMAC ns2__BoletoPaymentReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:boletoNumber' of XML schema type 'xsd:string'
        std::string *boletoNumber;
        /// Optional element 'ns2:expirationDate' of XML schema type 'xsd:string'
        std::string *expirationDate;
        /// Optional element 'ns2:url' of XML schema type 'xsd:string'
        std::string *url;
        /// Optional element 'ns2:avsCode' of XML schema type 'xsd:string'
        std::string *avsCode;
        /// Optional element 'ns2:avsCodeRaw' of XML schema type 'xsd:string'
        std::string *avsCodeRaw;
        /// Optional element 'ns2:barCodeNumber' of XML schema type 'xsd:string'
        std::string *barCodeNumber;
        /// Optional element 'ns2:assignor' of XML schema type 'xsd:string'
        std::string *assignor;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BoletoPaymentReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__BoletoPaymentReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BoletoPaymentReply, default initialized and not managed by a soap context
        virtual ns2__BoletoPaymentReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__BoletoPaymentReply); }
      public:
        /// Constructor with default initializations
        ns2__BoletoPaymentReply() : reasonCode(), requestDateTime(), amount(), reconciliationID(), boletoNumber(), expirationDate(), url(), avsCode(), avsCodeRaw(), barCodeNumber(), assignor(), soap() { }
        virtual ~ns2__BoletoPaymentReply() { }
        /// Friend allocator used by soap_new_ns2__BoletoPaymentReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__BoletoPaymentReply * SOAP_FMAC2 soap_instantiate_ns2__BoletoPaymentReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:614 */
#ifndef SOAP_TYPE_ns2__APInitiateReply
#define SOAP_TYPE_ns2__APInitiateReply (502)
/* complex XML schema type 'ns2:APInitiateReply': */
class SOAP_CMAC ns2__APInitiateReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:merchantURL' of XML schema type 'xsd:string'
        std::string *merchantURL;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:dateTime' of XML schema type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:signature' of XML schema type 'xsd:string'
        std::string *signature;
        /// Optional element 'ns2:publicKey' of XML schema type 'xsd:string'
        std::string *publicKey;
        /// Optional element 'ns2:paymentStatus' of XML schema type 'xsd:string'
        std::string *paymentStatus;
        /// Optional element 'ns2:responseCode' of XML schema type 'xsd:string'
        std::string *responseCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APInitiateReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APInitiateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APInitiateReply, default initialized and not managed by a soap context
        virtual ns2__APInitiateReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APInitiateReply); }
      public:
        /// Constructor with default initializations
        ns2__APInitiateReply() : reasonCode(), merchantURL(), reconciliationID(), amount(), dateTime(), signature(), publicKey(), paymentStatus(), responseCode(), soap() { }
        virtual ~ns2__APInitiateReply() { }
        /// Friend allocator used by soap_new_ns2__APInitiateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APInitiateReply * SOAP_FMAC2 soap_instantiate_ns2__APInitiateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:616 */
#ifndef SOAP_TYPE_ns2__APCheckStatusReply
#define SOAP_TYPE_ns2__APCheckStatusReply (503)
/* complex XML schema type 'ns2:APCheckStatusReply': */
class SOAP_CMAC ns2__APCheckStatusReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:paymentStatus' of XML schema type 'xsd:string'
        std::string *paymentStatus;
        /// Optional element 'ns2:processorTradeNo' of XML schema type 'xsd:string'
        std::string *processorTradeNo;
        /// Optional element 'ns2:processorTransactionID' of XML schema type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:ibanSuffix' of XML schema type 'xsd:string'
        std::string *ibanSuffix;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:processorToken' of XML schema type 'xsd:string'
        std::string *processorToken;
        /// Optional element 'ns2:dateTime' of XML schema type 'ns2:dateTime'
        std::string *dateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APCheckStatusReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APCheckStatusReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APCheckStatusReply, default initialized and not managed by a soap context
        virtual ns2__APCheckStatusReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APCheckStatusReply); }
      public:
        /// Constructor with default initializations
        ns2__APCheckStatusReply() : reasonCode(), reconciliationID(), paymentStatus(), processorTradeNo(), processorTransactionID(), ibanSuffix(), processorResponse(), processorToken(), dateTime(), soap() { }
        virtual ~ns2__APCheckStatusReply() { }
        /// Friend allocator used by soap_new_ns2__APCheckStatusReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APCheckStatusReply * SOAP_FMAC2 soap_instantiate_ns2__APCheckStatusReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:618 */
#ifndef SOAP_TYPE_ns2__SellerProtection
#define SOAP_TYPE_ns2__SellerProtection (504)
/* complex XML schema type 'ns2:SellerProtection': */
class SOAP_CMAC ns2__SellerProtection {
      public:
        /// Optional element 'ns2:eligibility' of XML schema type 'xsd:string'
        std::string *eligibility;
        /// Optional element 'ns2:type' of XML schema type 'xsd:string'
        std::string *type;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__SellerProtection
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__SellerProtection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__SellerProtection, default initialized and not managed by a soap context
        virtual ns2__SellerProtection *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__SellerProtection); }
      public:
        /// Constructor with default initializations
        ns2__SellerProtection() : eligibility(), type(), soap() { }
        virtual ~ns2__SellerProtection() { }
        /// Friend allocator used by soap_new_ns2__SellerProtection(struct soap*, int)
        friend SOAP_FMAC1 ns2__SellerProtection * SOAP_FMAC2 soap_instantiate_ns2__SellerProtection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:620 */
#ifndef SOAP_TYPE_ns2__APReply
#define SOAP_TYPE_ns2__APReply (505)
/* complex XML schema type 'ns2:APReply': */
class SOAP_CMAC ns2__APReply {
      public:
        /// Optional element 'ns2:orderID' of XML schema type 'xsd:string'
        std::string *orderID;
        /// Optional element 'ns2:cardGroup' of XML schema type 'xsd:string'
        std::string *cardGroup;
        /// Optional element 'ns2:cardType' of XML schema type 'xsd:string'
        std::string *cardType;
        /// Optional element 'ns2:cardNumberSuffix' of XML schema type 'xsd:string'
        std::string *cardNumberSuffix;
        /// Optional element 'ns2:cardExpirationMonth' of XML schema type 'xsd:string'
        std::string *cardExpirationMonth;
        /// Optional element 'ns2:cardExpirationYear' of XML schema type 'xsd:string'
        std::string *cardExpirationYear;
        /// Optional element 'ns2:avsCodeRaw' of XML schema type 'xsd:string'
        std::string *avsCodeRaw;
        /// Optional element 'ns2:purchaseID' of XML schema type 'xsd:string'
        std::string *purchaseID;
        /// Optional element 'ns2:productID' of XML schema type 'xsd:string'
        std::string *productID;
        /// Optional element 'ns2:productDescription' of XML schema type 'xsd:string'
        std::string *productDescription;
        /// Optional element 'ns2:shippingAmount' of XML schema type 'xsd:string'
        std::string *shippingAmount;
        /// Optional element 'ns2:handlingAmount' of XML schema type 'xsd:string'
        std::string *handlingAmount;
        /// Optional element 'ns2:shippingHandlingAmount' of XML schema type 'xsd:string'
        std::string *shippingHandlingAmount;
        /// Optional element 'ns2:additionalAmount' of XML schema type 'xsd:string'
        std::string *additionalAmount;
        /// Optional element 'ns2:taxAmount' of XML schema type 'xsd:string'
        std::string *taxAmount;
        /// Optional element 'ns2:subtotalAmount' of XML schema type 'xsd:string'
        std::string *subtotalAmount;
        /// Optional element 'ns2:totalPurchaseAmount' of XML schema type 'xsd:string'
        std::string *totalPurchaseAmount;
        /// Optional element 'ns2:giftWrapAmount' of XML schema type 'xsd:string'
        std::string *giftWrapAmount;
        /// Optional element 'ns2:discountAmount' of XML schema type 'xsd:string'
        std::string *discountAmount;
        /// Optional element 'ns2:cardNumberPrefix' of XML schema type 'xsd:string'
        std::string *cardNumberPrefix;
        /// Optional element 'ns2:riskIndicator' of XML schema type 'xsd:string'
        std::string *riskIndicator;
        /// Optional element 'ns2:merchantUUID' of XML schema type 'xsd:string'
        std::string *merchantUUID;
        /// Optional element 'ns2:merchantSiteID' of XML schema type 'xsd:string'
        std::string *merchantSiteID;
        /// Optional element 'ns2:transactionExpirationDate' of XML schema type 'xsd:string'
        std::string *transactionExpirationDate;
        /// Optional element 'ns2:sellerProtection' of XML schema type 'ns2:SellerProtection'
        ns2__SellerProtection *sellerProtection;
        /// Optional element 'ns2:processorFraudDecision' of XML schema type 'xsd:string'
        std::string *processorFraudDecision;
        /// Optional element 'ns2:processorFraudDecisionReason' of XML schema type 'xsd:string'
        std::string *processorFraudDecisionReason;
        /// Optional element 'ns2:customerID' of XML schema type 'xsd:string'
        std::string *customerID;
        /// Optional element 'ns2:billingAgreementID' of XML schema type 'xsd:string'
        std::string *billingAgreementID;
        /// Optional element 'ns2:payerID' of XML schema type 'xsd:string'
        std::string *payerID;
        /// Optional element 'ns2:fundingSource' of XML schema type 'xsd:string'
        std::string *fundingSource;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APReply, default initialized and not managed by a soap context
        virtual ns2__APReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APReply); }
      public:
        /// Constructor with default initializations
        ns2__APReply() : orderID(), cardGroup(), cardType(), cardNumberSuffix(), cardExpirationMonth(), cardExpirationYear(), avsCodeRaw(), purchaseID(), productID(), productDescription(), shippingAmount(), handlingAmount(), shippingHandlingAmount(), additionalAmount(), taxAmount(), subtotalAmount(), totalPurchaseAmount(), giftWrapAmount(), discountAmount(), cardNumberPrefix(), riskIndicator(), merchantUUID(), merchantSiteID(), transactionExpirationDate(), sellerProtection(), processorFraudDecision(), processorFraudDecisionReason(), customerID(), billingAgreementID(), payerID(), fundingSource(), soap() { }
        virtual ~ns2__APReply() { }
        /// Friend allocator used by soap_new_ns2__APReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APReply * SOAP_FMAC2 soap_instantiate_ns2__APReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:622 */
#ifndef SOAP_TYPE_ns2__APAuthReply
#define SOAP_TYPE_ns2__APAuthReply (506)
/* complex XML schema type 'ns2:APAuthReply': */
class SOAP_CMAC ns2__APAuthReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:transactionID' of XML schema type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:status' of XML schema type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:dateTime' of XML schema type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:providerResponse' of XML schema type 'xsd:string'
        std::string *providerResponse;
        /// Optional element 'ns2:paymentStatus' of XML schema type 'xsd:string'
        std::string *paymentStatus;
        /// Optional element 'ns2:responseCode' of XML schema type 'xsd:string'
        std::string *responseCode;
        /// Optional element 'ns2:authorizationCode' of XML schema type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:merchantURL' of XML schema type 'xsd:string'
        std::string *merchantURL;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorTransactionID' of XML schema type 'xsd:string'
        std::string *processorTransactionID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APAuthReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APAuthReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APAuthReply, default initialized and not managed by a soap context
        virtual ns2__APAuthReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APAuthReply); }
      public:
        /// Constructor with default initializations
        ns2__APAuthReply() : reasonCode(), transactionID(), status(), processorResponse(), amount(), dateTime(), providerResponse(), paymentStatus(), responseCode(), authorizationCode(), merchantURL(), reconciliationID(), processorTransactionID(), soap() { }
        virtual ~ns2__APAuthReply() { }
        /// Friend allocator used by soap_new_ns2__APAuthReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APAuthReply * SOAP_FMAC2 soap_instantiate_ns2__APAuthReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:624 */
#ifndef SOAP_TYPE_ns2__APAuthReversalReply
#define SOAP_TYPE_ns2__APAuthReversalReply (507)
/* complex XML schema type 'ns2:APAuthReversalReply': */
class SOAP_CMAC ns2__APAuthReversalReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:transactionID' of XML schema type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:status' of XML schema type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:dateTime' of XML schema type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:providerResponse' of XML schema type 'xsd:string'
        std::string *providerResponse;
        /// Optional element 'ns2:paymentStatus' of XML schema type 'xsd:string'
        std::string *paymentStatus;
        /// Optional element 'ns2:responseCode' of XML schema type 'xsd:string'
        std::string *responseCode;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorTransactionID' of XML schema type 'xsd:string'
        std::string *processorTransactionID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APAuthReversalReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APAuthReversalReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APAuthReversalReply, default initialized and not managed by a soap context
        virtual ns2__APAuthReversalReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APAuthReversalReply); }
      public:
        /// Constructor with default initializations
        ns2__APAuthReversalReply() : reasonCode(), transactionID(), status(), processorResponse(), amount(), dateTime(), providerResponse(), paymentStatus(), responseCode(), reconciliationID(), processorTransactionID(), soap() { }
        virtual ~ns2__APAuthReversalReply() { }
        /// Friend allocator used by soap_new_ns2__APAuthReversalReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APAuthReversalReply * SOAP_FMAC2 soap_instantiate_ns2__APAuthReversalReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:626 */
#ifndef SOAP_TYPE_ns2__APCaptureReply
#define SOAP_TYPE_ns2__APCaptureReply (508)
/* complex XML schema type 'ns2:APCaptureReply': */
class SOAP_CMAC ns2__APCaptureReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:processorTransactionID' of XML schema type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:status' of XML schema type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:dateTime' of XML schema type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:providerResponse' of XML schema type 'xsd:string'
        std::string *providerResponse;
        /// Optional element 'ns2:paymentStatus' of XML schema type 'xsd:string'
        std::string *paymentStatus;
        /// Optional element 'ns2:responseCode' of XML schema type 'xsd:string'
        std::string *responseCode;
        /// Optional element 'ns2:processorTransactionFee' of XML schema type 'xsd:string'
        std::string *processorTransactionFee;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APCaptureReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APCaptureReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APCaptureReply, default initialized and not managed by a soap context
        virtual ns2__APCaptureReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APCaptureReply); }
      public:
        /// Constructor with default initializations
        ns2__APCaptureReply() : reasonCode(), processorTransactionID(), status(), processorResponse(), amount(), dateTime(), reconciliationID(), providerResponse(), paymentStatus(), responseCode(), processorTransactionFee(), soap() { }
        virtual ~ns2__APCaptureReply() { }
        /// Friend allocator used by soap_new_ns2__APCaptureReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APCaptureReply * SOAP_FMAC2 soap_instantiate_ns2__APCaptureReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:628 */
#ifndef SOAP_TYPE_ns2__APOptionsReply
#define SOAP_TYPE_ns2__APOptionsReply (509)
/* complex XML schema type 'ns2:APOptionsReply': */
class SOAP_CMAC ns2__APOptionsReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:responseCode' of XML schema type 'xsd:string'
        std::string *responseCode;
        /// Optional element 'ns2:offset' of XML schema type 'xsd:string'
        std::string *offset;
        /// Optional element 'ns2:count' of XML schema type 'xsd:string'
        std::string *count;
        /// Optional element 'ns2:totalCount' of XML schema type 'xsd:string'
        std::string *totalCount;
        /// Sequence of 0 to 250 elements 'ns2:option' of XML schema type 'ns2:APOptionsOption'
        std::vector<ns2__APOptionsOption> option;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APOptionsReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APOptionsReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APOptionsReply, default initialized and not managed by a soap context
        virtual ns2__APOptionsReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APOptionsReply); }
      public:
        /// Constructor with default initializations
        ns2__APOptionsReply() : reasonCode(), responseCode(), offset(), count(), totalCount(), option(), soap() { }
        virtual ~ns2__APOptionsReply() { }
        /// Friend allocator used by soap_new_ns2__APOptionsReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APOptionsReply * SOAP_FMAC2 soap_instantiate_ns2__APOptionsReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:630 */
#ifndef SOAP_TYPE_ns2__APOptionsOption
#define SOAP_TYPE_ns2__APOptionsOption (510)
/* complex XML schema type 'ns2:APOptionsOption': */
class SOAP_CMAC ns2__APOptionsOption {
      public:
        /// Optional element 'ns2:id' of XML schema type 'xsd:string'
        std::string *id;
        /// Optional element 'ns2:name' of XML schema type 'xsd:string'
        std::string *name;
        /// Optional attribute 'data' of XML schema type 'xsd:integer'
        std::string *data;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APOptionsOption
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APOptionsOption; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APOptionsOption, default initialized and not managed by a soap context
        virtual ns2__APOptionsOption *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APOptionsOption); }
      public:
        /// Constructor with default initializations
        ns2__APOptionsOption() : id(), name(), data(), soap() { }
        virtual ~ns2__APOptionsOption() { }
        /// Friend allocator used by soap_new_ns2__APOptionsOption(struct soap*, int)
        friend SOAP_FMAC1 ns2__APOptionsOption * SOAP_FMAC2 soap_instantiate_ns2__APOptionsOption(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:632 */
#ifndef SOAP_TYPE_ns2__APRefundReply
#define SOAP_TYPE_ns2__APRefundReply (511)
/* complex XML schema type 'ns2:APRefundReply': */
class SOAP_CMAC ns2__APRefundReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:transactionID' of XML schema type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:status' of XML schema type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:dateTime' of XML schema type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:returnRef' of XML schema type 'xsd:string'
        std::string *returnRef;
        /// Optional element 'ns2:providerResponse' of XML schema type 'xsd:string'
        std::string *providerResponse;
        /// Optional element 'ns2:processorTransactionID' of XML schema type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:paymentStatus' of XML schema type 'xsd:string'
        std::string *paymentStatus;
        /// Optional element 'ns2:responseCode' of XML schema type 'xsd:string'
        std::string *responseCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APRefundReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APRefundReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APRefundReply, default initialized and not managed by a soap context
        virtual ns2__APRefundReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APRefundReply); }
      public:
        /// Constructor with default initializations
        ns2__APRefundReply() : reasonCode(), transactionID(), status(), processorResponse(), amount(), dateTime(), reconciliationID(), returnRef(), providerResponse(), processorTransactionID(), paymentStatus(), responseCode(), soap() { }
        virtual ~ns2__APRefundReply() { }
        /// Friend allocator used by soap_new_ns2__APRefundReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APRefundReply * SOAP_FMAC2 soap_instantiate_ns2__APRefundReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:634 */
#ifndef SOAP_TYPE_ns2__APSaleReply
#define SOAP_TYPE_ns2__APSaleReply (512)
/* complex XML schema type 'ns2:APSaleReply': */
class SOAP_CMAC ns2__APSaleReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:paymentStatus' of XML schema type 'xsd:string'
        std::string *paymentStatus;
        /// Optional element 'ns2:responseCode' of XML schema type 'xsd:string'
        std::string *responseCode;
        /// Optional element 'ns2:merchantURL' of XML schema type 'xsd:string'
        std::string *merchantURL;
        /// Optional element 'ns2:processorTransactionID' of XML schema type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorTransactionFee' of XML schema type 'xsd:string'
        std::string *processorTransactionFee;
        /// Optional element 'ns2:amount' of XML schema type 'xsd:string'
        std::string *amount;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:exchangeRate' of XML schema type 'xsd:string'
        std::string *exchangeRate;
        /// Optional element 'ns2:foreignCurrency' of XML schema type 'xsd:string'
        std::string *foreignCurrency;
        /// Optional element 'ns2:foreignAmount' of XML schema type 'xsd:string'
        std::string *foreignAmount;
        /// Optional element 'ns2:discountAmount' of XML schema type 'xsd:string'
        std::string *discountAmount;
        /// Optional element 'ns2:dateTime' of XML schema type 'ns2:dateTime'
        std::string *dateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APSaleReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APSaleReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APSaleReply, default initialized and not managed by a soap context
        virtual ns2__APSaleReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APSaleReply); }
      public:
        /// Constructor with default initializations
        ns2__APSaleReply() : reasonCode(), paymentStatus(), responseCode(), merchantURL(), processorTransactionID(), reconciliationID(), processorTransactionFee(), amount(), processorResponse(), exchangeRate(), foreignCurrency(), foreignAmount(), discountAmount(), dateTime(), soap() { }
        virtual ~ns2__APSaleReply() { }
        /// Friend allocator used by soap_new_ns2__APSaleReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APSaleReply * SOAP_FMAC2 soap_instantiate_ns2__APSaleReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:636 */
#ifndef SOAP_TYPE_ns2__APCheckOutDetailsReply
#define SOAP_TYPE_ns2__APCheckOutDetailsReply (513)
/* complex XML schema type 'ns2:APCheckOutDetailsReply': */
class SOAP_CMAC ns2__APCheckOutDetailsReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:status' of XML schema type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:dateTime' of XML schema type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:providerResponse' of XML schema type 'xsd:string'
        std::string *providerResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APCheckOutDetailsReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APCheckOutDetailsReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APCheckOutDetailsReply, default initialized and not managed by a soap context
        virtual ns2__APCheckOutDetailsReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APCheckOutDetailsReply); }
      public:
        /// Constructor with default initializations
        ns2__APCheckOutDetailsReply() : reasonCode(), status(), processorResponse(), dateTime(), providerResponse(), soap() { }
        virtual ~ns2__APCheckOutDetailsReply() { }
        /// Friend allocator used by soap_new_ns2__APCheckOutDetailsReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APCheckOutDetailsReply * SOAP_FMAC2 soap_instantiate_ns2__APCheckOutDetailsReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:638 */
#ifndef SOAP_TYPE_ns2__APTransactionDetailsReply
#define SOAP_TYPE_ns2__APTransactionDetailsReply (514)
/* complex XML schema type 'ns2:APTransactionDetailsReply': */
class SOAP_CMAC ns2__APTransactionDetailsReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:transactionID' of XML schema type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:status' of XML schema type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:dateTime' of XML schema type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:providerResponse' of XML schema type 'xsd:string'
        std::string *providerResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APTransactionDetailsReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APTransactionDetailsReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APTransactionDetailsReply, default initialized and not managed by a soap context
        virtual ns2__APTransactionDetailsReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APTransactionDetailsReply); }
      public:
        /// Constructor with default initializations
        ns2__APTransactionDetailsReply() : reasonCode(), transactionID(), status(), processorResponse(), dateTime(), reconciliationID(), providerResponse(), soap() { }
        virtual ~ns2__APTransactionDetailsReply() { }
        /// Friend allocator used by soap_new_ns2__APTransactionDetailsReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APTransactionDetailsReply * SOAP_FMAC2 soap_instantiate_ns2__APTransactionDetailsReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:640 */
#ifndef SOAP_TYPE_ns2__APConfirmPurchaseReply
#define SOAP_TYPE_ns2__APConfirmPurchaseReply (515)
/* complex XML schema type 'ns2:APConfirmPurchaseReply': */
class SOAP_CMAC ns2__APConfirmPurchaseReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:status' of XML schema type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:dateTime' of XML schema type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:providerResponse' of XML schema type 'xsd:string'
        std::string *providerResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APConfirmPurchaseReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APConfirmPurchaseReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APConfirmPurchaseReply, default initialized and not managed by a soap context
        virtual ns2__APConfirmPurchaseReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APConfirmPurchaseReply); }
      public:
        /// Constructor with default initializations
        ns2__APConfirmPurchaseReply() : reasonCode(), status(), processorResponse(), amount(), dateTime(), providerResponse(), soap() { }
        virtual ~ns2__APConfirmPurchaseReply() { }
        /// Friend allocator used by soap_new_ns2__APConfirmPurchaseReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APConfirmPurchaseReply * SOAP_FMAC2 soap_instantiate_ns2__APConfirmPurchaseReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:642 */
#ifndef SOAP_TYPE_ns2__APSessionsReply
#define SOAP_TYPE_ns2__APSessionsReply (516)
/* complex XML schema type 'ns2:APSessionsReply': */
class SOAP_CMAC ns2__APSessionsReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:responseCode' of XML schema type 'xsd:string'
        std::string *responseCode;
        /// Optional element 'ns2:merchantURL' of XML schema type 'xsd:string'
        std::string *merchantURL;
        /// Optional element 'ns2:processorToken' of XML schema type 'xsd:string'
        std::string *processorToken;
        /// Optional element 'ns2:processorTransactionID' of XML schema type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:amount' of XML schema type 'xsd:string'
        std::string *amount;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:status' of XML schema type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:dateTime' of XML schema type 'ns2:dateTime'
        std::string *dateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APSessionsReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APSessionsReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APSessionsReply, default initialized and not managed by a soap context
        virtual ns2__APSessionsReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APSessionsReply); }
      public:
        /// Constructor with default initializations
        ns2__APSessionsReply() : reasonCode(), responseCode(), merchantURL(), processorToken(), processorTransactionID(), amount(), reconciliationID(), status(), dateTime(), soap() { }
        virtual ~ns2__APSessionsReply() { }
        /// Friend allocator used by soap_new_ns2__APSessionsReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APSessionsReply * SOAP_FMAC2 soap_instantiate_ns2__APSessionsReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:644 */
#ifndef SOAP_TYPE_ns2__CCCheckStatusReply
#define SOAP_TYPE_ns2__CCCheckStatusReply (517)
/* complex XML schema type 'ns2:CCCheckStatusReply': */
class SOAP_CMAC ns2__CCCheckStatusReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:paymentStatus' of XML schema type 'xsd:string'
        std::string *paymentStatus;
        /// Optional element 'ns2:authorizationCode' of XML schema type 'xsd:string'
        std::string *authorizationCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCCheckStatusReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCCheckStatusReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCCheckStatusReply, default initialized and not managed by a soap context
        virtual ns2__CCCheckStatusReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCCheckStatusReply); }
      public:
        /// Constructor with default initializations
        ns2__CCCheckStatusReply() : reasonCode(), paymentStatus(), authorizationCode(), soap() { }
        virtual ~ns2__CCCheckStatusReply() { }
        /// Friend allocator used by soap_new_ns2__CCCheckStatusReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCCheckStatusReply * SOAP_FMAC2 soap_instantiate_ns2__CCCheckStatusReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:646 */
#ifndef SOAP_TYPE_ns2__ReplyMessage
#define SOAP_TYPE_ns2__ReplyMessage (518)
/* complex XML schema type 'ns2:ReplyMessage': */
class SOAP_CMAC ns2__ReplyMessage {
      public:
        /// Optional element 'ns2:merchantReferenceCode' of XML schema type 'xsd:string'
        std::string *merchantReferenceCode;
        /// Required element 'ns2:requestID' of XML schema type 'xsd:string'
        std::string requestID;
        /// Required element 'ns2:decision' of XML schema type 'xsd:string'
        std::string decision;
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Sequence of 0 to 1000 elements 'ns2:missingField' of XML schema type 'xsd:string'
        std::vector<std::string> missingField;
        /// Sequence of 0 to 1000 elements 'ns2:invalidField' of XML schema type 'xsd:string'
        std::vector<std::string> invalidField;
        /// Required element 'ns2:requestToken' of XML schema type 'xsd:string'
        std::string requestToken;
        /// Optional element 'ns2:purchaseTotals' of XML schema type 'ns2:PurchaseTotals'
        ns2__PurchaseTotals *purchaseTotals;
        /// Sequence of 0 to 100 elements 'ns2:deniedPartiesMatch' of XML schema type 'ns2:DeniedPartiesMatch'
        std::vector<ns2__DeniedPartiesMatch> deniedPartiesMatch;
        /// Optional element 'ns2:ccAuthReply' of XML schema type 'ns2:CCAuthReply'
        ns2__CCAuthReply *ccAuthReply;
        /// Optional element 'ns2:octReply' of XML schema type 'ns2:OCTReply'
        ns2__OCTReply *octReply;
        /// Optional element 'ns2:verificationReply' of XML schema type 'ns2:VerificationReply'
        ns2__VerificationReply *verificationReply;
        /// Optional element 'ns2:ccSaleReply' of XML schema type 'ns2:CCSaleReply'
        ns2__CCSaleReply *ccSaleReply;
        /// Optional element 'ns2:ccSaleCreditReply' of XML schema type 'ns2:CCSaleCreditReply'
        ns2__CCSaleCreditReply *ccSaleCreditReply;
        /// Optional element 'ns2:ccSaleReversalReply' of XML schema type 'ns2:CCSaleReversalReply'
        ns2__CCSaleReversalReply *ccSaleReversalReply;
        /// Optional element 'ns2:ccIncrementalAuthReply' of XML schema type 'ns2:CCIncrementalAuthReply'
        ns2__CCIncrementalAuthReply *ccIncrementalAuthReply;
        /// Optional element 'ns2:serviceFeeCalculateReply' of XML schema type 'ns2:ServiceFeeCalculateReply'
        ns2__ServiceFeeCalculateReply *serviceFeeCalculateReply;
        /// Optional element 'ns2:ccCaptureReply' of XML schema type 'ns2:CCCaptureReply'
        ns2__CCCaptureReply *ccCaptureReply;
        /// Optional element 'ns2:ccCreditReply' of XML schema type 'ns2:CCCreditReply'
        ns2__CCCreditReply *ccCreditReply;
        /// Optional element 'ns2:ccAuthReversalReply' of XML schema type 'ns2:CCAuthReversalReply'
        ns2__CCAuthReversalReply *ccAuthReversalReply;
        /// Optional element 'ns2:ccAutoAuthReversalReply' of XML schema type 'ns2:CCAutoAuthReversalReply'
        ns2__CCAutoAuthReversalReply *ccAutoAuthReversalReply;
        /// Optional element 'ns2:ccDCCReply' of XML schema type 'ns2:CCDCCReply'
        ns2__CCDCCReply *ccDCCReply;
        /// Optional element 'ns2:ccDCCUpdateReply' of XML schema type 'ns2:CCDCCUpdateReply'
        ns2__CCDCCUpdateReply *ccDCCUpdateReply;
        /// Optional element 'ns2:ecDebitReply' of XML schema type 'ns2:ECDebitReply'
        ns2__ECDebitReply *ecDebitReply;
        /// Optional element 'ns2:ecCreditReply' of XML schema type 'ns2:ECCreditReply'
        ns2__ECCreditReply *ecCreditReply;
        /// Optional element 'ns2:ecAuthenticateReply' of XML schema type 'ns2:ECAuthenticateReply'
        ns2__ECAuthenticateReply *ecAuthenticateReply;
        /// Optional element 'ns2:payerAuthSetupReply' of XML schema type 'ns2:PayerAuthSetupReply'
        ns2__PayerAuthSetupReply *payerAuthSetupReply;
        /// Optional element 'ns2:payerAuthEnrollReply' of XML schema type 'ns2:PayerAuthEnrollReply'
        ns2__PayerAuthEnrollReply *payerAuthEnrollReply;
        /// Optional element 'ns2:payerAuthValidateReply' of XML schema type 'ns2:PayerAuthValidateReply'
        ns2__PayerAuthValidateReply *payerAuthValidateReply;
        /// Optional element 'ns2:taxReply' of XML schema type 'ns2:TaxReply'
        ns2__TaxReply *taxReply;
        /// Optional element 'ns2:encryptedPayment' of XML schema type 'ns2:EncryptedPayment'
        ns2__EncryptedPayment *encryptedPayment;
        /// Optional element 'ns2:encryptPaymentDataReply' of XML schema type 'ns2:EncryptPaymentDataReply'
        ns2__EncryptPaymentDataReply *encryptPaymentDataReply;
        /// Optional element 'ns2:dmeReply' of XML schema type 'ns2:DMEReply'
        ns2__DMEReply *dmeReply;
        /// Optional element 'ns2:afsReply' of XML schema type 'ns2:AFSReply'
        ns2__AFSReply *afsReply;
        /// Optional element 'ns2:davReply' of XML schema type 'ns2:DAVReply'
        ns2__DAVReply *davReply;
        /// Optional element 'ns2:exportReply' of XML schema type 'ns2:ExportReply'
        ns2__ExportReply *exportReply;
        /// Optional element 'ns2:fxRatesReply' of XML schema type 'ns2:FXRatesReply'
        ns2__FXRatesReply *fxRatesReply;
        /// Optional element 'ns2:bankTransferReply' of XML schema type 'ns2:BankTransferReply'
        ns2__BankTransferReply *bankTransferReply;
        /// Optional element 'ns2:bankTransferRefundReply' of XML schema type 'ns2:BankTransferRefundReply'
        ns2__BankTransferRefundReply *bankTransferRefundReply;
        /// Optional element 'ns2:bankTransferRealTimeReply' of XML schema type 'ns2:BankTransferRealTimeReply'
        ns2__BankTransferRealTimeReply *bankTransferRealTimeReply;
        /// Optional element 'ns2:directDebitMandateReply' of XML schema type 'ns2:DirectDebitMandateReply'
        ns2__DirectDebitMandateReply *directDebitMandateReply;
        /// Optional element 'ns2:directDebitReply' of XML schema type 'ns2:DirectDebitReply'
        ns2__DirectDebitReply *directDebitReply;
        /// Optional element 'ns2:directDebitValidateReply' of XML schema type 'ns2:DirectDebitValidateReply'
        ns2__DirectDebitValidateReply *directDebitValidateReply;
        /// Optional element 'ns2:directDebitRefundReply' of XML schema type 'ns2:DirectDebitRefundReply'
        ns2__DirectDebitRefundReply *directDebitRefundReply;
        /// Optional element 'ns2:paySubscriptionCreateReply' of XML schema type 'ns2:PaySubscriptionCreateReply'
        ns2__PaySubscriptionCreateReply *paySubscriptionCreateReply;
        /// Optional element 'ns2:paySubscriptionUpdateReply' of XML schema type 'ns2:PaySubscriptionUpdateReply'
        ns2__PaySubscriptionUpdateReply *paySubscriptionUpdateReply;
        /// Optional element 'ns2:paySubscriptionEventUpdateReply' of XML schema type 'ns2:PaySubscriptionEventUpdateReply'
        ns2__PaySubscriptionEventUpdateReply *paySubscriptionEventUpdateReply;
        /// Optional element 'ns2:paySubscriptionRetrieveReply' of XML schema type 'ns2:PaySubscriptionRetrieveReply'
        ns2__PaySubscriptionRetrieveReply *paySubscriptionRetrieveReply;
        /// Optional element 'ns2:paySubscriptionDeleteReply' of XML schema type 'ns2:PaySubscriptionDeleteReply'
        ns2__PaySubscriptionDeleteReply *paySubscriptionDeleteReply;
        /// Optional element 'ns2:payPalPaymentReply' of XML schema type 'ns2:PayPalPaymentReply'
        ns2__PayPalPaymentReply *payPalPaymentReply;
        /// Optional element 'ns2:payPalCreditReply' of XML schema type 'ns2:PayPalCreditReply'
        ns2__PayPalCreditReply *payPalCreditReply;
        /// Optional element 'ns2:voidReply' of XML schema type 'ns2:VoidReply'
        ns2__VoidReply *voidReply;
        /// Optional element 'ns2:pinlessDebitReply' of XML schema type 'ns2:PinlessDebitReply'
        ns2__PinlessDebitReply *pinlessDebitReply;
        /// Optional element 'ns2:pinlessDebitValidateReply' of XML schema type 'ns2:PinlessDebitValidateReply'
        ns2__PinlessDebitValidateReply *pinlessDebitValidateReply;
        /// Optional element 'ns2:pinlessDebitReversalReply' of XML schema type 'ns2:PinlessDebitReversalReply'
        ns2__PinlessDebitReversalReply *pinlessDebitReversalReply;
        /// Optional element 'ns2:payPalButtonCreateReply' of XML schema type 'ns2:PayPalButtonCreateReply'
        ns2__PayPalButtonCreateReply *payPalButtonCreateReply;
        /// Optional element 'ns2:payPalPreapprovedPaymentReply' of XML schema type 'ns2:PayPalPreapprovedPaymentReply'
        ns2__PayPalPreapprovedPaymentReply *payPalPreapprovedPaymentReply;
        /// Optional element 'ns2:payPalPreapprovedUpdateReply' of XML schema type 'ns2:PayPalPreapprovedUpdateReply'
        ns2__PayPalPreapprovedUpdateReply *payPalPreapprovedUpdateReply;
        /// Optional element 'ns2:riskUpdateReply' of XML schema type 'ns2:RiskUpdateReply'
        ns2__RiskUpdateReply *riskUpdateReply;
        /// Optional element 'ns2:fraudUpdateReply' of XML schema type 'ns2:FraudUpdateReply'
        ns2__FraudUpdateReply *fraudUpdateReply;
        /// Optional element 'ns2:caseManagementActionReply' of XML schema type 'ns2:CaseManagementActionReply'
        ns2__CaseManagementActionReply *caseManagementActionReply;
        /// Optional element 'ns2:decisionEarlyReply' of XML schema type 'ns2:DecisionEarlyReply'
        ns2__DecisionEarlyReply *decisionEarlyReply;
        /// Optional element 'ns2:decisionReply' of XML schema type 'ns2:DecisionReply'
        ns2__DecisionReply *decisionReply;
        /// Optional element 'ns2:payPalRefundReply' of XML schema type 'ns2:PayPalRefundReply'
        ns2__PayPalRefundReply *payPalRefundReply;
        /// Optional element 'ns2:payPalAuthReversalReply' of XML schema type 'ns2:PayPalAuthReversalReply'
        ns2__PayPalAuthReversalReply *payPalAuthReversalReply;
        /// Optional element 'ns2:payPalDoCaptureReply' of XML schema type 'ns2:PayPalDoCaptureReply'
        ns2__PayPalDoCaptureReply *payPalDoCaptureReply;
        /// Optional element 'ns2:payPalEcDoPaymentReply' of XML schema type 'ns2:PayPalEcDoPaymentReply'
        ns2__PayPalEcDoPaymentReply *payPalEcDoPaymentReply;
        /// Optional element 'ns2:payPalEcGetDetailsReply' of XML schema type 'ns2:PayPalEcGetDetailsReply'
        ns2__PayPalEcGetDetailsReply *payPalEcGetDetailsReply;
        /// Optional element 'ns2:payPalEcSetReply' of XML schema type 'ns2:PayPalEcSetReply'
        ns2__PayPalEcSetReply *payPalEcSetReply;
        /// Optional element 'ns2:payPalAuthorizationReply' of XML schema type 'ns2:PayPalAuthorizationReply'
        ns2__PayPalAuthorizationReply *payPalAuthorizationReply;
        /// Optional element 'ns2:payPalEcOrderSetupReply' of XML schema type 'ns2:PayPalEcOrderSetupReply'
        ns2__PayPalEcOrderSetupReply *payPalEcOrderSetupReply;
        /// Optional element 'ns2:payPalUpdateAgreementReply' of XML schema type 'ns2:PayPalUpdateAgreementReply'
        ns2__PayPalUpdateAgreementReply *payPalUpdateAgreementReply;
        /// Optional element 'ns2:payPalCreateAgreementReply' of XML schema type 'ns2:PayPalCreateAgreementReply'
        ns2__PayPalCreateAgreementReply *payPalCreateAgreementReply;
        /// Optional element 'ns2:payPalDoRefTransactionReply' of XML schema type 'ns2:PayPalDoRefTransactionReply'
        ns2__PayPalDoRefTransactionReply *payPalDoRefTransactionReply;
        /// Optional element 'ns2:chinaPaymentReply' of XML schema type 'ns2:ChinaPaymentReply'
        ns2__ChinaPaymentReply *chinaPaymentReply;
        /// Optional element 'ns2:chinaRefundReply' of XML schema type 'ns2:ChinaRefundReply'
        ns2__ChinaRefundReply *chinaRefundReply;
        /// Optional element 'ns2:boletoPaymentReply' of XML schema type 'ns2:BoletoPaymentReply'
        ns2__BoletoPaymentReply *boletoPaymentReply;
        /// Optional element 'ns2:pinDebitPurchaseReply' of XML schema type 'ns2:PinDebitPurchaseReply'
        ns2__PinDebitPurchaseReply *pinDebitPurchaseReply;
        /// Optional element 'ns2:pinDebitCreditReply' of XML schema type 'ns2:PinDebitCreditReply'
        ns2__PinDebitCreditReply *pinDebitCreditReply;
        /// Optional element 'ns2:pinDebitReversalReply' of XML schema type 'ns2:PinDebitReversalReply'
        ns2__PinDebitReversalReply *pinDebitReversalReply;
        /// Optional element 'ns2:apInitiateReply' of XML schema type 'ns2:APInitiateReply'
        ns2__APInitiateReply *apInitiateReply;
        /// Optional element 'ns2:apCheckStatusReply' of XML schema type 'ns2:APCheckStatusReply'
        ns2__APCheckStatusReply *apCheckStatusReply;
        /// Optional element 'ns2:receiptNumber' of XML schema type 'xsd:string'
        std::string *receiptNumber;
        /// Optional element 'ns2:additionalData' of XML schema type 'xsd:string'
        std::string *additionalData;
        /// Optional element 'ns2:solutionProviderTransactionID' of XML schema type 'xsd:string'
        std::string *solutionProviderTransactionID;
        /// Optional element 'ns2:apReply' of XML schema type 'ns2:APReply'
        ns2__APReply *apReply;
        /// Optional element 'ns2:shipTo' of XML schema type 'ns2:ShipTo'
        ns2__ShipTo *shipTo;
        /// Optional element 'ns2:billTo' of XML schema type 'ns2:BillTo'
        ns2__BillTo *billTo;
        /// Optional element 'ns2:apAuthReply' of XML schema type 'ns2:APAuthReply'
        ns2__APAuthReply *apAuthReply;
        /// Optional element 'ns2:apSessionsReply' of XML schema type 'ns2:APSessionsReply'
        ns2__APSessionsReply *apSessionsReply;
        /// Optional element 'ns2:apAuthReversalReply' of XML schema type 'ns2:APAuthReversalReply'
        ns2__APAuthReversalReply *apAuthReversalReply;
        /// Optional element 'ns2:apCaptureReply' of XML schema type 'ns2:APCaptureReply'
        ns2__APCaptureReply *apCaptureReply;
        /// Optional element 'ns2:apOptionsReply' of XML schema type 'ns2:APOptionsReply'
        ns2__APOptionsReply *apOptionsReply;
        /// Optional element 'ns2:apRefundReply' of XML schema type 'ns2:APRefundReply'
        ns2__APRefundReply *apRefundReply;
        /// Optional element 'ns2:apSaleReply' of XML schema type 'ns2:APSaleReply'
        ns2__APSaleReply *apSaleReply;
        /// Optional element 'ns2:apCheckoutDetailsReply' of XML schema type 'ns2:APCheckOutDetailsReply'
        ns2__APCheckOutDetailsReply *apCheckoutDetailsReply;
        /// Optional element 'ns2:apTransactionDetailsReply' of XML schema type 'ns2:APTransactionDetailsReply'
        ns2__APTransactionDetailsReply *apTransactionDetailsReply;
        /// Optional element 'ns2:apConfirmPurchaseReply' of XML schema type 'ns2:APConfirmPurchaseReply'
        ns2__APConfirmPurchaseReply *apConfirmPurchaseReply;
        /// Optional element 'ns2:promotion' of XML schema type 'ns2:Promotion'
        ns2__Promotion *promotion;
        /// Sequence of 0 to 100 elements 'ns2:promotionGroup' of XML schema type 'ns2:PromotionGroupReply'
        std::vector<ns2__PromotionGroupReply> promotionGroup;
        /// Optional element 'ns2:payPalGetTxnDetailsReply' of XML schema type 'ns2:PayPalGetTxnDetailsReply'
        ns2__PayPalGetTxnDetailsReply *payPalGetTxnDetailsReply;
        /// Optional element 'ns2:payPalTransactionSearchReply' of XML schema type 'ns2:PayPalTransactionSearchReply'
        ns2__PayPalTransactionSearchReply *payPalTransactionSearchReply;
        /// Optional element 'ns2:emvReply' of XML schema type 'ns2:EmvReply'
        ns2__EmvReply *emvReply;
        /// Optional element 'ns2:originalTransaction' of XML schema type 'ns2:OriginalTransaction'
        ns2__OriginalTransaction *originalTransaction;
        /// Optional element 'ns2:hostedDataCreateReply' of XML schema type 'ns2:HostedDataCreateReply'
        ns2__HostedDataCreateReply *hostedDataCreateReply;
        /// Optional element 'ns2:hostedDataRetrieveReply' of XML schema type 'ns2:HostedDataRetrieveReply'
        ns2__HostedDataRetrieveReply *hostedDataRetrieveReply;
        /// Optional element 'ns2:salesSlipNumber' of XML schema type 'xsd:string'
        std::string *salesSlipNumber;
        /// Optional element 'ns2:additionalProcessorResponse' of XML schema type 'xsd:string'
        std::string *additionalProcessorResponse;
        /// Optional element 'ns2:jpo' of XML schema type 'ns2:JPO'
        ns2__JPO *jpo;
        /// Optional element 'ns2:card' of XML schema type 'ns2:Card'
        ns2__Card *card;
        /// Optional element 'ns2:paymentNetworkToken' of XML schema type 'ns2:PaymentNetworkToken'
        ns2__PaymentNetworkToken *paymentNetworkToken;
        /// Optional element 'ns2:vcReply' of XML schema type 'ns2:VCReply'
        ns2__VCReply *vcReply;
        /// Optional element 'ns2:decryptVisaCheckoutDataReply' of XML schema type 'ns2:DecryptVisaCheckoutDataReply'
        ns2__DecryptVisaCheckoutDataReply *decryptVisaCheckoutDataReply;
        /// Optional element 'ns2:getVisaCheckoutDataReply' of XML schema type 'ns2:GetVisaCheckoutDataReply'
        ns2__GetVisaCheckoutDataReply *getVisaCheckoutDataReply;
        /// Optional element 'ns2:binLookupReply' of XML schema type 'ns2:BinLookupReply'
        ns2__BinLookupReply *binLookupReply;
        /// Optional element 'ns2:issuerMessage' of XML schema type 'xsd:string'
        std::string *issuerMessage;
        /// Optional element 'ns2:token' of XML schema type 'ns2:Token'
        ns2__Token *token;
        /// Optional element 'ns2:issuer' of XML schema type 'ns2:issuer'
        ns2__issuer *issuer;
        /// Optional element 'ns2:recipient' of XML schema type 'ns2:Recipient'
        ns2__Recipient *recipient;
        /// Optional element 'ns2:feeProgramIndicator' of XML schema type 'xsd:string'
        std::string *feeProgramIndicator;
        /// Optional element 'ns2:installment' of XML schema type 'ns2:Installment'
        ns2__Installment *installment;
        /// Optional element 'ns2:paymentAccountReference' of XML schema type 'xsd:string'
        std::string *paymentAccountReference;
        /// Optional element 'ns2:paymentSolution' of XML schema type 'xsd:string'
        std::string *paymentSolution;
        /// Optional element 'ns2:authIndicator' of XML schema type 'xsd:string'
        std::string *authIndicator;
        /// Optional element 'ns2:ucaf' of XML schema type 'ns2:UCAF'
        ns2__UCAF *ucaf;
        /// Sequence of 0 to 100 elements 'ns2:network' of XML schema type 'ns2:Network'
        std::vector<ns2__Network> network;
        /// Optional element 'ns2:invoiceHeader' of XML schema type 'ns2:InvoiceHeader'
        ns2__InvoiceHeader *invoiceHeader;
        /// Optional element 'ns2:apOrderReply' of XML schema type 'ns2:APOrderReply'
        ns2__APOrderReply *apOrderReply;
        /// Optional element 'ns2:apCancelReply' of XML schema type 'ns2:APCancelReply'
        ns2__APCancelReply *apCancelReply;
        /// Optional element 'ns2:apBillingAgreementReply' of XML schema type 'ns2:APBillingAgreementReply'
        ns2__APBillingAgreementReply *apBillingAgreementReply;
        /// Optional element 'ns2:customerVerificationStatus' of XML schema type 'xsd:string'
        std::string *customerVerificationStatus;
        /// Optional element 'ns2:personalID' of XML schema type 'ns2:PersonalID'
        ns2__PersonalID *personalID;
        /// Optional element 'ns2:acquirerMerchantNumber' of XML schema type 'xsd:string'
        std::string *acquirerMerchantNumber;
        /// Optional element 'ns2:pos' of XML schema type 'ns2:Pos'
        ns2__Pos *pos;
        /// Sequence of 0 to 6 elements 'ns2:balanceInfo' of XML schema type 'ns2:BalanceInfo'
        std::vector<ns2__BalanceInfo> balanceInfo;
        /// Optional element 'ns2:issuerMessageAction' of XML schema type 'xsd:string'
        std::string *issuerMessageAction;
        /// Optional element 'ns2:customerID' of XML schema type 'xsd:string'
        std::string *customerID;
        /// Optional element 'ns2:routing' of XML schema type 'ns2:Routing'
        ns2__Routing *routing;
        /// Optional element 'ns2:transactionLocalDateTime' of XML schema type 'ns2:dateTime'
        std::string *transactionLocalDateTime;
        /// Optional element 'ns2:apCreateMandateReply' of XML schema type 'ns2:APCreateMandateReply'
        ns2__APCreateMandateReply *apCreateMandateReply;
        /// Optional element 'ns2:apMandateStatusReply' of XML schema type 'ns2:APMandateStatusReply'
        ns2__APMandateStatusReply *apMandateStatusReply;
        /// Optional element 'ns2:apUpdateMandateReply' of XML schema type 'ns2:APUpdateMandateReply'
        ns2__APUpdateMandateReply *apUpdateMandateReply;
        /// Optional element 'ns2:apImportMandateReply' of XML schema type 'ns2:APImportMandateReply'
        ns2__APImportMandateReply *apImportMandateReply;
        /// Optional element 'ns2:apRevokeMandateReply' of XML schema type 'ns2:APRevokeMandateReply'
        ns2__APRevokeMandateReply *apRevokeMandateReply;
        /// Optional element 'ns2:getMasterpassDataReply' of XML schema type 'ns2:GetMasterpassDataReply'
        ns2__GetMasterpassDataReply *getMasterpassDataReply;
        /// Optional element 'ns2:paymentNetworkMerchantID' of XML schema type 'xsd:string'
        std::string *paymentNetworkMerchantID;
        /// Optional element 'ns2:wallet' of XML schema type 'ns2:Wallet'
        ns2__Wallet *wallet;
        /// Optional element 'ns2:cashbackAmount' of XML schema type 'ns2:amount'
        std::string *cashbackAmount;
        /// Optional element 'ns2:giftCard' of XML schema type 'ns2:GiftCard'
        ns2__GiftCard *giftCard;
        /// Optional element 'ns2:giftCardActivationReply' of XML schema type 'ns2:GiftCardActivationReply'
        ns2__GiftCardActivationReply *giftCardActivationReply;
        /// Optional element 'ns2:giftCardBalanceInquiryReply' of XML schema type 'ns2:GiftCardBalanceInquiryReply'
        ns2__GiftCardBalanceInquiryReply *giftCardBalanceInquiryReply;
        /// Optional element 'ns2:giftCardRedemptionReply' of XML schema type 'ns2:GiftCardRedemptionReply'
        ns2__GiftCardRedemptionReply *giftCardRedemptionReply;
        /// Optional element 'ns2:giftCardVoidReply' of XML schema type 'ns2:GiftCardVoidReply'
        ns2__GiftCardVoidReply *giftCardVoidReply;
        /// Optional element 'ns2:giftCardReversalReply' of XML schema type 'ns2:GiftCardReversalReply'
        ns2__GiftCardReversalReply *giftCardReversalReply;
        /// Optional element 'ns2:giftCardReloadReply' of XML schema type 'ns2:GiftCardReloadReply'
        ns2__GiftCardReloadReply *giftCardReloadReply;
        /// Optional element 'ns2:giftCardRefundReply' of XML schema type 'ns2:GiftCardRefundReply'
        ns2__GiftCardRefundReply *giftCardRefundReply;
        /// Optional element 'ns2:ccCheckStatusReply' of XML schema type 'ns2:CCCheckStatusReply'
        ns2__CCCheckStatusReply *ccCheckStatusReply;
        /// Optional element 'ns2:ecAVSReply' of XML schema type 'ns2:ECAVSReply'
        ns2__ECAVSReply *ecAVSReply;
        /// Optional element 'ns2:abortReply' of XML schema type 'ns2:AbortReply'
        ns2__AbortReply *abortReply;
        /// Optional element 'ns2:payByPoints' of XML schema type 'ns2:payByPoints'
        ns2__payByPoints *payByPoints;
        /// Optional element 'ns2:reserved' of XML schema type 'ns2:ReplyReserved'
        ns2__ReplyReserved *reserved;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ReplyMessage
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ReplyMessage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ReplyMessage, default initialized and not managed by a soap context
        virtual ns2__ReplyMessage *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ReplyMessage); }
      public:
        /// Constructor with default initializations
        ns2__ReplyMessage() : merchantReferenceCode(), requestID(), decision(), reasonCode(), missingField(), invalidField(), requestToken(), purchaseTotals(), deniedPartiesMatch(), ccAuthReply(), octReply(), verificationReply(), ccSaleReply(), ccSaleCreditReply(), ccSaleReversalReply(), ccIncrementalAuthReply(), serviceFeeCalculateReply(), ccCaptureReply(), ccCreditReply(), ccAuthReversalReply(), ccAutoAuthReversalReply(), ccDCCReply(), ccDCCUpdateReply(), ecDebitReply(), ecCreditReply(), ecAuthenticateReply(), payerAuthSetupReply(), payerAuthEnrollReply(), payerAuthValidateReply(), taxReply(), encryptedPayment(), encryptPaymentDataReply(), dmeReply(), afsReply(), davReply(), exportReply(), fxRatesReply(), bankTransferReply(), bankTransferRefundReply(), bankTransferRealTimeReply(), directDebitMandateReply(), directDebitReply(), directDebitValidateReply(), directDebitRefundReply(), paySubscriptionCreateReply(), paySubscriptionUpdateReply(), paySubscriptionEventUpdateReply(), paySubscriptionRetrieveReply(), paySubscriptionDeleteReply(), payPalPaymentReply(), payPalCreditReply(), voidReply(), pinlessDebitReply(), pinlessDebitValidateReply(), pinlessDebitReversalReply(), payPalButtonCreateReply(), payPalPreapprovedPaymentReply(), payPalPreapprovedUpdateReply(), riskUpdateReply(), fraudUpdateReply(), caseManagementActionReply(), decisionEarlyReply(), decisionReply(), payPalRefundReply(), payPalAuthReversalReply(), payPalDoCaptureReply(), payPalEcDoPaymentReply(), payPalEcGetDetailsReply(), payPalEcSetReply(), payPalAuthorizationReply(), payPalEcOrderSetupReply(), payPalUpdateAgreementReply(), payPalCreateAgreementReply(), payPalDoRefTransactionReply(), chinaPaymentReply(), chinaRefundReply(), boletoPaymentReply(), pinDebitPurchaseReply(), pinDebitCreditReply(), pinDebitReversalReply(), apInitiateReply(), apCheckStatusReply(), receiptNumber(), additionalData(), solutionProviderTransactionID(), apReply(), shipTo(), billTo(), apAuthReply(), apSessionsReply(), apAuthReversalReply(), apCaptureReply(), apOptionsReply(), apRefundReply(), apSaleReply(), apCheckoutDetailsReply(), apTransactionDetailsReply(), apConfirmPurchaseReply(), promotion(), promotionGroup(), payPalGetTxnDetailsReply(), payPalTransactionSearchReply(), emvReply(), originalTransaction(), hostedDataCreateReply(), hostedDataRetrieveReply(), salesSlipNumber(), additionalProcessorResponse(), jpo(), card(), paymentNetworkToken(), vcReply(), decryptVisaCheckoutDataReply(), getVisaCheckoutDataReply(), binLookupReply(), issuerMessage(), token(), issuer(), recipient(), feeProgramIndicator(), installment(), paymentAccountReference(), paymentSolution(), authIndicator(), ucaf(), network(), invoiceHeader(), apOrderReply(), apCancelReply(), apBillingAgreementReply(), customerVerificationStatus(), personalID(), acquirerMerchantNumber(), pos(), balanceInfo(), issuerMessageAction(), customerID(), routing(), transactionLocalDateTime(), apCreateMandateReply(), apMandateStatusReply(), apUpdateMandateReply(), apImportMandateReply(), apRevokeMandateReply(), getMasterpassDataReply(), paymentNetworkMerchantID(), wallet(), cashbackAmount(), giftCard(), giftCardActivationReply(), giftCardBalanceInquiryReply(), giftCardRedemptionReply(), giftCardVoidReply(), giftCardReversalReply(), giftCardReloadReply(), giftCardRefundReply(), ccCheckStatusReply(), ecAVSReply(), abortReply(), payByPoints(), reserved(), soap() { }
        virtual ~ns2__ReplyMessage() { }
        /// Friend allocator used by soap_new_ns2__ReplyMessage(struct soap*, int)
        friend SOAP_FMAC1 ns2__ReplyMessage * SOAP_FMAC2 soap_instantiate_ns2__ReplyMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:648 */
#ifndef SOAP_TYPE_ns2__FaultDetails
#define SOAP_TYPE_ns2__FaultDetails (519)
/* complex XML schema type 'ns2:FaultDetails': */
class SOAP_CMAC ns2__FaultDetails {
      public:
        /// Required element 'ns2:requestID' of XML schema type 'xsd:string'
        std::string requestID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FaultDetails
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__FaultDetails; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FaultDetails, default initialized and not managed by a soap context
        virtual ns2__FaultDetails *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__FaultDetails); }
      public:
        /// Constructor with default initializations
        ns2__FaultDetails() : requestID(), soap() { }
        virtual ~ns2__FaultDetails() { }
        /// Friend allocator used by soap_new_ns2__FaultDetails(struct soap*, int)
        friend SOAP_FMAC1 ns2__FaultDetails * SOAP_FMAC2 soap_instantiate_ns2__FaultDetails(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:650 */
#ifndef SOAP_TYPE_ns2__AirlineData
#define SOAP_TYPE_ns2__AirlineData (520)
/* complex XML schema type 'ns2:AirlineData': */
class SOAP_CMAC ns2__AirlineData {
      public:
        /// Optional element 'ns2:agentCode' of XML schema type 'xsd:string'
        std::string *agentCode;
        /// Optional element 'ns2:agentName' of XML schema type 'xsd:string'
        std::string *agentName;
        /// Optional element 'ns2:ticketIssuerCity' of XML schema type 'xsd:string'
        std::string *ticketIssuerCity;
        /// Optional element 'ns2:ticketIssuerState' of XML schema type 'xsd:string'
        std::string *ticketIssuerState;
        /// Optional element 'ns2:ticketIssuerPostalCode' of XML schema type 'xsd:string'
        std::string *ticketIssuerPostalCode;
        /// Optional element 'ns2:ticketIssuerCountry' of XML schema type 'xsd:string'
        std::string *ticketIssuerCountry;
        /// Optional element 'ns2:ticketIssuerAddress' of XML schema type 'xsd:string'
        std::string *ticketIssuerAddress;
        /// Optional element 'ns2:ticketIssuerCode' of XML schema type 'xsd:string'
        std::string *ticketIssuerCode;
        /// Optional element 'ns2:ticketIssuerName' of XML schema type 'xsd:string'
        std::string *ticketIssuerName;
        /// Optional element 'ns2:ticketNumber' of XML schema type 'xsd:string'
        std::string *ticketNumber;
        /// Optional element 'ns2:checkDigit' of XML schema type 'xsd:integer'
        std::string *checkDigit;
        /// Optional element 'ns2:restrictedTicketIndicator' of XML schema type 'xsd:integer'
        std::string *restrictedTicketIndicator;
        /// Optional element 'ns2:transactionType' of XML schema type 'xsd:string'
        std::string *transactionType;
        /// Optional element 'ns2:extendedPaymentCode' of XML schema type 'xsd:string'
        std::string *extendedPaymentCode;
        /// Optional element 'ns2:carrierName' of XML schema type 'xsd:string'
        std::string *carrierName;
        /// Optional element 'ns2:passengerName' of XML schema type 'xsd:string'
        std::string *passengerName;
        /// Sequence of 0 to 1000 elements 'ns2:passenger' of XML schema type 'ns2:Passenger'
        std::vector<ns2__Passenger> passenger;
        /// Optional element 'ns2:customerCode' of XML schema type 'xsd:string'
        std::string *customerCode;
        /// Optional element 'ns2:documentType' of XML schema type 'xsd:string'
        std::string *documentType;
        /// Optional element 'ns2:documentNumber' of XML schema type 'xsd:string'
        std::string *documentNumber;
        /// Optional element 'ns2:documentNumberOfParts' of XML schema type 'xsd:string'
        std::string *documentNumberOfParts;
        /// Optional element 'ns2:invoiceNumber' of XML schema type 'xsd:string'
        std::string *invoiceNumber;
        /// Optional element 'ns2:invoiceDate' of XML schema type 'xsd:string'
        std::string *invoiceDate;
        /// Optional element 'ns2:chargeDetails' of XML schema type 'xsd:string'
        std::string *chargeDetails;
        /// Optional element 'ns2:bookingReference' of XML schema type 'xsd:string'
        std::string *bookingReference;
        /// Optional element 'ns2:totalFee' of XML schema type 'ns2:amount'
        std::string *totalFee;
        /// Optional element 'ns2:clearingSequence' of XML schema type 'xsd:string'
        std::string *clearingSequence;
        /// Optional element 'ns2:clearingCount' of XML schema type 'xsd:integer'
        std::string *clearingCount;
        /// Optional element 'ns2:totalClearingAmount' of XML schema type 'ns2:amount'
        std::string *totalClearingAmount;
        /// Sequence of 0 to 1000 elements 'ns2:leg' of XML schema type 'ns2:Leg'
        std::vector<ns2__Leg> leg;
        /// Optional element 'ns2:numberOfPassengers' of XML schema type 'xsd:string'
        std::string *numberOfPassengers;
        /// Optional element 'ns2:reservationSystem' of XML schema type 'xsd:string'
        std::string *reservationSystem;
        /// Optional element 'ns2:processIdentifier' of XML schema type 'xsd:string'
        std::string *processIdentifier;
        /// Optional element 'ns2:iataNumericCode' of XML schema type 'xsd:string'
        std::string *iataNumericCode;
        /// Optional element 'ns2:ticketIssueDate' of XML schema type 'xsd:string'
        std::string *ticketIssueDate;
        /// Optional element 'ns2:electronicTicket' of XML schema type 'xsd:string'
        std::string *electronicTicket;
        /// Optional element 'ns2:originalTicketNumber' of XML schema type 'xsd:string'
        std::string *originalTicketNumber;
        /// Optional element 'ns2:purchaseType' of XML schema type 'xsd:string'
        std::string *purchaseType;
        /// Optional element 'ns2:creditReasonIndicator' of XML schema type 'xsd:string'
        std::string *creditReasonIndicator;
        /// Optional element 'ns2:ticketUpdateIndicator' of XML schema type 'xsd:string'
        std::string *ticketUpdateIndicator;
        /// Optional element 'ns2:planNumber' of XML schema type 'xsd:string'
        std::string *planNumber;
        /// Optional element 'ns2:arrivalDate' of XML schema type 'xsd:string'
        std::string *arrivalDate;
        /// Optional element 'ns2:ticketRestrictionText' of XML schema type 'xsd:string'
        std::string *ticketRestrictionText;
        /// Optional element 'ns2:exchangeTicketAmount' of XML schema type 'ns2:amount'
        std::string *exchangeTicketAmount;
        /// Optional element 'ns2:exchangeTicketFee' of XML schema type 'ns2:amount'
        std::string *exchangeTicketFee;
        /// Optional element 'ns2:journeyType' of XML schema type 'xsd:string'
        std::string *journeyType;
        /// Optional element 'ns2:boardingFee' of XML schema type 'xsd:string'
        std::string *boardingFee;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AirlineData
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__AirlineData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AirlineData, default initialized and not managed by a soap context
        virtual ns2__AirlineData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__AirlineData); }
      public:
        /// Constructor with default initializations
        ns2__AirlineData() : agentCode(), agentName(), ticketIssuerCity(), ticketIssuerState(), ticketIssuerPostalCode(), ticketIssuerCountry(), ticketIssuerAddress(), ticketIssuerCode(), ticketIssuerName(), ticketNumber(), checkDigit(), restrictedTicketIndicator(), transactionType(), extendedPaymentCode(), carrierName(), passengerName(), passenger(), customerCode(), documentType(), documentNumber(), documentNumberOfParts(), invoiceNumber(), invoiceDate(), chargeDetails(), bookingReference(), totalFee(), clearingSequence(), clearingCount(), totalClearingAmount(), leg(), numberOfPassengers(), reservationSystem(), processIdentifier(), iataNumericCode(), ticketIssueDate(), electronicTicket(), originalTicketNumber(), purchaseType(), creditReasonIndicator(), ticketUpdateIndicator(), planNumber(), arrivalDate(), ticketRestrictionText(), exchangeTicketAmount(), exchangeTicketFee(), journeyType(), boardingFee(), soap() { }
        virtual ~ns2__AirlineData() { }
        /// Friend allocator used by soap_new_ns2__AirlineData(struct soap*, int)
        friend SOAP_FMAC1 ns2__AirlineData * SOAP_FMAC2 soap_instantiate_ns2__AirlineData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:652 */
#ifndef SOAP_TYPE_ns2__Leg
#define SOAP_TYPE_ns2__Leg (521)
/* complex XML schema type 'ns2:Leg': */
class SOAP_CMAC ns2__Leg {
      public:
        /// Optional element 'ns2:carrierCode' of XML schema type 'xsd:string'
        std::string *carrierCode;
        /// Optional element 'ns2:flightNumber' of XML schema type 'xsd:string'
        std::string *flightNumber;
        /// Optional element 'ns2:originatingAirportCode' of XML schema type 'xsd:string'
        std::string *originatingAirportCode;
        /// Optional element 'ns2:class' of XML schema type 'xsd:string'
        std::string *class_;
        /// Optional element 'ns2:stopoverCode' of XML schema type 'xsd:string'
        std::string *stopoverCode;
        /// Optional element 'ns2:departureDate' of XML schema type 'xsd:string'
        std::string *departureDate;
        /// Optional element 'ns2:destination' of XML schema type 'xsd:string'
        std::string *destination;
        /// Optional element 'ns2:fareBasis' of XML schema type 'xsd:string'
        std::string *fareBasis;
        /// Optional element 'ns2:departTax' of XML schema type 'xsd:string'
        std::string *departTax;
        /// Optional element 'ns2:conjunctionTicket' of XML schema type 'xsd:string'
        std::string *conjunctionTicket;
        /// Optional element 'ns2:exchangeTicket' of XML schema type 'xsd:string'
        std::string *exchangeTicket;
        /// Optional element 'ns2:couponNumber' of XML schema type 'xsd:string'
        std::string *couponNumber;
        /// Optional element 'ns2:departureTime' of XML schema type 'xsd:string'
        std::string *departureTime;
        /// Optional element 'ns2:departureTimeSegment' of XML schema type 'xsd:string'
        std::string *departureTimeSegment;
        /// Optional element 'ns2:arrivalTime' of XML schema type 'xsd:string'
        std::string *arrivalTime;
        /// Optional element 'ns2:arrivalTimeSegment' of XML schema type 'xsd:string'
        std::string *arrivalTimeSegment;
        /// Optional element 'ns2:endorsementsRestrictions' of XML schema type 'xsd:string'
        std::string *endorsementsRestrictions;
        /// Optional element 'ns2:fare' of XML schema type 'xsd:string'
        std::string *fare;
        /// Optional element 'ns2:fee' of XML schema type 'xsd:string'
        std::string *fee;
        /// Optional element 'ns2:tax' of XML schema type 'xsd:string'
        std::string *tax;
        /// Required attribute 'id' of XML schema type 'xsd:integer'
        std::string id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Leg
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Leg; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Leg, default initialized and not managed by a soap context
        virtual ns2__Leg *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Leg); }
      public:
        /// Constructor with default initializations
        ns2__Leg() : carrierCode(), flightNumber(), originatingAirportCode(), class_(), stopoverCode(), departureDate(), destination(), fareBasis(), departTax(), conjunctionTicket(), exchangeTicket(), couponNumber(), departureTime(), departureTimeSegment(), arrivalTime(), arrivalTimeSegment(), endorsementsRestrictions(), fare(), fee(), tax(), id(), soap() { }
        virtual ~ns2__Leg() { }
        /// Friend allocator used by soap_new_ns2__Leg(struct soap*, int)
        friend SOAP_FMAC1 ns2__Leg * SOAP_FMAC2 soap_instantiate_ns2__Leg(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:654 */
#ifndef SOAP_TYPE_ns2__AncillaryData
#define SOAP_TYPE_ns2__AncillaryData (522)
/* complex XML schema type 'ns2:AncillaryData': */
class SOAP_CMAC ns2__AncillaryData {
      public:
        /// Optional element 'ns2:ticketNumber' of XML schema type 'xsd:string'
        std::string *ticketNumber;
        /// Optional element 'ns2:passengerName' of XML schema type 'xsd:string'
        std::string *passengerName;
        /// Optional element 'ns2:connectedTicketNumber' of XML schema type 'xsd:string'
        std::string *connectedTicketNumber;
        /// Optional element 'ns2:creditReasonIndicator' of XML schema type 'xsd:string'
        std::string *creditReasonIndicator;
        /// Sequence of 0 to 1000 elements 'ns2:service' of XML schema type 'ns2:Service'
        std::vector<ns2__Service> service;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AncillaryData
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__AncillaryData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AncillaryData, default initialized and not managed by a soap context
        virtual ns2__AncillaryData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__AncillaryData); }
      public:
        /// Constructor with default initializations
        ns2__AncillaryData() : ticketNumber(), passengerName(), connectedTicketNumber(), creditReasonIndicator(), service(), soap() { }
        virtual ~ns2__AncillaryData() { }
        /// Friend allocator used by soap_new_ns2__AncillaryData(struct soap*, int)
        friend SOAP_FMAC1 ns2__AncillaryData * SOAP_FMAC2 soap_instantiate_ns2__AncillaryData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:656 */
#ifndef SOAP_TYPE_ns2__Service
#define SOAP_TYPE_ns2__Service (523)
/* complex XML schema type 'ns2:Service': */
class SOAP_CMAC ns2__Service {
      public:
        /// Optional element 'ns2:categoryCode' of XML schema type 'xsd:string'
        std::string *categoryCode;
        /// Optional element 'ns2:subcategoryCode' of XML schema type 'xsd:string'
        std::string *subcategoryCode;
        /// Required attribute 'id' of XML schema type 'xsd:integer'
        std::string id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Service
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Service; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Service, default initialized and not managed by a soap context
        virtual ns2__Service *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Service); }
      public:
        /// Constructor with default initializations
        ns2__Service() : categoryCode(), subcategoryCode(), id(), soap() { }
        virtual ~ns2__Service() { }
        /// Friend allocator used by soap_new_ns2__Service(struct soap*, int)
        friend SOAP_FMAC1 ns2__Service * SOAP_FMAC2 soap_instantiate_ns2__Service(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:658 */
#ifndef SOAP_TYPE_ns2__LodgingData
#define SOAP_TYPE_ns2__LodgingData (524)
/* complex XML schema type 'ns2:LodgingData': */
class SOAP_CMAC ns2__LodgingData {
      public:
        /// Optional element 'ns2:checkInDate' of XML schema type 'xsd:string'
        std::string *checkInDate;
        /// Optional element 'ns2:checkOutDate' of XML schema type 'xsd:string'
        std::string *checkOutDate;
        /// Optional element 'ns2:dailyRoomRate1' of XML schema type 'ns2:amount'
        std::string *dailyRoomRate1;
        /// Optional element 'ns2:dailyRoomRate2' of XML schema type 'ns2:amount'
        std::string *dailyRoomRate2;
        /// Optional element 'ns2:dailyRoomRate3' of XML schema type 'ns2:amount'
        std::string *dailyRoomRate3;
        /// Optional element 'ns2:roomNights1' of XML schema type 'xsd:integer'
        std::string *roomNights1;
        /// Optional element 'ns2:roomNights2' of XML schema type 'xsd:integer'
        std::string *roomNights2;
        /// Optional element 'ns2:roomNights3' of XML schema type 'xsd:integer'
        std::string *roomNights3;
        /// Optional element 'ns2:guestSmokingPreference' of XML schema type 'xsd:string'
        std::string *guestSmokingPreference;
        /// Optional element 'ns2:numberOfRoomsBooked' of XML schema type 'xsd:integer'
        std::string *numberOfRoomsBooked;
        /// Optional element 'ns2:numberOfGuests' of XML schema type 'xsd:integer'
        std::string *numberOfGuests;
        /// Optional element 'ns2:roomBedType' of XML schema type 'xsd:string'
        std::string *roomBedType;
        /// Optional element 'ns2:roomTaxElements' of XML schema type 'xsd:string'
        std::string *roomTaxElements;
        /// Optional element 'ns2:roomRateType' of XML schema type 'xsd:string'
        std::string *roomRateType;
        /// Optional element 'ns2:guestName' of XML schema type 'xsd:string'
        std::string *guestName;
        /// Optional element 'ns2:customerServicePhoneNumber' of XML schema type 'xsd:string'
        std::string *customerServicePhoneNumber;
        /// Optional element 'ns2:corporateClientCode' of XML schema type 'xsd:string'
        std::string *corporateClientCode;
        /// Optional element 'ns2:promotionalCode' of XML schema type 'xsd:string'
        std::string *promotionalCode;
        /// Optional element 'ns2:additionalCoupon' of XML schema type 'xsd:string'
        std::string *additionalCoupon;
        /// Optional element 'ns2:roomLocation' of XML schema type 'xsd:string'
        std::string *roomLocation;
        /// Optional element 'ns2:specialProgramCode' of XML schema type 'xsd:string'
        std::string *specialProgramCode;
        /// Optional element 'ns2:tax' of XML schema type 'ns2:amount'
        std::string *tax;
        /// Optional element 'ns2:prepaidCost' of XML schema type 'ns2:amount'
        std::string *prepaidCost;
        /// Optional element 'ns2:foodAndBeverageCost' of XML schema type 'ns2:amount'
        std::string *foodAndBeverageCost;
        /// Optional element 'ns2:roomTax' of XML schema type 'ns2:amount'
        std::string *roomTax;
        /// Optional element 'ns2:adjustmentAmount' of XML schema type 'ns2:amount'
        std::string *adjustmentAmount;
        /// Optional element 'ns2:phoneCost' of XML schema type 'ns2:amount'
        std::string *phoneCost;
        /// Optional element 'ns2:restaurantCost' of XML schema type 'ns2:amount'
        std::string *restaurantCost;
        /// Optional element 'ns2:roomServiceCost' of XML schema type 'ns2:amount'
        std::string *roomServiceCost;
        /// Optional element 'ns2:miniBarCost' of XML schema type 'ns2:amount'
        std::string *miniBarCost;
        /// Optional element 'ns2:laundryCost' of XML schema type 'ns2:amount'
        std::string *laundryCost;
        /// Optional element 'ns2:miscellaneousCost' of XML schema type 'ns2:amount'
        std::string *miscellaneousCost;
        /// Optional element 'ns2:giftShopCost' of XML schema type 'ns2:amount'
        std::string *giftShopCost;
        /// Optional element 'ns2:movieCost' of XML schema type 'ns2:amount'
        std::string *movieCost;
        /// Optional element 'ns2:healthClubCost' of XML schema type 'ns2:amount'
        std::string *healthClubCost;
        /// Optional element 'ns2:valetParkingCost' of XML schema type 'ns2:amount'
        std::string *valetParkingCost;
        /// Optional element 'ns2:cashDisbursementCost' of XML schema type 'ns2:amount'
        std::string *cashDisbursementCost;
        /// Optional element 'ns2:nonRoomCost' of XML schema type 'ns2:amount'
        std::string *nonRoomCost;
        /// Optional element 'ns2:businessCenterCost' of XML schema type 'ns2:amount'
        std::string *businessCenterCost;
        /// Optional element 'ns2:loungeBarCost' of XML schema type 'ns2:amount'
        std::string *loungeBarCost;
        /// Optional element 'ns2:transportationCost' of XML schema type 'ns2:amount'
        std::string *transportationCost;
        /// Optional element 'ns2:gratuityCost' of XML schema type 'ns2:amount'
        std::string *gratuityCost;
        /// Optional element 'ns2:conferenceRoomCost' of XML schema type 'ns2:amount'
        std::string *conferenceRoomCost;
        /// Optional element 'ns2:audioVisualCost' of XML schema type 'ns2:amount'
        std::string *audioVisualCost;
        /// Optional element 'ns2:banquetCost' of XML schema type 'ns2:amount'
        std::string *banquetCost;
        /// Optional element 'ns2:internetAccessCost' of XML schema type 'ns2:amount'
        std::string *internetAccessCost;
        /// Optional element 'ns2:earlyCheckOutCost' of XML schema type 'ns2:amount'
        std::string *earlyCheckOutCost;
        /// Optional element 'ns2:nonRoomTax' of XML schema type 'ns2:amount'
        std::string *nonRoomTax;
        /// Optional element 'ns2:travelAgencyCode' of XML schema type 'xsd:string'
        std::string *travelAgencyCode;
        /// Optional element 'ns2:travelAgencyName' of XML schema type 'xsd:string'
        std::string *travelAgencyName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__LodgingData
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__LodgingData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__LodgingData, default initialized and not managed by a soap context
        virtual ns2__LodgingData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__LodgingData); }
      public:
        /// Constructor with default initializations
        ns2__LodgingData() : checkInDate(), checkOutDate(), dailyRoomRate1(), dailyRoomRate2(), dailyRoomRate3(), roomNights1(), roomNights2(), roomNights3(), guestSmokingPreference(), numberOfRoomsBooked(), numberOfGuests(), roomBedType(), roomTaxElements(), roomRateType(), guestName(), customerServicePhoneNumber(), corporateClientCode(), promotionalCode(), additionalCoupon(), roomLocation(), specialProgramCode(), tax(), prepaidCost(), foodAndBeverageCost(), roomTax(), adjustmentAmount(), phoneCost(), restaurantCost(), roomServiceCost(), miniBarCost(), laundryCost(), miscellaneousCost(), giftShopCost(), movieCost(), healthClubCost(), valetParkingCost(), cashDisbursementCost(), nonRoomCost(), businessCenterCost(), loungeBarCost(), transportationCost(), gratuityCost(), conferenceRoomCost(), audioVisualCost(), banquetCost(), internetAccessCost(), earlyCheckOutCost(), nonRoomTax(), travelAgencyCode(), travelAgencyName(), soap() { }
        virtual ~ns2__LodgingData() { }
        /// Friend allocator used by soap_new_ns2__LodgingData(struct soap*, int)
        friend SOAP_FMAC1 ns2__LodgingData * SOAP_FMAC2 soap_instantiate_ns2__LodgingData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:660 */
#ifndef SOAP_TYPE_ns2__Pos
#define SOAP_TYPE_ns2__Pos (525)
/* complex XML schema type 'ns2:Pos': */
class SOAP_CMAC ns2__Pos {
      public:
        /// Optional element 'ns2:entryMode' of XML schema type 'xsd:string'
        std::string *entryMode;
        /// Optional element 'ns2:cardPresent' of XML schema type 'xsd:string'
        std::string *cardPresent;
        /// Optional element 'ns2:terminalCapability' of XML schema type 'xsd:string'
        std::string *terminalCapability;
        /// Optional element 'ns2:trackData' of XML schema type 'xsd:string'
        std::string *trackData;
        /// Optional element 'ns2:terminalID' of XML schema type 'xsd:string'
        std::string *terminalID;
        /// Optional element 'ns2:terminalType' of XML schema type 'xsd:string'
        std::string *terminalType;
        /// Optional element 'ns2:terminalLocation' of XML schema type 'xsd:string'
        std::string *terminalLocation;
        /// Optional element 'ns2:transactionSecurity' of XML schema type 'xsd:string'
        std::string *transactionSecurity;
        /// Optional element 'ns2:catLevel' of XML schema type 'xsd:string'
        std::string *catLevel;
        /// Optional element 'ns2:conditionCode' of XML schema type 'xsd:string'
        std::string *conditionCode;
        /// Optional element 'ns2:environment' of XML schema type 'xsd:string'
        std::string *environment;
        /// Optional element 'ns2:paymentData' of XML schema type 'xsd:string'
        std::string *paymentData;
        /// Optional element 'ns2:deviceReaderData' of XML schema type 'xsd:string'
        std::string *deviceReaderData;
        /// Optional element 'ns2:encryptionAlgorithm' of XML schema type 'xsd:string'
        std::string *encryptionAlgorithm;
        /// Optional element 'ns2:encodingMethod' of XML schema type 'xsd:string'
        std::string *encodingMethod;
        /// Optional element 'ns2:deviceID' of XML schema type 'xsd:string'
        std::string *deviceID;
        /// Optional element 'ns2:serviceCode' of XML schema type 'xsd:string'
        std::string *serviceCode;
        /// Optional element 'ns2:terminalIDAlternate' of XML schema type 'xsd:string'
        std::string *terminalIDAlternate;
        /// Optional element 'ns2:terminalCompliance' of XML schema type 'xsd:integer'
        std::string *terminalCompliance;
        /// Optional element 'ns2:terminalCardCaptureCapability' of XML schema type 'xsd:string'
        std::string *terminalCardCaptureCapability;
        /// Optional element 'ns2:terminalOutputCapability' of XML schema type 'xsd:string'
        std::string *terminalOutputCapability;
        /// Optional element 'ns2:terminalPINcapability' of XML schema type 'xsd:string'
        std::string *terminalPINcapability;
        /// Optional element 'ns2:terminalCVMcapabilities_0' of XML schema type 'xsd:string'
        std::string *terminalCVMcapabilities_USCORE0;
        /// Optional element 'ns2:terminalCVMcapabilities_1' of XML schema type 'xsd:string'
        std::string *terminalCVMcapabilities_USCORE1;
        /// Optional element 'ns2:terminalCVMcapabilities_2' of XML schema type 'xsd:string'
        std::string *terminalCVMcapabilities_USCORE2;
        /// Optional element 'ns2:terminalInputCapabilities_0' of XML schema type 'xsd:string'
        std::string *terminalInputCapabilities_USCORE0;
        /// Optional element 'ns2:terminalInputCapabilities_1' of XML schema type 'xsd:string'
        std::string *terminalInputCapabilities_USCORE1;
        /// Optional element 'ns2:terminalInputCapabilities_2' of XML schema type 'xsd:string'
        std::string *terminalInputCapabilities_USCORE2;
        /// Optional element 'ns2:terminalInputCapabilities_3' of XML schema type 'xsd:string'
        std::string *terminalInputCapabilities_USCORE3;
        /// Optional element 'ns2:terminalInputCapabilities_4' of XML schema type 'xsd:string'
        std::string *terminalInputCapabilities_USCORE4;
        /// Optional element 'ns2:terminalInputCapabilities_5' of XML schema type 'xsd:string'
        std::string *terminalInputCapabilities_USCORE5;
        /// Optional element 'ns2:terminalInputCapabilities_6' of XML schema type 'xsd:string'
        std::string *terminalInputCapabilities_USCORE6;
        /// Optional element 'ns2:terminalSerialNumber' of XML schema type 'xsd:string'
        std::string *terminalSerialNumber;
        /// Optional element 'ns2:storeAndForwardIndicator' of XML schema type 'xsd:string'
        std::string *storeAndForwardIndicator;
        /// Optional element 'ns2:panEntryMode' of XML schema type 'xsd:string'
        std::string *panEntryMode;
        /// Optional element 'ns2:endlessAisleTransactionIndicator' of XML schema type 'ns2:boolean'
        std::string *endlessAisleTransactionIndicator;
        /// Optional element 'ns2:terminalModel' of XML schema type 'xsd:string'
        std::string *terminalModel;
        /// Optional element 'ns2:terminalMake' of XML schema type 'xsd:string'
        std::string *terminalMake;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Pos
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Pos; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Pos, default initialized and not managed by a soap context
        virtual ns2__Pos *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Pos); }
      public:
        /// Constructor with default initializations
        ns2__Pos() : entryMode(), cardPresent(), terminalCapability(), trackData(), terminalID(), terminalType(), terminalLocation(), transactionSecurity(), catLevel(), conditionCode(), environment(), paymentData(), deviceReaderData(), encryptionAlgorithm(), encodingMethod(), deviceID(), serviceCode(), terminalIDAlternate(), terminalCompliance(), terminalCardCaptureCapability(), terminalOutputCapability(), terminalPINcapability(), terminalCVMcapabilities_USCORE0(), terminalCVMcapabilities_USCORE1(), terminalCVMcapabilities_USCORE2(), terminalInputCapabilities_USCORE0(), terminalInputCapabilities_USCORE1(), terminalInputCapabilities_USCORE2(), terminalInputCapabilities_USCORE3(), terminalInputCapabilities_USCORE4(), terminalInputCapabilities_USCORE5(), terminalInputCapabilities_USCORE6(), terminalSerialNumber(), storeAndForwardIndicator(), panEntryMode(), endlessAisleTransactionIndicator(), terminalModel(), terminalMake(), soap() { }
        virtual ~ns2__Pos() { }
        /// Friend allocator used by soap_new_ns2__Pos(struct soap*, int)
        friend SOAP_FMAC1 ns2__Pos * SOAP_FMAC2 soap_instantiate_ns2__Pos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:662 */
#ifndef SOAP_TYPE_ns2__Pin
#define SOAP_TYPE_ns2__Pin (526)
/* complex XML schema type 'ns2:Pin': */
class SOAP_CMAC ns2__Pin {
      public:
        /// Optional element 'ns2:entryCapability' of XML schema type 'xsd:string'
        std::string *entryCapability;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Pin
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Pin; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Pin, default initialized and not managed by a soap context
        virtual ns2__Pin *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Pin); }
      public:
        /// Constructor with default initializations
        ns2__Pin() : entryCapability(), soap() { }
        virtual ~ns2__Pin() { }
        /// Friend allocator used by soap_new_ns2__Pin(struct soap*, int)
        friend SOAP_FMAC1 ns2__Pin * SOAP_FMAC2 soap_instantiate_ns2__Pin(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:664 */
#ifndef SOAP_TYPE_ns2__EncryptedPayment
#define SOAP_TYPE_ns2__EncryptedPayment (527)
/* complex XML schema type 'ns2:EncryptedPayment': */
class SOAP_CMAC ns2__EncryptedPayment {
      public:
        /// Optional element 'ns2:descriptor' of XML schema type 'xsd:string'
        std::string *descriptor;
        /// Optional element 'ns2:data' of XML schema type 'xsd:string'
        std::string *data;
        /// Optional element 'ns2:encoding' of XML schema type 'xsd:string'
        std::string *encoding;
        /// Optional element 'ns2:wrappedKey' of XML schema type 'xsd:string'
        std::string *wrappedKey;
        /// Optional element 'ns2:referenceID' of XML schema type 'xsd:integer'
        std::string *referenceID;
        /// Optional element 'ns2:errorCode' of XML schema type 'xsd:string'
        std::string *errorCode;
        /// Optional element 'ns2:keySerialNumber' of XML schema type 'xsd:string'
        std::string *keySerialNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__EncryptedPayment
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__EncryptedPayment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__EncryptedPayment, default initialized and not managed by a soap context
        virtual ns2__EncryptedPayment *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__EncryptedPayment); }
      public:
        /// Constructor with default initializations
        ns2__EncryptedPayment() : descriptor(), data(), encoding(), wrappedKey(), referenceID(), errorCode(), keySerialNumber(), soap() { }
        virtual ~ns2__EncryptedPayment() { }
        /// Friend allocator used by soap_new_ns2__EncryptedPayment(struct soap*, int)
        friend SOAP_FMAC1 ns2__EncryptedPayment * SOAP_FMAC2 soap_instantiate_ns2__EncryptedPayment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:666 */
#ifndef SOAP_TYPE_ns2__Installment
#define SOAP_TYPE_ns2__Installment (528)
/* complex XML schema type 'ns2:Installment': */
class SOAP_CMAC ns2__Installment {
      public:
        /// Optional element 'ns2:sequence' of XML schema type 'xsd:string'
        std::string *sequence;
        /// Optional element 'ns2:totalCount' of XML schema type 'xsd:string'
        std::string *totalCount;
        /// Optional element 'ns2:totalAmount' of XML schema type 'xsd:string'
        std::string *totalAmount;
        /// Optional element 'ns2:frequency' of XML schema type 'xsd:string'
        std::string *frequency;
        /// Optional element 'ns2:amount' of XML schema type 'xsd:string'
        std::string *amount;
        /// Optional element 'ns2:planType' of XML schema type 'xsd:string'
        std::string *planType;
        /// Optional element 'ns2:firstInstallmentDate' of XML schema type 'xsd:string'
        std::string *firstInstallmentDate;
        /// Optional element 'ns2:amountFunded' of XML schema type 'xsd:string'
        std::string *amountFunded;
        /// Optional element 'ns2:amountRequestedPercentage' of XML schema type 'xsd:string'
        std::string *amountRequestedPercentage;
        /// Optional element 'ns2:expenses' of XML schema type 'xsd:string'
        std::string *expenses;
        /// Optional element 'ns2:expensesPercentage' of XML schema type 'xsd:string'
        std::string *expensesPercentage;
        /// Optional element 'ns2:fees' of XML schema type 'xsd:string'
        std::string *fees;
        /// Optional element 'ns2:feesPercentage' of XML schema type 'xsd:string'
        std::string *feesPercentage;
        /// Optional element 'ns2:taxes' of XML schema type 'xsd:string'
        std::string *taxes;
        /// Optional element 'ns2:taxesPercentage' of XML schema type 'xsd:string'
        std::string *taxesPercentage;
        /// Optional element 'ns2:insurance' of XML schema type 'xsd:string'
        std::string *insurance;
        /// Optional element 'ns2:insurancePercentage' of XML schema type 'xsd:string'
        std::string *insurancePercentage;
        /// Optional element 'ns2:additionalCosts' of XML schema type 'xsd:string'
        std::string *additionalCosts;
        /// Optional element 'ns2:additionalCostsPercentage' of XML schema type 'xsd:string'
        std::string *additionalCostsPercentage;
        /// Optional element 'ns2:monthlyInterestRate' of XML schema type 'xsd:string'
        std::string *monthlyInterestRate;
        /// Optional element 'ns2:annualInterestRate' of XML schema type 'xsd:string'
        std::string *annualInterestRate;
        /// Optional element 'ns2:annualFinancingCost' of XML schema type 'xsd:string'
        std::string *annualFinancingCost;
        /// Optional element 'ns2:paymentType' of XML schema type 'xsd:string'
        std::string *paymentType;
        /// Optional element 'ns2:invoiceData' of XML schema type 'xsd:string'
        std::string *invoiceData;
        /// Optional element 'ns2:downPayment' of XML schema type 'xsd:string'
        std::string *downPayment;
        /// Optional element 'ns2:firstInstallmentAmount' of XML schema type 'xsd:string'
        std::string *firstInstallmentAmount;
        /// Optional element 'ns2:minimumTotalCount' of XML schema type 'xsd:string'
        std::string *minimumTotalCount;
        /// Optional element 'ns2:maximumTotalCount' of XML schema type 'xsd:string'
        std::string *maximumTotalCount;
        /// Optional element 'ns2:gracePeriodDuration' of XML schema type 'xsd:string'
        std::string *gracePeriodDuration;
        /// Optional element 'ns2:gracePeriodDurationType' of XML schema type 'xsd:string'
        std::string *gracePeriodDurationType;
        /// Optional element 'ns2:planID' of XML schema type 'xsd:string'
        std::string *planID;
        /// Optional element 'ns2:interestAmount' of XML schema type 'xsd:string'
        std::string *interestAmount;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Installment
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Installment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Installment, default initialized and not managed by a soap context
        virtual ns2__Installment *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Installment); }
      public:
        /// Constructor with default initializations
        ns2__Installment() : sequence(), totalCount(), totalAmount(), frequency(), amount(), planType(), firstInstallmentDate(), amountFunded(), amountRequestedPercentage(), expenses(), expensesPercentage(), fees(), feesPercentage(), taxes(), taxesPercentage(), insurance(), insurancePercentage(), additionalCosts(), additionalCostsPercentage(), monthlyInterestRate(), annualInterestRate(), annualFinancingCost(), paymentType(), invoiceData(), downPayment(), firstInstallmentAmount(), minimumTotalCount(), maximumTotalCount(), gracePeriodDuration(), gracePeriodDurationType(), planID(), interestAmount(), soap() { }
        virtual ~ns2__Installment() { }
        /// Friend allocator used by soap_new_ns2__Installment(struct soap*, int)
        friend SOAP_FMAC1 ns2__Installment * SOAP_FMAC2 soap_instantiate_ns2__Installment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:670 */
#ifndef SOAP_TYPE_ns2__MerchantDefinedData
#define SOAP_TYPE_ns2__MerchantDefinedData (530)
/* complex XML schema type 'ns2:MerchantDefinedData': */
class SOAP_CMAC ns2__MerchantDefinedData {
      public:
        /// Optional element 'ns2:field1' of XML schema type 'xsd:string'
        std::string *field1;
        /// Optional element 'ns2:field2' of XML schema type 'xsd:string'
        std::string *field2;
        /// Optional element 'ns2:field3' of XML schema type 'xsd:string'
        std::string *field3;
        /// Optional element 'ns2:field4' of XML schema type 'xsd:string'
        std::string *field4;
        /// Optional element 'ns2:field5' of XML schema type 'xsd:string'
        std::string *field5;
        /// Optional element 'ns2:field6' of XML schema type 'xsd:string'
        std::string *field6;
        /// Optional element 'ns2:field7' of XML schema type 'xsd:string'
        std::string *field7;
        /// Optional element 'ns2:field8' of XML schema type 'xsd:string'
        std::string *field8;
        /// Optional element 'ns2:field9' of XML schema type 'xsd:string'
        std::string *field9;
        /// Optional element 'ns2:field10' of XML schema type 'xsd:string'
        std::string *field10;
        /// Optional element 'ns2:field11' of XML schema type 'xsd:string'
        std::string *field11;
        /// Optional element 'ns2:field12' of XML schema type 'xsd:string'
        std::string *field12;
        /// Optional element 'ns2:field13' of XML schema type 'xsd:string'
        std::string *field13;
        /// Optional element 'ns2:field14' of XML schema type 'xsd:string'
        std::string *field14;
        /// Optional element 'ns2:field15' of XML schema type 'xsd:string'
        std::string *field15;
        /// Optional element 'ns2:field16' of XML schema type 'xsd:string'
        std::string *field16;
        /// Optional element 'ns2:field17' of XML schema type 'xsd:string'
        std::string *field17;
        /// Optional element 'ns2:field18' of XML schema type 'xsd:string'
        std::string *field18;
        /// Optional element 'ns2:field19' of XML schema type 'xsd:string'
        std::string *field19;
        /// Optional element 'ns2:field20' of XML schema type 'xsd:string'
        std::string *field20;
        /// Sequence of 0 to 100 elements 'ns2:mddField' of XML schema type 'ns2:MDDField'
        std::vector<ns2__MDDField> mddField;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MerchantDefinedData
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__MerchantDefinedData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MerchantDefinedData, default initialized and not managed by a soap context
        virtual ns2__MerchantDefinedData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__MerchantDefinedData); }
      public:
        /// Constructor with default initializations
        ns2__MerchantDefinedData() : field1(), field2(), field3(), field4(), field5(), field6(), field7(), field8(), field9(), field10(), field11(), field12(), field13(), field14(), field15(), field16(), field17(), field18(), field19(), field20(), mddField(), soap() { }
        virtual ~ns2__MerchantDefinedData() { }
        /// Friend allocator used by soap_new_ns2__MerchantDefinedData(struct soap*, int)
        friend SOAP_FMAC1 ns2__MerchantDefinedData * SOAP_FMAC2 soap_instantiate_ns2__MerchantDefinedData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:674 */
#ifndef SOAP_TYPE_ns2__AuxiliaryData
#define SOAP_TYPE_ns2__AuxiliaryData (532)
/* complex XML schema type 'ns2:AuxiliaryData': */
class SOAP_CMAC ns2__AuxiliaryData {
      public:
        /// Sequence of 0 to 900 elements 'ns2:field' of XML schema type 'ns2:AuxiliaryField'
        std::vector<ns2__AuxiliaryField> field;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AuxiliaryData
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__AuxiliaryData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AuxiliaryData, default initialized and not managed by a soap context
        virtual ns2__AuxiliaryData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__AuxiliaryData); }
      public:
        /// Constructor with default initializations
        ns2__AuxiliaryData() : field(), soap() { }
        virtual ~ns2__AuxiliaryData() { }
        /// Friend allocator used by soap_new_ns2__AuxiliaryData(struct soap*, int)
        friend SOAP_FMAC1 ns2__AuxiliaryData * SOAP_FMAC2 soap_instantiate_ns2__AuxiliaryData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:676 */
#ifndef SOAP_TYPE_ns2__MerchantSecureData
#define SOAP_TYPE_ns2__MerchantSecureData (533)
/* complex XML schema type 'ns2:MerchantSecureData': */
class SOAP_CMAC ns2__MerchantSecureData {
      public:
        /// Optional element 'ns2:field1' of XML schema type 'xsd:string'
        std::string *field1;
        /// Optional element 'ns2:field2' of XML schema type 'xsd:string'
        std::string *field2;
        /// Optional element 'ns2:field3' of XML schema type 'xsd:string'
        std::string *field3;
        /// Optional element 'ns2:field4' of XML schema type 'xsd:string'
        std::string *field4;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MerchantSecureData
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__MerchantSecureData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MerchantSecureData, default initialized and not managed by a soap context
        virtual ns2__MerchantSecureData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__MerchantSecureData); }
      public:
        /// Constructor with default initializations
        ns2__MerchantSecureData() : field1(), field2(), field3(), field4(), soap() { }
        virtual ~ns2__MerchantSecureData() { }
        /// Friend allocator used by soap_new_ns2__MerchantSecureData(struct soap*, int)
        friend SOAP_FMAC1 ns2__MerchantSecureData * SOAP_FMAC2 soap_instantiate_ns2__MerchantSecureData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:678 */
#ifndef SOAP_TYPE_ns2__ReplyReserved
#define SOAP_TYPE_ns2__ReplyReserved (534)
/* complex XML schema type 'ns2:ReplyReserved': */
class SOAP_CMAC ns2__ReplyReserved {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ReplyReserved
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ReplyReserved; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ReplyReserved, default initialized and not managed by a soap context
        virtual ns2__ReplyReserved *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ReplyReserved); }
      public:
        /// Constructor with default initializations
        ns2__ReplyReserved() : __any(), soap() { }
        virtual ~ns2__ReplyReserved() { }
        /// Friend allocator used by soap_new_ns2__ReplyReserved(struct soap*, int)
        friend SOAP_FMAC1 ns2__ReplyReserved * SOAP_FMAC2 soap_instantiate_ns2__ReplyReserved(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:680 */
#ifndef SOAP_TYPE_ns2__RequestReserved
#define SOAP_TYPE_ns2__RequestReserved (535)
/* complex XML schema type 'ns2:RequestReserved': */
class SOAP_CMAC ns2__RequestReserved {
      public:
        /// Required element 'ns2:name' of XML schema type 'xsd:string'
        std::string name;
        /// Required element 'ns2:value' of XML schema type 'xsd:string'
        std::string value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RequestReserved
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__RequestReserved; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RequestReserved, default initialized and not managed by a soap context
        virtual ns2__RequestReserved *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__RequestReserved); }
      public:
        /// Constructor with default initializations
        ns2__RequestReserved() : name(), value(), soap() { }
        virtual ~ns2__RequestReserved() { }
        /// Friend allocator used by soap_new_ns2__RequestReserved(struct soap*, int)
        friend SOAP_FMAC1 ns2__RequestReserved * SOAP_FMAC2 soap_instantiate_ns2__RequestReserved(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:682 */
#ifndef SOAP_TYPE_ns2__PayPalGetTxnDetailsReply
#define SOAP_TYPE_ns2__PayPalGetTxnDetailsReply (536)
/* complex XML schema type 'ns2:PayPalGetTxnDetailsReply': */
class SOAP_CMAC ns2__PayPalGetTxnDetailsReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:payer' of XML schema type 'xsd:string'
        std::string *payer;
        /// Optional element 'ns2:payerId' of XML schema type 'xsd:string'
        std::string *payerId;
        /// Optional element 'ns2:payerStatus' of XML schema type 'xsd:string'
        std::string *payerStatus;
        /// Optional element 'ns2:payerCountry' of XML schema type 'xsd:string'
        std::string *payerCountry;
        /// Optional element 'ns2:payerBusiness' of XML schema type 'xsd:string'
        std::string *payerBusiness;
        /// Optional element 'ns2:payerSalutation' of XML schema type 'xsd:string'
        std::string *payerSalutation;
        /// Optional element 'ns2:payerFirstname' of XML schema type 'xsd:string'
        std::string *payerFirstname;
        /// Optional element 'ns2:payerMiddlename' of XML schema type 'xsd:string'
        std::string *payerMiddlename;
        /// Optional element 'ns2:payerLastname' of XML schema type 'xsd:string'
        std::string *payerLastname;
        /// Optional element 'ns2:payerSuffix' of XML schema type 'xsd:string'
        std::string *payerSuffix;
        /// Optional element 'ns2:addressID' of XML schema type 'xsd:string'
        std::string *addressID;
        /// Optional element 'ns2:addressStatus' of XML schema type 'xsd:string'
        std::string *addressStatus;
        /// Optional element 'ns2:shipToName' of XML schema type 'xsd:string'
        std::string *shipToName;
        /// Optional element 'ns2:shipToAddress1' of XML schema type 'xsd:string'
        std::string *shipToAddress1;
        /// Optional element 'ns2:shipToAddress2' of XML schema type 'xsd:string'
        std::string *shipToAddress2;
        /// Optional element 'ns2:shipToCity' of XML schema type 'xsd:string'
        std::string *shipToCity;
        /// Optional element 'ns2:shipToState' of XML schema type 'xsd:string'
        std::string *shipToState;
        /// Optional element 'ns2:shipToCountry' of XML schema type 'xsd:string'
        std::string *shipToCountry;
        /// Optional element 'ns2:shipToZip' of XML schema type 'xsd:string'
        std::string *shipToZip;
        /// Optional element 'ns2:payerPhone' of XML schema type 'xsd:string'
        std::string *payerPhone;
        /// Optional element 'ns2:transactionId' of XML schema type 'xsd:string'
        std::string *transactionId;
        /// Optional element 'ns2:parentTransactionId' of XML schema type 'xsd:string'
        std::string *parentTransactionId;
        /// Optional element 'ns2:paypalReceiptId' of XML schema type 'xsd:string'
        std::string *paypalReceiptId;
        /// Optional element 'ns2:paypalTransactiontype' of XML schema type 'xsd:string'
        std::string *paypalTransactiontype;
        /// Optional element 'ns2:paypalPaymentType' of XML schema type 'xsd:string'
        std::string *paypalPaymentType;
        /// Optional element 'ns2:paypalOrderTime' of XML schema type 'xsd:string'
        std::string *paypalOrderTime;
        /// Optional element 'ns2:paypalPaymentGrossAmount' of XML schema type 'xsd:string'
        std::string *paypalPaymentGrossAmount;
        /// Optional element 'ns2:paypalFeeAmount' of XML schema type 'xsd:string'
        std::string *paypalFeeAmount;
        /// Optional element 'ns2:currency' of XML schema type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:paypalSettleAmount' of XML schema type 'xsd:string'
        std::string *paypalSettleAmount;
        /// Optional element 'ns2:paypalTaxAmount' of XML schema type 'xsd:string'
        std::string *paypalTaxAmount;
        /// Optional element 'ns2:paypalExchangeRate' of XML schema type 'xsd:string'
        std::string *paypalExchangeRate;
        /// Optional element 'ns2:paypalPaymentStatus' of XML schema type 'xsd:string'
        std::string *paypalPaymentStatus;
        /// Optional element 'ns2:paypalPendingReason' of XML schema type 'xsd:string'
        std::string *paypalPendingReason;
        /// Optional element 'ns2:paypalReasonCode' of XML schema type 'xsd:string'
        std::string *paypalReasonCode;
        /// Optional element 'ns2:protectionEligibility' of XML schema type 'xsd:string'
        std::string *protectionEligibility;
        /// Optional element 'ns2:protectionEligibilityType' of XML schema type 'xsd:string'
        std::string *protectionEligibilityType;
        /// Optional element 'ns2:paypalNote' of XML schema type 'xsd:string'
        std::string *paypalNote;
        /// Optional element 'ns2:invoiceNumber' of XML schema type 'xsd:string'
        std::string *invoiceNumber;
        /// Sequence of 0 to 1000 elements 'ns2:item' of XML schema type 'ns2:Item'
        std::vector<ns2__Item> item;
        /// Optional element 'ns2:errorCode' of XML schema type 'xsd:string'
        std::string *errorCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalGetTxnDetailsReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalGetTxnDetailsReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalGetTxnDetailsReply, default initialized and not managed by a soap context
        virtual ns2__PayPalGetTxnDetailsReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalGetTxnDetailsReply); }
      public:
        /// Constructor with default initializations
        ns2__PayPalGetTxnDetailsReply() : reasonCode(), payer(), payerId(), payerStatus(), payerCountry(), payerBusiness(), payerSalutation(), payerFirstname(), payerMiddlename(), payerLastname(), payerSuffix(), addressID(), addressStatus(), shipToName(), shipToAddress1(), shipToAddress2(), shipToCity(), shipToState(), shipToCountry(), shipToZip(), payerPhone(), transactionId(), parentTransactionId(), paypalReceiptId(), paypalTransactiontype(), paypalPaymentType(), paypalOrderTime(), paypalPaymentGrossAmount(), paypalFeeAmount(), currency(), paypalSettleAmount(), paypalTaxAmount(), paypalExchangeRate(), paypalPaymentStatus(), paypalPendingReason(), paypalReasonCode(), protectionEligibility(), protectionEligibilityType(), paypalNote(), invoiceNumber(), item(), errorCode(), soap() { }
        virtual ~ns2__PayPalGetTxnDetailsReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalGetTxnDetailsReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalGetTxnDetailsReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalGetTxnDetailsReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:684 */
#ifndef SOAP_TYPE_ns2__PayPalTransactionSearchReply
#define SOAP_TYPE_ns2__PayPalTransactionSearchReply (537)
/* complex XML schema type 'ns2:PayPalTransactionSearchReply': */
class SOAP_CMAC ns2__PayPalTransactionSearchReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Sequence of 0 to 999 elements 'ns2:transaction' of XML schema type 'ns2:PaypalTransaction'
        std::vector<ns2__PaypalTransaction> transaction;
        /// Optional element 'ns2:errorCode' of XML schema type 'xsd:string'
        std::string *errorCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalTransactionSearchReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PayPalTransactionSearchReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalTransactionSearchReply, default initialized and not managed by a soap context
        virtual ns2__PayPalTransactionSearchReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PayPalTransactionSearchReply); }
      public:
        /// Constructor with default initializations
        ns2__PayPalTransactionSearchReply() : reasonCode(), transaction(), errorCode(), soap() { }
        virtual ~ns2__PayPalTransactionSearchReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalTransactionSearchReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalTransactionSearchReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalTransactionSearchReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:686 */
#ifndef SOAP_TYPE_ns2__PaypalTransaction
#define SOAP_TYPE_ns2__PaypalTransaction (538)
/* complex XML schema type 'ns2:PaypalTransaction': */
class SOAP_CMAC ns2__PaypalTransaction {
      public:
        /// Optional element 'ns2:transactionTime' of XML schema type 'ns2:dateTime'
        std::string *transactionTime;
        /// Optional element 'ns2:transactionTimeZone' of XML schema type 'xsd:string'
        std::string *transactionTimeZone;
        /// Optional element 'ns2:transactionType' of XML schema type 'xsd:string'
        std::string *transactionType;
        /// Optional element 'ns2:paypalPayerOrPayeeEmail' of XML schema type 'xsd:string'
        std::string *paypalPayerOrPayeeEmail;
        /// Optional element 'ns2:customerDisplayName' of XML schema type 'xsd:string'
        std::string *customerDisplayName;
        /// Optional element 'ns2:transactionID' of XML schema type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:paypalPaymentStatus' of XML schema type 'xsd:string'
        std::string *paypalPaymentStatus;
        /// Optional element 'ns2:grandTotalAmount' of XML schema type 'xsd:string'
        std::string *grandTotalAmount;
        /// Optional element 'ns2:currency' of XML schema type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:paypalFeeAmount' of XML schema type 'xsd:string'
        std::string *paypalFeeAmount;
        /// Optional element 'ns2:paypalNetAmount' of XML schema type 'xsd:string'
        std::string *paypalNetAmount;
        /// Optional attribute 'id' of XML schema type 'xsd:integer'
        std::string *id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaypalTransaction
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PaypalTransaction; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaypalTransaction, default initialized and not managed by a soap context
        virtual ns2__PaypalTransaction *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PaypalTransaction); }
      public:
        /// Constructor with default initializations
        ns2__PaypalTransaction() : transactionTime(), transactionTimeZone(), transactionType(), paypalPayerOrPayeeEmail(), customerDisplayName(), transactionID(), paypalPaymentStatus(), grandTotalAmount(), currency(), paypalFeeAmount(), paypalNetAmount(), id(), soap() { }
        virtual ~ns2__PaypalTransaction() { }
        /// Friend allocator used by soap_new_ns2__PaypalTransaction(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaypalTransaction * SOAP_FMAC2 soap_instantiate_ns2__PaypalTransaction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:688 */
#ifndef SOAP_TYPE_ns2__CCDCCUpdateService
#define SOAP_TYPE_ns2__CCDCCUpdateService (539)
/* complex XML schema type 'ns2:CCDCCUpdateService': */
class SOAP_CMAC ns2__CCDCCUpdateService {
      public:
        /// Optional element 'ns2:reason' of XML schema type 'xsd:string'
        std::string *reason;
        /// Optional element 'ns2:action' of XML schema type 'xsd:string'
        std::string *action;
        /// Optional element 'ns2:dccRequestID' of XML schema type 'xsd:string'
        std::string *dccRequestID;
        /// Optional element 'ns2:captureRequestID' of XML schema type 'xsd:string'
        std::string *captureRequestID;
        /// Optional element 'ns2:creditRequestID' of XML schema type 'xsd:string'
        std::string *creditRequestID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCDCCUpdateService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__CCDCCUpdateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCDCCUpdateService, default initialized and not managed by a soap context
        virtual ns2__CCDCCUpdateService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__CCDCCUpdateService); }
      public:
        /// Constructor with default initializations
        ns2__CCDCCUpdateService() : reason(), action(), dccRequestID(), captureRequestID(), creditRequestID(), run(), soap() { }
        virtual ~ns2__CCDCCUpdateService() { }
        /// Friend allocator used by soap_new_ns2__CCDCCUpdateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCDCCUpdateService * SOAP_FMAC2 soap_instantiate_ns2__CCDCCUpdateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:690 */
#ifndef SOAP_TYPE_ns2__ServiceFee
#define SOAP_TYPE_ns2__ServiceFee (540)
/* complex XML schema type 'ns2:ServiceFee': */
class SOAP_CMAC ns2__ServiceFee {
      public:
        /// Optional element 'ns2:merchantDescriptor' of XML schema type 'xsd:string'
        std::string *merchantDescriptor;
        /// Optional element 'ns2:merchantDescriptorContact' of XML schema type 'xsd:string'
        std::string *merchantDescriptorContact;
        /// Optional element 'ns2:merchantDescriptorState' of XML schema type 'xsd:string'
        std::string *merchantDescriptorState;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ServiceFee
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ServiceFee; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ServiceFee, default initialized and not managed by a soap context
        virtual ns2__ServiceFee *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ServiceFee); }
      public:
        /// Constructor with default initializations
        ns2__ServiceFee() : merchantDescriptor(), merchantDescriptorContact(), merchantDescriptorState(), soap() { }
        virtual ~ns2__ServiceFee() { }
        /// Friend allocator used by soap_new_ns2__ServiceFee(struct soap*, int)
        friend SOAP_FMAC1 ns2__ServiceFee * SOAP_FMAC2 soap_instantiate_ns2__ServiceFee(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:692 */
#ifndef SOAP_TYPE_ns2__EmvRequest
#define SOAP_TYPE_ns2__EmvRequest (541)
/* complex XML schema type 'ns2:EmvRequest': */
class SOAP_CMAC ns2__EmvRequest {
      public:
        /// Optional element 'ns2:combinedTags' of XML schema type 'xsd:string'
        std::string *combinedTags;
        /// Optional element 'ns2:repeat' of XML schema type 'xsd:string'
        std::string *repeat;
        /// Optional element 'ns2:cardSequenceNumber' of XML schema type 'xsd:string'
        std::string *cardSequenceNumber;
        /// Optional element 'ns2:aidAndDFname' of XML schema type 'xsd:string'
        std::string *aidAndDFname;
        /// Optional element 'ns2:fallback' of XML schema type 'xsd:string'
        std::string *fallback;
        /// Optional element 'ns2:fallbackCondition' of XML schema type 'xsd:string'
        std::string *fallbackCondition;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__EmvRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__EmvRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__EmvRequest, default initialized and not managed by a soap context
        virtual ns2__EmvRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__EmvRequest); }
      public:
        /// Constructor with default initializations
        ns2__EmvRequest() : combinedTags(), repeat(), cardSequenceNumber(), aidAndDFname(), fallback(), fallbackCondition(), soap() { }
        virtual ~ns2__EmvRequest() { }
        /// Friend allocator used by soap_new_ns2__EmvRequest(struct soap*, int)
        friend SOAP_FMAC1 ns2__EmvRequest * SOAP_FMAC2 soap_instantiate_ns2__EmvRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:694 */
#ifndef SOAP_TYPE_ns2__EmvReply
#define SOAP_TYPE_ns2__EmvReply (542)
/* complex XML schema type 'ns2:EmvReply': */
class SOAP_CMAC ns2__EmvReply {
      public:
        /// Optional element 'ns2:combinedTags' of XML schema type 'xsd:string'
        std::string *combinedTags;
        /// Optional element 'ns2:decryptedRequestTags' of XML schema type 'xsd:string'
        std::string *decryptedRequestTags;
        /// Optional element 'ns2:chipValidationResults' of XML schema type 'xsd:string'
        std::string *chipValidationResults;
        /// Optional element 'ns2:chipValidationType' of XML schema type 'xsd:string'
        std::string *chipValidationType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__EmvReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__EmvReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__EmvReply, default initialized and not managed by a soap context
        virtual ns2__EmvReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__EmvReply); }
      public:
        /// Constructor with default initializations
        ns2__EmvReply() : combinedTags(), decryptedRequestTags(), chipValidationResults(), chipValidationType(), soap() { }
        virtual ~ns2__EmvReply() { }
        /// Friend allocator used by soap_new_ns2__EmvReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__EmvReply * SOAP_FMAC2 soap_instantiate_ns2__EmvReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:696 */
#ifndef SOAP_TYPE_ns2__OriginalTransaction
#define SOAP_TYPE_ns2__OriginalTransaction (543)
/* complex XML schema type 'ns2:OriginalTransaction': */
class SOAP_CMAC ns2__OriginalTransaction {
      public:
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:reasonCode' of XML schema type 'xsd:string'
        std::string *reasonCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OriginalTransaction
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__OriginalTransaction; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OriginalTransaction, default initialized and not managed by a soap context
        virtual ns2__OriginalTransaction *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__OriginalTransaction); }
      public:
        /// Constructor with default initializations
        ns2__OriginalTransaction() : amount(), reasonCode(), soap() { }
        virtual ~ns2__OriginalTransaction() { }
        /// Friend allocator used by soap_new_ns2__OriginalTransaction(struct soap*, int)
        friend SOAP_FMAC1 ns2__OriginalTransaction * SOAP_FMAC2 soap_instantiate_ns2__OriginalTransaction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:698 */
#ifndef SOAP_TYPE_ns2__HostedDataCreateService
#define SOAP_TYPE_ns2__HostedDataCreateService (544)
/* complex XML schema type 'ns2:HostedDataCreateService': */
class SOAP_CMAC ns2__HostedDataCreateService {
      public:
        /// Optional element 'ns2:profileID' of XML schema type 'xsd:string'
        std::string *profileID;
        /// Optional element 'ns2:paymentMethod' of XML schema type 'xsd:string'
        std::string *paymentMethod;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__HostedDataCreateService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__HostedDataCreateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__HostedDataCreateService, default initialized and not managed by a soap context
        virtual ns2__HostedDataCreateService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__HostedDataCreateService); }
      public:
        /// Constructor with default initializations
        ns2__HostedDataCreateService() : profileID(), paymentMethod(), run(), soap() { }
        virtual ~ns2__HostedDataCreateService() { }
        /// Friend allocator used by soap_new_ns2__HostedDataCreateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__HostedDataCreateService * SOAP_FMAC2 soap_instantiate_ns2__HostedDataCreateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:700 */
#ifndef SOAP_TYPE_ns2__HostedDataRetrieveService
#define SOAP_TYPE_ns2__HostedDataRetrieveService (545)
/* complex XML schema type 'ns2:HostedDataRetrieveService': */
class SOAP_CMAC ns2__HostedDataRetrieveService {
      public:
        /// Optional element 'ns2:profileID' of XML schema type 'xsd:string'
        std::string *profileID;
        /// Optional element 'ns2:tokenValue' of XML schema type 'xsd:string'
        std::string *tokenValue;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__HostedDataRetrieveService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__HostedDataRetrieveService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__HostedDataRetrieveService, default initialized and not managed by a soap context
        virtual ns2__HostedDataRetrieveService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__HostedDataRetrieveService); }
      public:
        /// Constructor with default initializations
        ns2__HostedDataRetrieveService() : profileID(), tokenValue(), run(), soap() { }
        virtual ~ns2__HostedDataRetrieveService() { }
        /// Friend allocator used by soap_new_ns2__HostedDataRetrieveService(struct soap*, int)
        friend SOAP_FMAC1 ns2__HostedDataRetrieveService * SOAP_FMAC2 soap_instantiate_ns2__HostedDataRetrieveService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:702 */
#ifndef SOAP_TYPE_ns2__HostedDataCreateReply
#define SOAP_TYPE_ns2__HostedDataCreateReply (546)
/* complex XML schema type 'ns2:HostedDataCreateReply': */
class SOAP_CMAC ns2__HostedDataCreateReply {
      public:
        /// Optional element 'ns2:responseMessage' of XML schema type 'xsd:string'
        std::string *responseMessage;
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:cardAccountNumberToken' of XML schema type 'xsd:string'
        std::string *cardAccountNumberToken;
        /// Optional element 'ns2:customerID' of XML schema type 'xsd:string'
        std::string *customerID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__HostedDataCreateReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__HostedDataCreateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__HostedDataCreateReply, default initialized and not managed by a soap context
        virtual ns2__HostedDataCreateReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__HostedDataCreateReply); }
      public:
        /// Constructor with default initializations
        ns2__HostedDataCreateReply() : responseMessage(), reasonCode(), cardAccountNumberToken(), customerID(), soap() { }
        virtual ~ns2__HostedDataCreateReply() { }
        /// Friend allocator used by soap_new_ns2__HostedDataCreateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__HostedDataCreateReply * SOAP_FMAC2 soap_instantiate_ns2__HostedDataCreateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:704 */
#ifndef SOAP_TYPE_ns2__HostedDataRetrieveReply
#define SOAP_TYPE_ns2__HostedDataRetrieveReply (547)
/* complex XML schema type 'ns2:HostedDataRetrieveReply': */
class SOAP_CMAC ns2__HostedDataRetrieveReply {
      public:
        /// Optional element 'ns2:responseMessage' of XML schema type 'xsd:string'
        std::string *responseMessage;
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:aggregatorMerchantIdentifier' of XML schema type 'xsd:string'
        std::string *aggregatorMerchantIdentifier;
        /// Optional element 'ns2:customerFirstName' of XML schema type 'xsd:string'
        std::string *customerFirstName;
        /// Optional element 'ns2:customerLastName' of XML schema type 'xsd:string'
        std::string *customerLastName;
        /// Optional element 'ns2:customerID' of XML schema type 'xsd:string'
        std::string *customerID;
        /// Optional element 'ns2:paymentMethod' of XML schema type 'xsd:string'
        std::string *paymentMethod;
        /// Optional element 'ns2:billToStreet1' of XML schema type 'xsd:string'
        std::string *billToStreet1;
        /// Optional element 'ns2:billToStreet2' of XML schema type 'xsd:string'
        std::string *billToStreet2;
        /// Optional element 'ns2:billToEmail' of XML schema type 'xsd:string'
        std::string *billToEmail;
        /// Optional element 'ns2:billToState' of XML schema type 'xsd:string'
        std::string *billToState;
        /// Optional element 'ns2:billToFirstName' of XML schema type 'xsd:string'
        std::string *billToFirstName;
        /// Optional element 'ns2:billToLastName' of XML schema type 'xsd:string'
        std::string *billToLastName;
        /// Optional element 'ns2:billToCity' of XML schema type 'xsd:string'
        std::string *billToCity;
        /// Optional element 'ns2:billToCountry' of XML schema type 'xsd:string'
        std::string *billToCountry;
        /// Optional element 'ns2:billToPostalCode' of XML schema type 'xsd:string'
        std::string *billToPostalCode;
        /// Optional element 'ns2:cardAccountNumber' of XML schema type 'xsd:string'
        std::string *cardAccountNumber;
        /// Optional element 'ns2:cardType' of XML schema type 'xsd:string'
        std::string *cardType;
        /// Optional element 'ns2:cardExpirationMonth' of XML schema type 'xsd:string'
        std::string *cardExpirationMonth;
        /// Optional element 'ns2:cardExpirationYear' of XML schema type 'xsd:string'
        std::string *cardExpirationYear;
        /// Optional element 'ns2:cardIssueNumber' of XML schema type 'xsd:string'
        std::string *cardIssueNumber;
        /// Optional element 'ns2:cardStartMonth' of XML schema type 'xsd:string'
        std::string *cardStartMonth;
        /// Optional element 'ns2:cardStartYear' of XML schema type 'xsd:string'
        std::string *cardStartYear;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__HostedDataRetrieveReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__HostedDataRetrieveReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__HostedDataRetrieveReply, default initialized and not managed by a soap context
        virtual ns2__HostedDataRetrieveReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__HostedDataRetrieveReply); }
      public:
        /// Constructor with default initializations
        ns2__HostedDataRetrieveReply() : responseMessage(), reasonCode(), aggregatorMerchantIdentifier(), customerFirstName(), customerLastName(), customerID(), paymentMethod(), billToStreet1(), billToStreet2(), billToEmail(), billToState(), billToFirstName(), billToLastName(), billToCity(), billToCountry(), billToPostalCode(), cardAccountNumber(), cardType(), cardExpirationMonth(), cardExpirationYear(), cardIssueNumber(), cardStartMonth(), cardStartYear(), soap() { }
        virtual ~ns2__HostedDataRetrieveReply() { }
        /// Friend allocator used by soap_new_ns2__HostedDataRetrieveReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__HostedDataRetrieveReply * SOAP_FMAC2 soap_instantiate_ns2__HostedDataRetrieveReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:706 */
#ifndef SOAP_TYPE_ns2__AutoRentalData
#define SOAP_TYPE_ns2__AutoRentalData (548)
/* complex XML schema type 'ns2:AutoRentalData': */
class SOAP_CMAC ns2__AutoRentalData {
      public:
        /// Optional element 'ns2:adjustmentCost' of XML schema type 'ns2:amount'
        std::string *adjustmentCost;
        /// Optional element 'ns2:adjustmentCode' of XML schema type 'xsd:string'
        std::string *adjustmentCode;
        /// Optional element 'ns2:agreementNumber' of XML schema type 'xsd:string'
        std::string *agreementNumber;
        /// Optional element 'ns2:classCode' of XML schema type 'xsd:string'
        std::string *classCode;
        /// Optional element 'ns2:customerServicePhoneNumber' of XML schema type 'xsd:string'
        std::string *customerServicePhoneNumber;
        /// Optional element 'ns2:dailyRate' of XML schema type 'ns2:amount'
        std::string *dailyRate;
        /// Optional element 'ns2:mileageCost' of XML schema type 'ns2:amount'
        std::string *mileageCost;
        /// Optional element 'ns2:gasCost' of XML schema type 'ns2:amount'
        std::string *gasCost;
        /// Optional element 'ns2:insuranceCost' of XML schema type 'ns2:amount'
        std::string *insuranceCost;
        /// Optional element 'ns2:lateReturnCost' of XML schema type 'ns2:amount'
        std::string *lateReturnCost;
        /// Optional element 'ns2:maximumFreeMiles' of XML schema type 'xsd:integer'
        std::string *maximumFreeMiles;
        /// Optional element 'ns2:milesTraveled' of XML schema type 'xsd:integer'
        std::string *milesTraveled;
        /// Optional element 'ns2:oneWayCost' of XML schema type 'ns2:amount'
        std::string *oneWayCost;
        /// Optional element 'ns2:parkingViolationCost' of XML schema type 'ns2:amount'
        std::string *parkingViolationCost;
        /// Optional element 'ns2:pickUpCity' of XML schema type 'xsd:string'
        std::string *pickUpCity;
        /// Optional element 'ns2:pickUpCountry' of XML schema type 'xsd:string'
        std::string *pickUpCountry;
        /// Optional element 'ns2:pickUpDate' of XML schema type 'xsd:string'
        std::string *pickUpDate;
        /// Optional element 'ns2:pickUpState' of XML schema type 'xsd:string'
        std::string *pickUpState;
        /// Optional element 'ns2:pickUpTime' of XML schema type 'xsd:integer'
        std::string *pickUpTime;
        /// Optional element 'ns2:ratePerMile' of XML schema type 'ns2:amount'
        std::string *ratePerMile;
        /// Optional element 'ns2:renterName' of XML schema type 'xsd:string'
        std::string *renterName;
        /// Optional element 'ns2:returnCity' of XML schema type 'xsd:string'
        std::string *returnCity;
        /// Optional element 'ns2:returnCountry' of XML schema type 'xsd:string'
        std::string *returnCountry;
        /// Optional element 'ns2:returnDate' of XML schema type 'xsd:string'
        std::string *returnDate;
        /// Optional element 'ns2:returnLocationID' of XML schema type 'xsd:string'
        std::string *returnLocationID;
        /// Optional element 'ns2:returnState' of XML schema type 'xsd:string'
        std::string *returnState;
        /// Optional element 'ns2:returnTime' of XML schema type 'xsd:integer'
        std::string *returnTime;
        /// Optional element 'ns2:specialProgramCode' of XML schema type 'xsd:string'
        std::string *specialProgramCode;
        /// Optional element 'ns2:noShowIndicator' of XML schema type 'ns2:boolean'
        std::string *noShowIndicator;
        /// Optional element 'ns2:timePeriod' of XML schema type 'xsd:string'
        std::string *timePeriod;
        /// Optional element 'ns2:weeklyRentalRate' of XML schema type 'ns2:amount'
        std::string *weeklyRentalRate;
        /// Optional element 'ns2:distanceUnit' of XML schema type 'xsd:string'
        std::string *distanceUnit;
        /// Optional element 'ns2:rentalLocationID' of XML schema type 'xsd:string'
        std::string *rentalLocationID;
        /// Optional element 'ns2:vehicleInsuranceIndicator' of XML schema type 'ns2:boolean'
        std::string *vehicleInsuranceIndicator;
        /// Optional element 'ns2:programCode' of XML schema type 'xsd:string'
        std::string *programCode;
        /// Optional element 'ns2:otherCharges' of XML schema type 'ns2:amount'
        std::string *otherCharges;
        /// Optional element 'ns2:taxRate' of XML schema type 'ns2:amount'
        std::string *taxRate;
        /// Optional element 'ns2:taxIndicator' of XML schema type 'ns2:boolean'
        std::string *taxIndicator;
        /// Optional element 'ns2:taxStatusIndicator' of XML schema type 'xsd:string'
        std::string *taxStatusIndicator;
        /// Optional element 'ns2:taxAmount' of XML schema type 'ns2:amount'
        std::string *taxAmount;
        /// Optional element 'ns2:taxType' of XML schema type 'xsd:string'
        std::string *taxType;
        /// Optional element 'ns2:taxSummary' of XML schema type 'xsd:string'
        std::string *taxSummary;
        /// Optional element 'ns2:returnLocation' of XML schema type 'xsd:string'
        std::string *returnLocation;
        /// Optional element 'ns2:odometerReading' of XML schema type 'xsd:integer'
        std::string *odometerReading;
        /// Optional element 'ns2:vehicleIdentificationNumber' of XML schema type 'xsd:string'
        std::string *vehicleIdentificationNumber;
        /// Optional element 'ns2:commodityCode' of XML schema type 'xsd:string'
        std::string *commodityCode;
        /// Optional element 'ns2:companyId' of XML schema type 'xsd:string'
        std::string *companyId;
        /// Optional element 'ns2:regularMileageCost' of XML schema type 'ns2:amount'
        std::string *regularMileageCost;
        /// Optional element 'ns2:towingCharge' of XML schema type 'ns2:amount'
        std::string *towingCharge;
        /// Optional element 'ns2:extraCharge' of XML schema type 'ns2:amount'
        std::string *extraCharge;
        /// Optional element 'ns2:additionalDrivers' of XML schema type 'xsd:integer'
        std::string *additionalDrivers;
        /// Optional element 'ns2:rentalAddress' of XML schema type 'xsd:string'
        std::string *rentalAddress;
        /// Optional element 'ns2:driverAge' of XML schema type 'xsd:integer'
        std::string *driverAge;
        /// Optional element 'ns2:vehicleMake' of XML schema type 'xsd:string'
        std::string *vehicleMake;
        /// Optional element 'ns2:vehicleModel' of XML schema type 'xsd:string'
        std::string *vehicleModel;
        /// Optional element 'ns2:corporateClientCode' of XML schema type 'xsd:string'
        std::string *corporateClientCode;
        /// Optional element 'ns2:phoneCharge' of XML schema type 'ns2:amount'
        std::string *phoneCharge;
        /// Optional element 'ns2:gpsCharge' of XML schema type 'ns2:amount'
        std::string *gpsCharge;
        /// Optional element 'ns2:pickupLocation' of XML schema type 'xsd:string'
        std::string *pickupLocation;
        /// Optional element 'ns2:taxAmountSign' of XML schema type 'xsd:string'
        std::string *taxAmountSign;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AutoRentalData
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__AutoRentalData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AutoRentalData, default initialized and not managed by a soap context
        virtual ns2__AutoRentalData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__AutoRentalData); }
      public:
        /// Constructor with default initializations
        ns2__AutoRentalData() : adjustmentCost(), adjustmentCode(), agreementNumber(), classCode(), customerServicePhoneNumber(), dailyRate(), mileageCost(), gasCost(), insuranceCost(), lateReturnCost(), maximumFreeMiles(), milesTraveled(), oneWayCost(), parkingViolationCost(), pickUpCity(), pickUpCountry(), pickUpDate(), pickUpState(), pickUpTime(), ratePerMile(), renterName(), returnCity(), returnCountry(), returnDate(), returnLocationID(), returnState(), returnTime(), specialProgramCode(), noShowIndicator(), timePeriod(), weeklyRentalRate(), distanceUnit(), rentalLocationID(), vehicleInsuranceIndicator(), programCode(), otherCharges(), taxRate(), taxIndicator(), taxStatusIndicator(), taxAmount(), taxType(), taxSummary(), returnLocation(), odometerReading(), vehicleIdentificationNumber(), commodityCode(), companyId(), regularMileageCost(), towingCharge(), extraCharge(), additionalDrivers(), rentalAddress(), driverAge(), vehicleMake(), vehicleModel(), corporateClientCode(), phoneCharge(), gpsCharge(), pickupLocation(), taxAmountSign(), soap() { }
        virtual ~ns2__AutoRentalData() { }
        /// Friend allocator used by soap_new_ns2__AutoRentalData(struct soap*, int)
        friend SOAP_FMAC1 ns2__AutoRentalData * SOAP_FMAC2 soap_instantiate_ns2__AutoRentalData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:708 */
#ifndef SOAP_TYPE_ns2__AutoRental
#define SOAP_TYPE_ns2__AutoRental (549)
/* complex XML schema type 'ns2:AutoRental': */
class SOAP_CMAC ns2__AutoRental {
      public:
        /// Optional element 'ns2:promotion' of XML schema type 'ns2:Promotion'
        ns2__Promotion *promotion;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AutoRental
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__AutoRental; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AutoRental, default initialized and not managed by a soap context
        virtual ns2__AutoRental *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__AutoRental); }
      public:
        /// Constructor with default initializations
        ns2__AutoRental() : promotion(), soap() { }
        virtual ~ns2__AutoRental() { }
        /// Friend allocator used by soap_new_ns2__AutoRental(struct soap*, int)
        friend SOAP_FMAC1 ns2__AutoRental * SOAP_FMAC2 soap_instantiate_ns2__AutoRental(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:710 */
#ifndef SOAP_TYPE_ns2__AgencyInformation
#define SOAP_TYPE_ns2__AgencyInformation (550)
/* complex XML schema type 'ns2:AgencyInformation': */
class SOAP_CMAC ns2__AgencyInformation {
      public:
        /// Optional element 'ns2:code' of XML schema type 'xsd:string'
        std::string *code;
        /// Optional element 'ns2:name' of XML schema type 'xsd:string'
        std::string *name;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AgencyInformation
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__AgencyInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AgencyInformation, default initialized and not managed by a soap context
        virtual ns2__AgencyInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__AgencyInformation); }
      public:
        /// Constructor with default initializations
        ns2__AgencyInformation() : code(), name(), soap() { }
        virtual ~ns2__AgencyInformation() { }
        /// Friend allocator used by soap_new_ns2__AgencyInformation(struct soap*, int)
        friend SOAP_FMAC1 ns2__AgencyInformation * SOAP_FMAC2 soap_instantiate_ns2__AgencyInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:712 */
#ifndef SOAP_TYPE_ns2__HealthCare
#define SOAP_TYPE_ns2__HealthCare (551)
/* complex XML schema type 'ns2:HealthCare': */
class SOAP_CMAC ns2__HealthCare {
      public:
        /// Optional element 'ns2:amountType' of XML schema type 'xsd:string'
        std::string *amountType;
        /// Optional element 'ns2:amount' of XML schema type 'ns2:amount'
        std::string *amount;
        /// Required attribute 'id' of XML schema type 'xsd:integer'
        std::string id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__HealthCare
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__HealthCare; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__HealthCare, default initialized and not managed by a soap context
        virtual ns2__HealthCare *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__HealthCare); }
      public:
        /// Constructor with default initializations
        ns2__HealthCare() : amountType(), amount(), id(), soap() { }
        virtual ~ns2__HealthCare() { }
        /// Friend allocator used by soap_new_ns2__HealthCare(struct soap*, int)
        friend SOAP_FMAC1 ns2__HealthCare * SOAP_FMAC2 soap_instantiate_ns2__HealthCare(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:714 */
#ifndef SOAP_TYPE_ns2__VCReply
#define SOAP_TYPE_ns2__VCReply (552)
/* complex XML schema type 'ns2:VCReply': */
class SOAP_CMAC ns2__VCReply {
      public:
        /// Optional element 'ns2:creationTimeStamp' of XML schema type 'xsd:string'
        std::string *creationTimeStamp;
        /// Optional element 'ns2:alternateShippingAddressCountryCode' of XML schema type 'xsd:string'
        std::string *alternateShippingAddressCountryCode;
        /// Optional element 'ns2:alternateShippingAddressPostalCode' of XML schema type 'xsd:string'
        std::string *alternateShippingAddressPostalCode;
        /// Optional element 'ns2:vcAccountLoginName' of XML schema type 'xsd:string'
        std::string *vcAccountLoginName;
        /// Optional element 'ns2:vcAccountFirstName' of XML schema type 'xsd:string'
        std::string *vcAccountFirstName;
        /// Optional element 'ns2:vcAccountLastName' of XML schema type 'xsd:string'
        std::string *vcAccountLastName;
        /// Optional element 'ns2:vcAccountEncryptedID' of XML schema type 'xsd:string'
        std::string *vcAccountEncryptedID;
        /// Optional element 'ns2:vcAccountEmail' of XML schema type 'xsd:string'
        std::string *vcAccountEmail;
        /// Optional element 'ns2:vcAccountMobilePhoneNumber' of XML schema type 'xsd:string'
        std::string *vcAccountMobilePhoneNumber;
        /// Optional element 'ns2:merchantReferenceID' of XML schema type 'xsd:string'
        std::string *merchantReferenceID;
        /// Optional element 'ns2:subtotalAmount' of XML schema type 'xsd:string'
        std::string *subtotalAmount;
        /// Optional element 'ns2:shippingHandlingAmount' of XML schema type 'xsd:string'
        std::string *shippingHandlingAmount;
        /// Optional element 'ns2:taxAmount' of XML schema type 'xsd:string'
        std::string *taxAmount;
        /// Optional element 'ns2:discountAmount' of XML schema type 'xsd:string'
        std::string *discountAmount;
        /// Optional element 'ns2:giftWrapAmount' of XML schema type 'xsd:string'
        std::string *giftWrapAmount;
        /// Optional element 'ns2:uncategorizedAmount' of XML schema type 'xsd:string'
        std::string *uncategorizedAmount;
        /// Optional element 'ns2:totalPurchaseAmount' of XML schema type 'xsd:string'
        std::string *totalPurchaseAmount;
        /// Optional element 'ns2:walletReferenceID' of XML schema type 'xsd:string'
        std::string *walletReferenceID;
        /// Optional element 'ns2:promotionCode' of XML schema type 'xsd:string'
        std::string *promotionCode;
        /// Optional element 'ns2:paymentInstrumentID' of XML schema type 'xsd:string'
        std::string *paymentInstrumentID;
        /// Optional element 'ns2:cardVerificationStatus' of XML schema type 'xsd:string'
        std::string *cardVerificationStatus;
        /// Optional element 'ns2:issuerID' of XML schema type 'xsd:string'
        std::string *issuerID;
        /// Optional element 'ns2:paymentInstrumentNickName' of XML schema type 'xsd:string'
        std::string *paymentInstrumentNickName;
        /// Optional element 'ns2:nameOnCard' of XML schema type 'xsd:string'
        std::string *nameOnCard;
        /// Optional element 'ns2:cardType' of XML schema type 'xsd:string'
        std::string *cardType;
        /// Optional element 'ns2:cardGroup' of XML schema type 'xsd:string'
        std::string *cardGroup;
        /// Optional element 'ns2:cardArt' of XML schema type 'ns2:VCCardArt'
        ns2__VCCardArt *cardArt;
        /// Optional element 'ns2:riskAdvice' of XML schema type 'xsd:string'
        std::string *riskAdvice;
        /// Optional element 'ns2:riskScore' of XML schema type 'xsd:string'
        std::string *riskScore;
        /// Optional element 'ns2:riskAdditionalData' of XML schema type 'xsd:string'
        std::string *riskAdditionalData;
        /// Optional element 'ns2:avsCodeRaw' of XML schema type 'xsd:string'
        std::string *avsCodeRaw;
        /// Optional element 'ns2:cvnCodeRaw' of XML schema type 'xsd:string'
        std::string *cvnCodeRaw;
        /// Optional element 'ns2:eciRaw' of XML schema type 'xsd:string'
        std::string *eciRaw;
        /// Optional element 'ns2:eci' of XML schema type 'xsd:string'
        std::string *eci;
        /// Optional element 'ns2:cavv' of XML schema type 'xsd:string'
        std::string *cavv;
        /// Optional element 'ns2:veresEnrolled' of XML schema type 'xsd:string'
        std::string *veresEnrolled;
        /// Optional element 'ns2:veresTimeStamp' of XML schema type 'xsd:string'
        std::string *veresTimeStamp;
        /// Optional element 'ns2:paresStatus' of XML schema type 'xsd:string'
        std::string *paresStatus;
        /// Optional element 'ns2:paresTimeStamp' of XML schema type 'xsd:string'
        std::string *paresTimeStamp;
        /// Optional element 'ns2:xid' of XML schema type 'xsd:string'
        std::string *xid;
        /// Optional element 'ns2:customData' of XML schema type 'ns2:VCCustomData'
        ns2__VCCustomData *customData;
        /// Optional element 'ns2:vcAccountFullName' of XML schema type 'xsd:string'
        std::string *vcAccountFullName;
        /// Optional element 'ns2:paymentDescription' of XML schema type 'xsd:string'
        std::string *paymentDescription;
        /// Optional element 'ns2:billingAddressStreetName' of XML schema type 'xsd:string'
        std::string *billingAddressStreetName;
        /// Optional element 'ns2:billingAddressAdditionalLocation' of XML schema type 'xsd:string'
        std::string *billingAddressAdditionalLocation;
        /// Optional element 'ns2:billingAddressStreetNumber' of XML schema type 'xsd:string'
        std::string *billingAddressStreetNumber;
        /// Optional element 'ns2:expiredCard' of XML schema type 'xsd:string'
        std::string *expiredCard;
        /// Optional element 'ns2:cardFirstName' of XML schema type 'xsd:string'
        std::string *cardFirstName;
        /// Optional element 'ns2:cardLastName' of XML schema type 'xsd:string'
        std::string *cardLastName;
        /// Optional element 'ns2:shippingAddressStreetName' of XML schema type 'xsd:string'
        std::string *shippingAddressStreetName;
        /// Optional element 'ns2:shippingAddressAdditionalLocation' of XML schema type 'xsd:string'
        std::string *shippingAddressAdditionalLocation;
        /// Optional element 'ns2:shippingAddressStreetNumber' of XML schema type 'xsd:string'
        std::string *shippingAddressStreetNumber;
        /// Optional element 'ns2:ageOfAccount' of XML schema type 'xsd:string'
        std::string *ageOfAccount;
        /// Optional element 'ns2:newUser' of XML schema type 'xsd:string'
        std::string *newUser;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VCReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__VCReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VCReply, default initialized and not managed by a soap context
        virtual ns2__VCReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__VCReply); }
      public:
        /// Constructor with default initializations
        ns2__VCReply() : creationTimeStamp(), alternateShippingAddressCountryCode(), alternateShippingAddressPostalCode(), vcAccountLoginName(), vcAccountFirstName(), vcAccountLastName(), vcAccountEncryptedID(), vcAccountEmail(), vcAccountMobilePhoneNumber(), merchantReferenceID(), subtotalAmount(), shippingHandlingAmount(), taxAmount(), discountAmount(), giftWrapAmount(), uncategorizedAmount(), totalPurchaseAmount(), walletReferenceID(), promotionCode(), paymentInstrumentID(), cardVerificationStatus(), issuerID(), paymentInstrumentNickName(), nameOnCard(), cardType(), cardGroup(), cardArt(), riskAdvice(), riskScore(), riskAdditionalData(), avsCodeRaw(), cvnCodeRaw(), eciRaw(), eci(), cavv(), veresEnrolled(), veresTimeStamp(), paresStatus(), paresTimeStamp(), xid(), customData(), vcAccountFullName(), paymentDescription(), billingAddressStreetName(), billingAddressAdditionalLocation(), billingAddressStreetNumber(), expiredCard(), cardFirstName(), cardLastName(), shippingAddressStreetName(), shippingAddressAdditionalLocation(), shippingAddressStreetNumber(), ageOfAccount(), newUser(), soap() { }
        virtual ~ns2__VCReply() { }
        /// Friend allocator used by soap_new_ns2__VCReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__VCReply * SOAP_FMAC2 soap_instantiate_ns2__VCReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:716 */
#ifndef SOAP_TYPE_ns2__VCCardArt
#define SOAP_TYPE_ns2__VCCardArt (553)
/* complex XML schema type 'ns2:VCCardArt': */
class SOAP_CMAC ns2__VCCardArt {
      public:
        /// Optional element 'ns2:fileName' of XML schema type 'xsd:string'
        std::string *fileName;
        /// Optional element 'ns2:height' of XML schema type 'xsd:string'
        std::string *height;
        /// Optional element 'ns2:width' of XML schema type 'xsd:string'
        std::string *width;
        /// Optional attribute 'id' of XML schema type 'xsd:integer'
        std::string *id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VCCardArt
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__VCCardArt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VCCardArt, default initialized and not managed by a soap context
        virtual ns2__VCCardArt *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__VCCardArt); }
      public:
        /// Constructor with default initializations
        ns2__VCCardArt() : fileName(), height(), width(), id(), soap() { }
        virtual ~ns2__VCCardArt() { }
        /// Friend allocator used by soap_new_ns2__VCCardArt(struct soap*, int)
        friend SOAP_FMAC1 ns2__VCCardArt * SOAP_FMAC2 soap_instantiate_ns2__VCCardArt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:718 */
#ifndef SOAP_TYPE_ns2__VCCustomData
#define SOAP_TYPE_ns2__VCCustomData (554)
/* complex XML schema type 'ns2:VCCustomData': */
class SOAP_CMAC ns2__VCCustomData {
      public:
        /// Optional element 'ns2:name' of XML schema type 'xsd:string'
        std::string *name;
        /// Optional element 'ns2:value' of XML schema type 'xsd:string'
        std::string *value;
        /// Optional attribute 'id' of XML schema type 'xsd:integer'
        std::string *id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VCCustomData
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__VCCustomData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VCCustomData, default initialized and not managed by a soap context
        virtual ns2__VCCustomData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__VCCustomData); }
      public:
        /// Constructor with default initializations
        ns2__VCCustomData() : name(), value(), id(), soap() { }
        virtual ~ns2__VCCustomData() { }
        /// Friend allocator used by soap_new_ns2__VCCustomData(struct soap*, int)
        friend SOAP_FMAC1 ns2__VCCustomData * SOAP_FMAC2 soap_instantiate_ns2__VCCustomData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:720 */
#ifndef SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply
#define SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply (555)
/* complex XML schema type 'ns2:DecryptVisaCheckoutDataReply': */
class SOAP_CMAC ns2__DecryptVisaCheckoutDataReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DecryptVisaCheckoutDataReply, default initialized and not managed by a soap context
        virtual ns2__DecryptVisaCheckoutDataReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DecryptVisaCheckoutDataReply); }
      public:
        /// Constructor with default initializations
        ns2__DecryptVisaCheckoutDataReply() : reasonCode(), soap() { }
        virtual ~ns2__DecryptVisaCheckoutDataReply() { }
        /// Friend allocator used by soap_new_ns2__DecryptVisaCheckoutDataReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__DecryptVisaCheckoutDataReply * SOAP_FMAC2 soap_instantiate_ns2__DecryptVisaCheckoutDataReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:722 */
#ifndef SOAP_TYPE_ns2__GetVisaCheckoutDataReply
#define SOAP_TYPE_ns2__GetVisaCheckoutDataReply (556)
/* complex XML schema type 'ns2:GetVisaCheckoutDataReply': */
class SOAP_CMAC ns2__GetVisaCheckoutDataReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GetVisaCheckoutDataReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__GetVisaCheckoutDataReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GetVisaCheckoutDataReply, default initialized and not managed by a soap context
        virtual ns2__GetVisaCheckoutDataReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__GetVisaCheckoutDataReply); }
      public:
        /// Constructor with default initializations
        ns2__GetVisaCheckoutDataReply() : reasonCode(), soap() { }
        virtual ~ns2__GetVisaCheckoutDataReply() { }
        /// Friend allocator used by soap_new_ns2__GetVisaCheckoutDataReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__GetVisaCheckoutDataReply * SOAP_FMAC2 soap_instantiate_ns2__GetVisaCheckoutDataReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:724 */
#ifndef SOAP_TYPE_ns2__EncryptPaymentDataReply
#define SOAP_TYPE_ns2__EncryptPaymentDataReply (557)
/* complex XML schema type 'ns2:EncryptPaymentDataReply': */
class SOAP_CMAC ns2__EncryptPaymentDataReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__EncryptPaymentDataReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__EncryptPaymentDataReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__EncryptPaymentDataReply, default initialized and not managed by a soap context
        virtual ns2__EncryptPaymentDataReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__EncryptPaymentDataReply); }
      public:
        /// Constructor with default initializations
        ns2__EncryptPaymentDataReply() : reasonCode(), requestDateTime(), soap() { }
        virtual ~ns2__EncryptPaymentDataReply() { }
        /// Friend allocator used by soap_new_ns2__EncryptPaymentDataReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__EncryptPaymentDataReply * SOAP_FMAC2 soap_instantiate_ns2__EncryptPaymentDataReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:726 */
#ifndef SOAP_TYPE_ns2__BinLookupService
#define SOAP_TYPE_ns2__BinLookupService (558)
/* complex XML schema type 'ns2:BinLookupService': */
class SOAP_CMAC ns2__BinLookupService {
      public:
        /// Optional element 'ns2:mode' of XML schema type 'xsd:string'
        std::string *mode;
        /// Optional element 'ns2:networkOrder' of XML schema type 'xsd:string'
        std::string *networkOrder;
        /// Optional element 'ns2:retrievalReferenceNumber' of XML schema type 'xsd:string'
        std::string *retrievalReferenceNumber;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BinLookupService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__BinLookupService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BinLookupService, default initialized and not managed by a soap context
        virtual ns2__BinLookupService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__BinLookupService); }
      public:
        /// Constructor with default initializations
        ns2__BinLookupService() : mode(), networkOrder(), retrievalReferenceNumber(), run(), soap() { }
        virtual ~ns2__BinLookupService() { }
        /// Friend allocator used by soap_new_ns2__BinLookupService(struct soap*, int)
        friend SOAP_FMAC1 ns2__BinLookupService * SOAP_FMAC2 soap_instantiate_ns2__BinLookupService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:728 */
#ifndef SOAP_TYPE_ns2__BinLookupReply
#define SOAP_TYPE_ns2__BinLookupReply (559)
/* complex XML schema type 'ns2:BinLookupReply': */
class SOAP_CMAC ns2__BinLookupReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:cardCategory' of XML schema type 'xsd:string'
        std::string *cardCategory;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BinLookupReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__BinLookupReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BinLookupReply, default initialized and not managed by a soap context
        virtual ns2__BinLookupReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__BinLookupReply); }
      public:
        /// Constructor with default initializations
        ns2__BinLookupReply() : reasonCode(), requestDateTime(), cardCategory(), soap() { }
        virtual ~ns2__BinLookupReply() { }
        /// Friend allocator used by soap_new_ns2__BinLookupReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__BinLookupReply * SOAP_FMAC2 soap_instantiate_ns2__BinLookupReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:730 */
#ifndef SOAP_TYPE_ns2__issuer
#define SOAP_TYPE_ns2__issuer (560)
/* complex XML schema type 'ns2:issuer': */
class SOAP_CMAC ns2__issuer {
      public:
        /// Optional element 'ns2:additionalData' of XML schema type 'xsd:string'
        std::string *additionalData;
        /// Optional element 'ns2:name' of XML schema type 'xsd:string'
        std::string *name;
        /// Optional element 'ns2:country' of XML schema type 'xsd:string'
        std::string *country;
        /// Optional element 'ns2:countryNumericCode' of XML schema type 'xsd:string'
        std::string *countryNumericCode;
        /// Optional element 'ns2:phoneNumber' of XML schema type 'xsd:string'
        std::string *phoneNumber;
        /// Optional element 'ns2:responseCode' of XML schema type 'xsd:string'
        std::string *responseCode;
        /// Optional element 'ns2:riskAnalysisExemptionResult' of XML schema type 'xsd:string'
        std::string *riskAnalysisExemptionResult;
        /// Optional element 'ns2:trustedMerchantExemptionResult' of XML schema type 'xsd:string'
        std::string *trustedMerchantExemptionResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__issuer
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__issuer; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__issuer, default initialized and not managed by a soap context
        virtual ns2__issuer *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__issuer); }
      public:
        /// Constructor with default initializations
        ns2__issuer() : additionalData(), name(), country(), countryNumericCode(), phoneNumber(), responseCode(), riskAnalysisExemptionResult(), trustedMerchantExemptionResult(), soap() { }
        virtual ~ns2__issuer() { }
        /// Friend allocator used by soap_new_ns2__issuer(struct soap*, int)
        friend SOAP_FMAC1 ns2__issuer * SOAP_FMAC2 soap_instantiate_ns2__issuer(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:732 */
#ifndef SOAP_TYPE_ns2__GETVisaCheckoutDataService
#define SOAP_TYPE_ns2__GETVisaCheckoutDataService (561)
/* complex XML schema type 'ns2:GETVisaCheckoutDataService': */
class SOAP_CMAC ns2__GETVisaCheckoutDataService {
      public:
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GETVisaCheckoutDataService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__GETVisaCheckoutDataService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GETVisaCheckoutDataService, default initialized and not managed by a soap context
        virtual ns2__GETVisaCheckoutDataService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__GETVisaCheckoutDataService); }
      public:
        /// Constructor with default initializations
        ns2__GETVisaCheckoutDataService() : run(), soap() { }
        virtual ~ns2__GETVisaCheckoutDataService() { }
        /// Friend allocator used by soap_new_ns2__GETVisaCheckoutDataService(struct soap*, int)
        friend SOAP_FMAC1 ns2__GETVisaCheckoutDataService * SOAP_FMAC2 soap_instantiate_ns2__GETVisaCheckoutDataService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:734 */
#ifndef SOAP_TYPE_ns2__TransactionMetadataService
#define SOAP_TYPE_ns2__TransactionMetadataService (562)
/* complex XML schema type 'ns2:TransactionMetadataService': */
class SOAP_CMAC ns2__TransactionMetadataService {
      public:
        /// Optional element 'ns2:authRequestID' of XML schema type 'xsd:string'
        std::string *authRequestID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__TransactionMetadataService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__TransactionMetadataService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__TransactionMetadataService, default initialized and not managed by a soap context
        virtual ns2__TransactionMetadataService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__TransactionMetadataService); }
      public:
        /// Constructor with default initializations
        ns2__TransactionMetadataService() : authRequestID(), run(), soap() { }
        virtual ~ns2__TransactionMetadataService() { }
        /// Friend allocator used by soap_new_ns2__TransactionMetadataService(struct soap*, int)
        friend SOAP_FMAC1 ns2__TransactionMetadataService * SOAP_FMAC2 soap_instantiate_ns2__TransactionMetadataService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:736 */
#ifndef SOAP_TYPE_ns2__Loan
#define SOAP_TYPE_ns2__Loan (563)
/* complex XML schema type 'ns2:Loan': */
class SOAP_CMAC ns2__Loan {
      public:
        /// Optional element 'ns2:assetType' of XML schema type 'xsd:string'
        std::string *assetType;
        /// Optional element 'ns2:type' of XML schema type 'xsd:string'
        std::string *type;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Loan
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Loan; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Loan, default initialized and not managed by a soap context
        virtual ns2__Loan *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Loan); }
      public:
        /// Constructor with default initializations
        ns2__Loan() : assetType(), type(), soap() { }
        virtual ~ns2__Loan() { }
        /// Friend allocator used by soap_new_ns2__Loan(struct soap*, int)
        friend SOAP_FMAC1 ns2__Loan * SOAP_FMAC2 soap_instantiate_ns2__Loan(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:738 */
#ifndef SOAP_TYPE_ns2__APOrderService
#define SOAP_TYPE_ns2__APOrderService (564)
/* complex XML schema type 'ns2:APOrderService': */
class SOAP_CMAC ns2__APOrderService {
      public:
        /// Optional element 'ns2:sessionsRequestID' of XML schema type 'xsd:string'
        std::string *sessionsRequestID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APOrderService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APOrderService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APOrderService, default initialized and not managed by a soap context
        virtual ns2__APOrderService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APOrderService); }
      public:
        /// Constructor with default initializations
        ns2__APOrderService() : sessionsRequestID(), run(), soap() { }
        virtual ~ns2__APOrderService() { }
        /// Friend allocator used by soap_new_ns2__APOrderService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APOrderService * SOAP_FMAC2 soap_instantiate_ns2__APOrderService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:740 */
#ifndef SOAP_TYPE_ns2__APOrderReply
#define SOAP_TYPE_ns2__APOrderReply (565)
/* complex XML schema type 'ns2:APOrderReply': */
class SOAP_CMAC ns2__APOrderReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XML schema type 'xsd:string'
        std::string *amount;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:status' of XML schema type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:dateTime' of XML schema type 'ns2:dateTime'
        std::string *dateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APOrderReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APOrderReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APOrderReply, default initialized and not managed by a soap context
        virtual ns2__APOrderReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APOrderReply); }
      public:
        /// Constructor with default initializations
        ns2__APOrderReply() : reasonCode(), amount(), reconciliationID(), status(), processorResponse(), dateTime(), soap() { }
        virtual ~ns2__APOrderReply() { }
        /// Friend allocator used by soap_new_ns2__APOrderReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APOrderReply * SOAP_FMAC2 soap_instantiate_ns2__APOrderReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:742 */
#ifndef SOAP_TYPE_ns2__APCancelService
#define SOAP_TYPE_ns2__APCancelService (566)
/* complex XML schema type 'ns2:APCancelService': */
class SOAP_CMAC ns2__APCancelService {
      public:
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:orderRequestID' of XML schema type 'xsd:string'
        std::string *orderRequestID;
        /// Optional element 'ns2:saleRequestID' of XML schema type 'xsd:string'
        std::string *saleRequestID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APCancelService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APCancelService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APCancelService, default initialized and not managed by a soap context
        virtual ns2__APCancelService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APCancelService); }
      public:
        /// Constructor with default initializations
        ns2__APCancelService() : reconciliationID(), orderRequestID(), saleRequestID(), run(), soap() { }
        virtual ~ns2__APCancelService() { }
        /// Friend allocator used by soap_new_ns2__APCancelService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APCancelService * SOAP_FMAC2 soap_instantiate_ns2__APCancelService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:744 */
#ifndef SOAP_TYPE_ns2__APCancelReply
#define SOAP_TYPE_ns2__APCancelReply (567)
/* complex XML schema type 'ns2:APCancelReply': */
class SOAP_CMAC ns2__APCancelReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:processorTransactionID' of XML schema type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:status' of XML schema type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:dateTime' of XML schema type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:paymentStatus' of XML schema type 'xsd:string'
        std::string *paymentStatus;
        /// Optional element 'ns2:responseCode' of XML schema type 'xsd:string'
        std::string *responseCode;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APCancelReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APCancelReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APCancelReply, default initialized and not managed by a soap context
        virtual ns2__APCancelReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APCancelReply); }
      public:
        /// Constructor with default initializations
        ns2__APCancelReply() : reasonCode(), processorTransactionID(), status(), processorResponse(), dateTime(), paymentStatus(), responseCode(), reconciliationID(), soap() { }
        virtual ~ns2__APCancelReply() { }
        /// Friend allocator used by soap_new_ns2__APCancelReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APCancelReply * SOAP_FMAC2 soap_instantiate_ns2__APCancelReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:746 */
#ifndef SOAP_TYPE_ns2__APBillingAgreementService
#define SOAP_TYPE_ns2__APBillingAgreementService (568)
/* complex XML schema type 'ns2:APBillingAgreementService': */
class SOAP_CMAC ns2__APBillingAgreementService {
      public:
        /// Optional element 'ns2:sessionsRequestID' of XML schema type 'xsd:string'
        std::string *sessionsRequestID;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APBillingAgreementService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APBillingAgreementService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APBillingAgreementService, default initialized and not managed by a soap context
        virtual ns2__APBillingAgreementService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APBillingAgreementService); }
      public:
        /// Constructor with default initializations
        ns2__APBillingAgreementService() : sessionsRequestID(), run(), soap() { }
        virtual ~ns2__APBillingAgreementService() { }
        /// Friend allocator used by soap_new_ns2__APBillingAgreementService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APBillingAgreementService * SOAP_FMAC2 soap_instantiate_ns2__APBillingAgreementService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:748 */
#ifndef SOAP_TYPE_ns2__APBillingAgreementReply
#define SOAP_TYPE_ns2__APBillingAgreementReply (569)
/* complex XML schema type 'ns2:APBillingAgreementReply': */
class SOAP_CMAC ns2__APBillingAgreementReply {
      public:
        /// Optional element 'ns2:reasonCode' of XML schema type 'xsd:string'
        std::string *reasonCode;
        /// Optional element 'ns2:amount' of XML schema type 'xsd:string'
        std::string *amount;
        /// Optional element 'ns2:status' of XML schema type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:dateTime' of XML schema type 'ns2:dateTime'
        std::string *dateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APBillingAgreementReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APBillingAgreementReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APBillingAgreementReply, default initialized and not managed by a soap context
        virtual ns2__APBillingAgreementReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APBillingAgreementReply); }
      public:
        /// Constructor with default initializations
        ns2__APBillingAgreementReply() : reasonCode(), amount(), status(), processorResponse(), dateTime(), soap() { }
        virtual ~ns2__APBillingAgreementReply() { }
        /// Friend allocator used by soap_new_ns2__APBillingAgreementReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APBillingAgreementReply * SOAP_FMAC2 soap_instantiate_ns2__APBillingAgreementReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:750 */
#ifndef SOAP_TYPE_ns2__Passenger
#define SOAP_TYPE_ns2__Passenger (570)
/* complex XML schema type 'ns2:Passenger': */
class SOAP_CMAC ns2__Passenger {
      public:
        /// Optional element 'ns2:firstName' of XML schema type 'xsd:string'
        std::string *firstName;
        /// Optional element 'ns2:lastName' of XML schema type 'xsd:string'
        std::string *lastName;
        /// Required attribute 'id' of XML schema type 'xsd:integer'
        std::string id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Passenger
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Passenger; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Passenger, default initialized and not managed by a soap context
        virtual ns2__Passenger *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Passenger); }
      public:
        /// Constructor with default initializations
        ns2__Passenger() : firstName(), lastName(), id(), soap() { }
        virtual ~ns2__Passenger() { }
        /// Friend allocator used by soap_new_ns2__Passenger(struct soap*, int)
        friend SOAP_FMAC1 ns2__Passenger * SOAP_FMAC2 soap_instantiate_ns2__Passenger(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:752 */
#ifndef SOAP_TYPE_ns2__PostdatedTransaction
#define SOAP_TYPE_ns2__PostdatedTransaction (571)
/* complex XML schema type 'ns2:PostdatedTransaction': */
class SOAP_CMAC ns2__PostdatedTransaction {
      public:
        /// Optional element 'ns2:guaranteeIndicator' of XML schema type 'xsd:string'
        std::string *guaranteeIndicator;
        /// Optional element 'ns2:guaranteeAmount' of XML schema type 'xsd:string'
        std::string *guaranteeAmount;
        /// Optional element 'ns2:settlementDate' of XML schema type 'xsd:integer'
        std::string *settlementDate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PostdatedTransaction
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PostdatedTransaction; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PostdatedTransaction, default initialized and not managed by a soap context
        virtual ns2__PostdatedTransaction *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PostdatedTransaction); }
      public:
        /// Constructor with default initializations
        ns2__PostdatedTransaction() : guaranteeIndicator(), guaranteeAmount(), settlementDate(), soap() { }
        virtual ~ns2__PostdatedTransaction() { }
        /// Friend allocator used by soap_new_ns2__PostdatedTransaction(struct soap*, int)
        friend SOAP_FMAC1 ns2__PostdatedTransaction * SOAP_FMAC2 soap_instantiate_ns2__PostdatedTransaction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:754 */
#ifndef SOAP_TYPE_ns2__APCreateMandateService
#define SOAP_TYPE_ns2__APCreateMandateService (572)
/* complex XML schema type 'ns2:APCreateMandateService': */
class SOAP_CMAC ns2__APCreateMandateService {
      public:
        /// Optional element 'ns2:saleRequestID' of XML schema type 'xsd:string'
        std::string *saleRequestID;
        /// Optional element 'ns2:cancelURL' of XML schema type 'xsd:string'
        std::string *cancelURL;
        /// Optional element 'ns2:successURL' of XML schema type 'xsd:string'
        std::string *successURL;
        /// Optional element 'ns2:failureURL' of XML schema type 'xsd:string'
        std::string *failureURL;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APCreateMandateService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APCreateMandateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APCreateMandateService, default initialized and not managed by a soap context
        virtual ns2__APCreateMandateService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APCreateMandateService); }
      public:
        /// Constructor with default initializations
        ns2__APCreateMandateService() : saleRequestID(), cancelURL(), successURL(), failureURL(), run(), soap() { }
        virtual ~ns2__APCreateMandateService() { }
        /// Friend allocator used by soap_new_ns2__APCreateMandateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APCreateMandateService * SOAP_FMAC2 soap_instantiate_ns2__APCreateMandateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:756 */
#ifndef SOAP_TYPE_ns2__APCreateMandateReply
#define SOAP_TYPE_ns2__APCreateMandateReply (573)
/* complex XML schema type 'ns2:APCreateMandateReply': */
class SOAP_CMAC ns2__APCreateMandateReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Required element 'ns2:mandateID' of XML schema type 'xsd:string'
        std::string mandateID;
        /// Required element 'ns2:status' of XML schema type 'xsd:string'
        std::string status;
        /// Required element 'ns2:merchantURL' of XML schema type 'xsd:string'
        std::string merchantURL;
        /// Optional element 'ns2:responseCode' of XML schema type 'xsd:string'
        std::string *responseCode;
        /// Optional element 'ns2:processorTransactionID' of XML schema type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:riskScore' of XML schema type 'xsd:string'
        std::string *riskScore;
        /// Optional element 'ns2:encodedHTML' of XML schema type 'xsd:string'
        std::string *encodedHTML;
        /// Optional element 'ns2:encodedPopupHTML' of XML schema type 'xsd:string'
        std::string *encodedPopupHTML;
        /// Optional element 'ns2:dateTime' of XML schema type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:dateSigned' of XML schema type 'ns2:dateTime'
        std::string *dateSigned;
        /// Optional element 'ns2:dateCreated' of XML schema type 'ns2:dateTime'
        std::string *dateCreated;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APCreateMandateReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APCreateMandateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APCreateMandateReply, default initialized and not managed by a soap context
        virtual ns2__APCreateMandateReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APCreateMandateReply); }
      public:
        /// Constructor with default initializations
        ns2__APCreateMandateReply() : reasonCode(), mandateID(), status(), merchantURL(), responseCode(), processorTransactionID(), riskScore(), encodedHTML(), encodedPopupHTML(), dateTime(), dateSigned(), dateCreated(), soap() { }
        virtual ~ns2__APCreateMandateReply() { }
        /// Friend allocator used by soap_new_ns2__APCreateMandateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APCreateMandateReply * SOAP_FMAC2 soap_instantiate_ns2__APCreateMandateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:758 */
#ifndef SOAP_TYPE_ns2__APMandateStatusService
#define SOAP_TYPE_ns2__APMandateStatusService (574)
/* complex XML schema type 'ns2:APMandateStatusService': */
class SOAP_CMAC ns2__APMandateStatusService {
      public:
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APMandateStatusService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APMandateStatusService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APMandateStatusService, default initialized and not managed by a soap context
        virtual ns2__APMandateStatusService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APMandateStatusService); }
      public:
        /// Constructor with default initializations
        ns2__APMandateStatusService() : run(), soap() { }
        virtual ~ns2__APMandateStatusService() { }
        /// Friend allocator used by soap_new_ns2__APMandateStatusService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APMandateStatusService * SOAP_FMAC2 soap_instantiate_ns2__APMandateStatusService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:760 */
#ifndef SOAP_TYPE_ns2__APMandateStatusReply
#define SOAP_TYPE_ns2__APMandateStatusReply (575)
/* complex XML schema type 'ns2:APMandateStatusReply': */
class SOAP_CMAC ns2__APMandateStatusReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Required element 'ns2:mandateID' of XML schema type 'xsd:string'
        std::string mandateID;
        /// Required element 'ns2:status' of XML schema type 'xsd:string'
        std::string status;
        /// Optional element 'ns2:responseCode' of XML schema type 'xsd:string'
        std::string *responseCode;
        /// Optional element 'ns2:processorTransactionID' of XML schema type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:dateCreated' of XML schema type 'ns2:dateTime'
        std::string *dateCreated;
        /// Optional element 'ns2:dateSigned' of XML schema type 'ns2:dateTime'
        std::string *dateSigned;
        /// Optional element 'ns2:dateRevoked' of XML schema type 'ns2:dateTime'
        std::string *dateRevoked;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APMandateStatusReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APMandateStatusReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APMandateStatusReply, default initialized and not managed by a soap context
        virtual ns2__APMandateStatusReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APMandateStatusReply); }
      public:
        /// Constructor with default initializations
        ns2__APMandateStatusReply() : reasonCode(), mandateID(), status(), responseCode(), processorTransactionID(), dateCreated(), dateSigned(), dateRevoked(), soap() { }
        virtual ~ns2__APMandateStatusReply() { }
        /// Friend allocator used by soap_new_ns2__APMandateStatusReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APMandateStatusReply * SOAP_FMAC2 soap_instantiate_ns2__APMandateStatusReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:762 */
#ifndef SOAP_TYPE_ns2__APUpdateMandateService
#define SOAP_TYPE_ns2__APUpdateMandateService (576)
/* complex XML schema type 'ns2:APUpdateMandateService': */
class SOAP_CMAC ns2__APUpdateMandateService {
      public:
        /// Optional element 'ns2:esign' of XML schema type 'xsd:string'
        std::string *esign;
        /// Optional element 'ns2:cancelURL' of XML schema type 'xsd:string'
        std::string *cancelURL;
        /// Optional element 'ns2:successURL' of XML schema type 'xsd:string'
        std::string *successURL;
        /// Optional element 'ns2:failureURL' of XML schema type 'xsd:string'
        std::string *failureURL;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APUpdateMandateService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APUpdateMandateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APUpdateMandateService, default initialized and not managed by a soap context
        virtual ns2__APUpdateMandateService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APUpdateMandateService); }
      public:
        /// Constructor with default initializations
        ns2__APUpdateMandateService() : esign(), cancelURL(), successURL(), failureURL(), run(), soap() { }
        virtual ~ns2__APUpdateMandateService() { }
        /// Friend allocator used by soap_new_ns2__APUpdateMandateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APUpdateMandateService * SOAP_FMAC2 soap_instantiate_ns2__APUpdateMandateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:764 */
#ifndef SOAP_TYPE_ns2__GetMasterpassDataService
#define SOAP_TYPE_ns2__GetMasterpassDataService (577)
/* complex XML schema type 'ns2:GetMasterpassDataService': */
class SOAP_CMAC ns2__GetMasterpassDataService {
      public:
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GetMasterpassDataService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__GetMasterpassDataService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GetMasterpassDataService, default initialized and not managed by a soap context
        virtual ns2__GetMasterpassDataService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__GetMasterpassDataService); }
      public:
        /// Constructor with default initializations
        ns2__GetMasterpassDataService() : run(), soap() { }
        virtual ~ns2__GetMasterpassDataService() { }
        /// Friend allocator used by soap_new_ns2__GetMasterpassDataService(struct soap*, int)
        friend SOAP_FMAC1 ns2__GetMasterpassDataService * SOAP_FMAC2 soap_instantiate_ns2__GetMasterpassDataService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:766 */
#ifndef SOAP_TYPE_ns2__GetMasterpassDataReply
#define SOAP_TYPE_ns2__GetMasterpassDataReply (578)
/* complex XML schema type 'ns2:GetMasterpassDataReply': */
class SOAP_CMAC ns2__GetMasterpassDataReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GetMasterpassDataReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__GetMasterpassDataReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GetMasterpassDataReply, default initialized and not managed by a soap context
        virtual ns2__GetMasterpassDataReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__GetMasterpassDataReply); }
      public:
        /// Constructor with default initializations
        ns2__GetMasterpassDataReply() : reasonCode(), soap() { }
        virtual ~ns2__GetMasterpassDataReply() { }
        /// Friend allocator used by soap_new_ns2__GetMasterpassDataReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__GetMasterpassDataReply * SOAP_FMAC2 soap_instantiate_ns2__GetMasterpassDataReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:768 */
#ifndef SOAP_TYPE_ns2__APUpdateMandateReply
#define SOAP_TYPE_ns2__APUpdateMandateReply (579)
/* complex XML schema type 'ns2:APUpdateMandateReply': */
class SOAP_CMAC ns2__APUpdateMandateReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Required element 'ns2:mandateID' of XML schema type 'xsd:string'
        std::string mandateID;
        /// Required element 'ns2:status' of XML schema type 'xsd:string'
        std::string status;
        /// Required element 'ns2:merchantURL' of XML schema type 'xsd:string'
        std::string merchantURL;
        /// Optional element 'ns2:responseCode' of XML schema type 'xsd:string'
        std::string *responseCode;
        /// Optional element 'ns2:processorTransactionID' of XML schema type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:riskScore' of XML schema type 'xsd:string'
        std::string *riskScore;
        /// Optional element 'ns2:encodedHTML' of XML schema type 'xsd:string'
        std::string *encodedHTML;
        /// Optional element 'ns2:encodedPopupHTML' of XML schema type 'xsd:string'
        std::string *encodedPopupHTML;
        /// Optional element 'ns2:dateTime' of XML schema type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:dateSigned' of XML schema type 'ns2:dateTime'
        std::string *dateSigned;
        /// Optional element 'ns2:dateCreated' of XML schema type 'ns2:dateTime'
        std::string *dateCreated;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APUpdateMandateReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APUpdateMandateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APUpdateMandateReply, default initialized and not managed by a soap context
        virtual ns2__APUpdateMandateReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APUpdateMandateReply); }
      public:
        /// Constructor with default initializations
        ns2__APUpdateMandateReply() : reasonCode(), mandateID(), status(), merchantURL(), responseCode(), processorTransactionID(), riskScore(), encodedHTML(), encodedPopupHTML(), dateTime(), dateSigned(), dateCreated(), soap() { }
        virtual ~ns2__APUpdateMandateReply() { }
        /// Friend allocator used by soap_new_ns2__APUpdateMandateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APUpdateMandateReply * SOAP_FMAC2 soap_instantiate_ns2__APUpdateMandateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:770 */
#ifndef SOAP_TYPE_ns2__APImportMandateReply
#define SOAP_TYPE_ns2__APImportMandateReply (580)
/* complex XML schema type 'ns2:APImportMandateReply': */
class SOAP_CMAC ns2__APImportMandateReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Required element 'ns2:mandateID' of XML schema type 'xsd:string'
        std::string mandateID;
        /// Required element 'ns2:status' of XML schema type 'xsd:string'
        std::string status;
        /// Optional element 'ns2:responseCode' of XML schema type 'xsd:string'
        std::string *responseCode;
        /// Optional element 'ns2:processorTransactionID' of XML schema type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:dateSigned' of XML schema type 'ns2:dateTime'
        std::string *dateSigned;
        /// Optional element 'ns2:dateCreated' of XML schema type 'ns2:dateTime'
        std::string *dateCreated;
        /// Optional element 'ns2:dateTime' of XML schema type 'ns2:dateTime'
        std::string *dateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APImportMandateReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APImportMandateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APImportMandateReply, default initialized and not managed by a soap context
        virtual ns2__APImportMandateReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APImportMandateReply); }
      public:
        /// Constructor with default initializations
        ns2__APImportMandateReply() : reasonCode(), mandateID(), status(), responseCode(), processorTransactionID(), dateSigned(), dateCreated(), dateTime(), soap() { }
        virtual ~ns2__APImportMandateReply() { }
        /// Friend allocator used by soap_new_ns2__APImportMandateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APImportMandateReply * SOAP_FMAC2 soap_instantiate_ns2__APImportMandateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:772 */
#ifndef SOAP_TYPE_ns2__APRevokeMandateService
#define SOAP_TYPE_ns2__APRevokeMandateService (581)
/* complex XML schema type 'ns2:APRevokeMandateService': */
class SOAP_CMAC ns2__APRevokeMandateService {
      public:
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APRevokeMandateService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APRevokeMandateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APRevokeMandateService, default initialized and not managed by a soap context
        virtual ns2__APRevokeMandateService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APRevokeMandateService); }
      public:
        /// Constructor with default initializations
        ns2__APRevokeMandateService() : run(), soap() { }
        virtual ~ns2__APRevokeMandateService() { }
        /// Friend allocator used by soap_new_ns2__APRevokeMandateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APRevokeMandateService * SOAP_FMAC2 soap_instantiate_ns2__APRevokeMandateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:774 */
#ifndef SOAP_TYPE_ns2__APRevokeMandateReply
#define SOAP_TYPE_ns2__APRevokeMandateReply (582)
/* complex XML schema type 'ns2:APRevokeMandateReply': */
class SOAP_CMAC ns2__APRevokeMandateReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Required element 'ns2:mandateID' of XML schema type 'xsd:string'
        std::string mandateID;
        /// Required element 'ns2:status' of XML schema type 'xsd:string'
        std::string status;
        /// Optional element 'ns2:responseCode' of XML schema type 'xsd:string'
        std::string *responseCode;
        /// Optional element 'ns2:processorTransactionID' of XML schema type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:dateSigned' of XML schema type 'ns2:dateTime'
        std::string *dateSigned;
        /// Optional element 'ns2:dateCreated' of XML schema type 'ns2:dateTime'
        std::string *dateCreated;
        /// Optional element 'ns2:dateRevoked' of XML schema type 'ns2:dateTime'
        std::string *dateRevoked;
        /// Optional element 'ns2:dateTime' of XML schema type 'ns2:dateTime'
        std::string *dateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APRevokeMandateReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__APRevokeMandateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APRevokeMandateReply, default initialized and not managed by a soap context
        virtual ns2__APRevokeMandateReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__APRevokeMandateReply); }
      public:
        /// Constructor with default initializations
        ns2__APRevokeMandateReply() : reasonCode(), mandateID(), status(), responseCode(), processorTransactionID(), dateSigned(), dateCreated(), dateRevoked(), dateTime(), soap() { }
        virtual ~ns2__APRevokeMandateReply() { }
        /// Friend allocator used by soap_new_ns2__APRevokeMandateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APRevokeMandateReply * SOAP_FMAC2 soap_instantiate_ns2__APRevokeMandateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:776 */
#ifndef SOAP_TYPE_ns2__Category
#define SOAP_TYPE_ns2__Category (583)
/* complex XML schema type 'ns2:Category': */
class SOAP_CMAC ns2__Category {
      public:
        /// Optional element 'ns2:affiliate' of XML schema type 'xsd:string'
        std::string *affiliate;
        /// Optional element 'ns2:campaign' of XML schema type 'xsd:string'
        std::string *campaign;
        /// Optional element 'ns2:group' of XML schema type 'xsd:string'
        std::string *group;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Category
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__Category; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Category, default initialized and not managed by a soap context
        virtual ns2__Category *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__Category); }
      public:
        /// Constructor with default initializations
        ns2__Category() : affiliate(), campaign(), group(), soap() { }
        virtual ~ns2__Category() { }
        /// Friend allocator used by soap_new_ns2__Category(struct soap*, int)
        friend SOAP_FMAC1 ns2__Category * SOAP_FMAC2 soap_instantiate_ns2__Category(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:778 */
#ifndef SOAP_TYPE_ns2__ECAVSService
#define SOAP_TYPE_ns2__ECAVSService (584)
/* complex XML schema type 'ns2:ECAVSService': */
class SOAP_CMAC ns2__ECAVSService {
      public:
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ECAVSService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ECAVSService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ECAVSService, default initialized and not managed by a soap context
        virtual ns2__ECAVSService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ECAVSService); }
      public:
        /// Constructor with default initializations
        ns2__ECAVSService() : run(), soap() { }
        virtual ~ns2__ECAVSService() { }
        /// Friend allocator used by soap_new_ns2__ECAVSService(struct soap*, int)
        friend SOAP_FMAC1 ns2__ECAVSService * SOAP_FMAC2 soap_instantiate_ns2__ECAVSService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:780 */
#ifndef SOAP_TYPE_ns2__GiftCardActivationService
#define SOAP_TYPE_ns2__GiftCardActivationService (585)
/* complex XML schema type 'ns2:GiftCardActivationService': */
class SOAP_CMAC ns2__GiftCardActivationService {
      public:
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:commerceIndicator' of XML schema type 'xsd:string'
        std::string *commerceIndicator;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GiftCardActivationService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__GiftCardActivationService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GiftCardActivationService, default initialized and not managed by a soap context
        virtual ns2__GiftCardActivationService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__GiftCardActivationService); }
      public:
        /// Constructor with default initializations
        ns2__GiftCardActivationService() : reconciliationID(), commerceIndicator(), run(), soap() { }
        virtual ~ns2__GiftCardActivationService() { }
        /// Friend allocator used by soap_new_ns2__GiftCardActivationService(struct soap*, int)
        friend SOAP_FMAC1 ns2__GiftCardActivationService * SOAP_FMAC2 soap_instantiate_ns2__GiftCardActivationService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:782 */
#ifndef SOAP_TYPE_ns2__GiftCardBalanceInquiryService
#define SOAP_TYPE_ns2__GiftCardBalanceInquiryService (586)
/* complex XML schema type 'ns2:GiftCardBalanceInquiryService': */
class SOAP_CMAC ns2__GiftCardBalanceInquiryService {
      public:
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:commerceIndicator' of XML schema type 'xsd:string'
        std::string *commerceIndicator;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GiftCardBalanceInquiryService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__GiftCardBalanceInquiryService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GiftCardBalanceInquiryService, default initialized and not managed by a soap context
        virtual ns2__GiftCardBalanceInquiryService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__GiftCardBalanceInquiryService); }
      public:
        /// Constructor with default initializations
        ns2__GiftCardBalanceInquiryService() : reconciliationID(), commerceIndicator(), run(), soap() { }
        virtual ~ns2__GiftCardBalanceInquiryService() { }
        /// Friend allocator used by soap_new_ns2__GiftCardBalanceInquiryService(struct soap*, int)
        friend SOAP_FMAC1 ns2__GiftCardBalanceInquiryService * SOAP_FMAC2 soap_instantiate_ns2__GiftCardBalanceInquiryService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:784 */
#ifndef SOAP_TYPE_ns2__GiftCardVoidService
#define SOAP_TYPE_ns2__GiftCardVoidService (587)
/* complex XML schema type 'ns2:GiftCardVoidService': */
class SOAP_CMAC ns2__GiftCardVoidService {
      public:
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GiftCardVoidService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__GiftCardVoidService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GiftCardVoidService, default initialized and not managed by a soap context
        virtual ns2__GiftCardVoidService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__GiftCardVoidService); }
      public:
        /// Constructor with default initializations
        ns2__GiftCardVoidService() : run(), soap() { }
        virtual ~ns2__GiftCardVoidService() { }
        /// Friend allocator used by soap_new_ns2__GiftCardVoidService(struct soap*, int)
        friend SOAP_FMAC1 ns2__GiftCardVoidService * SOAP_FMAC2 soap_instantiate_ns2__GiftCardVoidService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:786 */
#ifndef SOAP_TYPE_ns2__GiftCardReversalService
#define SOAP_TYPE_ns2__GiftCardReversalService (588)
/* complex XML schema type 'ns2:GiftCardReversalService': */
class SOAP_CMAC ns2__GiftCardReversalService {
      public:
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GiftCardReversalService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__GiftCardReversalService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GiftCardReversalService, default initialized and not managed by a soap context
        virtual ns2__GiftCardReversalService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__GiftCardReversalService); }
      public:
        /// Constructor with default initializations
        ns2__GiftCardReversalService() : run(), soap() { }
        virtual ~ns2__GiftCardReversalService() { }
        /// Friend allocator used by soap_new_ns2__GiftCardReversalService(struct soap*, int)
        friend SOAP_FMAC1 ns2__GiftCardReversalService * SOAP_FMAC2 soap_instantiate_ns2__GiftCardReversalService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:788 */
#ifndef SOAP_TYPE_ns2__GiftCardRedemptionService
#define SOAP_TYPE_ns2__GiftCardRedemptionService (589)
/* complex XML schema type 'ns2:GiftCardRedemptionService': */
class SOAP_CMAC ns2__GiftCardRedemptionService {
      public:
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:commerceIndicator' of XML schema type 'xsd:string'
        std::string *commerceIndicator;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GiftCardRedemptionService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__GiftCardRedemptionService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GiftCardRedemptionService, default initialized and not managed by a soap context
        virtual ns2__GiftCardRedemptionService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__GiftCardRedemptionService); }
      public:
        /// Constructor with default initializations
        ns2__GiftCardRedemptionService() : reconciliationID(), commerceIndicator(), run(), soap() { }
        virtual ~ns2__GiftCardRedemptionService() { }
        /// Friend allocator used by soap_new_ns2__GiftCardRedemptionService(struct soap*, int)
        friend SOAP_FMAC1 ns2__GiftCardRedemptionService * SOAP_FMAC2 soap_instantiate_ns2__GiftCardRedemptionService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:790 */
#ifndef SOAP_TYPE_ns2__GiftCardReloadService
#define SOAP_TYPE_ns2__GiftCardReloadService (590)
/* complex XML schema type 'ns2:GiftCardReloadService': */
class SOAP_CMAC ns2__GiftCardReloadService {
      public:
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:commerceIndicator' of XML schema type 'xsd:string'
        std::string *commerceIndicator;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GiftCardReloadService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__GiftCardReloadService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GiftCardReloadService, default initialized and not managed by a soap context
        virtual ns2__GiftCardReloadService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__GiftCardReloadService); }
      public:
        /// Constructor with default initializations
        ns2__GiftCardReloadService() : reconciliationID(), commerceIndicator(), run(), soap() { }
        virtual ~ns2__GiftCardReloadService() { }
        /// Friend allocator used by soap_new_ns2__GiftCardReloadService(struct soap*, int)
        friend SOAP_FMAC1 ns2__GiftCardReloadService * SOAP_FMAC2 soap_instantiate_ns2__GiftCardReloadService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:792 */
#ifndef SOAP_TYPE_ns2__GiftCardRefundService
#define SOAP_TYPE_ns2__GiftCardRefundService (591)
/* complex XML schema type 'ns2:GiftCardRefundService': */
class SOAP_CMAC ns2__GiftCardRefundService {
      public:
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:commerceIndicator' of XML schema type 'xsd:string'
        std::string *commerceIndicator;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GiftCardRefundService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__GiftCardRefundService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GiftCardRefundService, default initialized and not managed by a soap context
        virtual ns2__GiftCardRefundService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__GiftCardRefundService); }
      public:
        /// Constructor with default initializations
        ns2__GiftCardRefundService() : reconciliationID(), commerceIndicator(), run(), soap() { }
        virtual ~ns2__GiftCardRefundService() { }
        /// Friend allocator used by soap_new_ns2__GiftCardRefundService(struct soap*, int)
        friend SOAP_FMAC1 ns2__GiftCardRefundService * SOAP_FMAC2 soap_instantiate_ns2__GiftCardRefundService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:794 */
#ifndef SOAP_TYPE_ns2__GiftCard
#define SOAP_TYPE_ns2__GiftCard (592)
/* complex XML schema type 'ns2:GiftCard': */
class SOAP_CMAC ns2__GiftCard {
      public:
        /// Optional element 'ns2:originalRequestID' of XML schema type 'xsd:string'
        std::string *originalRequestID;
        /// Optional element 'ns2:redemptionType' of XML schema type 'xsd:string'
        std::string *redemptionType;
        /// Optional element 'ns2:count' of XML schema type 'xsd:string'
        std::string *count;
        /// Optional element 'ns2:escheatable' of XML schema type 'ns2:boolean'
        std::string *escheatable;
        /// Optional element 'ns2:groupID' of XML schema type 'xsd:string'
        std::string *groupID;
        /// Optional element 'ns2:transactionPostingDate' of XML schema type 'xsd:string'
        std::string *transactionPostingDate;
        /// Optional element 'ns2:balanceCurrency' of XML schema type 'xsd:string'
        std::string *balanceCurrency;
        /// Optional element 'ns2:previousBalance' of XML schema type 'xsd:string'
        std::string *previousBalance;
        /// Optional element 'ns2:currentBalance' of XML schema type 'xsd:string'
        std::string *currentBalance;
        /// Optional element 'ns2:baseCurrencyPreviousBalance' of XML schema type 'xsd:string'
        std::string *baseCurrencyPreviousBalance;
        /// Optional element 'ns2:baseCurrencyCurrentBalance' of XML schema type 'xsd:string'
        std::string *baseCurrencyCurrentBalance;
        /// Optional element 'ns2:baseCurrencyCashbackAmount' of XML schema type 'xsd:string'
        std::string *baseCurrencyCashbackAmount;
        /// Optional element 'ns2:baseCurrency' of XML schema type 'xsd:string'
        std::string *baseCurrency;
        /// Optional element 'ns2:expirationDate' of XML schema type 'xsd:string'
        std::string *expirationDate;
        /// Optional element 'ns2:exchangeRate' of XML schema type 'xsd:string'
        std::string *exchangeRate;
        /// Optional element 'ns2:bonusAmount' of XML schema type 'xsd:string'
        std::string *bonusAmount;
        /// Optional element 'ns2:discountAmount' of XML schema type 'xsd:string'
        std::string *discountAmount;
        /// Optional element 'ns2:extendedAccountNumber' of XML schema type 'xsd:string'
        std::string *extendedAccountNumber;
        /// Optional element 'ns2:additionalAccountNumber' of XML schema type 'xsd:string'
        std::string *additionalAccountNumber;
        /// Optional element 'ns2:physicalCard' of XML schema type 'xsd:string'
        std::string *physicalCard;
        /// Optional element 'ns2:returnExtendedAccountNumber' of XML schema type 'xsd:string'
        std::string *returnExtendedAccountNumber;
        /// Optional element 'ns2:promoCode' of XML schema type 'xsd:string'
        std::string *promoCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GiftCard
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__GiftCard; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GiftCard, default initialized and not managed by a soap context
        virtual ns2__GiftCard *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__GiftCard); }
      public:
        /// Constructor with default initializations
        ns2__GiftCard() : originalRequestID(), redemptionType(), count(), escheatable(), groupID(), transactionPostingDate(), balanceCurrency(), previousBalance(), currentBalance(), baseCurrencyPreviousBalance(), baseCurrencyCurrentBalance(), baseCurrencyCashbackAmount(), baseCurrency(), expirationDate(), exchangeRate(), bonusAmount(), discountAmount(), extendedAccountNumber(), additionalAccountNumber(), physicalCard(), returnExtendedAccountNumber(), promoCode(), soap() { }
        virtual ~ns2__GiftCard() { }
        /// Friend allocator used by soap_new_ns2__GiftCard(struct soap*, int)
        friend SOAP_FMAC1 ns2__GiftCard * SOAP_FMAC2 soap_instantiate_ns2__GiftCard(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:796 */
#ifndef SOAP_TYPE_ns2__GiftCardActivationReply
#define SOAP_TYPE_ns2__GiftCardActivationReply (593)
/* complex XML schema type 'ns2:GiftCardActivationReply': */
class SOAP_CMAC ns2__GiftCardActivationReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:authorizationCode' of XML schema type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GiftCardActivationReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__GiftCardActivationReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GiftCardActivationReply, default initialized and not managed by a soap context
        virtual ns2__GiftCardActivationReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__GiftCardActivationReply); }
      public:
        /// Constructor with default initializations
        ns2__GiftCardActivationReply() : reasonCode(), authorizationCode(), processorResponse(), requestDateTime(), reconciliationID(), soap() { }
        virtual ~ns2__GiftCardActivationReply() { }
        /// Friend allocator used by soap_new_ns2__GiftCardActivationReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__GiftCardActivationReply * SOAP_FMAC2 soap_instantiate_ns2__GiftCardActivationReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:798 */
#ifndef SOAP_TYPE_ns2__GiftCardBalanceInquiryReply
#define SOAP_TYPE_ns2__GiftCardBalanceInquiryReply (594)
/* complex XML schema type 'ns2:GiftCardBalanceInquiryReply': */
class SOAP_CMAC ns2__GiftCardBalanceInquiryReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:authorizationCode' of XML schema type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GiftCardBalanceInquiryReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__GiftCardBalanceInquiryReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GiftCardBalanceInquiryReply, default initialized and not managed by a soap context
        virtual ns2__GiftCardBalanceInquiryReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__GiftCardBalanceInquiryReply); }
      public:
        /// Constructor with default initializations
        ns2__GiftCardBalanceInquiryReply() : reasonCode(), authorizationCode(), processorResponse(), requestDateTime(), reconciliationID(), soap() { }
        virtual ~ns2__GiftCardBalanceInquiryReply() { }
        /// Friend allocator used by soap_new_ns2__GiftCardBalanceInquiryReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__GiftCardBalanceInquiryReply * SOAP_FMAC2 soap_instantiate_ns2__GiftCardBalanceInquiryReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:800 */
#ifndef SOAP_TYPE_ns2__GiftCardRedemptionReply
#define SOAP_TYPE_ns2__GiftCardRedemptionReply (595)
/* complex XML schema type 'ns2:GiftCardRedemptionReply': */
class SOAP_CMAC ns2__GiftCardRedemptionReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:authorizationCode' of XML schema type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GiftCardRedemptionReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__GiftCardRedemptionReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GiftCardRedemptionReply, default initialized and not managed by a soap context
        virtual ns2__GiftCardRedemptionReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__GiftCardRedemptionReply); }
      public:
        /// Constructor with default initializations
        ns2__GiftCardRedemptionReply() : reasonCode(), authorizationCode(), processorResponse(), requestDateTime(), reconciliationID(), soap() { }
        virtual ~ns2__GiftCardRedemptionReply() { }
        /// Friend allocator used by soap_new_ns2__GiftCardRedemptionReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__GiftCardRedemptionReply * SOAP_FMAC2 soap_instantiate_ns2__GiftCardRedemptionReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:802 */
#ifndef SOAP_TYPE_ns2__GiftCardReversalReply
#define SOAP_TYPE_ns2__GiftCardReversalReply (596)
/* complex XML schema type 'ns2:GiftCardReversalReply': */
class SOAP_CMAC ns2__GiftCardReversalReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:authorizationCode' of XML schema type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GiftCardReversalReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__GiftCardReversalReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GiftCardReversalReply, default initialized and not managed by a soap context
        virtual ns2__GiftCardReversalReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__GiftCardReversalReply); }
      public:
        /// Constructor with default initializations
        ns2__GiftCardReversalReply() : reasonCode(), authorizationCode(), processorResponse(), requestDateTime(), reconciliationID(), soap() { }
        virtual ~ns2__GiftCardReversalReply() { }
        /// Friend allocator used by soap_new_ns2__GiftCardReversalReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__GiftCardReversalReply * SOAP_FMAC2 soap_instantiate_ns2__GiftCardReversalReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:804 */
#ifndef SOAP_TYPE_ns2__GiftCardVoidReply
#define SOAP_TYPE_ns2__GiftCardVoidReply (597)
/* complex XML schema type 'ns2:GiftCardVoidReply': */
class SOAP_CMAC ns2__GiftCardVoidReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:authorizationCode' of XML schema type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:requestDeTime' of XML schema type 'ns2:dateTime'
        std::string *requestDeTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GiftCardVoidReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__GiftCardVoidReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GiftCardVoidReply, default initialized and not managed by a soap context
        virtual ns2__GiftCardVoidReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__GiftCardVoidReply); }
      public:
        /// Constructor with default initializations
        ns2__GiftCardVoidReply() : reasonCode(), authorizationCode(), processorResponse(), requestDeTime(), reconciliationID(), soap() { }
        virtual ~ns2__GiftCardVoidReply() { }
        /// Friend allocator used by soap_new_ns2__GiftCardVoidReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__GiftCardVoidReply * SOAP_FMAC2 soap_instantiate_ns2__GiftCardVoidReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:806 */
#ifndef SOAP_TYPE_ns2__GiftCardReloadReply
#define SOAP_TYPE_ns2__GiftCardReloadReply (598)
/* complex XML schema type 'ns2:GiftCardReloadReply': */
class SOAP_CMAC ns2__GiftCardReloadReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:authorizationCode' of XML schema type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GiftCardReloadReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__GiftCardReloadReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GiftCardReloadReply, default initialized and not managed by a soap context
        virtual ns2__GiftCardReloadReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__GiftCardReloadReply); }
      public:
        /// Constructor with default initializations
        ns2__GiftCardReloadReply() : reasonCode(), authorizationCode(), processorResponse(), requestDateTime(), reconciliationID(), soap() { }
        virtual ~ns2__GiftCardReloadReply() { }
        /// Friend allocator used by soap_new_ns2__GiftCardReloadReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__GiftCardReloadReply * SOAP_FMAC2 soap_instantiate_ns2__GiftCardReloadReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:808 */
#ifndef SOAP_TYPE_ns2__GiftCardRefundReply
#define SOAP_TYPE_ns2__GiftCardRefundReply (599)
/* complex XML schema type 'ns2:GiftCardRefundReply': */
class SOAP_CMAC ns2__GiftCardRefundReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:authorizationCode' of XML schema type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:processorResponse' of XML schema type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XML schema type 'xsd:string'
        std::string *reconciliationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GiftCardRefundReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__GiftCardRefundReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GiftCardRefundReply, default initialized and not managed by a soap context
        virtual ns2__GiftCardRefundReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__GiftCardRefundReply); }
      public:
        /// Constructor with default initializations
        ns2__GiftCardRefundReply() : reasonCode(), authorizationCode(), processorResponse(), requestDateTime(), reconciliationID(), soap() { }
        virtual ~ns2__GiftCardRefundReply() { }
        /// Friend allocator used by soap_new_ns2__GiftCardRefundReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__GiftCardRefundReply * SOAP_FMAC2 soap_instantiate_ns2__GiftCardRefundReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:810 */
#ifndef SOAP_TYPE_ns2__mPOS
#define SOAP_TYPE_ns2__mPOS (600)
/* complex XML schema type 'ns2:mPOS': */
class SOAP_CMAC ns2__mPOS {
      public:
        /// Optional element 'ns2:deviceType' of XML schema type 'xsd:string'
        std::string *deviceType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__mPOS
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__mPOS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__mPOS, default initialized and not managed by a soap context
        virtual ns2__mPOS *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__mPOS); }
      public:
        /// Constructor with default initializations
        ns2__mPOS() : deviceType(), soap() { }
        virtual ~ns2__mPOS() { }
        /// Friend allocator used by soap_new_ns2__mPOS(struct soap*, int)
        friend SOAP_FMAC1 ns2__mPOS * SOAP_FMAC2 soap_instantiate_ns2__mPOS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:812 */
#ifndef SOAP_TYPE_ns2__AbortService
#define SOAP_TYPE_ns2__AbortService (601)
/* complex XML schema type 'ns2:AbortService': */
class SOAP_CMAC ns2__AbortService {
      public:
        /// Optional element 'ns2:authRequestID' of XML schema type 'xsd:string'
        std::string *authRequestID;
        /// Optional element 'ns2:creditRequestID' of XML schema type 'xsd:string'
        std::string *creditRequestID;
        /// Optional element 'ns2:cardholderVerificationMethod' of XML schema type 'xsd:string'
        std::string *cardholderVerificationMethod;
        /// Optional element 'ns2:commerceIndicator' of XML schema type 'xsd:string'
        std::string *commerceIndicator;
        /// Required attribute 'run' of XML schema type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AbortService
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__AbortService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AbortService, default initialized and not managed by a soap context
        virtual ns2__AbortService *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__AbortService); }
      public:
        /// Constructor with default initializations
        ns2__AbortService() : authRequestID(), creditRequestID(), cardholderVerificationMethod(), commerceIndicator(), run(), soap() { }
        virtual ~ns2__AbortService() { }
        /// Friend allocator used by soap_new_ns2__AbortService(struct soap*, int)
        friend SOAP_FMAC1 ns2__AbortService * SOAP_FMAC2 soap_instantiate_ns2__AbortService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:814 */
#ifndef SOAP_TYPE_ns2__AbortReply
#define SOAP_TYPE_ns2__AbortReply (602)
/* complex XML schema type 'ns2:AbortReply': */
class SOAP_CMAC ns2__AbortReply {
      public:
        /// Required element 'ns2:reasonCode' of XML schema type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XML schema type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reason' of XML schema type 'xsd:integer'
        std::string *reason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AbortReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__AbortReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AbortReply, default initialized and not managed by a soap context
        virtual ns2__AbortReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__AbortReply); }
      public:
        /// Constructor with default initializations
        ns2__AbortReply() : reasonCode(), requestDateTime(), reason(), soap() { }
        virtual ~ns2__AbortReply() { }
        /// Friend allocator used by soap_new_ns2__AbortReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__AbortReply * SOAP_FMAC2 soap_instantiate_ns2__AbortReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:816 */
#ifndef SOAP_TYPE_ns2__merchant
#define SOAP_TYPE_ns2__merchant (603)
/* complex XML schema type 'ns2:merchant': */
class SOAP_CMAC ns2__merchant {
      public:
        /// Optional element 'ns2:acquirerBIN' of XML schema type 'xsd:string'
        std::string *acquirerBIN;
        /// Optional element 'ns2:cardAcceptorID' of XML schema type 'xsd:string'
        std::string *cardAcceptorID;
        /// Optional element 'ns2:visaMerchantID' of XML schema type 'xsd:string'
        std::string *visaMerchantID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__merchant
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__merchant; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__merchant, default initialized and not managed by a soap context
        virtual ns2__merchant *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__merchant); }
      public:
        /// Constructor with default initializations
        ns2__merchant() : acquirerBIN(), cardAcceptorID(), visaMerchantID(), soap() { }
        virtual ~ns2__merchant() { }
        /// Friend allocator used by soap_new_ns2__merchant(struct soap*, int)
        friend SOAP_FMAC1 ns2__merchant * SOAP_FMAC2 soap_instantiate_ns2__merchant(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:818 */
#ifndef SOAP_TYPE_ns2__DecisionEarlyReply
#define SOAP_TYPE_ns2__DecisionEarlyReply (604)
/* complex XML schema type 'ns2:DecisionEarlyReply': */
class SOAP_CMAC ns2__DecisionEarlyReply {
      public:
        /// Optional element 'ns2:casePriority' of XML schema type 'xsd:integer'
        std::string *casePriority;
        /// Optional element 'ns2:decision' of XML schema type 'xsd:string'
        std::string *decision;
        /// Optional element 'ns2:action' of XML schema type 'xsd:string'
        std::string *action;
        /// Optional element 'ns2:applicableOrderModifications' of XML schema type 'xsd:string'
        std::string *applicableOrderModifications;
        /// Optional element 'ns2:appliedOrderModifications' of XML schema type 'xsd:string'
        std::string *appliedOrderModifications;
        /// Optional element 'ns2:activeProfileReply' of XML schema type 'ns2:ProfileReplyEarly'
        ns2__ProfileReplyEarly *activeProfileReply;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DecisionEarlyReply
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__DecisionEarlyReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DecisionEarlyReply, default initialized and not managed by a soap context
        virtual ns2__DecisionEarlyReply *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__DecisionEarlyReply); }
      public:
        /// Constructor with default initializations
        ns2__DecisionEarlyReply() : casePriority(), decision(), action(), applicableOrderModifications(), appliedOrderModifications(), activeProfileReply(), soap() { }
        virtual ~ns2__DecisionEarlyReply() { }
        /// Friend allocator used by soap_new_ns2__DecisionEarlyReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__DecisionEarlyReply * SOAP_FMAC2 soap_instantiate_ns2__DecisionEarlyReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:820 */
#ifndef SOAP_TYPE_ns2__ProfileReplyEarly
#define SOAP_TYPE_ns2__ProfileReplyEarly (605)
/* complex XML schema type 'ns2:ProfileReplyEarly': */
class SOAP_CMAC ns2__ProfileReplyEarly {
      public:
        /// Optional element 'ns2:name' of XML schema type 'xsd:string'
        std::string *name;
        /// Optional element 'ns2:selectedBy' of XML schema type 'xsd:string'
        std::string *selectedBy;
        /// Optional element 'ns2:pauseRulesTriggered' of XML schema type 'ns2:PauseRuleResultItems'
        ns2__PauseRuleResultItems *pauseRulesTriggered;
        /// Optional element 'ns2:rulesTriggered' of XML schema type 'ns2:RuleResultItems'
        ns2__RuleResultItems *rulesTriggered;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ProfileReplyEarly
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__ProfileReplyEarly; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ProfileReplyEarly, default initialized and not managed by a soap context
        virtual ns2__ProfileReplyEarly *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__ProfileReplyEarly); }
      public:
        /// Constructor with default initializations
        ns2__ProfileReplyEarly() : name(), selectedBy(), pauseRulesTriggered(), rulesTriggered(), soap() { }
        virtual ~ns2__ProfileReplyEarly() { }
        /// Friend allocator used by soap_new_ns2__ProfileReplyEarly(struct soap*, int)
        friend SOAP_FMAC1 ns2__ProfileReplyEarly * SOAP_FMAC2 soap_instantiate_ns2__ProfileReplyEarly(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:822 */
#ifndef SOAP_TYPE_ns2__PauseRuleResultItems
#define SOAP_TYPE_ns2__PauseRuleResultItems (606)
/* complex XML schema type 'ns2:PauseRuleResultItems': */
class SOAP_CMAC ns2__PauseRuleResultItems {
      public:
        /// Sequence of 0 to 1000 elements 'ns2:ruleResultItem' of XML schema type 'ns2:PauseRuleResultItem'
        std::vector<ns2__PauseRuleResultItem> ruleResultItem;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PauseRuleResultItems
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PauseRuleResultItems; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PauseRuleResultItems, default initialized and not managed by a soap context
        virtual ns2__PauseRuleResultItems *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PauseRuleResultItems); }
      public:
        /// Constructor with default initializations
        ns2__PauseRuleResultItems() : ruleResultItem(), soap() { }
        virtual ~ns2__PauseRuleResultItems() { }
        /// Friend allocator used by soap_new_ns2__PauseRuleResultItems(struct soap*, int)
        friend SOAP_FMAC1 ns2__PauseRuleResultItems * SOAP_FMAC2 soap_instantiate_ns2__PauseRuleResultItems(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:824 */
#ifndef SOAP_TYPE_ns2__PauseRuleResultItem
#define SOAP_TYPE_ns2__PauseRuleResultItem (607)
/* complex XML schema type 'ns2:PauseRuleResultItem': */
class SOAP_CMAC ns2__PauseRuleResultItem {
      public:
        /// Optional element 'ns2:ruleID' of XML schema type 'xsd:integer'
        std::string *ruleID;
        /// Optional element 'ns2:name' of XML schema type 'xsd:string'
        std::string *name;
        /// Optional element 'ns2:action' of XML schema type 'xsd:string'
        std::string *action;
        /// Optional element 'ns2:evaluation' of XML schema type 'xsd:string'
        std::string *evaluation;
        /// Optional element 'ns2:orderModification' of XML schema type 'xsd:string'
        std::string *orderModification;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PauseRuleResultItem
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__PauseRuleResultItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PauseRuleResultItem, default initialized and not managed by a soap context
        virtual ns2__PauseRuleResultItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__PauseRuleResultItem); }
      public:
        /// Constructor with default initializations
        ns2__PauseRuleResultItem() : ruleID(), name(), action(), evaluation(), orderModification(), soap() { }
        virtual ~ns2__PauseRuleResultItem() { }
        /// Friend allocator used by soap_new_ns2__PauseRuleResultItem(struct soap*, int)
        friend SOAP_FMAC1 ns2__PauseRuleResultItem * SOAP_FMAC2 soap_instantiate_ns2__PauseRuleResultItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:826 */
#ifndef SOAP_TYPE_ns2__payByPoints
#define SOAP_TYPE_ns2__payByPoints (608)
/* complex XML schema type 'ns2:payByPoints': */
class SOAP_CMAC ns2__payByPoints {
      public:
        /// Optional element 'ns2:indicator' of XML schema type 'xsd:string'
        std::string *indicator;
        /// Optional element 'ns2:pointsBeforeRedemption' of XML schema type 'xsd:string'
        std::string *pointsBeforeRedemption;
        /// Optional element 'ns2:pointsValueBeforeRedemption' of XML schema type 'xsd:string'
        std::string *pointsValueBeforeRedemption;
        /// Optional element 'ns2:pointsRedeemed' of XML schema type 'xsd:string'
        std::string *pointsRedeemed;
        /// Optional element 'ns2:pointsValueRedeemed' of XML schema type 'xsd:string'
        std::string *pointsValueRedeemed;
        /// Optional element 'ns2:pointsAfterRedemption' of XML schema type 'xsd:string'
        std::string *pointsAfterRedemption;
        /// Optional element 'ns2:pointsValueAfterRedemption' of XML schema type 'xsd:string'
        std::string *pointsValueAfterRedemption;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__payByPoints
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__payByPoints; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__payByPoints, default initialized and not managed by a soap context
        virtual ns2__payByPoints *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__payByPoints); }
      public:
        /// Constructor with default initializations
        ns2__payByPoints() : indicator(), pointsBeforeRedemption(), pointsValueBeforeRedemption(), pointsRedeemed(), pointsValueRedeemed(), pointsAfterRedemption(), pointsValueAfterRedemption(), soap() { }
        virtual ~ns2__payByPoints() { }
        /// Friend allocator used by soap_new_ns2__payByPoints(struct soap*, int)
        friend SOAP_FMAC1 ns2__payByPoints * SOAP_FMAC2 soap_instantiate_ns2__payByPoints(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:668 */
#ifndef SOAP_TYPE_ns2__MDDField
#define SOAP_TYPE_ns2__MDDField (529)
/* simple XML schema type 'ns2:MDDField': */
class SOAP_CMAC ns2__MDDField {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Required attribute 'id' of XML schema type 'xsd:integer'
        std::string id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MDDField
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__MDDField; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MDDField, default initialized and not managed by a soap context
        virtual ns2__MDDField *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__MDDField); }
      public:
        /// Constructor with default initializations
        ns2__MDDField() : __item(), id(), soap() { }
        virtual ~ns2__MDDField() { }
        /// Friend allocator used by soap_new_ns2__MDDField(struct soap*, int)
        friend SOAP_FMAC1 ns2__MDDField * SOAP_FMAC2 soap_instantiate_ns2__MDDField(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:672 */
#ifndef SOAP_TYPE_ns2__AuxiliaryField
#define SOAP_TYPE_ns2__AuxiliaryField (531)
/* simple XML schema type 'ns2:AuxiliaryField': */
class SOAP_CMAC ns2__AuxiliaryField {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Required attribute 'id' of XML schema type 'xsd:integer'
        std::string id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AuxiliaryField
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__AuxiliaryField; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AuxiliaryField, default initialized and not managed by a soap context
        virtual ns2__AuxiliaryField *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__AuxiliaryField); }
      public:
        /// Constructor with default initializations
        ns2__AuxiliaryField() : __item(), id(), soap() { }
        virtual ~ns2__AuxiliaryField() { }
        /// Friend allocator used by soap_new_ns2__AuxiliaryField(struct soap*, int)
        friend SOAP_FMAC1 ns2__AuxiliaryField * SOAP_FMAC2 soap_instantiate_ns2__AuxiliaryField(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:14497 */
#ifndef SOAP_TYPE___ns1__runTransactionResponse
#define SOAP_TYPE___ns1__runTransactionResponse (950)
/* Wrapper: */
struct SOAP_CMAC __ns1__runTransactionResponse {
      public:
        /** Required element 'ns2:nvpReply' of XML schema type 'xsd:string' */
        std::string ns2__nvpReply;
      public:
        /** Return unique type id SOAP_TYPE___ns1__runTransactionResponse */
        long soap_type() const { return SOAP_TYPE___ns1__runTransactionResponse; }
        /** Constructor with member initializations */
        __ns1__runTransactionResponse() : ns2__nvpReply() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__runTransactionResponse * SOAP_FMAC2 soap_instantiate___ns1__runTransactionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:14497 */
#ifndef SOAP_TYPE___ns1__runTransaction
#define SOAP_TYPE___ns1__runTransaction (951)
/* Wrapper: */
struct SOAP_CMAC __ns1__runTransaction {
      public:
        /** Required element 'ns2:nvpRequest' of XML schema type 'xsd:string' */
        std::string ns2__nvpRequest;
      public:
        /** Return unique type id SOAP_TYPE___ns1__runTransaction */
        long soap_type() const { return SOAP_TYPE___ns1__runTransaction; }
        /** Constructor with member initializations */
        __ns1__runTransaction() : ns2__nvpRequest() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__runTransaction * SOAP_FMAC2 soap_instantiate___ns1__runTransaction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_nvp_1.183.h:14574 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (952)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* CyberSourceTransaction_nvp_1.183.h:14574 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (954)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* CyberSourceTransaction_nvp_1.183.h:14574 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (957)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* CyberSourceTransaction_nvp_1.183.h:14574 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (958)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* ds.h:48 */
#ifndef SOAP_TYPE__ds__SignatureValue
#define SOAP_TYPE__ds__SignatureValue (30)
typedef char *_ds__SignatureValue;
#endif

/* ds.h:54 */
#ifndef SOAP_TYPE__ds__Signature
#define SOAP_TYPE__ds__Signature (35)
typedef struct ds__SignatureType _ds__Signature;
#endif

/* ds.h:80 */
#ifndef SOAP_TYPE__ds__Transform
#define SOAP_TYPE__ds__Transform (43)
typedef struct ds__TransformType _ds__Transform;
#endif

/* ds.h:94 */
#ifndef SOAP_TYPE__ds__KeyInfo
#define SOAP_TYPE__ds__KeyInfo (50)
typedef struct ds__KeyInfoType _ds__KeyInfo;
#endif

/* wsc.h:58 */
#ifndef SOAP_TYPE_wsc__FaultCodeOpenEnumType
#define SOAP_TYPE_wsc__FaultCodeOpenEnumType (87)
typedef char *wsc__FaultCodeOpenEnumType;
#endif

/* saml1.h:628 */
#ifndef SOAP_TYPE__saml1__AssertionIDReference
#define SOAP_TYPE__saml1__AssertionIDReference (152)
typedef char *_saml1__AssertionIDReference;
#endif

/* saml1.h:631 */
#ifndef SOAP_TYPE__saml1__Assertion
#define SOAP_TYPE__saml1__Assertion (153)
typedef struct saml1__AssertionType _saml1__Assertion;
#endif

/* saml1.h:634 */
#ifndef SOAP_TYPE__saml1__Conditions
#define SOAP_TYPE__saml1__Conditions (154)
typedef struct saml1__ConditionsType _saml1__Conditions;
#endif

/* saml1.h:637 */
#ifndef SOAP_TYPE__saml1__Condition
#define SOAP_TYPE__saml1__Condition (155)
typedef struct saml1__ConditionAbstractType _saml1__Condition;
#endif

/* saml1.h:640 */
#ifndef SOAP_TYPE__saml1__AudienceRestrictionCondition
#define SOAP_TYPE__saml1__AudienceRestrictionCondition (156)
typedef struct saml1__AudienceRestrictionConditionType _saml1__AudienceRestrictionCondition;
#endif

/* saml1.h:643 */
#ifndef SOAP_TYPE__saml1__Audience
#define SOAP_TYPE__saml1__Audience (157)
typedef char *_saml1__Audience;
#endif

/* saml1.h:646 */
#ifndef SOAP_TYPE__saml1__DoNotCacheCondition
#define SOAP_TYPE__saml1__DoNotCacheCondition (158)
typedef struct saml1__DoNotCacheConditionType _saml1__DoNotCacheCondition;
#endif

/* saml1.h:649 */
#ifndef SOAP_TYPE__saml1__Advice
#define SOAP_TYPE__saml1__Advice (159)
typedef struct saml1__AdviceType _saml1__Advice;
#endif

/* saml1.h:652 */
#ifndef SOAP_TYPE__saml1__Statement
#define SOAP_TYPE__saml1__Statement (160)
typedef struct saml1__StatementAbstractType _saml1__Statement;
#endif

/* saml1.h:655 */
#ifndef SOAP_TYPE__saml1__SubjectStatement
#define SOAP_TYPE__saml1__SubjectStatement (161)
typedef struct saml1__SubjectStatementAbstractType _saml1__SubjectStatement;
#endif

/* saml1.h:658 */
#ifndef SOAP_TYPE__saml1__Subject
#define SOAP_TYPE__saml1__Subject (162)
typedef struct saml1__SubjectType _saml1__Subject;
#endif

/* saml1.h:661 */
#ifndef SOAP_TYPE__saml1__NameIdentifier
#define SOAP_TYPE__saml1__NameIdentifier (163)
typedef struct saml1__NameIdentifierType _saml1__NameIdentifier;
#endif

/* saml1.h:664 */
#ifndef SOAP_TYPE__saml1__SubjectConfirmation
#define SOAP_TYPE__saml1__SubjectConfirmation (164)
typedef struct saml1__SubjectConfirmationType _saml1__SubjectConfirmation;
#endif

/* saml1.h:667 */
#ifndef SOAP_TYPE__saml1__SubjectConfirmationData
#define SOAP_TYPE__saml1__SubjectConfirmationData (165)
typedef _XML _saml1__SubjectConfirmationData;
#endif

/* saml1.h:670 */
#ifndef SOAP_TYPE__saml1__ConfirmationMethod
#define SOAP_TYPE__saml1__ConfirmationMethod (166)
typedef char *_saml1__ConfirmationMethod;
#endif

/* saml1.h:673 */
#ifndef SOAP_TYPE__saml1__AuthenticationStatement
#define SOAP_TYPE__saml1__AuthenticationStatement (167)
typedef struct saml1__AuthenticationStatementType _saml1__AuthenticationStatement;
#endif

/* saml1.h:676 */
#ifndef SOAP_TYPE__saml1__SubjectLocality
#define SOAP_TYPE__saml1__SubjectLocality (168)
typedef struct saml1__SubjectLocalityType _saml1__SubjectLocality;
#endif

/* saml1.h:679 */
#ifndef SOAP_TYPE__saml1__AuthorityBinding
#define SOAP_TYPE__saml1__AuthorityBinding (169)
typedef struct saml1__AuthorityBindingType _saml1__AuthorityBinding;
#endif

/* saml1.h:682 */
#ifndef SOAP_TYPE__saml1__AuthorizationDecisionStatement
#define SOAP_TYPE__saml1__AuthorizationDecisionStatement (170)
typedef struct saml1__AuthorizationDecisionStatementType _saml1__AuthorizationDecisionStatement;
#endif

/* saml1.h:685 */
#ifndef SOAP_TYPE__saml1__Action
#define SOAP_TYPE__saml1__Action (171)
typedef struct saml1__ActionType _saml1__Action;
#endif

/* saml1.h:688 */
#ifndef SOAP_TYPE__saml1__Evidence
#define SOAP_TYPE__saml1__Evidence (172)
typedef struct saml1__EvidenceType _saml1__Evidence;
#endif

/* saml1.h:691 */
#ifndef SOAP_TYPE__saml1__AttributeStatement
#define SOAP_TYPE__saml1__AttributeStatement (173)
typedef struct saml1__AttributeStatementType _saml1__AttributeStatement;
#endif

/* saml1.h:694 */
#ifndef SOAP_TYPE__saml1__AttributeDesignator
#define SOAP_TYPE__saml1__AttributeDesignator (174)
typedef struct saml1__AttributeDesignatorType _saml1__AttributeDesignator;
#endif

/* saml1.h:697 */
#ifndef SOAP_TYPE__saml1__Attribute
#define SOAP_TYPE__saml1__Attribute (175)
typedef struct saml1__AttributeType _saml1__Attribute;
#endif

/* saml1.h:700 */
#ifndef SOAP_TYPE__saml1__AttributeValue
#define SOAP_TYPE__saml1__AttributeValue (176)
typedef _XML _saml1__AttributeValue;
#endif

/* saml2.h:781 */
#ifndef SOAP_TYPE__saml2__BaseID
#define SOAP_TYPE__saml2__BaseID (235)
typedef struct saml2__BaseIDAbstractType _saml2__BaseID;
#endif

/* saml2.h:784 */
#ifndef SOAP_TYPE__saml2__NameID
#define SOAP_TYPE__saml2__NameID (236)
typedef struct saml2__NameIDType _saml2__NameID;
#endif

/* saml2.h:787 */
#ifndef SOAP_TYPE__saml2__EncryptedID
#define SOAP_TYPE__saml2__EncryptedID (237)
typedef struct saml2__EncryptedElementType _saml2__EncryptedID;
#endif

/* saml2.h:790 */
#ifndef SOAP_TYPE__saml2__Issuer
#define SOAP_TYPE__saml2__Issuer (238)
typedef struct saml2__NameIDType _saml2__Issuer;
#endif

/* saml2.h:793 */
#ifndef SOAP_TYPE__saml2__AssertionIDRef
#define SOAP_TYPE__saml2__AssertionIDRef (239)
typedef char *_saml2__AssertionIDRef;
#endif

/* saml2.h:796 */
#ifndef SOAP_TYPE__saml2__AssertionURIRef
#define SOAP_TYPE__saml2__AssertionURIRef (240)
typedef char *_saml2__AssertionURIRef;
#endif

/* saml2.h:799 */
#ifndef SOAP_TYPE__saml2__Assertion
#define SOAP_TYPE__saml2__Assertion (241)
typedef struct saml2__AssertionType _saml2__Assertion;
#endif

/* saml2.h:802 */
#ifndef SOAP_TYPE__saml2__Subject
#define SOAP_TYPE__saml2__Subject (242)
typedef struct saml2__SubjectType _saml2__Subject;
#endif

/* saml2.h:805 */
#ifndef SOAP_TYPE__saml2__SubjectConfirmation
#define SOAP_TYPE__saml2__SubjectConfirmation (243)
typedef struct saml2__SubjectConfirmationType _saml2__SubjectConfirmation;
#endif

/* saml2.h:808 */
#ifndef SOAP_TYPE__saml2__SubjectConfirmationData
#define SOAP_TYPE__saml2__SubjectConfirmationData (244)
typedef struct saml2__SubjectConfirmationDataType _saml2__SubjectConfirmationData;
#endif

/* saml2.h:811 */
#ifndef SOAP_TYPE__saml2__Conditions
#define SOAP_TYPE__saml2__Conditions (245)
typedef struct saml2__ConditionsType _saml2__Conditions;
#endif

/* saml2.h:814 */
#ifndef SOAP_TYPE__saml2__Condition
#define SOAP_TYPE__saml2__Condition (246)
typedef struct saml2__ConditionAbstractType _saml2__Condition;
#endif

/* saml2.h:817 */
#ifndef SOAP_TYPE__saml2__AudienceRestriction
#define SOAP_TYPE__saml2__AudienceRestriction (247)
typedef struct saml2__AudienceRestrictionType _saml2__AudienceRestriction;
#endif

/* saml2.h:820 */
#ifndef SOAP_TYPE__saml2__Audience
#define SOAP_TYPE__saml2__Audience (248)
typedef char *_saml2__Audience;
#endif

/* saml2.h:823 */
#ifndef SOAP_TYPE__saml2__OneTimeUse
#define SOAP_TYPE__saml2__OneTimeUse (249)
typedef struct saml2__OneTimeUseType _saml2__OneTimeUse;
#endif

/* saml2.h:826 */
#ifndef SOAP_TYPE__saml2__ProxyRestriction
#define SOAP_TYPE__saml2__ProxyRestriction (250)
typedef struct saml2__ProxyRestrictionType _saml2__ProxyRestriction;
#endif

/* saml2.h:829 */
#ifndef SOAP_TYPE__saml2__Advice
#define SOAP_TYPE__saml2__Advice (251)
typedef struct saml2__AdviceType _saml2__Advice;
#endif

/* saml2.h:832 */
#ifndef SOAP_TYPE__saml2__EncryptedAssertion
#define SOAP_TYPE__saml2__EncryptedAssertion (252)
typedef struct saml2__EncryptedElementType _saml2__EncryptedAssertion;
#endif

/* saml2.h:835 */
#ifndef SOAP_TYPE__saml2__Statement
#define SOAP_TYPE__saml2__Statement (253)
typedef struct saml2__StatementAbstractType _saml2__Statement;
#endif

/* saml2.h:838 */
#ifndef SOAP_TYPE__saml2__AuthnStatement
#define SOAP_TYPE__saml2__AuthnStatement (254)
typedef struct saml2__AuthnStatementType _saml2__AuthnStatement;
#endif

/* saml2.h:841 */
#ifndef SOAP_TYPE__saml2__SubjectLocality
#define SOAP_TYPE__saml2__SubjectLocality (255)
typedef struct saml2__SubjectLocalityType _saml2__SubjectLocality;
#endif

/* saml2.h:844 */
#ifndef SOAP_TYPE__saml2__AuthnContext
#define SOAP_TYPE__saml2__AuthnContext (256)
typedef struct saml2__AuthnContextType _saml2__AuthnContext;
#endif

/* saml2.h:847 */
#ifndef SOAP_TYPE__saml2__AuthnContextClassRef
#define SOAP_TYPE__saml2__AuthnContextClassRef (257)
typedef char *_saml2__AuthnContextClassRef;
#endif

/* saml2.h:850 */
#ifndef SOAP_TYPE__saml2__AuthnContextDeclRef
#define SOAP_TYPE__saml2__AuthnContextDeclRef (258)
typedef char *_saml2__AuthnContextDeclRef;
#endif

/* saml2.h:853 */
#ifndef SOAP_TYPE__saml2__AuthnContextDecl
#define SOAP_TYPE__saml2__AuthnContextDecl (259)
typedef _XML _saml2__AuthnContextDecl;
#endif

/* saml2.h:856 */
#ifndef SOAP_TYPE__saml2__AuthenticatingAuthority
#define SOAP_TYPE__saml2__AuthenticatingAuthority (260)
typedef char *_saml2__AuthenticatingAuthority;
#endif

/* saml2.h:859 */
#ifndef SOAP_TYPE__saml2__AuthzDecisionStatement
#define SOAP_TYPE__saml2__AuthzDecisionStatement (261)
typedef struct saml2__AuthzDecisionStatementType _saml2__AuthzDecisionStatement;
#endif

/* saml2.h:862 */
#ifndef SOAP_TYPE__saml2__Action
#define SOAP_TYPE__saml2__Action (262)
typedef struct saml2__ActionType _saml2__Action;
#endif

/* saml2.h:865 */
#ifndef SOAP_TYPE__saml2__Evidence
#define SOAP_TYPE__saml2__Evidence (263)
typedef struct saml2__EvidenceType _saml2__Evidence;
#endif

/* saml2.h:868 */
#ifndef SOAP_TYPE__saml2__AttributeStatement
#define SOAP_TYPE__saml2__AttributeStatement (264)
typedef struct saml2__AttributeStatementType _saml2__AttributeStatement;
#endif

/* saml2.h:871 */
#ifndef SOAP_TYPE__saml2__Attribute
#define SOAP_TYPE__saml2__Attribute (265)
typedef struct saml2__AttributeType _saml2__Attribute;
#endif

/* saml2.h:874 */
#ifndef SOAP_TYPE__saml2__AttributeValue
#define SOAP_TYPE__saml2__AttributeValue (266)
typedef _XML _saml2__AttributeValue;
#endif

/* saml2.h:877 */
#ifndef SOAP_TYPE__saml2__EncryptedAttribute
#define SOAP_TYPE__saml2__EncryptedAttribute (267)
typedef struct saml2__EncryptedElementType _saml2__EncryptedAttribute;
#endif

/* CyberSourceTransaction_nvp_1.183.h:163 */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (281)
typedef std::string xsd__decimal;
#endif

/* CyberSourceTransaction_nvp_1.183.h:166 */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (282)
typedef std::string xsd__integer;
#endif

/* CyberSourceTransaction_nvp_1.183.h:846 */
#ifndef SOAP_TYPE_ns2__amount
#define SOAP_TYPE_ns2__amount (609)
typedef std::string ns2__amount;
#endif

/* CyberSourceTransaction_nvp_1.183.h:850 */
#ifndef SOAP_TYPE_ns2__boolean
#define SOAP_TYPE_ns2__boolean (610)
typedef std::string ns2__boolean;
#endif

/* CyberSourceTransaction_nvp_1.183.h:854 */
#ifndef SOAP_TYPE_ns2__dateTime
#define SOAP_TYPE_ns2__dateTime (611)
typedef std::string ns2__dateTime;
#endif

/* CyberSourceTransaction_nvp_1.183.h:859 */
#ifndef SOAP_TYPE_ns2__RestrictedString
#define SOAP_TYPE_ns2__RestrictedString (612)
typedef std::string ns2__RestrictedString;
#endif

/* CyberSourceTransaction_nvp_1.183.h:865 */
#ifndef SOAP_TYPE_ns2__RestrictedDecimal
#define SOAP_TYPE_ns2__RestrictedDecimal (613)
typedef xsd__decimal ns2__RestrictedDecimal;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (278)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (15)
#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_ULONG64
#define SOAP_TYPE_ULONG64 (95)
#endif

/* enum saml2__DecisionType has binding name 'saml2__DecisionType' for type 'saml2:DecisionType' */
#ifndef SOAP_TYPE_saml2__DecisionType
#define SOAP_TYPE_saml2__DecisionType (200)
#endif

/* enum saml1__DecisionType has binding name 'saml1__DecisionType' for type 'saml1:DecisionType' */
#ifndef SOAP_TYPE_saml1__DecisionType
#define SOAP_TYPE_saml1__DecisionType (120)
#endif

/* enum wsc__FaultCodeType has binding name 'wsc__FaultCodeType' for type 'wsc:FaultCodeType' */
#ifndef SOAP_TYPE_wsc__FaultCodeType
#define SOAP_TYPE_wsc__FaultCodeType (88)
#endif

/* enum wsse__FaultcodeEnum has binding name 'wsse__FaultcodeEnum' for type 'wsse:FaultcodeEnum' */
#ifndef SOAP_TYPE_wsse__FaultcodeEnum
#define SOAP_TYPE_wsse__FaultcodeEnum (10)
#endif

/* enum wsu__tTimestampFault has binding name 'wsu__tTimestampFault' for type 'wsu:tTimestampFault' */
#ifndef SOAP_TYPE_wsu__tTimestampFault
#define SOAP_TYPE_wsu__tTimestampFault (7)
#endif

/* ns2__RestrictedDecimal has binding name 'ns2__RestrictedDecimal' for type 'ns2:RestrictedDecimal' */
#ifndef SOAP_TYPE_ns2__RestrictedDecimal
#define SOAP_TYPE_ns2__RestrictedDecimal (613)
#endif

/* ns2__RestrictedString has binding name 'ns2__RestrictedString' for type 'ns2:RestrictedString' */
#ifndef SOAP_TYPE_ns2__RestrictedString
#define SOAP_TYPE_ns2__RestrictedString (612)
#endif

/* ns2__dateTime has binding name 'ns2__dateTime' for type 'ns2:dateTime' */
#ifndef SOAP_TYPE_ns2__dateTime
#define SOAP_TYPE_ns2__dateTime (611)
#endif

/* ns2__boolean has binding name 'ns2__boolean' for type 'ns2:boolean' */
#ifndef SOAP_TYPE_ns2__boolean
#define SOAP_TYPE_ns2__boolean (610)
#endif

/* ns2__amount has binding name 'ns2__amount' for type 'ns2:amount' */
#ifndef SOAP_TYPE_ns2__amount
#define SOAP_TYPE_ns2__amount (609)
#endif

/* ns2__payByPoints has binding name 'ns2__payByPoints' for type 'ns2:payByPoints' */
#ifndef SOAP_TYPE_ns2__payByPoints
#define SOAP_TYPE_ns2__payByPoints (608)
#endif

/* ns2__PauseRuleResultItem has binding name 'ns2__PauseRuleResultItem' for type 'ns2:PauseRuleResultItem' */
#ifndef SOAP_TYPE_ns2__PauseRuleResultItem
#define SOAP_TYPE_ns2__PauseRuleResultItem (607)
#endif

/* ns2__PauseRuleResultItems has binding name 'ns2__PauseRuleResultItems' for type 'ns2:PauseRuleResultItems' */
#ifndef SOAP_TYPE_ns2__PauseRuleResultItems
#define SOAP_TYPE_ns2__PauseRuleResultItems (606)
#endif

/* ns2__ProfileReplyEarly has binding name 'ns2__ProfileReplyEarly' for type 'ns2:ProfileReplyEarly' */
#ifndef SOAP_TYPE_ns2__ProfileReplyEarly
#define SOAP_TYPE_ns2__ProfileReplyEarly (605)
#endif

/* ns2__DecisionEarlyReply has binding name 'ns2__DecisionEarlyReply' for type 'ns2:DecisionEarlyReply' */
#ifndef SOAP_TYPE_ns2__DecisionEarlyReply
#define SOAP_TYPE_ns2__DecisionEarlyReply (604)
#endif

/* ns2__merchant has binding name 'ns2__merchant' for type 'ns2:merchant' */
#ifndef SOAP_TYPE_ns2__merchant
#define SOAP_TYPE_ns2__merchant (603)
#endif

/* ns2__AbortReply has binding name 'ns2__AbortReply' for type 'ns2:AbortReply' */
#ifndef SOAP_TYPE_ns2__AbortReply
#define SOAP_TYPE_ns2__AbortReply (602)
#endif

/* ns2__AbortService has binding name 'ns2__AbortService' for type 'ns2:AbortService' */
#ifndef SOAP_TYPE_ns2__AbortService
#define SOAP_TYPE_ns2__AbortService (601)
#endif

/* ns2__mPOS has binding name 'ns2__mPOS' for type 'ns2:mPOS' */
#ifndef SOAP_TYPE_ns2__mPOS
#define SOAP_TYPE_ns2__mPOS (600)
#endif

/* ns2__GiftCardRefundReply has binding name 'ns2__GiftCardRefundReply' for type 'ns2:GiftCardRefundReply' */
#ifndef SOAP_TYPE_ns2__GiftCardRefundReply
#define SOAP_TYPE_ns2__GiftCardRefundReply (599)
#endif

/* ns2__GiftCardReloadReply has binding name 'ns2__GiftCardReloadReply' for type 'ns2:GiftCardReloadReply' */
#ifndef SOAP_TYPE_ns2__GiftCardReloadReply
#define SOAP_TYPE_ns2__GiftCardReloadReply (598)
#endif

/* ns2__GiftCardVoidReply has binding name 'ns2__GiftCardVoidReply' for type 'ns2:GiftCardVoidReply' */
#ifndef SOAP_TYPE_ns2__GiftCardVoidReply
#define SOAP_TYPE_ns2__GiftCardVoidReply (597)
#endif

/* ns2__GiftCardReversalReply has binding name 'ns2__GiftCardReversalReply' for type 'ns2:GiftCardReversalReply' */
#ifndef SOAP_TYPE_ns2__GiftCardReversalReply
#define SOAP_TYPE_ns2__GiftCardReversalReply (596)
#endif

/* ns2__GiftCardRedemptionReply has binding name 'ns2__GiftCardRedemptionReply' for type 'ns2:GiftCardRedemptionReply' */
#ifndef SOAP_TYPE_ns2__GiftCardRedemptionReply
#define SOAP_TYPE_ns2__GiftCardRedemptionReply (595)
#endif

/* ns2__GiftCardBalanceInquiryReply has binding name 'ns2__GiftCardBalanceInquiryReply' for type 'ns2:GiftCardBalanceInquiryReply' */
#ifndef SOAP_TYPE_ns2__GiftCardBalanceInquiryReply
#define SOAP_TYPE_ns2__GiftCardBalanceInquiryReply (594)
#endif

/* ns2__GiftCardActivationReply has binding name 'ns2__GiftCardActivationReply' for type 'ns2:GiftCardActivationReply' */
#ifndef SOAP_TYPE_ns2__GiftCardActivationReply
#define SOAP_TYPE_ns2__GiftCardActivationReply (593)
#endif

/* ns2__GiftCard has binding name 'ns2__GiftCard' for type 'ns2:GiftCard' */
#ifndef SOAP_TYPE_ns2__GiftCard
#define SOAP_TYPE_ns2__GiftCard (592)
#endif

/* ns2__GiftCardRefundService has binding name 'ns2__GiftCardRefundService' for type 'ns2:GiftCardRefundService' */
#ifndef SOAP_TYPE_ns2__GiftCardRefundService
#define SOAP_TYPE_ns2__GiftCardRefundService (591)
#endif

/* ns2__GiftCardReloadService has binding name 'ns2__GiftCardReloadService' for type 'ns2:GiftCardReloadService' */
#ifndef SOAP_TYPE_ns2__GiftCardReloadService
#define SOAP_TYPE_ns2__GiftCardReloadService (590)
#endif

/* ns2__GiftCardRedemptionService has binding name 'ns2__GiftCardRedemptionService' for type 'ns2:GiftCardRedemptionService' */
#ifndef SOAP_TYPE_ns2__GiftCardRedemptionService
#define SOAP_TYPE_ns2__GiftCardRedemptionService (589)
#endif

/* ns2__GiftCardReversalService has binding name 'ns2__GiftCardReversalService' for type 'ns2:GiftCardReversalService' */
#ifndef SOAP_TYPE_ns2__GiftCardReversalService
#define SOAP_TYPE_ns2__GiftCardReversalService (588)
#endif

/* ns2__GiftCardVoidService has binding name 'ns2__GiftCardVoidService' for type 'ns2:GiftCardVoidService' */
#ifndef SOAP_TYPE_ns2__GiftCardVoidService
#define SOAP_TYPE_ns2__GiftCardVoidService (587)
#endif

/* ns2__GiftCardBalanceInquiryService has binding name 'ns2__GiftCardBalanceInquiryService' for type 'ns2:GiftCardBalanceInquiryService' */
#ifndef SOAP_TYPE_ns2__GiftCardBalanceInquiryService
#define SOAP_TYPE_ns2__GiftCardBalanceInquiryService (586)
#endif

/* ns2__GiftCardActivationService has binding name 'ns2__GiftCardActivationService' for type 'ns2:GiftCardActivationService' */
#ifndef SOAP_TYPE_ns2__GiftCardActivationService
#define SOAP_TYPE_ns2__GiftCardActivationService (585)
#endif

/* ns2__ECAVSService has binding name 'ns2__ECAVSService' for type 'ns2:ECAVSService' */
#ifndef SOAP_TYPE_ns2__ECAVSService
#define SOAP_TYPE_ns2__ECAVSService (584)
#endif

/* ns2__Category has binding name 'ns2__Category' for type 'ns2:Category' */
#ifndef SOAP_TYPE_ns2__Category
#define SOAP_TYPE_ns2__Category (583)
#endif

/* ns2__APRevokeMandateReply has binding name 'ns2__APRevokeMandateReply' for type 'ns2:APRevokeMandateReply' */
#ifndef SOAP_TYPE_ns2__APRevokeMandateReply
#define SOAP_TYPE_ns2__APRevokeMandateReply (582)
#endif

/* ns2__APRevokeMandateService has binding name 'ns2__APRevokeMandateService' for type 'ns2:APRevokeMandateService' */
#ifndef SOAP_TYPE_ns2__APRevokeMandateService
#define SOAP_TYPE_ns2__APRevokeMandateService (581)
#endif

/* ns2__APImportMandateReply has binding name 'ns2__APImportMandateReply' for type 'ns2:APImportMandateReply' */
#ifndef SOAP_TYPE_ns2__APImportMandateReply
#define SOAP_TYPE_ns2__APImportMandateReply (580)
#endif

/* ns2__APUpdateMandateReply has binding name 'ns2__APUpdateMandateReply' for type 'ns2:APUpdateMandateReply' */
#ifndef SOAP_TYPE_ns2__APUpdateMandateReply
#define SOAP_TYPE_ns2__APUpdateMandateReply (579)
#endif

/* ns2__GetMasterpassDataReply has binding name 'ns2__GetMasterpassDataReply' for type 'ns2:GetMasterpassDataReply' */
#ifndef SOAP_TYPE_ns2__GetMasterpassDataReply
#define SOAP_TYPE_ns2__GetMasterpassDataReply (578)
#endif

/* ns2__GetMasterpassDataService has binding name 'ns2__GetMasterpassDataService' for type 'ns2:GetMasterpassDataService' */
#ifndef SOAP_TYPE_ns2__GetMasterpassDataService
#define SOAP_TYPE_ns2__GetMasterpassDataService (577)
#endif

/* ns2__APUpdateMandateService has binding name 'ns2__APUpdateMandateService' for type 'ns2:APUpdateMandateService' */
#ifndef SOAP_TYPE_ns2__APUpdateMandateService
#define SOAP_TYPE_ns2__APUpdateMandateService (576)
#endif

/* ns2__APMandateStatusReply has binding name 'ns2__APMandateStatusReply' for type 'ns2:APMandateStatusReply' */
#ifndef SOAP_TYPE_ns2__APMandateStatusReply
#define SOAP_TYPE_ns2__APMandateStatusReply (575)
#endif

/* ns2__APMandateStatusService has binding name 'ns2__APMandateStatusService' for type 'ns2:APMandateStatusService' */
#ifndef SOAP_TYPE_ns2__APMandateStatusService
#define SOAP_TYPE_ns2__APMandateStatusService (574)
#endif

/* ns2__APCreateMandateReply has binding name 'ns2__APCreateMandateReply' for type 'ns2:APCreateMandateReply' */
#ifndef SOAP_TYPE_ns2__APCreateMandateReply
#define SOAP_TYPE_ns2__APCreateMandateReply (573)
#endif

/* ns2__APCreateMandateService has binding name 'ns2__APCreateMandateService' for type 'ns2:APCreateMandateService' */
#ifndef SOAP_TYPE_ns2__APCreateMandateService
#define SOAP_TYPE_ns2__APCreateMandateService (572)
#endif

/* ns2__PostdatedTransaction has binding name 'ns2__PostdatedTransaction' for type 'ns2:PostdatedTransaction' */
#ifndef SOAP_TYPE_ns2__PostdatedTransaction
#define SOAP_TYPE_ns2__PostdatedTransaction (571)
#endif

/* ns2__Passenger has binding name 'ns2__Passenger' for type 'ns2:Passenger' */
#ifndef SOAP_TYPE_ns2__Passenger
#define SOAP_TYPE_ns2__Passenger (570)
#endif

/* ns2__APBillingAgreementReply has binding name 'ns2__APBillingAgreementReply' for type 'ns2:APBillingAgreementReply' */
#ifndef SOAP_TYPE_ns2__APBillingAgreementReply
#define SOAP_TYPE_ns2__APBillingAgreementReply (569)
#endif

/* ns2__APBillingAgreementService has binding name 'ns2__APBillingAgreementService' for type 'ns2:APBillingAgreementService' */
#ifndef SOAP_TYPE_ns2__APBillingAgreementService
#define SOAP_TYPE_ns2__APBillingAgreementService (568)
#endif

/* ns2__APCancelReply has binding name 'ns2__APCancelReply' for type 'ns2:APCancelReply' */
#ifndef SOAP_TYPE_ns2__APCancelReply
#define SOAP_TYPE_ns2__APCancelReply (567)
#endif

/* ns2__APCancelService has binding name 'ns2__APCancelService' for type 'ns2:APCancelService' */
#ifndef SOAP_TYPE_ns2__APCancelService
#define SOAP_TYPE_ns2__APCancelService (566)
#endif

/* ns2__APOrderReply has binding name 'ns2__APOrderReply' for type 'ns2:APOrderReply' */
#ifndef SOAP_TYPE_ns2__APOrderReply
#define SOAP_TYPE_ns2__APOrderReply (565)
#endif

/* ns2__APOrderService has binding name 'ns2__APOrderService' for type 'ns2:APOrderService' */
#ifndef SOAP_TYPE_ns2__APOrderService
#define SOAP_TYPE_ns2__APOrderService (564)
#endif

/* ns2__Loan has binding name 'ns2__Loan' for type 'ns2:Loan' */
#ifndef SOAP_TYPE_ns2__Loan
#define SOAP_TYPE_ns2__Loan (563)
#endif

/* ns2__TransactionMetadataService has binding name 'ns2__TransactionMetadataService' for type 'ns2:TransactionMetadataService' */
#ifndef SOAP_TYPE_ns2__TransactionMetadataService
#define SOAP_TYPE_ns2__TransactionMetadataService (562)
#endif

/* ns2__GETVisaCheckoutDataService has binding name 'ns2__GETVisaCheckoutDataService' for type 'ns2:GETVisaCheckoutDataService' */
#ifndef SOAP_TYPE_ns2__GETVisaCheckoutDataService
#define SOAP_TYPE_ns2__GETVisaCheckoutDataService (561)
#endif

/* ns2__issuer has binding name 'ns2__issuer' for type 'ns2:issuer' */
#ifndef SOAP_TYPE_ns2__issuer
#define SOAP_TYPE_ns2__issuer (560)
#endif

/* ns2__BinLookupReply has binding name 'ns2__BinLookupReply' for type 'ns2:BinLookupReply' */
#ifndef SOAP_TYPE_ns2__BinLookupReply
#define SOAP_TYPE_ns2__BinLookupReply (559)
#endif

/* ns2__BinLookupService has binding name 'ns2__BinLookupService' for type 'ns2:BinLookupService' */
#ifndef SOAP_TYPE_ns2__BinLookupService
#define SOAP_TYPE_ns2__BinLookupService (558)
#endif

/* ns2__EncryptPaymentDataReply has binding name 'ns2__EncryptPaymentDataReply' for type 'ns2:EncryptPaymentDataReply' */
#ifndef SOAP_TYPE_ns2__EncryptPaymentDataReply
#define SOAP_TYPE_ns2__EncryptPaymentDataReply (557)
#endif

/* ns2__GetVisaCheckoutDataReply has binding name 'ns2__GetVisaCheckoutDataReply' for type 'ns2:GetVisaCheckoutDataReply' */
#ifndef SOAP_TYPE_ns2__GetVisaCheckoutDataReply
#define SOAP_TYPE_ns2__GetVisaCheckoutDataReply (556)
#endif

/* ns2__DecryptVisaCheckoutDataReply has binding name 'ns2__DecryptVisaCheckoutDataReply' for type 'ns2:DecryptVisaCheckoutDataReply' */
#ifndef SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply
#define SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply (555)
#endif

/* ns2__VCCustomData has binding name 'ns2__VCCustomData' for type 'ns2:VCCustomData' */
#ifndef SOAP_TYPE_ns2__VCCustomData
#define SOAP_TYPE_ns2__VCCustomData (554)
#endif

/* ns2__VCCardArt has binding name 'ns2__VCCardArt' for type 'ns2:VCCardArt' */
#ifndef SOAP_TYPE_ns2__VCCardArt
#define SOAP_TYPE_ns2__VCCardArt (553)
#endif

/* ns2__VCReply has binding name 'ns2__VCReply' for type 'ns2:VCReply' */
#ifndef SOAP_TYPE_ns2__VCReply
#define SOAP_TYPE_ns2__VCReply (552)
#endif

/* ns2__HealthCare has binding name 'ns2__HealthCare' for type 'ns2:HealthCare' */
#ifndef SOAP_TYPE_ns2__HealthCare
#define SOAP_TYPE_ns2__HealthCare (551)
#endif

/* ns2__AgencyInformation has binding name 'ns2__AgencyInformation' for type 'ns2:AgencyInformation' */
#ifndef SOAP_TYPE_ns2__AgencyInformation
#define SOAP_TYPE_ns2__AgencyInformation (550)
#endif

/* ns2__AutoRental has binding name 'ns2__AutoRental' for type 'ns2:AutoRental' */
#ifndef SOAP_TYPE_ns2__AutoRental
#define SOAP_TYPE_ns2__AutoRental (549)
#endif

/* ns2__AutoRentalData has binding name 'ns2__AutoRentalData' for type 'ns2:AutoRentalData' */
#ifndef SOAP_TYPE_ns2__AutoRentalData
#define SOAP_TYPE_ns2__AutoRentalData (548)
#endif

/* ns2__HostedDataRetrieveReply has binding name 'ns2__HostedDataRetrieveReply' for type 'ns2:HostedDataRetrieveReply' */
#ifndef SOAP_TYPE_ns2__HostedDataRetrieveReply
#define SOAP_TYPE_ns2__HostedDataRetrieveReply (547)
#endif

/* ns2__HostedDataCreateReply has binding name 'ns2__HostedDataCreateReply' for type 'ns2:HostedDataCreateReply' */
#ifndef SOAP_TYPE_ns2__HostedDataCreateReply
#define SOAP_TYPE_ns2__HostedDataCreateReply (546)
#endif

/* ns2__HostedDataRetrieveService has binding name 'ns2__HostedDataRetrieveService' for type 'ns2:HostedDataRetrieveService' */
#ifndef SOAP_TYPE_ns2__HostedDataRetrieveService
#define SOAP_TYPE_ns2__HostedDataRetrieveService (545)
#endif

/* ns2__HostedDataCreateService has binding name 'ns2__HostedDataCreateService' for type 'ns2:HostedDataCreateService' */
#ifndef SOAP_TYPE_ns2__HostedDataCreateService
#define SOAP_TYPE_ns2__HostedDataCreateService (544)
#endif

/* ns2__OriginalTransaction has binding name 'ns2__OriginalTransaction' for type 'ns2:OriginalTransaction' */
#ifndef SOAP_TYPE_ns2__OriginalTransaction
#define SOAP_TYPE_ns2__OriginalTransaction (543)
#endif

/* ns2__EmvReply has binding name 'ns2__EmvReply' for type 'ns2:EmvReply' */
#ifndef SOAP_TYPE_ns2__EmvReply
#define SOAP_TYPE_ns2__EmvReply (542)
#endif

/* ns2__EmvRequest has binding name 'ns2__EmvRequest' for type 'ns2:EmvRequest' */
#ifndef SOAP_TYPE_ns2__EmvRequest
#define SOAP_TYPE_ns2__EmvRequest (541)
#endif

/* ns2__ServiceFee has binding name 'ns2__ServiceFee' for type 'ns2:ServiceFee' */
#ifndef SOAP_TYPE_ns2__ServiceFee
#define SOAP_TYPE_ns2__ServiceFee (540)
#endif

/* ns2__CCDCCUpdateService has binding name 'ns2__CCDCCUpdateService' for type 'ns2:CCDCCUpdateService' */
#ifndef SOAP_TYPE_ns2__CCDCCUpdateService
#define SOAP_TYPE_ns2__CCDCCUpdateService (539)
#endif

/* ns2__PaypalTransaction has binding name 'ns2__PaypalTransaction' for type 'ns2:PaypalTransaction' */
#ifndef SOAP_TYPE_ns2__PaypalTransaction
#define SOAP_TYPE_ns2__PaypalTransaction (538)
#endif

/* ns2__PayPalTransactionSearchReply has binding name 'ns2__PayPalTransactionSearchReply' for type 'ns2:PayPalTransactionSearchReply' */
#ifndef SOAP_TYPE_ns2__PayPalTransactionSearchReply
#define SOAP_TYPE_ns2__PayPalTransactionSearchReply (537)
#endif

/* ns2__PayPalGetTxnDetailsReply has binding name 'ns2__PayPalGetTxnDetailsReply' for type 'ns2:PayPalGetTxnDetailsReply' */
#ifndef SOAP_TYPE_ns2__PayPalGetTxnDetailsReply
#define SOAP_TYPE_ns2__PayPalGetTxnDetailsReply (536)
#endif

/* ns2__RequestReserved has binding name 'ns2__RequestReserved' for type 'ns2:RequestReserved' */
#ifndef SOAP_TYPE_ns2__RequestReserved
#define SOAP_TYPE_ns2__RequestReserved (535)
#endif

/* ns2__ReplyReserved has binding name 'ns2__ReplyReserved' for type 'ns2:ReplyReserved' */
#ifndef SOAP_TYPE_ns2__ReplyReserved
#define SOAP_TYPE_ns2__ReplyReserved (534)
#endif

/* ns2__MerchantSecureData has binding name 'ns2__MerchantSecureData' for type 'ns2:MerchantSecureData' */
#ifndef SOAP_TYPE_ns2__MerchantSecureData
#define SOAP_TYPE_ns2__MerchantSecureData (533)
#endif

/* ns2__AuxiliaryData has binding name 'ns2__AuxiliaryData' for type 'ns2:AuxiliaryData' */
#ifndef SOAP_TYPE_ns2__AuxiliaryData
#define SOAP_TYPE_ns2__AuxiliaryData (532)
#endif

/* ns2__AuxiliaryField has binding name 'ns2__AuxiliaryField' for type 'ns2:AuxiliaryField' */
#ifndef SOAP_TYPE_ns2__AuxiliaryField
#define SOAP_TYPE_ns2__AuxiliaryField (531)
#endif

/* ns2__MerchantDefinedData has binding name 'ns2__MerchantDefinedData' for type 'ns2:MerchantDefinedData' */
#ifndef SOAP_TYPE_ns2__MerchantDefinedData
#define SOAP_TYPE_ns2__MerchantDefinedData (530)
#endif

/* ns2__MDDField has binding name 'ns2__MDDField' for type 'ns2:MDDField' */
#ifndef SOAP_TYPE_ns2__MDDField
#define SOAP_TYPE_ns2__MDDField (529)
#endif

/* ns2__Installment has binding name 'ns2__Installment' for type 'ns2:Installment' */
#ifndef SOAP_TYPE_ns2__Installment
#define SOAP_TYPE_ns2__Installment (528)
#endif

/* ns2__EncryptedPayment has binding name 'ns2__EncryptedPayment' for type 'ns2:EncryptedPayment' */
#ifndef SOAP_TYPE_ns2__EncryptedPayment
#define SOAP_TYPE_ns2__EncryptedPayment (527)
#endif

/* ns2__Pin has binding name 'ns2__Pin' for type 'ns2:Pin' */
#ifndef SOAP_TYPE_ns2__Pin
#define SOAP_TYPE_ns2__Pin (526)
#endif

/* ns2__Pos has binding name 'ns2__Pos' for type 'ns2:Pos' */
#ifndef SOAP_TYPE_ns2__Pos
#define SOAP_TYPE_ns2__Pos (525)
#endif

/* ns2__LodgingData has binding name 'ns2__LodgingData' for type 'ns2:LodgingData' */
#ifndef SOAP_TYPE_ns2__LodgingData
#define SOAP_TYPE_ns2__LodgingData (524)
#endif

/* ns2__Service has binding name 'ns2__Service' for type 'ns2:Service' */
#ifndef SOAP_TYPE_ns2__Service
#define SOAP_TYPE_ns2__Service (523)
#endif

/* ns2__AncillaryData has binding name 'ns2__AncillaryData' for type 'ns2:AncillaryData' */
#ifndef SOAP_TYPE_ns2__AncillaryData
#define SOAP_TYPE_ns2__AncillaryData (522)
#endif

/* ns2__Leg has binding name 'ns2__Leg' for type 'ns2:Leg' */
#ifndef SOAP_TYPE_ns2__Leg
#define SOAP_TYPE_ns2__Leg (521)
#endif

/* ns2__AirlineData has binding name 'ns2__AirlineData' for type 'ns2:AirlineData' */
#ifndef SOAP_TYPE_ns2__AirlineData
#define SOAP_TYPE_ns2__AirlineData (520)
#endif

/* ns2__FaultDetails has binding name 'ns2__FaultDetails' for type 'ns2:FaultDetails' */
#ifndef SOAP_TYPE_ns2__FaultDetails
#define SOAP_TYPE_ns2__FaultDetails (519)
#endif

/* ns2__ReplyMessage has binding name 'ns2__ReplyMessage' for type 'ns2:ReplyMessage' */
#ifndef SOAP_TYPE_ns2__ReplyMessage
#define SOAP_TYPE_ns2__ReplyMessage (518)
#endif

/* ns2__CCCheckStatusReply has binding name 'ns2__CCCheckStatusReply' for type 'ns2:CCCheckStatusReply' */
#ifndef SOAP_TYPE_ns2__CCCheckStatusReply
#define SOAP_TYPE_ns2__CCCheckStatusReply (517)
#endif

/* ns2__APSessionsReply has binding name 'ns2__APSessionsReply' for type 'ns2:APSessionsReply' */
#ifndef SOAP_TYPE_ns2__APSessionsReply
#define SOAP_TYPE_ns2__APSessionsReply (516)
#endif

/* ns2__APConfirmPurchaseReply has binding name 'ns2__APConfirmPurchaseReply' for type 'ns2:APConfirmPurchaseReply' */
#ifndef SOAP_TYPE_ns2__APConfirmPurchaseReply
#define SOAP_TYPE_ns2__APConfirmPurchaseReply (515)
#endif

/* ns2__APTransactionDetailsReply has binding name 'ns2__APTransactionDetailsReply' for type 'ns2:APTransactionDetailsReply' */
#ifndef SOAP_TYPE_ns2__APTransactionDetailsReply
#define SOAP_TYPE_ns2__APTransactionDetailsReply (514)
#endif

/* ns2__APCheckOutDetailsReply has binding name 'ns2__APCheckOutDetailsReply' for type 'ns2:APCheckOutDetailsReply' */
#ifndef SOAP_TYPE_ns2__APCheckOutDetailsReply
#define SOAP_TYPE_ns2__APCheckOutDetailsReply (513)
#endif

/* ns2__APSaleReply has binding name 'ns2__APSaleReply' for type 'ns2:APSaleReply' */
#ifndef SOAP_TYPE_ns2__APSaleReply
#define SOAP_TYPE_ns2__APSaleReply (512)
#endif

/* ns2__APRefundReply has binding name 'ns2__APRefundReply' for type 'ns2:APRefundReply' */
#ifndef SOAP_TYPE_ns2__APRefundReply
#define SOAP_TYPE_ns2__APRefundReply (511)
#endif

/* ns2__APOptionsOption has binding name 'ns2__APOptionsOption' for type 'ns2:APOptionsOption' */
#ifndef SOAP_TYPE_ns2__APOptionsOption
#define SOAP_TYPE_ns2__APOptionsOption (510)
#endif

/* ns2__APOptionsReply has binding name 'ns2__APOptionsReply' for type 'ns2:APOptionsReply' */
#ifndef SOAP_TYPE_ns2__APOptionsReply
#define SOAP_TYPE_ns2__APOptionsReply (509)
#endif

/* ns2__APCaptureReply has binding name 'ns2__APCaptureReply' for type 'ns2:APCaptureReply' */
#ifndef SOAP_TYPE_ns2__APCaptureReply
#define SOAP_TYPE_ns2__APCaptureReply (508)
#endif

/* ns2__APAuthReversalReply has binding name 'ns2__APAuthReversalReply' for type 'ns2:APAuthReversalReply' */
#ifndef SOAP_TYPE_ns2__APAuthReversalReply
#define SOAP_TYPE_ns2__APAuthReversalReply (507)
#endif

/* ns2__APAuthReply has binding name 'ns2__APAuthReply' for type 'ns2:APAuthReply' */
#ifndef SOAP_TYPE_ns2__APAuthReply
#define SOAP_TYPE_ns2__APAuthReply (506)
#endif

/* ns2__APReply has binding name 'ns2__APReply' for type 'ns2:APReply' */
#ifndef SOAP_TYPE_ns2__APReply
#define SOAP_TYPE_ns2__APReply (505)
#endif

/* ns2__SellerProtection has binding name 'ns2__SellerProtection' for type 'ns2:SellerProtection' */
#ifndef SOAP_TYPE_ns2__SellerProtection
#define SOAP_TYPE_ns2__SellerProtection (504)
#endif

/* ns2__APCheckStatusReply has binding name 'ns2__APCheckStatusReply' for type 'ns2:APCheckStatusReply' */
#ifndef SOAP_TYPE_ns2__APCheckStatusReply
#define SOAP_TYPE_ns2__APCheckStatusReply (503)
#endif

/* ns2__APInitiateReply has binding name 'ns2__APInitiateReply' for type 'ns2:APInitiateReply' */
#ifndef SOAP_TYPE_ns2__APInitiateReply
#define SOAP_TYPE_ns2__APInitiateReply (502)
#endif

/* ns2__BoletoPaymentReply has binding name 'ns2__BoletoPaymentReply' for type 'ns2:BoletoPaymentReply' */
#ifndef SOAP_TYPE_ns2__BoletoPaymentReply
#define SOAP_TYPE_ns2__BoletoPaymentReply (501)
#endif

/* ns2__ChinaRefundReply has binding name 'ns2__ChinaRefundReply' for type 'ns2:ChinaRefundReply' */
#ifndef SOAP_TYPE_ns2__ChinaRefundReply
#define SOAP_TYPE_ns2__ChinaRefundReply (500)
#endif

/* ns2__ChinaPaymentReply has binding name 'ns2__ChinaPaymentReply' for type 'ns2:ChinaPaymentReply' */
#ifndef SOAP_TYPE_ns2__ChinaPaymentReply
#define SOAP_TYPE_ns2__ChinaPaymentReply (499)
#endif

/* ns2__CCDCCUpdateReply has binding name 'ns2__CCDCCUpdateReply' for type 'ns2:CCDCCUpdateReply' */
#ifndef SOAP_TYPE_ns2__CCDCCUpdateReply
#define SOAP_TYPE_ns2__CCDCCUpdateReply (498)
#endif

/* ns2__paymentCurrencyOffer has binding name 'ns2__paymentCurrencyOffer' for type 'ns2:paymentCurrencyOffer' */
#ifndef SOAP_TYPE_ns2__paymentCurrencyOffer
#define SOAP_TYPE_ns2__paymentCurrencyOffer (497)
#endif

/* ns2__CCDCCReply has binding name 'ns2__CCDCCReply' for type 'ns2:CCDCCReply' */
#ifndef SOAP_TYPE_ns2__CCDCCReply
#define SOAP_TYPE_ns2__CCDCCReply (496)
#endif

/* ns2__ProfileReply has binding name 'ns2__ProfileReply' for type 'ns2:ProfileReply' */
#ifndef SOAP_TYPE_ns2__ProfileReply
#define SOAP_TYPE_ns2__ProfileReply (495)
#endif

/* ns2__DMEReply has binding name 'ns2__DMEReply' for type 'ns2:DMEReply' */
#ifndef SOAP_TYPE_ns2__DMEReply
#define SOAP_TYPE_ns2__DMEReply (494)
#endif

/* ns2__Travel has binding name 'ns2__Travel' for type 'ns2:Travel' */
#ifndef SOAP_TYPE_ns2__Travel
#define SOAP_TYPE_ns2__Travel (493)
#endif

/* ns2__Element has binding name 'ns2__Element' for type 'ns2:Element' */
#ifndef SOAP_TYPE_ns2__Element
#define SOAP_TYPE_ns2__Element (492)
#endif

/* ns2__MorphingElement has binding name 'ns2__MorphingElement' for type 'ns2:MorphingElement' */
#ifndef SOAP_TYPE_ns2__MorphingElement
#define SOAP_TYPE_ns2__MorphingElement (491)
#endif

/* ns2__Field has binding name 'ns2__Field' for type 'ns2:Field' */
#ifndef SOAP_TYPE_ns2__Field
#define SOAP_TYPE_ns2__Field (490)
#endif

/* ns2__AdditionalFields has binding name 'ns2__AdditionalFields' for type 'ns2:AdditionalFields' */
#ifndef SOAP_TYPE_ns2__AdditionalFields
#define SOAP_TYPE_ns2__AdditionalFields (489)
#endif

/* ns2__ProviderField has binding name 'ns2__ProviderField' for type 'ns2:ProviderField' */
#ifndef SOAP_TYPE_ns2__ProviderField
#define SOAP_TYPE_ns2__ProviderField (488)
#endif

/* ns2__Provider has binding name 'ns2__Provider' for type 'ns2:Provider' */
#ifndef SOAP_TYPE_ns2__Provider
#define SOAP_TYPE_ns2__Provider (487)
#endif

/* ns2__ProviderFields has binding name 'ns2__ProviderFields' for type 'ns2:ProviderFields' */
#ifndef SOAP_TYPE_ns2__ProviderFields
#define SOAP_TYPE_ns2__ProviderFields (486)
#endif

/* ns2__DecisionReply has binding name 'ns2__DecisionReply' for type 'ns2:DecisionReply' */
#ifndef SOAP_TYPE_ns2__DecisionReply
#define SOAP_TYPE_ns2__DecisionReply (485)
#endif

/* ns2__RuleResultItems has binding name 'ns2__RuleResultItems' for type 'ns2:RuleResultItems' */
#ifndef SOAP_TYPE_ns2__RuleResultItems
#define SOAP_TYPE_ns2__RuleResultItems (484)
#endif

/* ns2__RuleResultItem has binding name 'ns2__RuleResultItem' for type 'ns2:RuleResultItem' */
#ifndef SOAP_TYPE_ns2__RuleResultItem
#define SOAP_TYPE_ns2__RuleResultItem (483)
#endif

/* ns2__CaseManagementActionReply has binding name 'ns2__CaseManagementActionReply' for type 'ns2:CaseManagementActionReply' */
#ifndef SOAP_TYPE_ns2__CaseManagementActionReply
#define SOAP_TYPE_ns2__CaseManagementActionReply (482)
#endif

/* ns2__FraudUpdateReply has binding name 'ns2__FraudUpdateReply' for type 'ns2:FraudUpdateReply' */
#ifndef SOAP_TYPE_ns2__FraudUpdateReply
#define SOAP_TYPE_ns2__FraudUpdateReply (481)
#endif

/* ns2__RiskUpdateReply has binding name 'ns2__RiskUpdateReply' for type 'ns2:RiskUpdateReply' */
#ifndef SOAP_TYPE_ns2__RiskUpdateReply
#define SOAP_TYPE_ns2__RiskUpdateReply (480)
#endif

/* ns2__PayPalDoRefTransactionReply has binding name 'ns2__PayPalDoRefTransactionReply' for type 'ns2:PayPalDoRefTransactionReply' */
#ifndef SOAP_TYPE_ns2__PayPalDoRefTransactionReply
#define SOAP_TYPE_ns2__PayPalDoRefTransactionReply (479)
#endif

/* ns2__PayPalCreateAgreementReply has binding name 'ns2__PayPalCreateAgreementReply' for type 'ns2:PayPalCreateAgreementReply' */
#ifndef SOAP_TYPE_ns2__PayPalCreateAgreementReply
#define SOAP_TYPE_ns2__PayPalCreateAgreementReply (478)
#endif

/* ns2__PayPalUpdateAgreementReply has binding name 'ns2__PayPalUpdateAgreementReply' for type 'ns2:PayPalUpdateAgreementReply' */
#ifndef SOAP_TYPE_ns2__PayPalUpdateAgreementReply
#define SOAP_TYPE_ns2__PayPalUpdateAgreementReply (477)
#endif

/* ns2__PayPalAuthorizationReply has binding name 'ns2__PayPalAuthorizationReply' for type 'ns2:PayPalAuthorizationReply' */
#ifndef SOAP_TYPE_ns2__PayPalAuthorizationReply
#define SOAP_TYPE_ns2__PayPalAuthorizationReply (476)
#endif

/* ns2__PayPalEcOrderSetupReply has binding name 'ns2__PayPalEcOrderSetupReply' for type 'ns2:PayPalEcOrderSetupReply' */
#ifndef SOAP_TYPE_ns2__PayPalEcOrderSetupReply
#define SOAP_TYPE_ns2__PayPalEcOrderSetupReply (475)
#endif

/* ns2__PayPalRefundReply has binding name 'ns2__PayPalRefundReply' for type 'ns2:PayPalRefundReply' */
#ifndef SOAP_TYPE_ns2__PayPalRefundReply
#define SOAP_TYPE_ns2__PayPalRefundReply (474)
#endif

/* ns2__PayPalAuthReversalReply has binding name 'ns2__PayPalAuthReversalReply' for type 'ns2:PayPalAuthReversalReply' */
#ifndef SOAP_TYPE_ns2__PayPalAuthReversalReply
#define SOAP_TYPE_ns2__PayPalAuthReversalReply (473)
#endif

/* ns2__PayPalDoCaptureReply has binding name 'ns2__PayPalDoCaptureReply' for type 'ns2:PayPalDoCaptureReply' */
#ifndef SOAP_TYPE_ns2__PayPalDoCaptureReply
#define SOAP_TYPE_ns2__PayPalDoCaptureReply (472)
#endif

/* ns2__PayPalEcDoPaymentReply has binding name 'ns2__PayPalEcDoPaymentReply' for type 'ns2:PayPalEcDoPaymentReply' */
#ifndef SOAP_TYPE_ns2__PayPalEcDoPaymentReply
#define SOAP_TYPE_ns2__PayPalEcDoPaymentReply (471)
#endif

/* ns2__PayPalEcGetDetailsReply has binding name 'ns2__PayPalEcGetDetailsReply' for type 'ns2:PayPalEcGetDetailsReply' */
#ifndef SOAP_TYPE_ns2__PayPalEcGetDetailsReply
#define SOAP_TYPE_ns2__PayPalEcGetDetailsReply (470)
#endif

/* ns2__PayPalEcSetReply has binding name 'ns2__PayPalEcSetReply' for type 'ns2:PayPalEcSetReply' */
#ifndef SOAP_TYPE_ns2__PayPalEcSetReply
#define SOAP_TYPE_ns2__PayPalEcSetReply (469)
#endif

/* ns2__PayPalPreapprovedUpdateReply has binding name 'ns2__PayPalPreapprovedUpdateReply' for type 'ns2:PayPalPreapprovedUpdateReply' */
#ifndef SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply
#define SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply (468)
#endif

/* ns2__PayPalPreapprovedPaymentReply has binding name 'ns2__PayPalPreapprovedPaymentReply' for type 'ns2:PayPalPreapprovedPaymentReply' */
#ifndef SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply
#define SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply (467)
#endif

/* ns2__PayPalButtonCreateReply has binding name 'ns2__PayPalButtonCreateReply' for type 'ns2:PayPalButtonCreateReply' */
#ifndef SOAP_TYPE_ns2__PayPalButtonCreateReply
#define SOAP_TYPE_ns2__PayPalButtonCreateReply (466)
#endif

/* ns2__PinlessDebitReversalReply has binding name 'ns2__PinlessDebitReversalReply' for type 'ns2:PinlessDebitReversalReply' */
#ifndef SOAP_TYPE_ns2__PinlessDebitReversalReply
#define SOAP_TYPE_ns2__PinlessDebitReversalReply (465)
#endif

/* ns2__PinlessDebitValidateReply has binding name 'ns2__PinlessDebitValidateReply' for type 'ns2:PinlessDebitValidateReply' */
#ifndef SOAP_TYPE_ns2__PinlessDebitValidateReply
#define SOAP_TYPE_ns2__PinlessDebitValidateReply (464)
#endif

/* ns2__PinlessDebitReply has binding name 'ns2__PinlessDebitReply' for type 'ns2:PinlessDebitReply' */
#ifndef SOAP_TYPE_ns2__PinlessDebitReply
#define SOAP_TYPE_ns2__PinlessDebitReply (463)
#endif

/* ns2__VoidReply has binding name 'ns2__VoidReply' for type 'ns2:VoidReply' */
#ifndef SOAP_TYPE_ns2__VoidReply
#define SOAP_TYPE_ns2__VoidReply (462)
#endif

/* ns2__PayPalCreditReply has binding name 'ns2__PayPalCreditReply' for type 'ns2:PayPalCreditReply' */
#ifndef SOAP_TYPE_ns2__PayPalCreditReply
#define SOAP_TYPE_ns2__PayPalCreditReply (461)
#endif

/* ns2__PayPalPaymentReply has binding name 'ns2__PayPalPaymentReply' for type 'ns2:PayPalPaymentReply' */
#ifndef SOAP_TYPE_ns2__PayPalPaymentReply
#define SOAP_TYPE_ns2__PayPalPaymentReply (460)
#endif

/* ns2__PaySubscriptionDeleteReply has binding name 'ns2__PaySubscriptionDeleteReply' for type 'ns2:PaySubscriptionDeleteReply' */
#ifndef SOAP_TYPE_ns2__PaySubscriptionDeleteReply
#define SOAP_TYPE_ns2__PaySubscriptionDeleteReply (459)
#endif

/* ns2__PaySubscriptionRetrieveReply has binding name 'ns2__PaySubscriptionRetrieveReply' for type 'ns2:PaySubscriptionRetrieveReply' */
#ifndef SOAP_TYPE_ns2__PaySubscriptionRetrieveReply
#define SOAP_TYPE_ns2__PaySubscriptionRetrieveReply (458)
#endif

/* ns2__PaySubscriptionEventUpdateReply has binding name 'ns2__PaySubscriptionEventUpdateReply' for type 'ns2:PaySubscriptionEventUpdateReply' */
#ifndef SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply
#define SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply (457)
#endif

/* ns2__PaySubscriptionUpdateReply has binding name 'ns2__PaySubscriptionUpdateReply' for type 'ns2:PaySubscriptionUpdateReply' */
#ifndef SOAP_TYPE_ns2__PaySubscriptionUpdateReply
#define SOAP_TYPE_ns2__PaySubscriptionUpdateReply (456)
#endif

/* ns2__PaySubscriptionCreateReply has binding name 'ns2__PaySubscriptionCreateReply' for type 'ns2:PaySubscriptionCreateReply' */
#ifndef SOAP_TYPE_ns2__PaySubscriptionCreateReply
#define SOAP_TYPE_ns2__PaySubscriptionCreateReply (455)
#endif

/* ns2__DirectDebitRefundReply has binding name 'ns2__DirectDebitRefundReply' for type 'ns2:DirectDebitRefundReply' */
#ifndef SOAP_TYPE_ns2__DirectDebitRefundReply
#define SOAP_TYPE_ns2__DirectDebitRefundReply (454)
#endif

/* ns2__DirectDebitValidateReply has binding name 'ns2__DirectDebitValidateReply' for type 'ns2:DirectDebitValidateReply' */
#ifndef SOAP_TYPE_ns2__DirectDebitValidateReply
#define SOAP_TYPE_ns2__DirectDebitValidateReply (453)
#endif

/* ns2__DirectDebitReply has binding name 'ns2__DirectDebitReply' for type 'ns2:DirectDebitReply' */
#ifndef SOAP_TYPE_ns2__DirectDebitReply
#define SOAP_TYPE_ns2__DirectDebitReply (452)
#endif

/* ns2__BankTransferRefundReply has binding name 'ns2__BankTransferRefundReply' for type 'ns2:BankTransferRefundReply' */
#ifndef SOAP_TYPE_ns2__BankTransferRefundReply
#define SOAP_TYPE_ns2__BankTransferRefundReply (451)
#endif

/* ns2__DirectDebitMandateReply has binding name 'ns2__DirectDebitMandateReply' for type 'ns2:DirectDebitMandateReply' */
#ifndef SOAP_TYPE_ns2__DirectDebitMandateReply
#define SOAP_TYPE_ns2__DirectDebitMandateReply (450)
#endif

/* ns2__BankTransferRealTimeReply has binding name 'ns2__BankTransferRealTimeReply' for type 'ns2:BankTransferRealTimeReply' */
#ifndef SOAP_TYPE_ns2__BankTransferRealTimeReply
#define SOAP_TYPE_ns2__BankTransferRealTimeReply (449)
#endif

/* ns2__BankTransferReply has binding name 'ns2__BankTransferReply' for type 'ns2:BankTransferReply' */
#ifndef SOAP_TYPE_ns2__BankTransferReply
#define SOAP_TYPE_ns2__BankTransferReply (448)
#endif

/* ns2__FXRatesReply has binding name 'ns2__FXRatesReply' for type 'ns2:FXRatesReply' */
#ifndef SOAP_TYPE_ns2__FXRatesReply
#define SOAP_TYPE_ns2__FXRatesReply (447)
#endif

/* ns2__FXQuote has binding name 'ns2__FXQuote' for type 'ns2:FXQuote' */
#ifndef SOAP_TYPE_ns2__FXQuote
#define SOAP_TYPE_ns2__FXQuote (446)
#endif

/* ns2__ExportReply has binding name 'ns2__ExportReply' for type 'ns2:ExportReply' */
#ifndef SOAP_TYPE_ns2__ExportReply
#define SOAP_TYPE_ns2__ExportReply (445)
#endif

/* ns2__DeniedPartiesMatch has binding name 'ns2__DeniedPartiesMatch' for type 'ns2:DeniedPartiesMatch' */
#ifndef SOAP_TYPE_ns2__DeniedPartiesMatch
#define SOAP_TYPE_ns2__DeniedPartiesMatch (444)
#endif

/* ns2__DAVReply has binding name 'ns2__DAVReply' for type 'ns2:DAVReply' */
#ifndef SOAP_TYPE_ns2__DAVReply
#define SOAP_TYPE_ns2__DAVReply (443)
#endif

/* ns2__AFSReply has binding name 'ns2__AFSReply' for type 'ns2:AFSReply' */
#ifndef SOAP_TYPE_ns2__AFSReply
#define SOAP_TYPE_ns2__AFSReply (442)
#endif

/* ns2__DeviceFingerprint has binding name 'ns2__DeviceFingerprint' for type 'ns2:DeviceFingerprint' */
#ifndef SOAP_TYPE_ns2__DeviceFingerprint
#define SOAP_TYPE_ns2__DeviceFingerprint (441)
#endif

/* ns2__TaxReply has binding name 'ns2__TaxReply' for type 'ns2:TaxReply' */
#ifndef SOAP_TYPE_ns2__TaxReply
#define SOAP_TYPE_ns2__TaxReply (440)
#endif

/* ns2__TaxReplyItemJurisdiction has binding name 'ns2__TaxReplyItemJurisdiction' for type 'ns2:TaxReplyItemJurisdiction' */
#ifndef SOAP_TYPE_ns2__TaxReplyItemJurisdiction
#define SOAP_TYPE_ns2__TaxReplyItemJurisdiction (439)
#endif

/* ns2__TaxReplyItem has binding name 'ns2__TaxReplyItem' for type 'ns2:TaxReplyItem' */
#ifndef SOAP_TYPE_ns2__TaxReplyItem
#define SOAP_TYPE_ns2__TaxReplyItem (438)
#endif

/* ns2__PayerAuthValidateReply has binding name 'ns2__PayerAuthValidateReply' for type 'ns2:PayerAuthValidateReply' */
#ifndef SOAP_TYPE_ns2__PayerAuthValidateReply
#define SOAP_TYPE_ns2__PayerAuthValidateReply (437)
#endif

/* ns2__PayerAuthEnrollReply has binding name 'ns2__PayerAuthEnrollReply' for type 'ns2:PayerAuthEnrollReply' */
#ifndef SOAP_TYPE_ns2__PayerAuthEnrollReply
#define SOAP_TYPE_ns2__PayerAuthEnrollReply (436)
#endif

/* ns2__PayerAuthSetupReply has binding name 'ns2__PayerAuthSetupReply' for type 'ns2:PayerAuthSetupReply' */
#ifndef SOAP_TYPE_ns2__PayerAuthSetupReply
#define SOAP_TYPE_ns2__PayerAuthSetupReply (435)
#endif

/* ns2__ECAuthenticateReply has binding name 'ns2__ECAuthenticateReply' for type 'ns2:ECAuthenticateReply' */
#ifndef SOAP_TYPE_ns2__ECAuthenticateReply
#define SOAP_TYPE_ns2__ECAuthenticateReply (434)
#endif

/* ns2__ECCreditReply has binding name 'ns2__ECCreditReply' for type 'ns2:ECCreditReply' */
#ifndef SOAP_TYPE_ns2__ECCreditReply
#define SOAP_TYPE_ns2__ECCreditReply (433)
#endif

/* ns2__ECDebitReply has binding name 'ns2__ECDebitReply' for type 'ns2:ECDebitReply' */
#ifndef SOAP_TYPE_ns2__ECDebitReply
#define SOAP_TYPE_ns2__ECDebitReply (432)
#endif

/* ns2__ECAVSReply has binding name 'ns2__ECAVSReply' for type 'ns2:ECAVSReply' */
#ifndef SOAP_TYPE_ns2__ECAVSReply
#define SOAP_TYPE_ns2__ECAVSReply (431)
#endif

/* ns2__CCAutoAuthReversalReply has binding name 'ns2__CCAutoAuthReversalReply' for type 'ns2:CCAutoAuthReversalReply' */
#ifndef SOAP_TYPE_ns2__CCAutoAuthReversalReply
#define SOAP_TYPE_ns2__CCAutoAuthReversalReply (430)
#endif

/* ns2__CCAuthReversalReply has binding name 'ns2__CCAuthReversalReply' for type 'ns2:CCAuthReversalReply' */
#ifndef SOAP_TYPE_ns2__CCAuthReversalReply
#define SOAP_TYPE_ns2__CCAuthReversalReply (429)
#endif

/* ns2__PinDebitReversalReply has binding name 'ns2__PinDebitReversalReply' for type 'ns2:PinDebitReversalReply' */
#ifndef SOAP_TYPE_ns2__PinDebitReversalReply
#define SOAP_TYPE_ns2__PinDebitReversalReply (428)
#endif

/* ns2__PinDebitCreditReply has binding name 'ns2__PinDebitCreditReply' for type 'ns2:PinDebitCreditReply' */
#ifndef SOAP_TYPE_ns2__PinDebitCreditReply
#define SOAP_TYPE_ns2__PinDebitCreditReply (427)
#endif

/* ns2__PinDebitPurchaseReply has binding name 'ns2__PinDebitPurchaseReply' for type 'ns2:PinDebitPurchaseReply' */
#ifndef SOAP_TYPE_ns2__PinDebitPurchaseReply
#define SOAP_TYPE_ns2__PinDebitPurchaseReply (426)
#endif

/* ns2__CCCreditReply has binding name 'ns2__CCCreditReply' for type 'ns2:CCCreditReply' */
#ifndef SOAP_TYPE_ns2__CCCreditReply
#define SOAP_TYPE_ns2__CCCreditReply (425)
#endif

/* ns2__ServiceFeeCalculateReply has binding name 'ns2__ServiceFeeCalculateReply' for type 'ns2:ServiceFeeCalculateReply' */
#ifndef SOAP_TYPE_ns2__ServiceFeeCalculateReply
#define SOAP_TYPE_ns2__ServiceFeeCalculateReply (424)
#endif

/* ns2__CCCaptureReply has binding name 'ns2__CCCaptureReply' for type 'ns2:CCCaptureReply' */
#ifndef SOAP_TYPE_ns2__CCCaptureReply
#define SOAP_TYPE_ns2__CCCaptureReply (423)
#endif

/* ns2__CCIncrementalAuthReply has binding name 'ns2__CCIncrementalAuthReply' for type 'ns2:CCIncrementalAuthReply' */
#ifndef SOAP_TYPE_ns2__CCIncrementalAuthReply
#define SOAP_TYPE_ns2__CCIncrementalAuthReply (422)
#endif

/* ns2__CCSaleReversalReply has binding name 'ns2__CCSaleReversalReply' for type 'ns2:CCSaleReversalReply' */
#ifndef SOAP_TYPE_ns2__CCSaleReversalReply
#define SOAP_TYPE_ns2__CCSaleReversalReply (421)
#endif

/* ns2__CCSaleCreditReply has binding name 'ns2__CCSaleCreditReply' for type 'ns2:CCSaleCreditReply' */
#ifndef SOAP_TYPE_ns2__CCSaleCreditReply
#define SOAP_TYPE_ns2__CCSaleCreditReply (420)
#endif

/* ns2__CCSaleReply has binding name 'ns2__CCSaleReply' for type 'ns2:CCSaleReply' */
#ifndef SOAP_TYPE_ns2__CCSaleReply
#define SOAP_TYPE_ns2__CCSaleReply (419)
#endif

/* ns2__VerificationReply has binding name 'ns2__VerificationReply' for type 'ns2:VerificationReply' */
#ifndef SOAP_TYPE_ns2__VerificationReply
#define SOAP_TYPE_ns2__VerificationReply (418)
#endif

/* ns2__OCTReply has binding name 'ns2__OCTReply' for type 'ns2:OCTReply' */
#ifndef SOAP_TYPE_ns2__OCTReply
#define SOAP_TYPE_ns2__OCTReply (417)
#endif

/* ns2__CCAuthReply has binding name 'ns2__CCAuthReply' for type 'ns2:CCAuthReply' */
#ifndef SOAP_TYPE_ns2__CCAuthReply
#define SOAP_TYPE_ns2__CCAuthReply (416)
#endif

/* ns2__BalanceInfo has binding name 'ns2__BalanceInfo' for type 'ns2:BalanceInfo' */
#ifndef SOAP_TYPE_ns2__BalanceInfo
#define SOAP_TYPE_ns2__BalanceInfo (415)
#endif

/* ns2__PromotionGroupReply has binding name 'ns2__PromotionGroupReply' for type 'ns2:PromotionGroupReply' */
#ifndef SOAP_TYPE_ns2__PromotionGroupReply
#define SOAP_TYPE_ns2__PromotionGroupReply (414)
#endif

/* ns2__PromotionGroup has binding name 'ns2__PromotionGroup' for type 'ns2:PromotionGroup' */
#ifndef SOAP_TYPE_ns2__PromotionGroup
#define SOAP_TYPE_ns2__PromotionGroup (413)
#endif

/* ns2__Promotion has binding name 'ns2__Promotion' for type 'ns2:Promotion' */
#ifndef SOAP_TYPE_ns2__Promotion
#define SOAP_TYPE_ns2__Promotion (412)
#endif

/* ns2__DCC has binding name 'ns2__DCC' for type 'ns2:DCC' */
#ifndef SOAP_TYPE_ns2__DCC
#define SOAP_TYPE_ns2__DCC (411)
#endif

/* ns2__DecryptVisaCheckoutDataService has binding name 'ns2__DecryptVisaCheckoutDataService' for type 'ns2:DecryptVisaCheckoutDataService' */
#ifndef SOAP_TYPE_ns2__DecryptVisaCheckoutDataService
#define SOAP_TYPE_ns2__DecryptVisaCheckoutDataService (410)
#endif

/* ns2__VC has binding name 'ns2__VC' for type 'ns2:VC' */
#ifndef SOAP_TYPE_ns2__VC
#define SOAP_TYPE_ns2__VC (409)
#endif

/* ns2__RequestMessage has binding name 'ns2__RequestMessage' for type 'ns2:RequestMessage' */
#ifndef SOAP_TYPE_ns2__RequestMessage
#define SOAP_TYPE_ns2__RequestMessage (408)
#endif

/* ns2__CCCheckStatusService has binding name 'ns2__CCCheckStatusService' for type 'ns2:CCCheckStatusService' */
#ifndef SOAP_TYPE_ns2__CCCheckStatusService
#define SOAP_TYPE_ns2__CCCheckStatusService (407)
#endif

/* ns2__Sender has binding name 'ns2__Sender' for type 'ns2:Sender' */
#ifndef SOAP_TYPE_ns2__Sender
#define SOAP_TYPE_ns2__Sender (406)
#endif

/* ns2__Recipient has binding name 'ns2__Recipient' for type 'ns2:Recipient' */
#ifndef SOAP_TYPE_ns2__Recipient
#define SOAP_TYPE_ns2__Recipient (405)
#endif

/* ns2__PayPalTransactionSearchService has binding name 'ns2__PayPalTransactionSearchService' for type 'ns2:PayPalTransactionSearchService' */
#ifndef SOAP_TYPE_ns2__PayPalTransactionSearchService
#define SOAP_TYPE_ns2__PayPalTransactionSearchService (404)
#endif

/* ns2__PayPalGetTxnDetailsService has binding name 'ns2__PayPalGetTxnDetailsService' for type 'ns2:PayPalGetTxnDetailsService' */
#ifndef SOAP_TYPE_ns2__PayPalGetTxnDetailsService
#define SOAP_TYPE_ns2__PayPalGetTxnDetailsService (403)
#endif

/* ns2__APUI has binding name 'ns2__APUI' for type 'ns2:APUI' */
#ifndef SOAP_TYPE_ns2__APUI
#define SOAP_TYPE_ns2__APUI (402)
#endif

/* ns2__APSessionsService has binding name 'ns2__APSessionsService' for type 'ns2:APSessionsService' */
#ifndef SOAP_TYPE_ns2__APSessionsService
#define SOAP_TYPE_ns2__APSessionsService (401)
#endif

/* ns2__APConfirmPurchaseService has binding name 'ns2__APConfirmPurchaseService' for type 'ns2:APConfirmPurchaseService' */
#ifndef SOAP_TYPE_ns2__APConfirmPurchaseService
#define SOAP_TYPE_ns2__APConfirmPurchaseService (400)
#endif

/* ns2__APTransactionDetailsService has binding name 'ns2__APTransactionDetailsService' for type 'ns2:APTransactionDetailsService' */
#ifndef SOAP_TYPE_ns2__APTransactionDetailsService
#define SOAP_TYPE_ns2__APTransactionDetailsService (399)
#endif

/* ns2__APCheckOutDetailsService has binding name 'ns2__APCheckOutDetailsService' for type 'ns2:APCheckOutDetailsService' */
#ifndef SOAP_TYPE_ns2__APCheckOutDetailsService
#define SOAP_TYPE_ns2__APCheckOutDetailsService (398)
#endif

/* ns2__APSaleService has binding name 'ns2__APSaleService' for type 'ns2:APSaleService' */
#ifndef SOAP_TYPE_ns2__APSaleService
#define SOAP_TYPE_ns2__APSaleService (397)
#endif

/* ns2__APRefundService has binding name 'ns2__APRefundService' for type 'ns2:APRefundService' */
#ifndef SOAP_TYPE_ns2__APRefundService
#define SOAP_TYPE_ns2__APRefundService (396)
#endif

/* ns2__APOptionsService has binding name 'ns2__APOptionsService' for type 'ns2:APOptionsService' */
#ifndef SOAP_TYPE_ns2__APOptionsService
#define SOAP_TYPE_ns2__APOptionsService (395)
#endif

/* ns2__APCaptureService has binding name 'ns2__APCaptureService' for type 'ns2:APCaptureService' */
#ifndef SOAP_TYPE_ns2__APCaptureService
#define SOAP_TYPE_ns2__APCaptureService (394)
#endif

/* ns2__APAuthReversalService has binding name 'ns2__APAuthReversalService' for type 'ns2:APAuthReversalService' */
#ifndef SOAP_TYPE_ns2__APAuthReversalService
#define SOAP_TYPE_ns2__APAuthReversalService (393)
#endif

/* ns2__APImportMandateService has binding name 'ns2__APImportMandateService' for type 'ns2:APImportMandateService' */
#ifndef SOAP_TYPE_ns2__APImportMandateService
#define SOAP_TYPE_ns2__APImportMandateService (392)
#endif

/* ns2__APAuthService has binding name 'ns2__APAuthService' for type 'ns2:APAuthService' */
#ifndef SOAP_TYPE_ns2__APAuthService
#define SOAP_TYPE_ns2__APAuthService (391)
#endif

/* ns2__APDevice has binding name 'ns2__APDevice' for type 'ns2:APDevice' */
#ifndef SOAP_TYPE_ns2__APDevice
#define SOAP_TYPE_ns2__APDevice (390)
#endif

/* ns2__AP has binding name 'ns2__AP' for type 'ns2:AP' */
#ifndef SOAP_TYPE_ns2__AP
#define SOAP_TYPE_ns2__AP (389)
#endif

/* ns2__Token has binding name 'ns2__Token' for type 'ns2:Token' */
#ifndef SOAP_TYPE_ns2__Token
#define SOAP_TYPE_ns2__Token (388)
#endif

/* ns2__JPO has binding name 'ns2__JPO' for type 'ns2:JPO' */
#ifndef SOAP_TYPE_ns2__JPO
#define SOAP_TYPE_ns2__JPO (387)
#endif

/* ns2__PayPal has binding name 'ns2__PayPal' for type 'ns2:PayPal' */
#ifndef SOAP_TYPE_ns2__PayPal
#define SOAP_TYPE_ns2__PayPal (386)
#endif

/* ns2__Batch has binding name 'ns2__Batch' for type 'ns2:Batch' */
#ifndef SOAP_TYPE_ns2__Batch
#define SOAP_TYPE_ns2__Batch (385)
#endif

/* ns2__DecisionManagerTravelLeg has binding name 'ns2__DecisionManagerTravelLeg' for type 'ns2:DecisionManagerTravelLeg' */
#ifndef SOAP_TYPE_ns2__DecisionManagerTravelLeg
#define SOAP_TYPE_ns2__DecisionManagerTravelLeg (384)
#endif

/* ns2__DecisionManagerTravelData has binding name 'ns2__DecisionManagerTravelData' for type 'ns2:DecisionManagerTravelData' */
#ifndef SOAP_TYPE_ns2__DecisionManagerTravelData
#define SOAP_TYPE_ns2__DecisionManagerTravelData (383)
#endif

/* ns2__Authentication has binding name 'ns2__Authentication' for type 'ns2:Authentication' */
#ifndef SOAP_TYPE_ns2__Authentication
#define SOAP_TYPE_ns2__Authentication (382)
#endif

/* ns2__DecisionManager has binding name 'ns2__DecisionManager' for type 'ns2:DecisionManager' */
#ifndef SOAP_TYPE_ns2__DecisionManager
#define SOAP_TYPE_ns2__DecisionManager (381)
#endif

/* ns2__PaymentNetworkToken has binding name 'ns2__PaymentNetworkToken' for type 'ns2:PaymentNetworkToken' */
#ifndef SOAP_TYPE_ns2__PaymentNetworkToken
#define SOAP_TYPE_ns2__PaymentNetworkToken (380)
#endif

/* ns2__TokenSource has binding name 'ns2__TokenSource' for type 'ns2:TokenSource' */
#ifndef SOAP_TYPE_ns2__TokenSource
#define SOAP_TYPE_ns2__TokenSource (379)
#endif

/* ns2__Subscription has binding name 'ns2__Subscription' for type 'ns2:Subscription' */
#ifndef SOAP_TYPE_ns2__Subscription
#define SOAP_TYPE_ns2__Subscription (378)
#endif

/* ns2__PaySubscriptionEvent has binding name 'ns2__PaySubscriptionEvent' for type 'ns2:PaySubscriptionEvent' */
#ifndef SOAP_TYPE_ns2__PaySubscriptionEvent
#define SOAP_TYPE_ns2__PaySubscriptionEvent (377)
#endif

/* ns2__RecurringSubscriptionInfo has binding name 'ns2__RecurringSubscriptionInfo' for type 'ns2:RecurringSubscriptionInfo' */
#ifndef SOAP_TYPE_ns2__RecurringSubscriptionInfo
#define SOAP_TYPE_ns2__RecurringSubscriptionInfo (376)
#endif

/* ns2__BankInfo has binding name 'ns2__BankInfo' for type 'ns2:BankInfo' */
#ifndef SOAP_TYPE_ns2__BankInfo
#define SOAP_TYPE_ns2__BankInfo (375)
#endif

/* ns2__FundTransfer has binding name 'ns2__FundTransfer' for type 'ns2:FundTransfer' */
#ifndef SOAP_TYPE_ns2__FundTransfer
#define SOAP_TYPE_ns2__FundTransfer (374)
#endif

/* ns2__Brands has binding name 'ns2__Brands' for type 'ns2:Brands' */
#ifndef SOAP_TYPE_ns2__Brands
#define SOAP_TYPE_ns2__Brands (373)
#endif

/* ns2__Network has binding name 'ns2__Network' for type 'ns2:Network' */
#ifndef SOAP_TYPE_ns2__Network
#define SOAP_TYPE_ns2__Network (372)
#endif

/* ns2__UCAF has binding name 'ns2__UCAF' for type 'ns2:UCAF' */
#ifndef SOAP_TYPE_ns2__UCAF
#define SOAP_TYPE_ns2__UCAF (371)
#endif

/* ns2__GECC has binding name 'ns2__GECC' for type 'ns2:GECC' */
#ifndef SOAP_TYPE_ns2__GECC
#define SOAP_TYPE_ns2__GECC (370)
#endif

/* ns2__FundingTotals has binding name 'ns2__FundingTotals' for type 'ns2:FundingTotals' */
#ifndef SOAP_TYPE_ns2__FundingTotals
#define SOAP_TYPE_ns2__FundingTotals (369)
#endif

/* ns2__PurchaseTotals has binding name 'ns2__PurchaseTotals' for type 'ns2:PurchaseTotals' */
#ifndef SOAP_TYPE_ns2__PurchaseTotals
#define SOAP_TYPE_ns2__PurchaseTotals (368)
#endif

/* ns2__Wallet has binding name 'ns2__Wallet' for type 'ns2:Wallet' */
#ifndef SOAP_TYPE_ns2__Wallet
#define SOAP_TYPE_ns2__Wallet (367)
#endif

/* ns2__Aft has binding name 'ns2__Aft' for type 'ns2:Aft' */
#ifndef SOAP_TYPE_ns2__Aft
#define SOAP_TYPE_ns2__Aft (366)
#endif

/* ns2__OtherTax has binding name 'ns2__OtherTax' for type 'ns2:OtherTax' */
#ifndef SOAP_TYPE_ns2__OtherTax
#define SOAP_TYPE_ns2__OtherTax (365)
#endif

/* ns2__BML has binding name 'ns2__BML' for type 'ns2:BML' */
#ifndef SOAP_TYPE_ns2__BML
#define SOAP_TYPE_ns2__BML (364)
#endif

/* ns2__Check has binding name 'ns2__Check' for type 'ns2:Check' */
#ifndef SOAP_TYPE_ns2__Check
#define SOAP_TYPE_ns2__Check (363)
#endif

/* ns2__Card has binding name 'ns2__Card' for type 'ns2:Card' */
#ifndef SOAP_TYPE_ns2__Card
#define SOAP_TYPE_ns2__Card (362)
#endif

/* ns2__ShipFrom has binding name 'ns2__ShipFrom' for type 'ns2:ShipFrom' */
#ifndef SOAP_TYPE_ns2__ShipFrom
#define SOAP_TYPE_ns2__ShipFrom (361)
#endif

/* ns2__ShipTo has binding name 'ns2__ShipTo' for type 'ns2:ShipTo' */
#ifndef SOAP_TYPE_ns2__ShipTo
#define SOAP_TYPE_ns2__ShipTo (360)
#endif

/* ns2__BillTo has binding name 'ns2__BillTo' for type 'ns2:BillTo' */
#ifndef SOAP_TYPE_ns2__BillTo
#define SOAP_TYPE_ns2__BillTo (359)
#endif

/* ns2__BusinessRules has binding name 'ns2__BusinessRules' for type 'ns2:BusinessRules' */
#ifndef SOAP_TYPE_ns2__BusinessRules
#define SOAP_TYPE_ns2__BusinessRules (358)
#endif

/* ns2__InvoiceHeader has binding name 'ns2__InvoiceHeader' for type 'ns2:InvoiceHeader' */
#ifndef SOAP_TYPE_ns2__InvoiceHeader
#define SOAP_TYPE_ns2__InvoiceHeader (357)
#endif

/* ns2__EncryptPaymentDataService has binding name 'ns2__EncryptPaymentDataService' for type 'ns2:EncryptPaymentDataService' */
#ifndef SOAP_TYPE_ns2__EncryptPaymentDataService
#define SOAP_TYPE_ns2__EncryptPaymentDataService (356)
#endif

/* ns2__CaseManagementActionService has binding name 'ns2__CaseManagementActionService' for type 'ns2:CaseManagementActionService' */
#ifndef SOAP_TYPE_ns2__CaseManagementActionService
#define SOAP_TYPE_ns2__CaseManagementActionService (355)
#endif

/* ns2__FraudUpdateService has binding name 'ns2__FraudUpdateService' for type 'ns2:FraudUpdateService' */
#ifndef SOAP_TYPE_ns2__FraudUpdateService
#define SOAP_TYPE_ns2__FraudUpdateService (354)
#endif

/* ns2__RiskUpdateService has binding name 'ns2__RiskUpdateService' for type 'ns2:RiskUpdateService' */
#ifndef SOAP_TYPE_ns2__RiskUpdateService
#define SOAP_TYPE_ns2__RiskUpdateService (353)
#endif

/* ns2__APCheckStatusService has binding name 'ns2__APCheckStatusService' for type 'ns2:APCheckStatusService' */
#ifndef SOAP_TYPE_ns2__APCheckStatusService
#define SOAP_TYPE_ns2__APCheckStatusService (352)
#endif

/* ns2__APInitiateService has binding name 'ns2__APInitiateService' for type 'ns2:APInitiateService' */
#ifndef SOAP_TYPE_ns2__APInitiateService
#define SOAP_TYPE_ns2__APInitiateService (351)
#endif

/* ns2__Address has binding name 'ns2__Address' for type 'ns2:Address' */
#ifndef SOAP_TYPE_ns2__Address
#define SOAP_TYPE_ns2__Address (350)
#endif

/* ns2__Routing has binding name 'ns2__Routing' for type 'ns2:Routing' */
#ifndef SOAP_TYPE_ns2__Routing
#define SOAP_TYPE_ns2__Routing (349)
#endif

/* ns2__PersonalID has binding name 'ns2__PersonalID' for type 'ns2:PersonalID' */
#ifndef SOAP_TYPE_ns2__PersonalID
#define SOAP_TYPE_ns2__PersonalID (348)
#endif

/* ns2__BoletoPaymentService has binding name 'ns2__BoletoPaymentService' for type 'ns2:BoletoPaymentService' */
#ifndef SOAP_TYPE_ns2__BoletoPaymentService
#define SOAP_TYPE_ns2__BoletoPaymentService (347)
#endif

/* ns2__ChinaRefundService has binding name 'ns2__ChinaRefundService' for type 'ns2:ChinaRefundService' */
#ifndef SOAP_TYPE_ns2__ChinaRefundService
#define SOAP_TYPE_ns2__ChinaRefundService (346)
#endif

/* ns2__ChinaPaymentService has binding name 'ns2__ChinaPaymentService' for type 'ns2:ChinaPaymentService' */
#ifndef SOAP_TYPE_ns2__ChinaPaymentService
#define SOAP_TYPE_ns2__ChinaPaymentService (345)
#endif

/* ns2__PayPalPreapprovedUpdateService has binding name 'ns2__PayPalPreapprovedUpdateService' for type 'ns2:PayPalPreapprovedUpdateService' */
#ifndef SOAP_TYPE_ns2__PayPalPreapprovedUpdateService
#define SOAP_TYPE_ns2__PayPalPreapprovedUpdateService (344)
#endif

/* ns2__PayPalPreapprovedPaymentService has binding name 'ns2__PayPalPreapprovedPaymentService' for type 'ns2:PayPalPreapprovedPaymentService' */
#ifndef SOAP_TYPE_ns2__PayPalPreapprovedPaymentService
#define SOAP_TYPE_ns2__PayPalPreapprovedPaymentService (343)
#endif

/* ns2__PayPalButtonCreateService has binding name 'ns2__PayPalButtonCreateService' for type 'ns2:PayPalButtonCreateService' */
#ifndef SOAP_TYPE_ns2__PayPalButtonCreateService
#define SOAP_TYPE_ns2__PayPalButtonCreateService (342)
#endif

/* ns2__PinDebitReversalService has binding name 'ns2__PinDebitReversalService' for type 'ns2:PinDebitReversalService' */
#ifndef SOAP_TYPE_ns2__PinDebitReversalService
#define SOAP_TYPE_ns2__PinDebitReversalService (341)
#endif

/* ns2__PinDebitCreditService has binding name 'ns2__PinDebitCreditService' for type 'ns2:PinDebitCreditService' */
#ifndef SOAP_TYPE_ns2__PinDebitCreditService
#define SOAP_TYPE_ns2__PinDebitCreditService (340)
#endif

/* ns2__PinDebitPurchaseService has binding name 'ns2__PinDebitPurchaseService' for type 'ns2:PinDebitPurchaseService' */
#ifndef SOAP_TYPE_ns2__PinDebitPurchaseService
#define SOAP_TYPE_ns2__PinDebitPurchaseService (339)
#endif

/* ns2__PinlessDebitReversalService has binding name 'ns2__PinlessDebitReversalService' for type 'ns2:PinlessDebitReversalService' */
#ifndef SOAP_TYPE_ns2__PinlessDebitReversalService
#define SOAP_TYPE_ns2__PinlessDebitReversalService (338)
#endif

/* ns2__PinlessDebitValidateService has binding name 'ns2__PinlessDebitValidateService' for type 'ns2:PinlessDebitValidateService' */
#ifndef SOAP_TYPE_ns2__PinlessDebitValidateService
#define SOAP_TYPE_ns2__PinlessDebitValidateService (337)
#endif

/* ns2__PinlessDebitService has binding name 'ns2__PinlessDebitService' for type 'ns2:PinlessDebitService' */
#ifndef SOAP_TYPE_ns2__PinlessDebitService
#define SOAP_TYPE_ns2__PinlessDebitService (336)
#endif

/* ns2__VoidService has binding name 'ns2__VoidService' for type 'ns2:VoidService' */
#ifndef SOAP_TYPE_ns2__VoidService
#define SOAP_TYPE_ns2__VoidService (335)
#endif

/* ns2__PayPalDoRefTransactionService has binding name 'ns2__PayPalDoRefTransactionService' for type 'ns2:PayPalDoRefTransactionService' */
#ifndef SOAP_TYPE_ns2__PayPalDoRefTransactionService
#define SOAP_TYPE_ns2__PayPalDoRefTransactionService (334)
#endif

/* ns2__PayPalCreateAgreementService has binding name 'ns2__PayPalCreateAgreementService' for type 'ns2:PayPalCreateAgreementService' */
#ifndef SOAP_TYPE_ns2__PayPalCreateAgreementService
#define SOAP_TYPE_ns2__PayPalCreateAgreementService (333)
#endif

/* ns2__PayPalUpdateAgreementService has binding name 'ns2__PayPalUpdateAgreementService' for type 'ns2:PayPalUpdateAgreementService' */
#ifndef SOAP_TYPE_ns2__PayPalUpdateAgreementService
#define SOAP_TYPE_ns2__PayPalUpdateAgreementService (332)
#endif

/* ns2__PayPalAuthorizationService has binding name 'ns2__PayPalAuthorizationService' for type 'ns2:PayPalAuthorizationService' */
#ifndef SOAP_TYPE_ns2__PayPalAuthorizationService
#define SOAP_TYPE_ns2__PayPalAuthorizationService (331)
#endif

/* ns2__PayPalEcOrderSetupService has binding name 'ns2__PayPalEcOrderSetupService' for type 'ns2:PayPalEcOrderSetupService' */
#ifndef SOAP_TYPE_ns2__PayPalEcOrderSetupService
#define SOAP_TYPE_ns2__PayPalEcOrderSetupService (330)
#endif

/* ns2__PayPalRefundService has binding name 'ns2__PayPalRefundService' for type 'ns2:PayPalRefundService' */
#ifndef SOAP_TYPE_ns2__PayPalRefundService
#define SOAP_TYPE_ns2__PayPalRefundService (329)
#endif

/* ns2__PayPalAuthReversalService has binding name 'ns2__PayPalAuthReversalService' for type 'ns2:PayPalAuthReversalService' */
#ifndef SOAP_TYPE_ns2__PayPalAuthReversalService
#define SOAP_TYPE_ns2__PayPalAuthReversalService (328)
#endif

/* ns2__PayPalDoCaptureService has binding name 'ns2__PayPalDoCaptureService' for type 'ns2:PayPalDoCaptureService' */
#ifndef SOAP_TYPE_ns2__PayPalDoCaptureService
#define SOAP_TYPE_ns2__PayPalDoCaptureService (327)
#endif

/* ns2__PayPalEcDoPaymentService has binding name 'ns2__PayPalEcDoPaymentService' for type 'ns2:PayPalEcDoPaymentService' */
#ifndef SOAP_TYPE_ns2__PayPalEcDoPaymentService
#define SOAP_TYPE_ns2__PayPalEcDoPaymentService (326)
#endif

/* ns2__PayPalEcGetDetailsService has binding name 'ns2__PayPalEcGetDetailsService' for type 'ns2:PayPalEcGetDetailsService' */
#ifndef SOAP_TYPE_ns2__PayPalEcGetDetailsService
#define SOAP_TYPE_ns2__PayPalEcGetDetailsService (325)
#endif

/* ns2__PayPalEcSetService has binding name 'ns2__PayPalEcSetService' for type 'ns2:PayPalEcSetService' */
#ifndef SOAP_TYPE_ns2__PayPalEcSetService
#define SOAP_TYPE_ns2__PayPalEcSetService (324)
#endif

/* ns2__PayPalCreditService has binding name 'ns2__PayPalCreditService' for type 'ns2:PayPalCreditService' */
#ifndef SOAP_TYPE_ns2__PayPalCreditService
#define SOAP_TYPE_ns2__PayPalCreditService (323)
#endif

/* ns2__PayPalPaymentService has binding name 'ns2__PayPalPaymentService' for type 'ns2:PayPalPaymentService' */
#ifndef SOAP_TYPE_ns2__PayPalPaymentService
#define SOAP_TYPE_ns2__PayPalPaymentService (322)
#endif

/* ns2__PaySubscriptionDeleteService has binding name 'ns2__PaySubscriptionDeleteService' for type 'ns2:PaySubscriptionDeleteService' */
#ifndef SOAP_TYPE_ns2__PaySubscriptionDeleteService
#define SOAP_TYPE_ns2__PaySubscriptionDeleteService (321)
#endif

/* ns2__PaySubscriptionRetrieveService has binding name 'ns2__PaySubscriptionRetrieveService' for type 'ns2:PaySubscriptionRetrieveService' */
#ifndef SOAP_TYPE_ns2__PaySubscriptionRetrieveService
#define SOAP_TYPE_ns2__PaySubscriptionRetrieveService (320)
#endif

/* ns2__PaySubscriptionEventUpdateService has binding name 'ns2__PaySubscriptionEventUpdateService' for type 'ns2:PaySubscriptionEventUpdateService' */
#ifndef SOAP_TYPE_ns2__PaySubscriptionEventUpdateService
#define SOAP_TYPE_ns2__PaySubscriptionEventUpdateService (319)
#endif

/* ns2__PaySubscriptionUpdateService has binding name 'ns2__PaySubscriptionUpdateService' for type 'ns2:PaySubscriptionUpdateService' */
#ifndef SOAP_TYPE_ns2__PaySubscriptionUpdateService
#define SOAP_TYPE_ns2__PaySubscriptionUpdateService (318)
#endif

/* ns2__PaySubscriptionCreateService has binding name 'ns2__PaySubscriptionCreateService' for type 'ns2:PaySubscriptionCreateService' */
#ifndef SOAP_TYPE_ns2__PaySubscriptionCreateService
#define SOAP_TYPE_ns2__PaySubscriptionCreateService (317)
#endif

/* ns2__DeviceFingerprintData has binding name 'ns2__DeviceFingerprintData' for type 'ns2:DeviceFingerprintData' */
#ifndef SOAP_TYPE_ns2__DeviceFingerprintData
#define SOAP_TYPE_ns2__DeviceFingerprintData (316)
#endif

/* ns2__DirectDebitValidateService has binding name 'ns2__DirectDebitValidateService' for type 'ns2:DirectDebitValidateService' */
#ifndef SOAP_TYPE_ns2__DirectDebitValidateService
#define SOAP_TYPE_ns2__DirectDebitValidateService (315)
#endif

/* ns2__DirectDebitRefundService has binding name 'ns2__DirectDebitRefundService' for type 'ns2:DirectDebitRefundService' */
#ifndef SOAP_TYPE_ns2__DirectDebitRefundService
#define SOAP_TYPE_ns2__DirectDebitRefundService (314)
#endif

/* ns2__DirectDebitService has binding name 'ns2__DirectDebitService' for type 'ns2:DirectDebitService' */
#ifndef SOAP_TYPE_ns2__DirectDebitService
#define SOAP_TYPE_ns2__DirectDebitService (313)
#endif

/* ns2__DirectDebitMandateService has binding name 'ns2__DirectDebitMandateService' for type 'ns2:DirectDebitMandateService' */
#ifndef SOAP_TYPE_ns2__DirectDebitMandateService
#define SOAP_TYPE_ns2__DirectDebitMandateService (312)
#endif

/* ns2__BankTransferRealTimeService has binding name 'ns2__BankTransferRealTimeService' for type 'ns2:BankTransferRealTimeService' */
#ifndef SOAP_TYPE_ns2__BankTransferRealTimeService
#define SOAP_TYPE_ns2__BankTransferRealTimeService (311)
#endif

/* ns2__BankTransferRefundService has binding name 'ns2__BankTransferRefundService' for type 'ns2:BankTransferRefundService' */
#ifndef SOAP_TYPE_ns2__BankTransferRefundService
#define SOAP_TYPE_ns2__BankTransferRefundService (310)
#endif

/* ns2__BankTransferService has binding name 'ns2__BankTransferService' for type 'ns2:BankTransferService' */
#ifndef SOAP_TYPE_ns2__BankTransferService
#define SOAP_TYPE_ns2__BankTransferService (309)
#endif

/* ns2__FXRatesService has binding name 'ns2__FXRatesService' for type 'ns2:FXRatesService' */
#ifndef SOAP_TYPE_ns2__FXRatesService
#define SOAP_TYPE_ns2__FXRatesService (308)
#endif

/* ns2__ExportService has binding name 'ns2__ExportService' for type 'ns2:ExportService' */
#ifndef SOAP_TYPE_ns2__ExportService
#define SOAP_TYPE_ns2__ExportService (307)
#endif

/* ns2__DAVService has binding name 'ns2__DAVService' for type 'ns2:DAVService' */
#ifndef SOAP_TYPE_ns2__DAVService
#define SOAP_TYPE_ns2__DAVService (306)
#endif

/* ns2__AFSService has binding name 'ns2__AFSService' for type 'ns2:AFSService' */
#ifndef SOAP_TYPE_ns2__AFSService
#define SOAP_TYPE_ns2__AFSService (305)
#endif

/* ns2__DMEService has binding name 'ns2__DMEService' for type 'ns2:DMEService' */
#ifndef SOAP_TYPE_ns2__DMEService
#define SOAP_TYPE_ns2__DMEService (304)
#endif

/* ns2__TaxService has binding name 'ns2__TaxService' for type 'ns2:TaxService' */
#ifndef SOAP_TYPE_ns2__TaxService
#define SOAP_TYPE_ns2__TaxService (303)
#endif

/* ns2__PayerAuthSetupService has binding name 'ns2__PayerAuthSetupService' for type 'ns2:PayerAuthSetupService' */
#ifndef SOAP_TYPE_ns2__PayerAuthSetupService
#define SOAP_TYPE_ns2__PayerAuthSetupService (302)
#endif

/* ns2__PayerAuthValidateService has binding name 'ns2__PayerAuthValidateService' for type 'ns2:PayerAuthValidateService' */
#ifndef SOAP_TYPE_ns2__PayerAuthValidateService
#define SOAP_TYPE_ns2__PayerAuthValidateService (301)
#endif

/* ns2__PayerAuthEnrollService has binding name 'ns2__PayerAuthEnrollService' for type 'ns2:PayerAuthEnrollService' */
#ifndef SOAP_TYPE_ns2__PayerAuthEnrollService
#define SOAP_TYPE_ns2__PayerAuthEnrollService (300)
#endif

/* ns2__ECAuthenticateService has binding name 'ns2__ECAuthenticateService' for type 'ns2:ECAuthenticateService' */
#ifndef SOAP_TYPE_ns2__ECAuthenticateService
#define SOAP_TYPE_ns2__ECAuthenticateService (299)
#endif

/* ns2__ECCreditService has binding name 'ns2__ECCreditService' for type 'ns2:ECCreditService' */
#ifndef SOAP_TYPE_ns2__ECCreditService
#define SOAP_TYPE_ns2__ECCreditService (298)
#endif

/* ns2__ECDebitService has binding name 'ns2__ECDebitService' for type 'ns2:ECDebitService' */
#ifndef SOAP_TYPE_ns2__ECDebitService
#define SOAP_TYPE_ns2__ECDebitService (297)
#endif

/* ns2__ServiceFeeCalculateService has binding name 'ns2__ServiceFeeCalculateService' for type 'ns2:ServiceFeeCalculateService' */
#ifndef SOAP_TYPE_ns2__ServiceFeeCalculateService
#define SOAP_TYPE_ns2__ServiceFeeCalculateService (296)
#endif

/* ns2__CCDCCService has binding name 'ns2__CCDCCService' for type 'ns2:CCDCCService' */
#ifndef SOAP_TYPE_ns2__CCDCCService
#define SOAP_TYPE_ns2__CCDCCService (295)
#endif

/* ns2__CCAutoAuthReversalService has binding name 'ns2__CCAutoAuthReversalService' for type 'ns2:CCAutoAuthReversalService' */
#ifndef SOAP_TYPE_ns2__CCAutoAuthReversalService
#define SOAP_TYPE_ns2__CCAutoAuthReversalService (294)
#endif

/* ns2__CCAuthReversalService has binding name 'ns2__CCAuthReversalService' for type 'ns2:CCAuthReversalService' */
#ifndef SOAP_TYPE_ns2__CCAuthReversalService
#define SOAP_TYPE_ns2__CCAuthReversalService (293)
#endif

/* ns2__CCCreditService has binding name 'ns2__CCCreditService' for type 'ns2:CCCreditService' */
#ifndef SOAP_TYPE_ns2__CCCreditService
#define SOAP_TYPE_ns2__CCCreditService (292)
#endif

/* ns2__CCCaptureService has binding name 'ns2__CCCaptureService' for type 'ns2:CCCaptureService' */
#ifndef SOAP_TYPE_ns2__CCCaptureService
#define SOAP_TYPE_ns2__CCCaptureService (291)
#endif

/* ns2__CCIncrementalAuthService has binding name 'ns2__CCIncrementalAuthService' for type 'ns2:CCIncrementalAuthService' */
#ifndef SOAP_TYPE_ns2__CCIncrementalAuthService
#define SOAP_TYPE_ns2__CCIncrementalAuthService (290)
#endif

/* ns2__CCSaleReversalService has binding name 'ns2__CCSaleReversalService' for type 'ns2:CCSaleReversalService' */
#ifndef SOAP_TYPE_ns2__CCSaleReversalService
#define SOAP_TYPE_ns2__CCSaleReversalService (289)
#endif

/* ns2__CCSaleCreditService has binding name 'ns2__CCSaleCreditService' for type 'ns2:CCSaleCreditService' */
#ifndef SOAP_TYPE_ns2__CCSaleCreditService
#define SOAP_TYPE_ns2__CCSaleCreditService (288)
#endif

/* ns2__CCSaleService has binding name 'ns2__CCSaleService' for type 'ns2:CCSaleService' */
#ifndef SOAP_TYPE_ns2__CCSaleService
#define SOAP_TYPE_ns2__CCSaleService (287)
#endif

/* ns2__VerificationService has binding name 'ns2__VerificationService' for type 'ns2:VerificationService' */
#ifndef SOAP_TYPE_ns2__VerificationService
#define SOAP_TYPE_ns2__VerificationService (286)
#endif

/* ns2__OCTService has binding name 'ns2__OCTService' for type 'ns2:OCTService' */
#ifndef SOAP_TYPE_ns2__OCTService
#define SOAP_TYPE_ns2__OCTService (285)
#endif

/* ns2__CCAuthService has binding name 'ns2__CCAuthService' for type 'ns2:CCAuthService' */
#ifndef SOAP_TYPE_ns2__CCAuthService
#define SOAP_TYPE_ns2__CCAuthService (284)
#endif

/* ns2__Item has binding name 'ns2__Item' for type 'ns2:Item' */
#ifndef SOAP_TYPE_ns2__Item
#define SOAP_TYPE_ns2__Item (283)
#endif

/* xsd__integer has binding name 'xsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (282)
#endif

/* xsd__decimal has binding name 'xsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (281)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (280)
#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (277)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (958)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (957)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (954)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (952)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (274)
#endif

/* struct _wsse__Security has binding name '_wsse__Security' for type '' */
#ifndef SOAP_TYPE__wsse__Security
#define SOAP_TYPE__wsse__Security (268)
#endif

/* _saml2__EncryptedAttribute has binding name '_saml2__EncryptedAttribute' for type '' */
#ifndef SOAP_TYPE__saml2__EncryptedAttribute
#define SOAP_TYPE__saml2__EncryptedAttribute (267)
#endif

/* _saml2__Attribute has binding name '_saml2__Attribute' for type '' */
#ifndef SOAP_TYPE__saml2__Attribute
#define SOAP_TYPE__saml2__Attribute (265)
#endif

/* _saml2__AttributeStatement has binding name '_saml2__AttributeStatement' for type '' */
#ifndef SOAP_TYPE__saml2__AttributeStatement
#define SOAP_TYPE__saml2__AttributeStatement (264)
#endif

/* _saml2__Evidence has binding name '_saml2__Evidence' for type '' */
#ifndef SOAP_TYPE__saml2__Evidence
#define SOAP_TYPE__saml2__Evidence (263)
#endif

/* _saml2__Action has binding name '_saml2__Action' for type '' */
#ifndef SOAP_TYPE__saml2__Action
#define SOAP_TYPE__saml2__Action (262)
#endif

/* _saml2__AuthzDecisionStatement has binding name '_saml2__AuthzDecisionStatement' for type '' */
#ifndef SOAP_TYPE__saml2__AuthzDecisionStatement
#define SOAP_TYPE__saml2__AuthzDecisionStatement (261)
#endif

/* _saml2__AuthnContext has binding name '_saml2__AuthnContext' for type '' */
#ifndef SOAP_TYPE__saml2__AuthnContext
#define SOAP_TYPE__saml2__AuthnContext (256)
#endif

/* _saml2__SubjectLocality has binding name '_saml2__SubjectLocality' for type '' */
#ifndef SOAP_TYPE__saml2__SubjectLocality
#define SOAP_TYPE__saml2__SubjectLocality (255)
#endif

/* _saml2__AuthnStatement has binding name '_saml2__AuthnStatement' for type '' */
#ifndef SOAP_TYPE__saml2__AuthnStatement
#define SOAP_TYPE__saml2__AuthnStatement (254)
#endif

/* _saml2__Statement has binding name '_saml2__Statement' for type '' */
#ifndef SOAP_TYPE__saml2__Statement
#define SOAP_TYPE__saml2__Statement (253)
#endif

/* _saml2__EncryptedAssertion has binding name '_saml2__EncryptedAssertion' for type '' */
#ifndef SOAP_TYPE__saml2__EncryptedAssertion
#define SOAP_TYPE__saml2__EncryptedAssertion (252)
#endif

/* _saml2__Advice has binding name '_saml2__Advice' for type '' */
#ifndef SOAP_TYPE__saml2__Advice
#define SOAP_TYPE__saml2__Advice (251)
#endif

/* _saml2__ProxyRestriction has binding name '_saml2__ProxyRestriction' for type '' */
#ifndef SOAP_TYPE__saml2__ProxyRestriction
#define SOAP_TYPE__saml2__ProxyRestriction (250)
#endif

/* _saml2__OneTimeUse has binding name '_saml2__OneTimeUse' for type '' */
#ifndef SOAP_TYPE__saml2__OneTimeUse
#define SOAP_TYPE__saml2__OneTimeUse (249)
#endif

/* _saml2__AudienceRestriction has binding name '_saml2__AudienceRestriction' for type '' */
#ifndef SOAP_TYPE__saml2__AudienceRestriction
#define SOAP_TYPE__saml2__AudienceRestriction (247)
#endif

/* _saml2__Condition has binding name '_saml2__Condition' for type '' */
#ifndef SOAP_TYPE__saml2__Condition
#define SOAP_TYPE__saml2__Condition (246)
#endif

/* _saml2__Conditions has binding name '_saml2__Conditions' for type '' */
#ifndef SOAP_TYPE__saml2__Conditions
#define SOAP_TYPE__saml2__Conditions (245)
#endif

/* _saml2__SubjectConfirmationData has binding name '_saml2__SubjectConfirmationData' for type '' */
#ifndef SOAP_TYPE__saml2__SubjectConfirmationData
#define SOAP_TYPE__saml2__SubjectConfirmationData (244)
#endif

/* _saml2__SubjectConfirmation has binding name '_saml2__SubjectConfirmation' for type '' */
#ifndef SOAP_TYPE__saml2__SubjectConfirmation
#define SOAP_TYPE__saml2__SubjectConfirmation (243)
#endif

/* _saml2__Subject has binding name '_saml2__Subject' for type '' */
#ifndef SOAP_TYPE__saml2__Subject
#define SOAP_TYPE__saml2__Subject (242)
#endif

/* _saml2__Assertion has binding name '_saml2__Assertion' for type '' */
#ifndef SOAP_TYPE__saml2__Assertion
#define SOAP_TYPE__saml2__Assertion (241)
#endif

/* _saml2__Issuer has binding name '_saml2__Issuer' for type '' */
#ifndef SOAP_TYPE__saml2__Issuer
#define SOAP_TYPE__saml2__Issuer (238)
#endif

/* _saml2__EncryptedID has binding name '_saml2__EncryptedID' for type '' */
#ifndef SOAP_TYPE__saml2__EncryptedID
#define SOAP_TYPE__saml2__EncryptedID (237)
#endif

/* _saml2__NameID has binding name '_saml2__NameID' for type '' */
#ifndef SOAP_TYPE__saml2__NameID
#define SOAP_TYPE__saml2__NameID (236)
#endif

/* _saml2__BaseID has binding name '_saml2__BaseID' for type '' */
#ifndef SOAP_TYPE__saml2__BaseID
#define SOAP_TYPE__saml2__BaseID (235)
#endif

/* struct saml2__AttributeType has binding name 'saml2__AttributeType' for type 'saml2:AttributeType' */
#ifndef SOAP_TYPE_saml2__AttributeType
#define SOAP_TYPE_saml2__AttributeType (199)
#endif

/* struct saml2__AttributeStatementType has binding name 'saml2__AttributeStatementType' for type 'saml2:AttributeStatementType' */
#ifndef SOAP_TYPE_saml2__AttributeStatementType
#define SOAP_TYPE_saml2__AttributeStatementType (198)
#endif

/* struct saml2__EvidenceType has binding name 'saml2__EvidenceType' for type 'saml2:EvidenceType' */
#ifndef SOAP_TYPE_saml2__EvidenceType
#define SOAP_TYPE_saml2__EvidenceType (197)
#endif

/* struct saml2__ActionType has binding name 'saml2__ActionType' for type 'saml2:ActionType' */
#ifndef SOAP_TYPE_saml2__ActionType
#define SOAP_TYPE_saml2__ActionType (196)
#endif

/* struct saml2__AuthzDecisionStatementType has binding name 'saml2__AuthzDecisionStatementType' for type 'saml2:AuthzDecisionStatementType' */
#ifndef SOAP_TYPE_saml2__AuthzDecisionStatementType
#define SOAP_TYPE_saml2__AuthzDecisionStatementType (195)
#endif

/* struct saml2__AuthnContextType has binding name 'saml2__AuthnContextType' for type 'saml2:AuthnContextType' */
#ifndef SOAP_TYPE_saml2__AuthnContextType
#define SOAP_TYPE_saml2__AuthnContextType (194)
#endif

/* struct saml2__SubjectLocalityType has binding name 'saml2__SubjectLocalityType' for type 'saml2:SubjectLocalityType' */
#ifndef SOAP_TYPE_saml2__SubjectLocalityType
#define SOAP_TYPE_saml2__SubjectLocalityType (193)
#endif

/* struct saml2__AuthnStatementType has binding name 'saml2__AuthnStatementType' for type 'saml2:AuthnStatementType' */
#ifndef SOAP_TYPE_saml2__AuthnStatementType
#define SOAP_TYPE_saml2__AuthnStatementType (192)
#endif

/* struct saml2__StatementAbstractType has binding name 'saml2__StatementAbstractType' for type 'saml2:StatementAbstractType' */
#ifndef SOAP_TYPE_saml2__StatementAbstractType
#define SOAP_TYPE_saml2__StatementAbstractType (191)
#endif

/* struct saml2__AdviceType has binding name 'saml2__AdviceType' for type 'saml2:AdviceType' */
#ifndef SOAP_TYPE_saml2__AdviceType
#define SOAP_TYPE_saml2__AdviceType (190)
#endif

/* struct saml2__ProxyRestrictionType has binding name 'saml2__ProxyRestrictionType' for type 'saml2:ProxyRestrictionType' */
#ifndef SOAP_TYPE_saml2__ProxyRestrictionType
#define SOAP_TYPE_saml2__ProxyRestrictionType (189)
#endif

/* struct saml2__OneTimeUseType has binding name 'saml2__OneTimeUseType' for type 'saml2:OneTimeUseType' */
#ifndef SOAP_TYPE_saml2__OneTimeUseType
#define SOAP_TYPE_saml2__OneTimeUseType (188)
#endif

/* struct saml2__AudienceRestrictionType has binding name 'saml2__AudienceRestrictionType' for type 'saml2:AudienceRestrictionType' */
#ifndef SOAP_TYPE_saml2__AudienceRestrictionType
#define SOAP_TYPE_saml2__AudienceRestrictionType (187)
#endif

/* struct saml2__ConditionAbstractType has binding name 'saml2__ConditionAbstractType' for type 'saml2:ConditionAbstractType' */
#ifndef SOAP_TYPE_saml2__ConditionAbstractType
#define SOAP_TYPE_saml2__ConditionAbstractType (186)
#endif

/* struct saml2__ConditionsType has binding name 'saml2__ConditionsType' for type 'saml2:ConditionsType' */
#ifndef SOAP_TYPE_saml2__ConditionsType
#define SOAP_TYPE_saml2__ConditionsType (185)
#endif

/* struct saml2__KeyInfoConfirmationDataType has binding name 'saml2__KeyInfoConfirmationDataType' for type 'saml2:KeyInfoConfirmationDataType' */
#ifndef SOAP_TYPE_saml2__KeyInfoConfirmationDataType
#define SOAP_TYPE_saml2__KeyInfoConfirmationDataType (184)
#endif

/* struct saml2__SubjectConfirmationDataType has binding name 'saml2__SubjectConfirmationDataType' for type 'saml2:SubjectConfirmationDataType' */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationDataType
#define SOAP_TYPE_saml2__SubjectConfirmationDataType (183)
#endif

/* struct saml2__SubjectConfirmationType has binding name 'saml2__SubjectConfirmationType' for type 'saml2:SubjectConfirmationType' */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationType
#define SOAP_TYPE_saml2__SubjectConfirmationType (182)
#endif

/* struct saml2__SubjectType has binding name 'saml2__SubjectType' for type 'saml2:SubjectType' */
#ifndef SOAP_TYPE_saml2__SubjectType
#define SOAP_TYPE_saml2__SubjectType (181)
#endif

/* struct saml2__AssertionType has binding name 'saml2__AssertionType' for type 'saml2:AssertionType' */
#ifndef SOAP_TYPE_saml2__AssertionType
#define SOAP_TYPE_saml2__AssertionType (180)
#endif

/* struct saml2__EncryptedElementType has binding name 'saml2__EncryptedElementType' for type 'saml2:EncryptedElementType' */
#ifndef SOAP_TYPE_saml2__EncryptedElementType
#define SOAP_TYPE_saml2__EncryptedElementType (179)
#endif

/* struct saml2__NameIDType has binding name 'saml2__NameIDType' for type 'saml2:NameIDType' */
#ifndef SOAP_TYPE_saml2__NameIDType
#define SOAP_TYPE_saml2__NameIDType (178)
#endif

/* struct saml2__BaseIDAbstractType has binding name 'saml2__BaseIDAbstractType' for type 'saml2:BaseIDAbstractType' */
#ifndef SOAP_TYPE_saml2__BaseIDAbstractType
#define SOAP_TYPE_saml2__BaseIDAbstractType (177)
#endif

/* _saml1__Attribute has binding name '_saml1__Attribute' for type '' */
#ifndef SOAP_TYPE__saml1__Attribute
#define SOAP_TYPE__saml1__Attribute (175)
#endif

/* _saml1__AttributeDesignator has binding name '_saml1__AttributeDesignator' for type '' */
#ifndef SOAP_TYPE__saml1__AttributeDesignator
#define SOAP_TYPE__saml1__AttributeDesignator (174)
#endif

/* _saml1__AttributeStatement has binding name '_saml1__AttributeStatement' for type '' */
#ifndef SOAP_TYPE__saml1__AttributeStatement
#define SOAP_TYPE__saml1__AttributeStatement (173)
#endif

/* _saml1__Evidence has binding name '_saml1__Evidence' for type '' */
#ifndef SOAP_TYPE__saml1__Evidence
#define SOAP_TYPE__saml1__Evidence (172)
#endif

/* _saml1__Action has binding name '_saml1__Action' for type '' */
#ifndef SOAP_TYPE__saml1__Action
#define SOAP_TYPE__saml1__Action (171)
#endif

/* _saml1__AuthorizationDecisionStatement has binding name '_saml1__AuthorizationDecisionStatement' for type '' */
#ifndef SOAP_TYPE__saml1__AuthorizationDecisionStatement
#define SOAP_TYPE__saml1__AuthorizationDecisionStatement (170)
#endif

/* _saml1__AuthorityBinding has binding name '_saml1__AuthorityBinding' for type '' */
#ifndef SOAP_TYPE__saml1__AuthorityBinding
#define SOAP_TYPE__saml1__AuthorityBinding (169)
#endif

/* _saml1__SubjectLocality has binding name '_saml1__SubjectLocality' for type '' */
#ifndef SOAP_TYPE__saml1__SubjectLocality
#define SOAP_TYPE__saml1__SubjectLocality (168)
#endif

/* _saml1__AuthenticationStatement has binding name '_saml1__AuthenticationStatement' for type '' */
#ifndef SOAP_TYPE__saml1__AuthenticationStatement
#define SOAP_TYPE__saml1__AuthenticationStatement (167)
#endif

/* _saml1__SubjectConfirmation has binding name '_saml1__SubjectConfirmation' for type '' */
#ifndef SOAP_TYPE__saml1__SubjectConfirmation
#define SOAP_TYPE__saml1__SubjectConfirmation (164)
#endif

/* _saml1__NameIdentifier has binding name '_saml1__NameIdentifier' for type '' */
#ifndef SOAP_TYPE__saml1__NameIdentifier
#define SOAP_TYPE__saml1__NameIdentifier (163)
#endif

/* _saml1__Subject has binding name '_saml1__Subject' for type '' */
#ifndef SOAP_TYPE__saml1__Subject
#define SOAP_TYPE__saml1__Subject (162)
#endif

/* _saml1__SubjectStatement has binding name '_saml1__SubjectStatement' for type '' */
#ifndef SOAP_TYPE__saml1__SubjectStatement
#define SOAP_TYPE__saml1__SubjectStatement (161)
#endif

/* _saml1__Statement has binding name '_saml1__Statement' for type '' */
#ifndef SOAP_TYPE__saml1__Statement
#define SOAP_TYPE__saml1__Statement (160)
#endif

/* _saml1__Advice has binding name '_saml1__Advice' for type '' */
#ifndef SOAP_TYPE__saml1__Advice
#define SOAP_TYPE__saml1__Advice (159)
#endif

/* _saml1__DoNotCacheCondition has binding name '_saml1__DoNotCacheCondition' for type '' */
#ifndef SOAP_TYPE__saml1__DoNotCacheCondition
#define SOAP_TYPE__saml1__DoNotCacheCondition (158)
#endif

/* _saml1__AudienceRestrictionCondition has binding name '_saml1__AudienceRestrictionCondition' for type '' */
#ifndef SOAP_TYPE__saml1__AudienceRestrictionCondition
#define SOAP_TYPE__saml1__AudienceRestrictionCondition (156)
#endif

/* _saml1__Condition has binding name '_saml1__Condition' for type '' */
#ifndef SOAP_TYPE__saml1__Condition
#define SOAP_TYPE__saml1__Condition (155)
#endif

/* _saml1__Conditions has binding name '_saml1__Conditions' for type '' */
#ifndef SOAP_TYPE__saml1__Conditions
#define SOAP_TYPE__saml1__Conditions (154)
#endif

/* _saml1__Assertion has binding name '_saml1__Assertion' for type '' */
#ifndef SOAP_TYPE__saml1__Assertion
#define SOAP_TYPE__saml1__Assertion (153)
#endif

/* struct saml1__AttributeType has binding name 'saml1__AttributeType' for type 'saml1:AttributeType' */
#ifndef SOAP_TYPE_saml1__AttributeType
#define SOAP_TYPE_saml1__AttributeType (119)
#endif

/* struct saml1__AttributeDesignatorType has binding name 'saml1__AttributeDesignatorType' for type 'saml1:AttributeDesignatorType' */
#ifndef SOAP_TYPE_saml1__AttributeDesignatorType
#define SOAP_TYPE_saml1__AttributeDesignatorType (118)
#endif

/* struct saml1__AttributeStatementType has binding name 'saml1__AttributeStatementType' for type 'saml1:AttributeStatementType' */
#ifndef SOAP_TYPE_saml1__AttributeStatementType
#define SOAP_TYPE_saml1__AttributeStatementType (117)
#endif

/* struct saml1__EvidenceType has binding name 'saml1__EvidenceType' for type 'saml1:EvidenceType' */
#ifndef SOAP_TYPE_saml1__EvidenceType
#define SOAP_TYPE_saml1__EvidenceType (116)
#endif

/* struct saml1__ActionType has binding name 'saml1__ActionType' for type 'saml1:ActionType' */
#ifndef SOAP_TYPE_saml1__ActionType
#define SOAP_TYPE_saml1__ActionType (115)
#endif

/* struct saml1__AuthorizationDecisionStatementType has binding name 'saml1__AuthorizationDecisionStatementType' for type 'saml1:AuthorizationDecisionStatementType' */
#ifndef SOAP_TYPE_saml1__AuthorizationDecisionStatementType
#define SOAP_TYPE_saml1__AuthorizationDecisionStatementType (114)
#endif

/* struct saml1__AuthorityBindingType has binding name 'saml1__AuthorityBindingType' for type 'saml1:AuthorityBindingType' */
#ifndef SOAP_TYPE_saml1__AuthorityBindingType
#define SOAP_TYPE_saml1__AuthorityBindingType (113)
#endif

/* struct saml1__SubjectLocalityType has binding name 'saml1__SubjectLocalityType' for type 'saml1:SubjectLocalityType' */
#ifndef SOAP_TYPE_saml1__SubjectLocalityType
#define SOAP_TYPE_saml1__SubjectLocalityType (112)
#endif

/* struct saml1__AuthenticationStatementType has binding name 'saml1__AuthenticationStatementType' for type 'saml1:AuthenticationStatementType' */
#ifndef SOAP_TYPE_saml1__AuthenticationStatementType
#define SOAP_TYPE_saml1__AuthenticationStatementType (111)
#endif

/* struct saml1__SubjectConfirmationType has binding name 'saml1__SubjectConfirmationType' for type 'saml1:SubjectConfirmationType' */
#ifndef SOAP_TYPE_saml1__SubjectConfirmationType
#define SOAP_TYPE_saml1__SubjectConfirmationType (110)
#endif

/* struct saml1__NameIdentifierType has binding name 'saml1__NameIdentifierType' for type 'saml1:NameIdentifierType' */
#ifndef SOAP_TYPE_saml1__NameIdentifierType
#define SOAP_TYPE_saml1__NameIdentifierType (109)
#endif

/* struct saml1__SubjectType has binding name 'saml1__SubjectType' for type 'saml1:SubjectType' */
#ifndef SOAP_TYPE_saml1__SubjectType
#define SOAP_TYPE_saml1__SubjectType (108)
#endif

/* struct saml1__SubjectStatementAbstractType has binding name 'saml1__SubjectStatementAbstractType' for type 'saml1:SubjectStatementAbstractType' */
#ifndef SOAP_TYPE_saml1__SubjectStatementAbstractType
#define SOAP_TYPE_saml1__SubjectStatementAbstractType (107)
#endif

/* struct saml1__StatementAbstractType has binding name 'saml1__StatementAbstractType' for type 'saml1:StatementAbstractType' */
#ifndef SOAP_TYPE_saml1__StatementAbstractType
#define SOAP_TYPE_saml1__StatementAbstractType (106)
#endif

/* struct saml1__AdviceType has binding name 'saml1__AdviceType' for type 'saml1:AdviceType' */
#ifndef SOAP_TYPE_saml1__AdviceType
#define SOAP_TYPE_saml1__AdviceType (105)
#endif

/* struct saml1__DoNotCacheConditionType has binding name 'saml1__DoNotCacheConditionType' for type 'saml1:DoNotCacheConditionType' */
#ifndef SOAP_TYPE_saml1__DoNotCacheConditionType
#define SOAP_TYPE_saml1__DoNotCacheConditionType (104)
#endif

/* struct saml1__AudienceRestrictionConditionType has binding name 'saml1__AudienceRestrictionConditionType' for type 'saml1:AudienceRestrictionConditionType' */
#ifndef SOAP_TYPE_saml1__AudienceRestrictionConditionType
#define SOAP_TYPE_saml1__AudienceRestrictionConditionType (103)
#endif

/* struct saml1__ConditionAbstractType has binding name 'saml1__ConditionAbstractType' for type 'saml1:ConditionAbstractType' */
#ifndef SOAP_TYPE_saml1__ConditionAbstractType
#define SOAP_TYPE_saml1__ConditionAbstractType (102)
#endif

/* struct saml1__ConditionsType has binding name 'saml1__ConditionsType' for type 'saml1:ConditionsType' */
#ifndef SOAP_TYPE_saml1__ConditionsType
#define SOAP_TYPE_saml1__ConditionsType (101)
#endif

/* struct saml1__AssertionType has binding name 'saml1__AssertionType' for type 'saml1:AssertionType' */
#ifndef SOAP_TYPE_saml1__AssertionType
#define SOAP_TYPE_saml1__AssertionType (100)
#endif

/* xsd__dateTime has binding name 'xsd__dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (99)
#endif

/* struct wsc__PropertiesType has binding name 'wsc__PropertiesType' for type 'wsc:PropertiesType' */
#ifndef SOAP_TYPE_wsc__PropertiesType
#define SOAP_TYPE_wsc__PropertiesType (91)
#endif

/* struct wsc__DerivedKeyTokenType has binding name 'wsc__DerivedKeyTokenType' for type 'wsc:DerivedKeyTokenType' */
#ifndef SOAP_TYPE_wsc__DerivedKeyTokenType
#define SOAP_TYPE_wsc__DerivedKeyTokenType (90)
#endif

/* struct wsc__SecurityContextTokenType has binding name 'wsc__SecurityContextTokenType' for type 'wsc:SecurityContextTokenType' */
#ifndef SOAP_TYPE_wsc__SecurityContextTokenType
#define SOAP_TYPE_wsc__SecurityContextTokenType (89)
#endif

/* struct _xenc__ReferenceList has binding name '_xenc__ReferenceList' for type '' */
#ifndef SOAP_TYPE__xenc__ReferenceList
#define SOAP_TYPE__xenc__ReferenceList (75)
#endif

/* struct xenc__EncryptionPropertyType has binding name 'xenc__EncryptionPropertyType' for type 'xenc:EncryptionPropertyType' */
#ifndef SOAP_TYPE_xenc__EncryptionPropertyType
#define SOAP_TYPE_xenc__EncryptionPropertyType (74)
#endif

/* struct xenc__EncryptionPropertiesType has binding name 'xenc__EncryptionPropertiesType' for type 'xenc:EncryptionPropertiesType' */
#ifndef SOAP_TYPE_xenc__EncryptionPropertiesType
#define SOAP_TYPE_xenc__EncryptionPropertiesType (73)
#endif

/* struct xenc__ReferenceType has binding name 'xenc__ReferenceType' for type 'xenc:ReferenceType' */
#ifndef SOAP_TYPE_xenc__ReferenceType
#define SOAP_TYPE_xenc__ReferenceType (72)
#endif

/* struct xenc__AgreementMethodType has binding name 'xenc__AgreementMethodType' for type 'xenc:AgreementMethodType' */
#ifndef SOAP_TYPE_xenc__AgreementMethodType
#define SOAP_TYPE_xenc__AgreementMethodType (71)
#endif

/* struct xenc__EncryptedDataType has binding name 'xenc__EncryptedDataType' for type 'xenc:EncryptedDataType' */
#ifndef SOAP_TYPE_xenc__EncryptedDataType
#define SOAP_TYPE_xenc__EncryptedDataType (70)
#endif

/* struct xenc__TransformsType has binding name 'xenc__TransformsType' for type 'xenc:TransformsType' */
#ifndef SOAP_TYPE_xenc__TransformsType
#define SOAP_TYPE_xenc__TransformsType (69)
#endif

/* struct xenc__CipherReferenceType has binding name 'xenc__CipherReferenceType' for type 'xenc:CipherReferenceType' */
#ifndef SOAP_TYPE_xenc__CipherReferenceType
#define SOAP_TYPE_xenc__CipherReferenceType (68)
#endif

/* struct xenc__CipherDataType has binding name 'xenc__CipherDataType' for type 'xenc:CipherDataType' */
#ifndef SOAP_TYPE_xenc__CipherDataType
#define SOAP_TYPE_xenc__CipherDataType (67)
#endif

/* struct xenc__EncryptionMethodType has binding name 'xenc__EncryptionMethodType' for type 'xenc:EncryptionMethodType' */
#ifndef SOAP_TYPE_xenc__EncryptionMethodType
#define SOAP_TYPE_xenc__EncryptionMethodType (66)
#endif

/* struct xenc__EncryptedType has binding name 'xenc__EncryptedType' for type 'xenc:EncryptedType' */
#ifndef SOAP_TYPE_xenc__EncryptedType
#define SOAP_TYPE_xenc__EncryptedType (65)
#endif

/* struct ds__RSAKeyValueType has binding name 'ds__RSAKeyValueType' for type 'ds:RSAKeyValueType' */
#ifndef SOAP_TYPE_ds__RSAKeyValueType
#define SOAP_TYPE_ds__RSAKeyValueType (53)
#endif

/* struct ds__DSAKeyValueType has binding name 'ds__DSAKeyValueType' for type 'ds:DSAKeyValueType' */
#ifndef SOAP_TYPE_ds__DSAKeyValueType
#define SOAP_TYPE_ds__DSAKeyValueType (52)
#endif

/* struct ds__X509IssuerSerialType has binding name 'ds__X509IssuerSerialType' for type 'ds:X509IssuerSerialType' */
#ifndef SOAP_TYPE_ds__X509IssuerSerialType
#define SOAP_TYPE_ds__X509IssuerSerialType (51)
#endif

/* _ds__KeyInfo has binding name '_ds__KeyInfo' for type '' */
#ifndef SOAP_TYPE__ds__KeyInfo
#define SOAP_TYPE__ds__KeyInfo (50)
#endif

/* struct ds__RetrievalMethodType has binding name 'ds__RetrievalMethodType' for type 'ds:RetrievalMethodType' */
#ifndef SOAP_TYPE_ds__RetrievalMethodType
#define SOAP_TYPE_ds__RetrievalMethodType (47)
#endif

/* struct ds__KeyValueType has binding name 'ds__KeyValueType' for type 'ds:KeyValueType' */
#ifndef SOAP_TYPE_ds__KeyValueType
#define SOAP_TYPE_ds__KeyValueType (45)
#endif

/* struct ds__DigestMethodType has binding name 'ds__DigestMethodType' for type 'ds:DigestMethodType' */
#ifndef SOAP_TYPE_ds__DigestMethodType
#define SOAP_TYPE_ds__DigestMethodType (44)
#endif

/* _ds__Transform has binding name '_ds__Transform' for type '' */
#ifndef SOAP_TYPE__ds__Transform
#define SOAP_TYPE__ds__Transform (43)
#endif

/* struct ds__TransformType has binding name 'ds__TransformType' for type 'ds:TransformType' */
#ifndef SOAP_TYPE_ds__TransformType
#define SOAP_TYPE_ds__TransformType (41)
#endif

/* struct _c14n__InclusiveNamespaces has binding name '_c14n__InclusiveNamespaces' for type '' */
#ifndef SOAP_TYPE__c14n__InclusiveNamespaces
#define SOAP_TYPE__c14n__InclusiveNamespaces (40)
#endif

/* struct ds__TransformsType has binding name 'ds__TransformsType' for type 'ds:TransformsType' */
#ifndef SOAP_TYPE_ds__TransformsType
#define SOAP_TYPE_ds__TransformsType (39)
#endif

/* struct ds__ReferenceType has binding name 'ds__ReferenceType' for type 'ds:ReferenceType' */
#ifndef SOAP_TYPE_ds__ReferenceType
#define SOAP_TYPE_ds__ReferenceType (38)
#endif

/* struct ds__SignatureMethodType has binding name 'ds__SignatureMethodType' for type 'ds:SignatureMethodType' */
#ifndef SOAP_TYPE_ds__SignatureMethodType
#define SOAP_TYPE_ds__SignatureMethodType (37)
#endif

/* struct ds__CanonicalizationMethodType has binding name 'ds__CanonicalizationMethodType' for type 'ds:CanonicalizationMethodType' */
#ifndef SOAP_TYPE_ds__CanonicalizationMethodType
#define SOAP_TYPE_ds__CanonicalizationMethodType (36)
#endif

/* _ds__Signature has binding name '_ds__Signature' for type '' */
#ifndef SOAP_TYPE__ds__Signature
#define SOAP_TYPE__ds__Signature (35)
#endif

/* struct ds__SignedInfoType has binding name 'ds__SignedInfoType' for type 'ds:SignedInfoType' */
#ifndef SOAP_TYPE_ds__SignedInfoType
#define SOAP_TYPE_ds__SignedInfoType (32)
#endif

/* struct ds__SignatureType has binding name 'ds__SignatureType' for type 'ds:SignatureType' */
#ifndef SOAP_TYPE_ds__SignatureType
#define SOAP_TYPE_ds__SignatureType (31)
#endif

/* struct xenc__EncryptedKeyType has binding name 'xenc__EncryptedKeyType' for type 'xenc:EncryptedKeyType' */
#ifndef SOAP_TYPE_xenc__EncryptedKeyType
#define SOAP_TYPE_xenc__EncryptedKeyType (28)
#endif

/* struct ds__KeyInfoType has binding name 'ds__KeyInfoType' for type 'ds:KeyInfoType' */
#ifndef SOAP_TYPE_ds__KeyInfoType
#define SOAP_TYPE_ds__KeyInfoType (27)
#endif

/* struct ds__X509DataType has binding name 'ds__X509DataType' for type 'ds:X509DataType' */
#ifndef SOAP_TYPE_ds__X509DataType
#define SOAP_TYPE_ds__X509DataType (25)
#endif

/* struct _wsse__SecurityTokenReference has binding name '_wsse__SecurityTokenReference' for type '' */
#ifndef SOAP_TYPE__wsse__SecurityTokenReference
#define SOAP_TYPE__wsse__SecurityTokenReference (21)
#endif

/* struct _wsse__KeyIdentifier has binding name '_wsse__KeyIdentifier' for type '' */
#ifndef SOAP_TYPE__wsse__KeyIdentifier
#define SOAP_TYPE__wsse__KeyIdentifier (20)
#endif

/* struct _wsse__Embedded has binding name '_wsse__Embedded' for type '' */
#ifndef SOAP_TYPE__wsse__Embedded
#define SOAP_TYPE__wsse__Embedded (19)
#endif

/* struct _wsse__Reference has binding name '_wsse__Reference' for type '' */
#ifndef SOAP_TYPE__wsse__Reference
#define SOAP_TYPE__wsse__Reference (18)
#endif

/* struct _wsse__BinarySecurityToken has binding name '_wsse__BinarySecurityToken' for type '' */
#ifndef SOAP_TYPE__wsse__BinarySecurityToken
#define SOAP_TYPE__wsse__BinarySecurityToken (17)
#endif

/* struct _wsse__Password has binding name '_wsse__Password' for type '' */
#ifndef SOAP_TYPE__wsse__Password
#define SOAP_TYPE__wsse__Password (12)
#endif

/* struct _wsse__UsernameToken has binding name '_wsse__UsernameToken' for type '' */
#ifndef SOAP_TYPE__wsse__UsernameToken
#define SOAP_TYPE__wsse__UsernameToken (11)
#endif

/* struct wsse__EncodedString has binding name 'wsse__EncodedString' for type 'wsse:EncodedString' */
#ifndef SOAP_TYPE_wsse__EncodedString
#define SOAP_TYPE_wsse__EncodedString (9)
#endif

/* struct _wsu__Timestamp has binding name '_wsu__Timestamp' for type '' */
#ifndef SOAP_TYPE__wsu__Timestamp
#define SOAP_TYPE__wsu__Timestamp (8)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (960)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (959)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (953)
#endif

/* ns2__PauseRuleResultItems * has binding name 'PointerTons2__PauseRuleResultItems' for type 'ns2:PauseRuleResultItems' */
#ifndef SOAP_TYPE_PointerTons2__PauseRuleResultItems
#define SOAP_TYPE_PointerTons2__PauseRuleResultItems (946)
#endif

/* ns2__ProfileReplyEarly * has binding name 'PointerTons2__ProfileReplyEarly' for type 'ns2:ProfileReplyEarly' */
#ifndef SOAP_TYPE_PointerTons2__ProfileReplyEarly
#define SOAP_TYPE_PointerTons2__ProfileReplyEarly (945)
#endif

/* ns2__VCCustomData * has binding name 'PointerTons2__VCCustomData' for type 'ns2:VCCustomData' */
#ifndef SOAP_TYPE_PointerTons2__VCCustomData
#define SOAP_TYPE_PointerTons2__VCCustomData (944)
#endif

/* ns2__VCCardArt * has binding name 'PointerTons2__VCCardArt' for type 'ns2:VCCardArt' */
#ifndef SOAP_TYPE_PointerTons2__VCCardArt
#define SOAP_TYPE_PointerTons2__VCCardArt (943)
#endif

/* ns2__ReplyReserved * has binding name 'PointerTons2__ReplyReserved' for type 'ns2:ReplyReserved' */
#ifndef SOAP_TYPE_PointerTons2__ReplyReserved
#define SOAP_TYPE_PointerTons2__ReplyReserved (936)
#endif

/* ns2__AbortReply * has binding name 'PointerTons2__AbortReply' for type 'ns2:AbortReply' */
#ifndef SOAP_TYPE_PointerTons2__AbortReply
#define SOAP_TYPE_PointerTons2__AbortReply (935)
#endif

/* ns2__ECAVSReply * has binding name 'PointerTons2__ECAVSReply' for type 'ns2:ECAVSReply' */
#ifndef SOAP_TYPE_PointerTons2__ECAVSReply
#define SOAP_TYPE_PointerTons2__ECAVSReply (934)
#endif

/* ns2__CCCheckStatusReply * has binding name 'PointerTons2__CCCheckStatusReply' for type 'ns2:CCCheckStatusReply' */
#ifndef SOAP_TYPE_PointerTons2__CCCheckStatusReply
#define SOAP_TYPE_PointerTons2__CCCheckStatusReply (933)
#endif

/* ns2__GiftCardRefundReply * has binding name 'PointerTons2__GiftCardRefundReply' for type 'ns2:GiftCardRefundReply' */
#ifndef SOAP_TYPE_PointerTons2__GiftCardRefundReply
#define SOAP_TYPE_PointerTons2__GiftCardRefundReply (932)
#endif

/* ns2__GiftCardReloadReply * has binding name 'PointerTons2__GiftCardReloadReply' for type 'ns2:GiftCardReloadReply' */
#ifndef SOAP_TYPE_PointerTons2__GiftCardReloadReply
#define SOAP_TYPE_PointerTons2__GiftCardReloadReply (931)
#endif

/* ns2__GiftCardReversalReply * has binding name 'PointerTons2__GiftCardReversalReply' for type 'ns2:GiftCardReversalReply' */
#ifndef SOAP_TYPE_PointerTons2__GiftCardReversalReply
#define SOAP_TYPE_PointerTons2__GiftCardReversalReply (930)
#endif

/* ns2__GiftCardVoidReply * has binding name 'PointerTons2__GiftCardVoidReply' for type 'ns2:GiftCardVoidReply' */
#ifndef SOAP_TYPE_PointerTons2__GiftCardVoidReply
#define SOAP_TYPE_PointerTons2__GiftCardVoidReply (929)
#endif

/* ns2__GiftCardRedemptionReply * has binding name 'PointerTons2__GiftCardRedemptionReply' for type 'ns2:GiftCardRedemptionReply' */
#ifndef SOAP_TYPE_PointerTons2__GiftCardRedemptionReply
#define SOAP_TYPE_PointerTons2__GiftCardRedemptionReply (928)
#endif

/* ns2__GiftCardBalanceInquiryReply * has binding name 'PointerTons2__GiftCardBalanceInquiryReply' for type 'ns2:GiftCardBalanceInquiryReply' */
#ifndef SOAP_TYPE_PointerTons2__GiftCardBalanceInquiryReply
#define SOAP_TYPE_PointerTons2__GiftCardBalanceInquiryReply (927)
#endif

/* ns2__GiftCardActivationReply * has binding name 'PointerTons2__GiftCardActivationReply' for type 'ns2:GiftCardActivationReply' */
#ifndef SOAP_TYPE_PointerTons2__GiftCardActivationReply
#define SOAP_TYPE_PointerTons2__GiftCardActivationReply (926)
#endif

/* ns2__GetMasterpassDataReply * has binding name 'PointerTons2__GetMasterpassDataReply' for type 'ns2:GetMasterpassDataReply' */
#ifndef SOAP_TYPE_PointerTons2__GetMasterpassDataReply
#define SOAP_TYPE_PointerTons2__GetMasterpassDataReply (925)
#endif

/* ns2__APRevokeMandateReply * has binding name 'PointerTons2__APRevokeMandateReply' for type 'ns2:APRevokeMandateReply' */
#ifndef SOAP_TYPE_PointerTons2__APRevokeMandateReply
#define SOAP_TYPE_PointerTons2__APRevokeMandateReply (924)
#endif

/* ns2__APImportMandateReply * has binding name 'PointerTons2__APImportMandateReply' for type 'ns2:APImportMandateReply' */
#ifndef SOAP_TYPE_PointerTons2__APImportMandateReply
#define SOAP_TYPE_PointerTons2__APImportMandateReply (923)
#endif

/* ns2__APUpdateMandateReply * has binding name 'PointerTons2__APUpdateMandateReply' for type 'ns2:APUpdateMandateReply' */
#ifndef SOAP_TYPE_PointerTons2__APUpdateMandateReply
#define SOAP_TYPE_PointerTons2__APUpdateMandateReply (922)
#endif

/* ns2__APMandateStatusReply * has binding name 'PointerTons2__APMandateStatusReply' for type 'ns2:APMandateStatusReply' */
#ifndef SOAP_TYPE_PointerTons2__APMandateStatusReply
#define SOAP_TYPE_PointerTons2__APMandateStatusReply (921)
#endif

/* ns2__APCreateMandateReply * has binding name 'PointerTons2__APCreateMandateReply' for type 'ns2:APCreateMandateReply' */
#ifndef SOAP_TYPE_PointerTons2__APCreateMandateReply
#define SOAP_TYPE_PointerTons2__APCreateMandateReply (920)
#endif

/* ns2__Routing * has binding name 'PointerTons2__Routing' for type 'ns2:Routing' */
#ifndef SOAP_TYPE_PointerTons2__Routing
#define SOAP_TYPE_PointerTons2__Routing (919)
#endif

/* ns2__APBillingAgreementReply * has binding name 'PointerTons2__APBillingAgreementReply' for type 'ns2:APBillingAgreementReply' */
#ifndef SOAP_TYPE_PointerTons2__APBillingAgreementReply
#define SOAP_TYPE_PointerTons2__APBillingAgreementReply (917)
#endif

/* ns2__APCancelReply * has binding name 'PointerTons2__APCancelReply' for type 'ns2:APCancelReply' */
#ifndef SOAP_TYPE_PointerTons2__APCancelReply
#define SOAP_TYPE_PointerTons2__APCancelReply (916)
#endif

/* ns2__APOrderReply * has binding name 'PointerTons2__APOrderReply' for type 'ns2:APOrderReply' */
#ifndef SOAP_TYPE_PointerTons2__APOrderReply
#define SOAP_TYPE_PointerTons2__APOrderReply (915)
#endif

/* ns2__Token * has binding name 'PointerTons2__Token' for type 'ns2:Token' */
#ifndef SOAP_TYPE_PointerTons2__Token
#define SOAP_TYPE_PointerTons2__Token (913)
#endif

/* ns2__BinLookupReply * has binding name 'PointerTons2__BinLookupReply' for type 'ns2:BinLookupReply' */
#ifndef SOAP_TYPE_PointerTons2__BinLookupReply
#define SOAP_TYPE_PointerTons2__BinLookupReply (912)
#endif

/* ns2__GetVisaCheckoutDataReply * has binding name 'PointerTons2__GetVisaCheckoutDataReply' for type 'ns2:GetVisaCheckoutDataReply' */
#ifndef SOAP_TYPE_PointerTons2__GetVisaCheckoutDataReply
#define SOAP_TYPE_PointerTons2__GetVisaCheckoutDataReply (911)
#endif

/* ns2__DecryptVisaCheckoutDataReply * has binding name 'PointerTons2__DecryptVisaCheckoutDataReply' for type 'ns2:DecryptVisaCheckoutDataReply' */
#ifndef SOAP_TYPE_PointerTons2__DecryptVisaCheckoutDataReply
#define SOAP_TYPE_PointerTons2__DecryptVisaCheckoutDataReply (910)
#endif

/* ns2__VCReply * has binding name 'PointerTons2__VCReply' for type 'ns2:VCReply' */
#ifndef SOAP_TYPE_PointerTons2__VCReply
#define SOAP_TYPE_PointerTons2__VCReply (909)
#endif

/* ns2__HostedDataRetrieveReply * has binding name 'PointerTons2__HostedDataRetrieveReply' for type 'ns2:HostedDataRetrieveReply' */
#ifndef SOAP_TYPE_PointerTons2__HostedDataRetrieveReply
#define SOAP_TYPE_PointerTons2__HostedDataRetrieveReply (908)
#endif

/* ns2__HostedDataCreateReply * has binding name 'PointerTons2__HostedDataCreateReply' for type 'ns2:HostedDataCreateReply' */
#ifndef SOAP_TYPE_PointerTons2__HostedDataCreateReply
#define SOAP_TYPE_PointerTons2__HostedDataCreateReply (907)
#endif

/* ns2__OriginalTransaction * has binding name 'PointerTons2__OriginalTransaction' for type 'ns2:OriginalTransaction' */
#ifndef SOAP_TYPE_PointerTons2__OriginalTransaction
#define SOAP_TYPE_PointerTons2__OriginalTransaction (906)
#endif

/* ns2__EmvReply * has binding name 'PointerTons2__EmvReply' for type 'ns2:EmvReply' */
#ifndef SOAP_TYPE_PointerTons2__EmvReply
#define SOAP_TYPE_PointerTons2__EmvReply (905)
#endif

/* ns2__PayPalTransactionSearchReply * has binding name 'PointerTons2__PayPalTransactionSearchReply' for type 'ns2:PayPalTransactionSearchReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalTransactionSearchReply
#define SOAP_TYPE_PointerTons2__PayPalTransactionSearchReply (904)
#endif

/* ns2__PayPalGetTxnDetailsReply * has binding name 'PointerTons2__PayPalGetTxnDetailsReply' for type 'ns2:PayPalGetTxnDetailsReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalGetTxnDetailsReply
#define SOAP_TYPE_PointerTons2__PayPalGetTxnDetailsReply (903)
#endif

/* ns2__Promotion * has binding name 'PointerTons2__Promotion' for type 'ns2:Promotion' */
#ifndef SOAP_TYPE_PointerTons2__Promotion
#define SOAP_TYPE_PointerTons2__Promotion (901)
#endif

/* ns2__APConfirmPurchaseReply * has binding name 'PointerTons2__APConfirmPurchaseReply' for type 'ns2:APConfirmPurchaseReply' */
#ifndef SOAP_TYPE_PointerTons2__APConfirmPurchaseReply
#define SOAP_TYPE_PointerTons2__APConfirmPurchaseReply (900)
#endif

/* ns2__APTransactionDetailsReply * has binding name 'PointerTons2__APTransactionDetailsReply' for type 'ns2:APTransactionDetailsReply' */
#ifndef SOAP_TYPE_PointerTons2__APTransactionDetailsReply
#define SOAP_TYPE_PointerTons2__APTransactionDetailsReply (899)
#endif

/* ns2__APCheckOutDetailsReply * has binding name 'PointerTons2__APCheckOutDetailsReply' for type 'ns2:APCheckOutDetailsReply' */
#ifndef SOAP_TYPE_PointerTons2__APCheckOutDetailsReply
#define SOAP_TYPE_PointerTons2__APCheckOutDetailsReply (898)
#endif

/* ns2__APSaleReply * has binding name 'PointerTons2__APSaleReply' for type 'ns2:APSaleReply' */
#ifndef SOAP_TYPE_PointerTons2__APSaleReply
#define SOAP_TYPE_PointerTons2__APSaleReply (897)
#endif

/* ns2__APRefundReply * has binding name 'PointerTons2__APRefundReply' for type 'ns2:APRefundReply' */
#ifndef SOAP_TYPE_PointerTons2__APRefundReply
#define SOAP_TYPE_PointerTons2__APRefundReply (896)
#endif

/* ns2__APOptionsReply * has binding name 'PointerTons2__APOptionsReply' for type 'ns2:APOptionsReply' */
#ifndef SOAP_TYPE_PointerTons2__APOptionsReply
#define SOAP_TYPE_PointerTons2__APOptionsReply (895)
#endif

/* ns2__APCaptureReply * has binding name 'PointerTons2__APCaptureReply' for type 'ns2:APCaptureReply' */
#ifndef SOAP_TYPE_PointerTons2__APCaptureReply
#define SOAP_TYPE_PointerTons2__APCaptureReply (894)
#endif

/* ns2__APAuthReversalReply * has binding name 'PointerTons2__APAuthReversalReply' for type 'ns2:APAuthReversalReply' */
#ifndef SOAP_TYPE_PointerTons2__APAuthReversalReply
#define SOAP_TYPE_PointerTons2__APAuthReversalReply (893)
#endif

/* ns2__APSessionsReply * has binding name 'PointerTons2__APSessionsReply' for type 'ns2:APSessionsReply' */
#ifndef SOAP_TYPE_PointerTons2__APSessionsReply
#define SOAP_TYPE_PointerTons2__APSessionsReply (892)
#endif

/* ns2__APAuthReply * has binding name 'PointerTons2__APAuthReply' for type 'ns2:APAuthReply' */
#ifndef SOAP_TYPE_PointerTons2__APAuthReply
#define SOAP_TYPE_PointerTons2__APAuthReply (891)
#endif

/* ns2__APReply * has binding name 'PointerTons2__APReply' for type 'ns2:APReply' */
#ifndef SOAP_TYPE_PointerTons2__APReply
#define SOAP_TYPE_PointerTons2__APReply (890)
#endif

/* ns2__APCheckStatusReply * has binding name 'PointerTons2__APCheckStatusReply' for type 'ns2:APCheckStatusReply' */
#ifndef SOAP_TYPE_PointerTons2__APCheckStatusReply
#define SOAP_TYPE_PointerTons2__APCheckStatusReply (889)
#endif

/* ns2__APInitiateReply * has binding name 'PointerTons2__APInitiateReply' for type 'ns2:APInitiateReply' */
#ifndef SOAP_TYPE_PointerTons2__APInitiateReply
#define SOAP_TYPE_PointerTons2__APInitiateReply (888)
#endif

/* ns2__PinDebitReversalReply * has binding name 'PointerTons2__PinDebitReversalReply' for type 'ns2:PinDebitReversalReply' */
#ifndef SOAP_TYPE_PointerTons2__PinDebitReversalReply
#define SOAP_TYPE_PointerTons2__PinDebitReversalReply (887)
#endif

/* ns2__PinDebitCreditReply * has binding name 'PointerTons2__PinDebitCreditReply' for type 'ns2:PinDebitCreditReply' */
#ifndef SOAP_TYPE_PointerTons2__PinDebitCreditReply
#define SOAP_TYPE_PointerTons2__PinDebitCreditReply (886)
#endif

/* ns2__PinDebitPurchaseReply * has binding name 'PointerTons2__PinDebitPurchaseReply' for type 'ns2:PinDebitPurchaseReply' */
#ifndef SOAP_TYPE_PointerTons2__PinDebitPurchaseReply
#define SOAP_TYPE_PointerTons2__PinDebitPurchaseReply (885)
#endif

/* ns2__BoletoPaymentReply * has binding name 'PointerTons2__BoletoPaymentReply' for type 'ns2:BoletoPaymentReply' */
#ifndef SOAP_TYPE_PointerTons2__BoletoPaymentReply
#define SOAP_TYPE_PointerTons2__BoletoPaymentReply (884)
#endif

/* ns2__ChinaRefundReply * has binding name 'PointerTons2__ChinaRefundReply' for type 'ns2:ChinaRefundReply' */
#ifndef SOAP_TYPE_PointerTons2__ChinaRefundReply
#define SOAP_TYPE_PointerTons2__ChinaRefundReply (883)
#endif

/* ns2__ChinaPaymentReply * has binding name 'PointerTons2__ChinaPaymentReply' for type 'ns2:ChinaPaymentReply' */
#ifndef SOAP_TYPE_PointerTons2__ChinaPaymentReply
#define SOAP_TYPE_PointerTons2__ChinaPaymentReply (882)
#endif

/* ns2__PayPalDoRefTransactionReply * has binding name 'PointerTons2__PayPalDoRefTransactionReply' for type 'ns2:PayPalDoRefTransactionReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalDoRefTransactionReply
#define SOAP_TYPE_PointerTons2__PayPalDoRefTransactionReply (881)
#endif

/* ns2__PayPalCreateAgreementReply * has binding name 'PointerTons2__PayPalCreateAgreementReply' for type 'ns2:PayPalCreateAgreementReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalCreateAgreementReply
#define SOAP_TYPE_PointerTons2__PayPalCreateAgreementReply (880)
#endif

/* ns2__PayPalUpdateAgreementReply * has binding name 'PointerTons2__PayPalUpdateAgreementReply' for type 'ns2:PayPalUpdateAgreementReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalUpdateAgreementReply
#define SOAP_TYPE_PointerTons2__PayPalUpdateAgreementReply (879)
#endif

/* ns2__PayPalEcOrderSetupReply * has binding name 'PointerTons2__PayPalEcOrderSetupReply' for type 'ns2:PayPalEcOrderSetupReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalEcOrderSetupReply
#define SOAP_TYPE_PointerTons2__PayPalEcOrderSetupReply (878)
#endif

/* ns2__PayPalAuthorizationReply * has binding name 'PointerTons2__PayPalAuthorizationReply' for type 'ns2:PayPalAuthorizationReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalAuthorizationReply
#define SOAP_TYPE_PointerTons2__PayPalAuthorizationReply (877)
#endif

/* ns2__PayPalEcSetReply * has binding name 'PointerTons2__PayPalEcSetReply' for type 'ns2:PayPalEcSetReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalEcSetReply
#define SOAP_TYPE_PointerTons2__PayPalEcSetReply (876)
#endif

/* ns2__PayPalEcGetDetailsReply * has binding name 'PointerTons2__PayPalEcGetDetailsReply' for type 'ns2:PayPalEcGetDetailsReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalEcGetDetailsReply
#define SOAP_TYPE_PointerTons2__PayPalEcGetDetailsReply (875)
#endif

/* ns2__PayPalEcDoPaymentReply * has binding name 'PointerTons2__PayPalEcDoPaymentReply' for type 'ns2:PayPalEcDoPaymentReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalEcDoPaymentReply
#define SOAP_TYPE_PointerTons2__PayPalEcDoPaymentReply (874)
#endif

/* ns2__PayPalDoCaptureReply * has binding name 'PointerTons2__PayPalDoCaptureReply' for type 'ns2:PayPalDoCaptureReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalDoCaptureReply
#define SOAP_TYPE_PointerTons2__PayPalDoCaptureReply (873)
#endif

/* ns2__PayPalAuthReversalReply * has binding name 'PointerTons2__PayPalAuthReversalReply' for type 'ns2:PayPalAuthReversalReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalAuthReversalReply
#define SOAP_TYPE_PointerTons2__PayPalAuthReversalReply (872)
#endif

/* ns2__PayPalRefundReply * has binding name 'PointerTons2__PayPalRefundReply' for type 'ns2:PayPalRefundReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalRefundReply
#define SOAP_TYPE_PointerTons2__PayPalRefundReply (871)
#endif

/* ns2__DecisionReply * has binding name 'PointerTons2__DecisionReply' for type 'ns2:DecisionReply' */
#ifndef SOAP_TYPE_PointerTons2__DecisionReply
#define SOAP_TYPE_PointerTons2__DecisionReply (870)
#endif

/* ns2__DecisionEarlyReply * has binding name 'PointerTons2__DecisionEarlyReply' for type 'ns2:DecisionEarlyReply' */
#ifndef SOAP_TYPE_PointerTons2__DecisionEarlyReply
#define SOAP_TYPE_PointerTons2__DecisionEarlyReply (869)
#endif

/* ns2__CaseManagementActionReply * has binding name 'PointerTons2__CaseManagementActionReply' for type 'ns2:CaseManagementActionReply' */
#ifndef SOAP_TYPE_PointerTons2__CaseManagementActionReply
#define SOAP_TYPE_PointerTons2__CaseManagementActionReply (868)
#endif

/* ns2__FraudUpdateReply * has binding name 'PointerTons2__FraudUpdateReply' for type 'ns2:FraudUpdateReply' */
#ifndef SOAP_TYPE_PointerTons2__FraudUpdateReply
#define SOAP_TYPE_PointerTons2__FraudUpdateReply (867)
#endif

/* ns2__RiskUpdateReply * has binding name 'PointerTons2__RiskUpdateReply' for type 'ns2:RiskUpdateReply' */
#ifndef SOAP_TYPE_PointerTons2__RiskUpdateReply
#define SOAP_TYPE_PointerTons2__RiskUpdateReply (866)
#endif

/* ns2__PayPalPreapprovedUpdateReply * has binding name 'PointerTons2__PayPalPreapprovedUpdateReply' for type 'ns2:PayPalPreapprovedUpdateReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalPreapprovedUpdateReply
#define SOAP_TYPE_PointerTons2__PayPalPreapprovedUpdateReply (865)
#endif

/* ns2__PayPalPreapprovedPaymentReply * has binding name 'PointerTons2__PayPalPreapprovedPaymentReply' for type 'ns2:PayPalPreapprovedPaymentReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalPreapprovedPaymentReply
#define SOAP_TYPE_PointerTons2__PayPalPreapprovedPaymentReply (864)
#endif

/* ns2__PayPalButtonCreateReply * has binding name 'PointerTons2__PayPalButtonCreateReply' for type 'ns2:PayPalButtonCreateReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalButtonCreateReply
#define SOAP_TYPE_PointerTons2__PayPalButtonCreateReply (863)
#endif

/* ns2__PinlessDebitReversalReply * has binding name 'PointerTons2__PinlessDebitReversalReply' for type 'ns2:PinlessDebitReversalReply' */
#ifndef SOAP_TYPE_PointerTons2__PinlessDebitReversalReply
#define SOAP_TYPE_PointerTons2__PinlessDebitReversalReply (862)
#endif

/* ns2__PinlessDebitValidateReply * has binding name 'PointerTons2__PinlessDebitValidateReply' for type 'ns2:PinlessDebitValidateReply' */
#ifndef SOAP_TYPE_PointerTons2__PinlessDebitValidateReply
#define SOAP_TYPE_PointerTons2__PinlessDebitValidateReply (861)
#endif

/* ns2__PinlessDebitReply * has binding name 'PointerTons2__PinlessDebitReply' for type 'ns2:PinlessDebitReply' */
#ifndef SOAP_TYPE_PointerTons2__PinlessDebitReply
#define SOAP_TYPE_PointerTons2__PinlessDebitReply (860)
#endif

/* ns2__VoidReply * has binding name 'PointerTons2__VoidReply' for type 'ns2:VoidReply' */
#ifndef SOAP_TYPE_PointerTons2__VoidReply
#define SOAP_TYPE_PointerTons2__VoidReply (859)
#endif

/* ns2__PayPalCreditReply * has binding name 'PointerTons2__PayPalCreditReply' for type 'ns2:PayPalCreditReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalCreditReply
#define SOAP_TYPE_PointerTons2__PayPalCreditReply (858)
#endif

/* ns2__PayPalPaymentReply * has binding name 'PointerTons2__PayPalPaymentReply' for type 'ns2:PayPalPaymentReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalPaymentReply
#define SOAP_TYPE_PointerTons2__PayPalPaymentReply (857)
#endif

/* ns2__PaySubscriptionDeleteReply * has binding name 'PointerTons2__PaySubscriptionDeleteReply' for type 'ns2:PaySubscriptionDeleteReply' */
#ifndef SOAP_TYPE_PointerTons2__PaySubscriptionDeleteReply
#define SOAP_TYPE_PointerTons2__PaySubscriptionDeleteReply (856)
#endif

/* ns2__PaySubscriptionRetrieveReply * has binding name 'PointerTons2__PaySubscriptionRetrieveReply' for type 'ns2:PaySubscriptionRetrieveReply' */
#ifndef SOAP_TYPE_PointerTons2__PaySubscriptionRetrieveReply
#define SOAP_TYPE_PointerTons2__PaySubscriptionRetrieveReply (855)
#endif

/* ns2__PaySubscriptionEventUpdateReply * has binding name 'PointerTons2__PaySubscriptionEventUpdateReply' for type 'ns2:PaySubscriptionEventUpdateReply' */
#ifndef SOAP_TYPE_PointerTons2__PaySubscriptionEventUpdateReply
#define SOAP_TYPE_PointerTons2__PaySubscriptionEventUpdateReply (854)
#endif

/* ns2__PaySubscriptionUpdateReply * has binding name 'PointerTons2__PaySubscriptionUpdateReply' for type 'ns2:PaySubscriptionUpdateReply' */
#ifndef SOAP_TYPE_PointerTons2__PaySubscriptionUpdateReply
#define SOAP_TYPE_PointerTons2__PaySubscriptionUpdateReply (853)
#endif

/* ns2__PaySubscriptionCreateReply * has binding name 'PointerTons2__PaySubscriptionCreateReply' for type 'ns2:PaySubscriptionCreateReply' */
#ifndef SOAP_TYPE_PointerTons2__PaySubscriptionCreateReply
#define SOAP_TYPE_PointerTons2__PaySubscriptionCreateReply (852)
#endif

/* ns2__DirectDebitRefundReply * has binding name 'PointerTons2__DirectDebitRefundReply' for type 'ns2:DirectDebitRefundReply' */
#ifndef SOAP_TYPE_PointerTons2__DirectDebitRefundReply
#define SOAP_TYPE_PointerTons2__DirectDebitRefundReply (851)
#endif

/* ns2__DirectDebitValidateReply * has binding name 'PointerTons2__DirectDebitValidateReply' for type 'ns2:DirectDebitValidateReply' */
#ifndef SOAP_TYPE_PointerTons2__DirectDebitValidateReply
#define SOAP_TYPE_PointerTons2__DirectDebitValidateReply (850)
#endif

/* ns2__DirectDebitReply * has binding name 'PointerTons2__DirectDebitReply' for type 'ns2:DirectDebitReply' */
#ifndef SOAP_TYPE_PointerTons2__DirectDebitReply
#define SOAP_TYPE_PointerTons2__DirectDebitReply (849)
#endif

/* ns2__DirectDebitMandateReply * has binding name 'PointerTons2__DirectDebitMandateReply' for type 'ns2:DirectDebitMandateReply' */
#ifndef SOAP_TYPE_PointerTons2__DirectDebitMandateReply
#define SOAP_TYPE_PointerTons2__DirectDebitMandateReply (848)
#endif

/* ns2__BankTransferRealTimeReply * has binding name 'PointerTons2__BankTransferRealTimeReply' for type 'ns2:BankTransferRealTimeReply' */
#ifndef SOAP_TYPE_PointerTons2__BankTransferRealTimeReply
#define SOAP_TYPE_PointerTons2__BankTransferRealTimeReply (847)
#endif

/* ns2__BankTransferRefundReply * has binding name 'PointerTons2__BankTransferRefundReply' for type 'ns2:BankTransferRefundReply' */
#ifndef SOAP_TYPE_PointerTons2__BankTransferRefundReply
#define SOAP_TYPE_PointerTons2__BankTransferRefundReply (846)
#endif

/* ns2__BankTransferReply * has binding name 'PointerTons2__BankTransferReply' for type 'ns2:BankTransferReply' */
#ifndef SOAP_TYPE_PointerTons2__BankTransferReply
#define SOAP_TYPE_PointerTons2__BankTransferReply (845)
#endif

/* ns2__FXRatesReply * has binding name 'PointerTons2__FXRatesReply' for type 'ns2:FXRatesReply' */
#ifndef SOAP_TYPE_PointerTons2__FXRatesReply
#define SOAP_TYPE_PointerTons2__FXRatesReply (844)
#endif

/* ns2__ExportReply * has binding name 'PointerTons2__ExportReply' for type 'ns2:ExportReply' */
#ifndef SOAP_TYPE_PointerTons2__ExportReply
#define SOAP_TYPE_PointerTons2__ExportReply (843)
#endif

/* ns2__DAVReply * has binding name 'PointerTons2__DAVReply' for type 'ns2:DAVReply' */
#ifndef SOAP_TYPE_PointerTons2__DAVReply
#define SOAP_TYPE_PointerTons2__DAVReply (842)
#endif

/* ns2__AFSReply * has binding name 'PointerTons2__AFSReply' for type 'ns2:AFSReply' */
#ifndef SOAP_TYPE_PointerTons2__AFSReply
#define SOAP_TYPE_PointerTons2__AFSReply (841)
#endif

/* ns2__DMEReply * has binding name 'PointerTons2__DMEReply' for type 'ns2:DMEReply' */
#ifndef SOAP_TYPE_PointerTons2__DMEReply
#define SOAP_TYPE_PointerTons2__DMEReply (840)
#endif

/* ns2__EncryptPaymentDataReply * has binding name 'PointerTons2__EncryptPaymentDataReply' for type 'ns2:EncryptPaymentDataReply' */
#ifndef SOAP_TYPE_PointerTons2__EncryptPaymentDataReply
#define SOAP_TYPE_PointerTons2__EncryptPaymentDataReply (839)
#endif

/* ns2__TaxReply * has binding name 'PointerTons2__TaxReply' for type 'ns2:TaxReply' */
#ifndef SOAP_TYPE_PointerTons2__TaxReply
#define SOAP_TYPE_PointerTons2__TaxReply (838)
#endif

/* ns2__PayerAuthValidateReply * has binding name 'PointerTons2__PayerAuthValidateReply' for type 'ns2:PayerAuthValidateReply' */
#ifndef SOAP_TYPE_PointerTons2__PayerAuthValidateReply
#define SOAP_TYPE_PointerTons2__PayerAuthValidateReply (837)
#endif

/* ns2__PayerAuthEnrollReply * has binding name 'PointerTons2__PayerAuthEnrollReply' for type 'ns2:PayerAuthEnrollReply' */
#ifndef SOAP_TYPE_PointerTons2__PayerAuthEnrollReply
#define SOAP_TYPE_PointerTons2__PayerAuthEnrollReply (836)
#endif

/* ns2__PayerAuthSetupReply * has binding name 'PointerTons2__PayerAuthSetupReply' for type 'ns2:PayerAuthSetupReply' */
#ifndef SOAP_TYPE_PointerTons2__PayerAuthSetupReply
#define SOAP_TYPE_PointerTons2__PayerAuthSetupReply (835)
#endif

/* ns2__ECAuthenticateReply * has binding name 'PointerTons2__ECAuthenticateReply' for type 'ns2:ECAuthenticateReply' */
#ifndef SOAP_TYPE_PointerTons2__ECAuthenticateReply
#define SOAP_TYPE_PointerTons2__ECAuthenticateReply (834)
#endif

/* ns2__ECCreditReply * has binding name 'PointerTons2__ECCreditReply' for type 'ns2:ECCreditReply' */
#ifndef SOAP_TYPE_PointerTons2__ECCreditReply
#define SOAP_TYPE_PointerTons2__ECCreditReply (833)
#endif

/* ns2__ECDebitReply * has binding name 'PointerTons2__ECDebitReply' for type 'ns2:ECDebitReply' */
#ifndef SOAP_TYPE_PointerTons2__ECDebitReply
#define SOAP_TYPE_PointerTons2__ECDebitReply (832)
#endif

/* ns2__CCDCCUpdateReply * has binding name 'PointerTons2__CCDCCUpdateReply' for type 'ns2:CCDCCUpdateReply' */
#ifndef SOAP_TYPE_PointerTons2__CCDCCUpdateReply
#define SOAP_TYPE_PointerTons2__CCDCCUpdateReply (831)
#endif

/* ns2__CCDCCReply * has binding name 'PointerTons2__CCDCCReply' for type 'ns2:CCDCCReply' */
#ifndef SOAP_TYPE_PointerTons2__CCDCCReply
#define SOAP_TYPE_PointerTons2__CCDCCReply (830)
#endif

/* ns2__CCAutoAuthReversalReply * has binding name 'PointerTons2__CCAutoAuthReversalReply' for type 'ns2:CCAutoAuthReversalReply' */
#ifndef SOAP_TYPE_PointerTons2__CCAutoAuthReversalReply
#define SOAP_TYPE_PointerTons2__CCAutoAuthReversalReply (829)
#endif

/* ns2__CCAuthReversalReply * has binding name 'PointerTons2__CCAuthReversalReply' for type 'ns2:CCAuthReversalReply' */
#ifndef SOAP_TYPE_PointerTons2__CCAuthReversalReply
#define SOAP_TYPE_PointerTons2__CCAuthReversalReply (828)
#endif

/* ns2__CCCreditReply * has binding name 'PointerTons2__CCCreditReply' for type 'ns2:CCCreditReply' */
#ifndef SOAP_TYPE_PointerTons2__CCCreditReply
#define SOAP_TYPE_PointerTons2__CCCreditReply (827)
#endif

/* ns2__CCCaptureReply * has binding name 'PointerTons2__CCCaptureReply' for type 'ns2:CCCaptureReply' */
#ifndef SOAP_TYPE_PointerTons2__CCCaptureReply
#define SOAP_TYPE_PointerTons2__CCCaptureReply (826)
#endif

/* ns2__ServiceFeeCalculateReply * has binding name 'PointerTons2__ServiceFeeCalculateReply' for type 'ns2:ServiceFeeCalculateReply' */
#ifndef SOAP_TYPE_PointerTons2__ServiceFeeCalculateReply
#define SOAP_TYPE_PointerTons2__ServiceFeeCalculateReply (825)
#endif

/* ns2__CCIncrementalAuthReply * has binding name 'PointerTons2__CCIncrementalAuthReply' for type 'ns2:CCIncrementalAuthReply' */
#ifndef SOAP_TYPE_PointerTons2__CCIncrementalAuthReply
#define SOAP_TYPE_PointerTons2__CCIncrementalAuthReply (824)
#endif

/* ns2__CCSaleReversalReply * has binding name 'PointerTons2__CCSaleReversalReply' for type 'ns2:CCSaleReversalReply' */
#ifndef SOAP_TYPE_PointerTons2__CCSaleReversalReply
#define SOAP_TYPE_PointerTons2__CCSaleReversalReply (823)
#endif

/* ns2__CCSaleCreditReply * has binding name 'PointerTons2__CCSaleCreditReply' for type 'ns2:CCSaleCreditReply' */
#ifndef SOAP_TYPE_PointerTons2__CCSaleCreditReply
#define SOAP_TYPE_PointerTons2__CCSaleCreditReply (822)
#endif

/* ns2__CCSaleReply * has binding name 'PointerTons2__CCSaleReply' for type 'ns2:CCSaleReply' */
#ifndef SOAP_TYPE_PointerTons2__CCSaleReply
#define SOAP_TYPE_PointerTons2__CCSaleReply (821)
#endif

/* ns2__VerificationReply * has binding name 'PointerTons2__VerificationReply' for type 'ns2:VerificationReply' */
#ifndef SOAP_TYPE_PointerTons2__VerificationReply
#define SOAP_TYPE_PointerTons2__VerificationReply (820)
#endif

/* ns2__OCTReply * has binding name 'PointerTons2__OCTReply' for type 'ns2:OCTReply' */
#ifndef SOAP_TYPE_PointerTons2__OCTReply
#define SOAP_TYPE_PointerTons2__OCTReply (819)
#endif

/* ns2__CCAuthReply * has binding name 'PointerTons2__CCAuthReply' for type 'ns2:CCAuthReply' */
#ifndef SOAP_TYPE_PointerTons2__CCAuthReply
#define SOAP_TYPE_PointerTons2__CCAuthReply (818)
#endif

/* ns2__SellerProtection * has binding name 'PointerTons2__SellerProtection' for type 'ns2:SellerProtection' */
#ifndef SOAP_TYPE_PointerTons2__SellerProtection
#define SOAP_TYPE_PointerTons2__SellerProtection (815)
#endif

/* ns2__RuleResultItems * has binding name 'PointerTons2__RuleResultItems' for type 'ns2:RuleResultItems' */
#ifndef SOAP_TYPE_PointerTons2__RuleResultItems
#define SOAP_TYPE_PointerTons2__RuleResultItems (813)
#endif

/* std::string * has binding name 'PointerTons2__RestrictedDecimal' for type 'ns2:RestrictedDecimal' */
#ifndef SOAP_TYPE_PointerTons2__RestrictedDecimal
#define SOAP_TYPE_PointerTons2__RestrictedDecimal (812)
#endif

/* std::string * has binding name 'PointerTons2__RestrictedString' for type 'ns2:RestrictedString' */
#ifndef SOAP_TYPE_PointerTons2__RestrictedString
#define SOAP_TYPE_PointerTons2__RestrictedString (811)
#endif

/* ns2__Travel * has binding name 'PointerTons2__Travel' for type 'ns2:Travel' */
#ifndef SOAP_TYPE_PointerTons2__Travel
#define SOAP_TYPE_PointerTons2__Travel (806)
#endif

/* ns2__ProviderFields * has binding name 'PointerTons2__ProviderFields' for type 'ns2:ProviderFields' */
#ifndef SOAP_TYPE_PointerTons2__ProviderFields
#define SOAP_TYPE_PointerTons2__ProviderFields (805)
#endif

/* ns2__MorphingElement * has binding name 'PointerTons2__MorphingElement' for type 'ns2:MorphingElement' */
#ifndef SOAP_TYPE_PointerTons2__MorphingElement
#define SOAP_TYPE_PointerTons2__MorphingElement (804)
#endif

/* ns2__AdditionalFields * has binding name 'PointerTons2__AdditionalFields' for type 'ns2:AdditionalFields' */
#ifndef SOAP_TYPE_PointerTons2__AdditionalFields
#define SOAP_TYPE_PointerTons2__AdditionalFields (803)
#endif

/* ns2__ProfileReply * has binding name 'PointerTons2__ProfileReply' for type 'ns2:ProfileReply' */
#ifndef SOAP_TYPE_PointerTons2__ProfileReply
#define SOAP_TYPE_PointerTons2__ProfileReply (802)
#endif

/* ns2__DeviceFingerprint * has binding name 'PointerTons2__DeviceFingerprint' for type 'ns2:DeviceFingerprint' */
#ifndef SOAP_TYPE_PointerTons2__DeviceFingerprint
#define SOAP_TYPE_PointerTons2__DeviceFingerprint (799)
#endif

/* xsd__base64Binary * has binding name 'PointerToxsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_PointerToxsd__base64Binary
#define SOAP_TYPE_PointerToxsd__base64Binary (796)
#endif

/* ns2__payByPoints * has binding name 'PointerTons2__payByPoints' for type 'ns2:payByPoints' */
#ifndef SOAP_TYPE_PointerTons2__payByPoints
#define SOAP_TYPE_PointerTons2__payByPoints (795)
#endif

/* ns2__AutoRental * has binding name 'PointerTons2__AutoRental' for type 'ns2:AutoRental' */
#ifndef SOAP_TYPE_PointerTons2__AutoRental
#define SOAP_TYPE_PointerTons2__AutoRental (793)
#endif

/* ns2__AgencyInformation * has binding name 'PointerTons2__AgencyInformation' for type 'ns2:AgencyInformation' */
#ifndef SOAP_TYPE_PointerTons2__AgencyInformation
#define SOAP_TYPE_PointerTons2__AgencyInformation (792)
#endif

/* ns2__AbortService * has binding name 'PointerTons2__AbortService' for type 'ns2:AbortService' */
#ifndef SOAP_TYPE_PointerTons2__AbortService
#define SOAP_TYPE_PointerTons2__AbortService (791)
#endif

/* ns2__mPOS * has binding name 'PointerTons2__mPOS' for type 'ns2:mPOS' */
#ifndef SOAP_TYPE_PointerTons2__mPOS
#define SOAP_TYPE_PointerTons2__mPOS (790)
#endif

/* ns2__CCCheckStatusService * has binding name 'PointerTons2__CCCheckStatusService' for type 'ns2:CCCheckStatusService' */
#ifndef SOAP_TYPE_PointerTons2__CCCheckStatusService
#define SOAP_TYPE_PointerTons2__CCCheckStatusService (789)
#endif

/* ns2__GetMasterpassDataService * has binding name 'PointerTons2__GetMasterpassDataService' for type 'ns2:GetMasterpassDataService' */
#ifndef SOAP_TYPE_PointerTons2__GetMasterpassDataService
#define SOAP_TYPE_PointerTons2__GetMasterpassDataService (788)
#endif

/* ns2__PostdatedTransaction * has binding name 'PointerTons2__PostdatedTransaction' for type 'ns2:PostdatedTransaction' */
#ifndef SOAP_TYPE_PointerTons2__PostdatedTransaction
#define SOAP_TYPE_PointerTons2__PostdatedTransaction (787)
#endif

/* ns2__APRevokeMandateService * has binding name 'PointerTons2__APRevokeMandateService' for type 'ns2:APRevokeMandateService' */
#ifndef SOAP_TYPE_PointerTons2__APRevokeMandateService
#define SOAP_TYPE_PointerTons2__APRevokeMandateService (786)
#endif

/* ns2__APImportMandateService * has binding name 'PointerTons2__APImportMandateService' for type 'ns2:APImportMandateService' */
#ifndef SOAP_TYPE_PointerTons2__APImportMandateService
#define SOAP_TYPE_PointerTons2__APImportMandateService (785)
#endif

/* ns2__APUpdateMandateService * has binding name 'PointerTons2__APUpdateMandateService' for type 'ns2:APUpdateMandateService' */
#ifndef SOAP_TYPE_PointerTons2__APUpdateMandateService
#define SOAP_TYPE_PointerTons2__APUpdateMandateService (784)
#endif

/* ns2__APMandateStatusService * has binding name 'PointerTons2__APMandateStatusService' for type 'ns2:APMandateStatusService' */
#ifndef SOAP_TYPE_PointerTons2__APMandateStatusService
#define SOAP_TYPE_PointerTons2__APMandateStatusService (783)
#endif

/* ns2__APCreateMandateService * has binding name 'PointerTons2__APCreateMandateService' for type 'ns2:APCreateMandateService' */
#ifndef SOAP_TYPE_PointerTons2__APCreateMandateService
#define SOAP_TYPE_PointerTons2__APCreateMandateService (782)
#endif

/* ns2__APBillingAgreementService * has binding name 'PointerTons2__APBillingAgreementService' for type 'ns2:APBillingAgreementService' */
#ifndef SOAP_TYPE_PointerTons2__APBillingAgreementService
#define SOAP_TYPE_PointerTons2__APBillingAgreementService (781)
#endif

/* ns2__APCancelService * has binding name 'PointerTons2__APCancelService' for type 'ns2:APCancelService' */
#ifndef SOAP_TYPE_PointerTons2__APCancelService
#define SOAP_TYPE_PointerTons2__APCancelService (780)
#endif

/* ns2__APOrderService * has binding name 'PointerTons2__APOrderService' for type 'ns2:APOrderService' */
#ifndef SOAP_TYPE_PointerTons2__APOrderService
#define SOAP_TYPE_PointerTons2__APOrderService (779)
#endif

/* ns2__Loan * has binding name 'PointerTons2__Loan' for type 'ns2:Loan' */
#ifndef SOAP_TYPE_PointerTons2__Loan
#define SOAP_TYPE_PointerTons2__Loan (778)
#endif

/* ns2__TransactionMetadataService * has binding name 'PointerTons2__TransactionMetadataService' for type 'ns2:TransactionMetadataService' */
#ifndef SOAP_TYPE_PointerTons2__TransactionMetadataService
#define SOAP_TYPE_PointerTons2__TransactionMetadataService (777)
#endif

/* ns2__GETVisaCheckoutDataService * has binding name 'PointerTons2__GETVisaCheckoutDataService' for type 'ns2:GETVisaCheckoutDataService' */
#ifndef SOAP_TYPE_PointerTons2__GETVisaCheckoutDataService
#define SOAP_TYPE_PointerTons2__GETVisaCheckoutDataService (776)
#endif

/* ns2__issuer * has binding name 'PointerTons2__issuer' for type 'ns2:issuer' */
#ifndef SOAP_TYPE_PointerTons2__issuer
#define SOAP_TYPE_PointerTons2__issuer (775)
#endif

/* ns2__BinLookupService * has binding name 'PointerTons2__BinLookupService' for type 'ns2:BinLookupService' */
#ifndef SOAP_TYPE_PointerTons2__BinLookupService
#define SOAP_TYPE_PointerTons2__BinLookupService (774)
#endif

/* ns2__EncryptPaymentDataService * has binding name 'PointerTons2__EncryptPaymentDataService' for type 'ns2:EncryptPaymentDataService' */
#ifndef SOAP_TYPE_PointerTons2__EncryptPaymentDataService
#define SOAP_TYPE_PointerTons2__EncryptPaymentDataService (773)
#endif

/* ns2__Aft * has binding name 'PointerTons2__Aft' for type 'ns2:Aft' */
#ifndef SOAP_TYPE_PointerTons2__Aft
#define SOAP_TYPE_PointerTons2__Aft (772)
#endif

/* ns2__Wallet * has binding name 'PointerTons2__Wallet' for type 'ns2:Wallet' */
#ifndef SOAP_TYPE_PointerTons2__Wallet
#define SOAP_TYPE_PointerTons2__Wallet (771)
#endif

/* ns2__DecryptVisaCheckoutDataService * has binding name 'PointerTons2__DecryptVisaCheckoutDataService' for type 'ns2:DecryptVisaCheckoutDataService' */
#ifndef SOAP_TYPE_PointerTons2__DecryptVisaCheckoutDataService
#define SOAP_TYPE_PointerTons2__DecryptVisaCheckoutDataService (769)
#endif

/* ns2__VC * has binding name 'PointerTons2__VC' for type 'ns2:VC' */
#ifndef SOAP_TYPE_PointerTons2__VC
#define SOAP_TYPE_PointerTons2__VC (768)
#endif

/* ns2__AutoRentalData * has binding name 'PointerTons2__AutoRentalData' for type 'ns2:AutoRentalData' */
#ifndef SOAP_TYPE_PointerTons2__AutoRentalData
#define SOAP_TYPE_PointerTons2__AutoRentalData (767)
#endif

/* ns2__Sender * has binding name 'PointerTons2__Sender' for type 'ns2:Sender' */
#ifndef SOAP_TYPE_PointerTons2__Sender
#define SOAP_TYPE_PointerTons2__Sender (766)
#endif

/* ns2__Recipient * has binding name 'PointerTons2__Recipient' for type 'ns2:Recipient' */
#ifndef SOAP_TYPE_PointerTons2__Recipient
#define SOAP_TYPE_PointerTons2__Recipient (765)
#endif

/* ns2__PaymentNetworkToken * has binding name 'PointerTons2__PaymentNetworkToken' for type 'ns2:PaymentNetworkToken' */
#ifndef SOAP_TYPE_PointerTons2__PaymentNetworkToken
#define SOAP_TYPE_PointerTons2__PaymentNetworkToken (764)
#endif

/* ns2__HostedDataRetrieveService * has binding name 'PointerTons2__HostedDataRetrieveService' for type 'ns2:HostedDataRetrieveService' */
#ifndef SOAP_TYPE_PointerTons2__HostedDataRetrieveService
#define SOAP_TYPE_PointerTons2__HostedDataRetrieveService (763)
#endif

/* ns2__HostedDataCreateService * has binding name 'PointerTons2__HostedDataCreateService' for type 'ns2:HostedDataCreateService' */
#ifndef SOAP_TYPE_PointerTons2__HostedDataCreateService
#define SOAP_TYPE_PointerTons2__HostedDataCreateService (762)
#endif

/* ns2__merchant * has binding name 'PointerTons2__merchant' for type 'ns2:merchant' */
#ifndef SOAP_TYPE_PointerTons2__merchant
#define SOAP_TYPE_PointerTons2__merchant (761)
#endif

/* ns2__EmvRequest * has binding name 'PointerTons2__EmvRequest' for type 'ns2:EmvRequest' */
#ifndef SOAP_TYPE_PointerTons2__EmvRequest
#define SOAP_TYPE_PointerTons2__EmvRequest (760)
#endif

/* ns2__CCDCCUpdateService * has binding name 'PointerTons2__CCDCCUpdateService' for type 'ns2:CCDCCUpdateService' */
#ifndef SOAP_TYPE_PointerTons2__CCDCCUpdateService
#define SOAP_TYPE_PointerTons2__CCDCCUpdateService (759)
#endif

/* ns2__PayPalTransactionSearchService * has binding name 'PointerTons2__PayPalTransactionSearchService' for type 'ns2:PayPalTransactionSearchService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalTransactionSearchService
#define SOAP_TYPE_PointerTons2__PayPalTransactionSearchService (758)
#endif

/* ns2__PayPalGetTxnDetailsService * has binding name 'PointerTons2__PayPalGetTxnDetailsService' for type 'ns2:PayPalGetTxnDetailsService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalGetTxnDetailsService
#define SOAP_TYPE_PointerTons2__PayPalGetTxnDetailsService (757)
#endif

/* ns2__APConfirmPurchaseService * has binding name 'PointerTons2__APConfirmPurchaseService' for type 'ns2:APConfirmPurchaseService' */
#ifndef SOAP_TYPE_PointerTons2__APConfirmPurchaseService
#define SOAP_TYPE_PointerTons2__APConfirmPurchaseService (756)
#endif

/* ns2__APTransactionDetailsService * has binding name 'PointerTons2__APTransactionDetailsService' for type 'ns2:APTransactionDetailsService' */
#ifndef SOAP_TYPE_PointerTons2__APTransactionDetailsService
#define SOAP_TYPE_PointerTons2__APTransactionDetailsService (755)
#endif

/* ns2__APUI * has binding name 'PointerTons2__APUI' for type 'ns2:APUI' */
#ifndef SOAP_TYPE_PointerTons2__APUI
#define SOAP_TYPE_PointerTons2__APUI (754)
#endif

/* ns2__APSessionsService * has binding name 'PointerTons2__APSessionsService' for type 'ns2:APSessionsService' */
#ifndef SOAP_TYPE_PointerTons2__APSessionsService
#define SOAP_TYPE_PointerTons2__APSessionsService (753)
#endif

/* ns2__APCheckOutDetailsService * has binding name 'PointerTons2__APCheckOutDetailsService' for type 'ns2:APCheckOutDetailsService' */
#ifndef SOAP_TYPE_PointerTons2__APCheckOutDetailsService
#define SOAP_TYPE_PointerTons2__APCheckOutDetailsService (752)
#endif

/* ns2__APSaleService * has binding name 'PointerTons2__APSaleService' for type 'ns2:APSaleService' */
#ifndef SOAP_TYPE_PointerTons2__APSaleService
#define SOAP_TYPE_PointerTons2__APSaleService (751)
#endif

/* ns2__APRefundService * has binding name 'PointerTons2__APRefundService' for type 'ns2:APRefundService' */
#ifndef SOAP_TYPE_PointerTons2__APRefundService
#define SOAP_TYPE_PointerTons2__APRefundService (750)
#endif

/* ns2__APOptionsService * has binding name 'PointerTons2__APOptionsService' for type 'ns2:APOptionsService' */
#ifndef SOAP_TYPE_PointerTons2__APOptionsService
#define SOAP_TYPE_PointerTons2__APOptionsService (749)
#endif

/* ns2__APCaptureService * has binding name 'PointerTons2__APCaptureService' for type 'ns2:APCaptureService' */
#ifndef SOAP_TYPE_PointerTons2__APCaptureService
#define SOAP_TYPE_PointerTons2__APCaptureService (748)
#endif

/* ns2__APAuthReversalService * has binding name 'PointerTons2__APAuthReversalService' for type 'ns2:APAuthReversalService' */
#ifndef SOAP_TYPE_PointerTons2__APAuthReversalService
#define SOAP_TYPE_PointerTons2__APAuthReversalService (747)
#endif

/* ns2__APAuthService * has binding name 'PointerTons2__APAuthService' for type 'ns2:APAuthService' */
#ifndef SOAP_TYPE_PointerTons2__APAuthService
#define SOAP_TYPE_PointerTons2__APAuthService (746)
#endif

/* ns2__AP * has binding name 'PointerTons2__AP' for type 'ns2:AP' */
#ifndef SOAP_TYPE_PointerTons2__AP
#define SOAP_TYPE_PointerTons2__AP (745)
#endif

/* ns2__PinDebitReversalService * has binding name 'PointerTons2__PinDebitReversalService' for type 'ns2:PinDebitReversalService' */
#ifndef SOAP_TYPE_PointerTons2__PinDebitReversalService
#define SOAP_TYPE_PointerTons2__PinDebitReversalService (744)
#endif

/* ns2__PinDebitCreditService * has binding name 'PointerTons2__PinDebitCreditService' for type 'ns2:PinDebitCreditService' */
#ifndef SOAP_TYPE_PointerTons2__PinDebitCreditService
#define SOAP_TYPE_PointerTons2__PinDebitCreditService (743)
#endif

/* ns2__PinDebitPurchaseService * has binding name 'PointerTons2__PinDebitPurchaseService' for type 'ns2:PinDebitPurchaseService' */
#ifndef SOAP_TYPE_PointerTons2__PinDebitPurchaseService
#define SOAP_TYPE_PointerTons2__PinDebitPurchaseService (742)
#endif

/* ns2__APCheckStatusService * has binding name 'PointerTons2__APCheckStatusService' for type 'ns2:APCheckStatusService' */
#ifndef SOAP_TYPE_PointerTons2__APCheckStatusService
#define SOAP_TYPE_PointerTons2__APCheckStatusService (741)
#endif

/* ns2__APInitiateService * has binding name 'PointerTons2__APInitiateService' for type 'ns2:APInitiateService' */
#ifndef SOAP_TYPE_PointerTons2__APInitiateService
#define SOAP_TYPE_PointerTons2__APInitiateService (740)
#endif

/* ns2__BoletoPaymentService * has binding name 'PointerTons2__BoletoPaymentService' for type 'ns2:BoletoPaymentService' */
#ifndef SOAP_TYPE_PointerTons2__BoletoPaymentService
#define SOAP_TYPE_PointerTons2__BoletoPaymentService (739)
#endif

/* ns2__ChinaRefundService * has binding name 'PointerTons2__ChinaRefundService' for type 'ns2:ChinaRefundService' */
#ifndef SOAP_TYPE_PointerTons2__ChinaRefundService
#define SOAP_TYPE_PointerTons2__ChinaRefundService (738)
#endif

/* ns2__ChinaPaymentService * has binding name 'PointerTons2__ChinaPaymentService' for type 'ns2:ChinaPaymentService' */
#ifndef SOAP_TYPE_PointerTons2__ChinaPaymentService
#define SOAP_TYPE_PointerTons2__ChinaPaymentService (737)
#endif

/* ns2__PayPalDoRefTransactionService * has binding name 'PointerTons2__PayPalDoRefTransactionService' for type 'ns2:PayPalDoRefTransactionService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalDoRefTransactionService
#define SOAP_TYPE_PointerTons2__PayPalDoRefTransactionService (736)
#endif

/* ns2__PayPalCreateAgreementService * has binding name 'PointerTons2__PayPalCreateAgreementService' for type 'ns2:PayPalCreateAgreementService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalCreateAgreementService
#define SOAP_TYPE_PointerTons2__PayPalCreateAgreementService (735)
#endif

/* ns2__PayPalUpdateAgreementService * has binding name 'PointerTons2__PayPalUpdateAgreementService' for type 'ns2:PayPalUpdateAgreementService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalUpdateAgreementService
#define SOAP_TYPE_PointerTons2__PayPalUpdateAgreementService (734)
#endif

/* ns2__PayPalAuthorizationService * has binding name 'PointerTons2__PayPalAuthorizationService' for type 'ns2:PayPalAuthorizationService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalAuthorizationService
#define SOAP_TYPE_PointerTons2__PayPalAuthorizationService (733)
#endif

/* ns2__PayPalEcOrderSetupService * has binding name 'PointerTons2__PayPalEcOrderSetupService' for type 'ns2:PayPalEcOrderSetupService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalEcOrderSetupService
#define SOAP_TYPE_PointerTons2__PayPalEcOrderSetupService (732)
#endif

/* ns2__PayPalEcSetService * has binding name 'PointerTons2__PayPalEcSetService' for type 'ns2:PayPalEcSetService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalEcSetService
#define SOAP_TYPE_PointerTons2__PayPalEcSetService (731)
#endif

/* ns2__PayPalEcGetDetailsService * has binding name 'PointerTons2__PayPalEcGetDetailsService' for type 'ns2:PayPalEcGetDetailsService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalEcGetDetailsService
#define SOAP_TYPE_PointerTons2__PayPalEcGetDetailsService (730)
#endif

/* ns2__PayPalEcDoPaymentService * has binding name 'PointerTons2__PayPalEcDoPaymentService' for type 'ns2:PayPalEcDoPaymentService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalEcDoPaymentService
#define SOAP_TYPE_PointerTons2__PayPalEcDoPaymentService (729)
#endif

/* ns2__PayPalDoCaptureService * has binding name 'PointerTons2__PayPalDoCaptureService' for type 'ns2:PayPalDoCaptureService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalDoCaptureService
#define SOAP_TYPE_PointerTons2__PayPalDoCaptureService (728)
#endif

/* ns2__PayPalAuthReversalService * has binding name 'PointerTons2__PayPalAuthReversalService' for type 'ns2:PayPalAuthReversalService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalAuthReversalService
#define SOAP_TYPE_PointerTons2__PayPalAuthReversalService (727)
#endif

/* ns2__PayPalRefundService * has binding name 'PointerTons2__PayPalRefundService' for type 'ns2:PayPalRefundService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalRefundService
#define SOAP_TYPE_PointerTons2__PayPalRefundService (726)
#endif

/* ns2__CaseManagementActionService * has binding name 'PointerTons2__CaseManagementActionService' for type 'ns2:CaseManagementActionService' */
#ifndef SOAP_TYPE_PointerTons2__CaseManagementActionService
#define SOAP_TYPE_PointerTons2__CaseManagementActionService (724)
#endif

/* ns2__FraudUpdateService * has binding name 'PointerTons2__FraudUpdateService' for type 'ns2:FraudUpdateService' */
#ifndef SOAP_TYPE_PointerTons2__FraudUpdateService
#define SOAP_TYPE_PointerTons2__FraudUpdateService (723)
#endif

/* ns2__RiskUpdateService * has binding name 'PointerTons2__RiskUpdateService' for type 'ns2:RiskUpdateService' */
#ifndef SOAP_TYPE_PointerTons2__RiskUpdateService
#define SOAP_TYPE_PointerTons2__RiskUpdateService (722)
#endif

/* ns2__PayPalPreapprovedUpdateService * has binding name 'PointerTons2__PayPalPreapprovedUpdateService' for type 'ns2:PayPalPreapprovedUpdateService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalPreapprovedUpdateService
#define SOAP_TYPE_PointerTons2__PayPalPreapprovedUpdateService (721)
#endif

/* ns2__PayPalPreapprovedPaymentService * has binding name 'PointerTons2__PayPalPreapprovedPaymentService' for type 'ns2:PayPalPreapprovedPaymentService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalPreapprovedPaymentService
#define SOAP_TYPE_PointerTons2__PayPalPreapprovedPaymentService (720)
#endif

/* ns2__PayPalButtonCreateService * has binding name 'PointerTons2__PayPalButtonCreateService' for type 'ns2:PayPalButtonCreateService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalButtonCreateService
#define SOAP_TYPE_PointerTons2__PayPalButtonCreateService (719)
#endif

/* ns2__LodgingData * has binding name 'PointerTons2__LodgingData' for type 'ns2:LodgingData' */
#ifndef SOAP_TYPE_PointerTons2__LodgingData
#define SOAP_TYPE_PointerTons2__LodgingData (718)
#endif

/* ns2__AncillaryData * has binding name 'PointerTons2__AncillaryData' for type 'ns2:AncillaryData' */
#ifndef SOAP_TYPE_PointerTons2__AncillaryData
#define SOAP_TYPE_PointerTons2__AncillaryData (717)
#endif

/* ns2__AirlineData * has binding name 'PointerTons2__AirlineData' for type 'ns2:AirlineData' */
#ifndef SOAP_TYPE_PointerTons2__AirlineData
#define SOAP_TYPE_PointerTons2__AirlineData (716)
#endif

/* ns2__Batch * has binding name 'PointerTons2__Batch' for type 'ns2:Batch' */
#ifndef SOAP_TYPE_PointerTons2__Batch
#define SOAP_TYPE_PointerTons2__Batch (715)
#endif

/* ns2__PinlessDebitReversalService * has binding name 'PointerTons2__PinlessDebitReversalService' for type 'ns2:PinlessDebitReversalService' */
#ifndef SOAP_TYPE_PointerTons2__PinlessDebitReversalService
#define SOAP_TYPE_PointerTons2__PinlessDebitReversalService (714)
#endif

/* ns2__PinlessDebitValidateService * has binding name 'PointerTons2__PinlessDebitValidateService' for type 'ns2:PinlessDebitValidateService' */
#ifndef SOAP_TYPE_PointerTons2__PinlessDebitValidateService
#define SOAP_TYPE_PointerTons2__PinlessDebitValidateService (713)
#endif

/* ns2__PinlessDebitService * has binding name 'PointerTons2__PinlessDebitService' for type 'ns2:PinlessDebitService' */
#ifndef SOAP_TYPE_PointerTons2__PinlessDebitService
#define SOAP_TYPE_PointerTons2__PinlessDebitService (712)
#endif

/* ns2__BusinessRules * has binding name 'PointerTons2__BusinessRules' for type 'ns2:BusinessRules' */
#ifndef SOAP_TYPE_PointerTons2__BusinessRules
#define SOAP_TYPE_PointerTons2__BusinessRules (711)
#endif

/* ns2__VoidService * has binding name 'PointerTons2__VoidService' for type 'ns2:VoidService' */
#ifndef SOAP_TYPE_PointerTons2__VoidService
#define SOAP_TYPE_PointerTons2__VoidService (710)
#endif

/* ns2__PayPalCreditService * has binding name 'PointerTons2__PayPalCreditService' for type 'ns2:PayPalCreditService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalCreditService
#define SOAP_TYPE_PointerTons2__PayPalCreditService (709)
#endif

/* ns2__PayPalPaymentService * has binding name 'PointerTons2__PayPalPaymentService' for type 'ns2:PayPalPaymentService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalPaymentService
#define SOAP_TYPE_PointerTons2__PayPalPaymentService (708)
#endif

/* ns2__PaySubscriptionDeleteService * has binding name 'PointerTons2__PaySubscriptionDeleteService' for type 'ns2:PaySubscriptionDeleteService' */
#ifndef SOAP_TYPE_PointerTons2__PaySubscriptionDeleteService
#define SOAP_TYPE_PointerTons2__PaySubscriptionDeleteService (707)
#endif

/* ns2__PaySubscriptionRetrieveService * has binding name 'PointerTons2__PaySubscriptionRetrieveService' for type 'ns2:PaySubscriptionRetrieveService' */
#ifndef SOAP_TYPE_PointerTons2__PaySubscriptionRetrieveService
#define SOAP_TYPE_PointerTons2__PaySubscriptionRetrieveService (706)
#endif

/* ns2__PaySubscriptionEventUpdateService * has binding name 'PointerTons2__PaySubscriptionEventUpdateService' for type 'ns2:PaySubscriptionEventUpdateService' */
#ifndef SOAP_TYPE_PointerTons2__PaySubscriptionEventUpdateService
#define SOAP_TYPE_PointerTons2__PaySubscriptionEventUpdateService (705)
#endif

/* ns2__PaySubscriptionUpdateService * has binding name 'PointerTons2__PaySubscriptionUpdateService' for type 'ns2:PaySubscriptionUpdateService' */
#ifndef SOAP_TYPE_PointerTons2__PaySubscriptionUpdateService
#define SOAP_TYPE_PointerTons2__PaySubscriptionUpdateService (704)
#endif

/* ns2__PaySubscriptionCreateService * has binding name 'PointerTons2__PaySubscriptionCreateService' for type 'ns2:PaySubscriptionCreateService' */
#ifndef SOAP_TYPE_PointerTons2__PaySubscriptionCreateService
#define SOAP_TYPE_PointerTons2__PaySubscriptionCreateService (703)
#endif

/* ns2__DirectDebitValidateService * has binding name 'PointerTons2__DirectDebitValidateService' for type 'ns2:DirectDebitValidateService' */
#ifndef SOAP_TYPE_PointerTons2__DirectDebitValidateService
#define SOAP_TYPE_PointerTons2__DirectDebitValidateService (701)
#endif

/* ns2__DirectDebitRefundService * has binding name 'PointerTons2__DirectDebitRefundService' for type 'ns2:DirectDebitRefundService' */
#ifndef SOAP_TYPE_PointerTons2__DirectDebitRefundService
#define SOAP_TYPE_PointerTons2__DirectDebitRefundService (700)
#endif

/* ns2__DirectDebitService * has binding name 'PointerTons2__DirectDebitService' for type 'ns2:DirectDebitService' */
#ifndef SOAP_TYPE_PointerTons2__DirectDebitService
#define SOAP_TYPE_PointerTons2__DirectDebitService (699)
#endif

/* ns2__DirectDebitMandateService * has binding name 'PointerTons2__DirectDebitMandateService' for type 'ns2:DirectDebitMandateService' */
#ifndef SOAP_TYPE_PointerTons2__DirectDebitMandateService
#define SOAP_TYPE_PointerTons2__DirectDebitMandateService (698)
#endif

/* ns2__BankTransferRealTimeService * has binding name 'PointerTons2__BankTransferRealTimeService' for type 'ns2:BankTransferRealTimeService' */
#ifndef SOAP_TYPE_PointerTons2__BankTransferRealTimeService
#define SOAP_TYPE_PointerTons2__BankTransferRealTimeService (697)
#endif

/* ns2__BankTransferRefundService * has binding name 'PointerTons2__BankTransferRefundService' for type 'ns2:BankTransferRefundService' */
#ifndef SOAP_TYPE_PointerTons2__BankTransferRefundService
#define SOAP_TYPE_PointerTons2__BankTransferRefundService (696)
#endif

/* ns2__BankTransferService * has binding name 'PointerTons2__BankTransferService' for type 'ns2:BankTransferService' */
#ifndef SOAP_TYPE_PointerTons2__BankTransferService
#define SOAP_TYPE_PointerTons2__BankTransferService (695)
#endif

/* ns2__FXRatesService * has binding name 'PointerTons2__FXRatesService' for type 'ns2:FXRatesService' */
#ifndef SOAP_TYPE_PointerTons2__FXRatesService
#define SOAP_TYPE_PointerTons2__FXRatesService (694)
#endif

/* ns2__ExportService * has binding name 'PointerTons2__ExportService' for type 'ns2:ExportService' */
#ifndef SOAP_TYPE_PointerTons2__ExportService
#define SOAP_TYPE_PointerTons2__ExportService (693)
#endif

/* ns2__DAVService * has binding name 'PointerTons2__DAVService' for type 'ns2:DAVService' */
#ifndef SOAP_TYPE_PointerTons2__DAVService
#define SOAP_TYPE_PointerTons2__DAVService (692)
#endif

/* ns2__AFSService * has binding name 'PointerTons2__AFSService' for type 'ns2:AFSService' */
#ifndef SOAP_TYPE_PointerTons2__AFSService
#define SOAP_TYPE_PointerTons2__AFSService (691)
#endif

/* ns2__DMEService * has binding name 'PointerTons2__DMEService' for type 'ns2:DMEService' */
#ifndef SOAP_TYPE_PointerTons2__DMEService
#define SOAP_TYPE_PointerTons2__DMEService (690)
#endif

/* ns2__TaxService * has binding name 'PointerTons2__TaxService' for type 'ns2:TaxService' */
#ifndef SOAP_TYPE_PointerTons2__TaxService
#define SOAP_TYPE_PointerTons2__TaxService (689)
#endif

/* ns2__PayerAuthValidateService * has binding name 'PointerTons2__PayerAuthValidateService' for type 'ns2:PayerAuthValidateService' */
#ifndef SOAP_TYPE_PointerTons2__PayerAuthValidateService
#define SOAP_TYPE_PointerTons2__PayerAuthValidateService (688)
#endif

/* ns2__PayerAuthEnrollService * has binding name 'PointerTons2__PayerAuthEnrollService' for type 'ns2:PayerAuthEnrollService' */
#ifndef SOAP_TYPE_PointerTons2__PayerAuthEnrollService
#define SOAP_TYPE_PointerTons2__PayerAuthEnrollService (687)
#endif

/* ns2__PayerAuthSetupService * has binding name 'PointerTons2__PayerAuthSetupService' for type 'ns2:PayerAuthSetupService' */
#ifndef SOAP_TYPE_PointerTons2__PayerAuthSetupService
#define SOAP_TYPE_PointerTons2__PayerAuthSetupService (686)
#endif

/* ns2__ECAuthenticateService * has binding name 'PointerTons2__ECAuthenticateService' for type 'ns2:ECAuthenticateService' */
#ifndef SOAP_TYPE_PointerTons2__ECAuthenticateService
#define SOAP_TYPE_PointerTons2__ECAuthenticateService (685)
#endif

/* ns2__ECCreditService * has binding name 'PointerTons2__ECCreditService' for type 'ns2:ECCreditService' */
#ifndef SOAP_TYPE_PointerTons2__ECCreditService
#define SOAP_TYPE_PointerTons2__ECCreditService (684)
#endif

/* ns2__ECDebitService * has binding name 'PointerTons2__ECDebitService' for type 'ns2:ECDebitService' */
#ifndef SOAP_TYPE_PointerTons2__ECDebitService
#define SOAP_TYPE_PointerTons2__ECDebitService (683)
#endif

/* ns2__ServiceFeeCalculateService * has binding name 'PointerTons2__ServiceFeeCalculateService' for type 'ns2:ServiceFeeCalculateService' */
#ifndef SOAP_TYPE_PointerTons2__ServiceFeeCalculateService
#define SOAP_TYPE_PointerTons2__ServiceFeeCalculateService (682)
#endif

/* ns2__CCDCCService * has binding name 'PointerTons2__CCDCCService' for type 'ns2:CCDCCService' */
#ifndef SOAP_TYPE_PointerTons2__CCDCCService
#define SOAP_TYPE_PointerTons2__CCDCCService (681)
#endif

/* ns2__CCAutoAuthReversalService * has binding name 'PointerTons2__CCAutoAuthReversalService' for type 'ns2:CCAutoAuthReversalService' */
#ifndef SOAP_TYPE_PointerTons2__CCAutoAuthReversalService
#define SOAP_TYPE_PointerTons2__CCAutoAuthReversalService (680)
#endif

/* ns2__CCAuthReversalService * has binding name 'PointerTons2__CCAuthReversalService' for type 'ns2:CCAuthReversalService' */
#ifndef SOAP_TYPE_PointerTons2__CCAuthReversalService
#define SOAP_TYPE_PointerTons2__CCAuthReversalService (679)
#endif

/* ns2__CCCreditService * has binding name 'PointerTons2__CCCreditService' for type 'ns2:CCCreditService' */
#ifndef SOAP_TYPE_PointerTons2__CCCreditService
#define SOAP_TYPE_PointerTons2__CCCreditService (678)
#endif

/* ns2__CCCaptureService * has binding name 'PointerTons2__CCCaptureService' for type 'ns2:CCCaptureService' */
#ifndef SOAP_TYPE_PointerTons2__CCCaptureService
#define SOAP_TYPE_PointerTons2__CCCaptureService (677)
#endif

/* ns2__CCIncrementalAuthService * has binding name 'PointerTons2__CCIncrementalAuthService' for type 'ns2:CCIncrementalAuthService' */
#ifndef SOAP_TYPE_PointerTons2__CCIncrementalAuthService
#define SOAP_TYPE_PointerTons2__CCIncrementalAuthService (676)
#endif

/* ns2__CCSaleReversalService * has binding name 'PointerTons2__CCSaleReversalService' for type 'ns2:CCSaleReversalService' */
#ifndef SOAP_TYPE_PointerTons2__CCSaleReversalService
#define SOAP_TYPE_PointerTons2__CCSaleReversalService (675)
#endif

/* ns2__CCSaleCreditService * has binding name 'PointerTons2__CCSaleCreditService' for type 'ns2:CCSaleCreditService' */
#ifndef SOAP_TYPE_PointerTons2__CCSaleCreditService
#define SOAP_TYPE_PointerTons2__CCSaleCreditService (674)
#endif

/* ns2__CCSaleService * has binding name 'PointerTons2__CCSaleService' for type 'ns2:CCSaleService' */
#ifndef SOAP_TYPE_PointerTons2__CCSaleService
#define SOAP_TYPE_PointerTons2__CCSaleService (673)
#endif

/* ns2__VerificationService * has binding name 'PointerTons2__VerificationService' for type 'ns2:VerificationService' */
#ifndef SOAP_TYPE_PointerTons2__VerificationService
#define SOAP_TYPE_PointerTons2__VerificationService (672)
#endif

/* ns2__GiftCardRefundService * has binding name 'PointerTons2__GiftCardRefundService' for type 'ns2:GiftCardRefundService' */
#ifndef SOAP_TYPE_PointerTons2__GiftCardRefundService
#define SOAP_TYPE_PointerTons2__GiftCardRefundService (671)
#endif

/* ns2__GiftCardReloadService * has binding name 'PointerTons2__GiftCardReloadService' for type 'ns2:GiftCardReloadService' */
#ifndef SOAP_TYPE_PointerTons2__GiftCardReloadService
#define SOAP_TYPE_PointerTons2__GiftCardReloadService (670)
#endif

/* ns2__GiftCardReversalService * has binding name 'PointerTons2__GiftCardReversalService' for type 'ns2:GiftCardReversalService' */
#ifndef SOAP_TYPE_PointerTons2__GiftCardReversalService
#define SOAP_TYPE_PointerTons2__GiftCardReversalService (669)
#endif

/* ns2__GiftCardVoidService * has binding name 'PointerTons2__GiftCardVoidService' for type 'ns2:GiftCardVoidService' */
#ifndef SOAP_TYPE_PointerTons2__GiftCardVoidService
#define SOAP_TYPE_PointerTons2__GiftCardVoidService (668)
#endif

/* ns2__GiftCardRedemptionService * has binding name 'PointerTons2__GiftCardRedemptionService' for type 'ns2:GiftCardRedemptionService' */
#ifndef SOAP_TYPE_PointerTons2__GiftCardRedemptionService
#define SOAP_TYPE_PointerTons2__GiftCardRedemptionService (667)
#endif

/* ns2__GiftCardBalanceInquiryService * has binding name 'PointerTons2__GiftCardBalanceInquiryService' for type 'ns2:GiftCardBalanceInquiryService' */
#ifndef SOAP_TYPE_PointerTons2__GiftCardBalanceInquiryService
#define SOAP_TYPE_PointerTons2__GiftCardBalanceInquiryService (666)
#endif

/* ns2__GiftCardActivationService * has binding name 'PointerTons2__GiftCardActivationService' for type 'ns2:GiftCardActivationService' */
#ifndef SOAP_TYPE_PointerTons2__GiftCardActivationService
#define SOAP_TYPE_PointerTons2__GiftCardActivationService (665)
#endif

/* ns2__ECAVSService * has binding name 'PointerTons2__ECAVSService' for type 'ns2:ECAVSService' */
#ifndef SOAP_TYPE_PointerTons2__ECAVSService
#define SOAP_TYPE_PointerTons2__ECAVSService (664)
#endif

/* ns2__OCTService * has binding name 'PointerTons2__OCTService' for type 'ns2:OCTService' */
#ifndef SOAP_TYPE_PointerTons2__OCTService
#define SOAP_TYPE_PointerTons2__OCTService (663)
#endif

/* ns2__CCAuthService * has binding name 'PointerTons2__CCAuthService' for type 'ns2:CCAuthService' */
#ifndef SOAP_TYPE_PointerTons2__CCAuthService
#define SOAP_TYPE_PointerTons2__CCAuthService (662)
#endif

/* ns2__GiftCard * has binding name 'PointerTons2__GiftCard' for type 'ns2:GiftCard' */
#ifndef SOAP_TYPE_PointerTons2__GiftCard
#define SOAP_TYPE_PointerTons2__GiftCard (661)
#endif

/* ns2__ServiceFee * has binding name 'PointerTons2__ServiceFee' for type 'ns2:ServiceFee' */
#ifndef SOAP_TYPE_PointerTons2__ServiceFee
#define SOAP_TYPE_PointerTons2__ServiceFee (660)
#endif

/* ns2__JPO * has binding name 'PointerTons2__JPO' for type 'ns2:JPO' */
#ifndef SOAP_TYPE_PointerTons2__JPO
#define SOAP_TYPE_PointerTons2__JPO (659)
#endif

/* ns2__MerchantSecureData * has binding name 'PointerTons2__MerchantSecureData' for type 'ns2:MerchantSecureData' */
#ifndef SOAP_TYPE_PointerTons2__MerchantSecureData
#define SOAP_TYPE_PointerTons2__MerchantSecureData (658)
#endif

/* ns2__AuxiliaryData * has binding name 'PointerTons2__AuxiliaryData' for type 'ns2:AuxiliaryData' */
#ifndef SOAP_TYPE_PointerTons2__AuxiliaryData
#define SOAP_TYPE_PointerTons2__AuxiliaryData (657)
#endif

/* ns2__MerchantDefinedData * has binding name 'PointerTons2__MerchantDefinedData' for type 'ns2:MerchantDefinedData' */
#ifndef SOAP_TYPE_PointerTons2__MerchantDefinedData
#define SOAP_TYPE_PointerTons2__MerchantDefinedData (656)
#endif

/* ns2__PayPal * has binding name 'PointerTons2__PayPal' for type 'ns2:PayPal' */
#ifndef SOAP_TYPE_PointerTons2__PayPal
#define SOAP_TYPE_PointerTons2__PayPal (655)
#endif

/* ns2__OtherTax * has binding name 'PointerTons2__OtherTax' for type 'ns2:OtherTax' */
#ifndef SOAP_TYPE_PointerTons2__OtherTax
#define SOAP_TYPE_PointerTons2__OtherTax (654)
#endif

/* ns2__DecisionManager * has binding name 'PointerTons2__DecisionManager' for type 'ns2:DecisionManager' */
#ifndef SOAP_TYPE_PointerTons2__DecisionManager
#define SOAP_TYPE_PointerTons2__DecisionManager (653)
#endif

/* ns2__TokenSource * has binding name 'PointerTons2__TokenSource' for type 'ns2:TokenSource' */
#ifndef SOAP_TYPE_PointerTons2__TokenSource
#define SOAP_TYPE_PointerTons2__TokenSource (652)
#endif

/* ns2__RecurringSubscriptionInfo * has binding name 'PointerTons2__RecurringSubscriptionInfo' for type 'ns2:RecurringSubscriptionInfo' */
#ifndef SOAP_TYPE_PointerTons2__RecurringSubscriptionInfo
#define SOAP_TYPE_PointerTons2__RecurringSubscriptionInfo (651)
#endif

/* ns2__Subscription * has binding name 'PointerTons2__Subscription' for type 'ns2:Subscription' */
#ifndef SOAP_TYPE_PointerTons2__Subscription
#define SOAP_TYPE_PointerTons2__Subscription (650)
#endif

/* ns2__BankInfo * has binding name 'PointerTons2__BankInfo' for type 'ns2:BankInfo' */
#ifndef SOAP_TYPE_PointerTons2__BankInfo
#define SOAP_TYPE_PointerTons2__BankInfo (649)
#endif

/* ns2__FundTransfer * has binding name 'PointerTons2__FundTransfer' for type 'ns2:FundTransfer' */
#ifndef SOAP_TYPE_PointerTons2__FundTransfer
#define SOAP_TYPE_PointerTons2__FundTransfer (648)
#endif

/* ns2__UCAF * has binding name 'PointerTons2__UCAF' for type 'ns2:UCAF' */
#ifndef SOAP_TYPE_PointerTons2__UCAF
#define SOAP_TYPE_PointerTons2__UCAF (647)
#endif

/* ns2__GECC * has binding name 'PointerTons2__GECC' for type 'ns2:GECC' */
#ifndef SOAP_TYPE_PointerTons2__GECC
#define SOAP_TYPE_PointerTons2__GECC (646)
#endif

/* ns2__BML * has binding name 'PointerTons2__BML' for type 'ns2:BML' */
#ifndef SOAP_TYPE_PointerTons2__BML
#define SOAP_TYPE_PointerTons2__BML (645)
#endif

/* ns2__Check * has binding name 'PointerTons2__Check' for type 'ns2:Check' */
#ifndef SOAP_TYPE_PointerTons2__Check
#define SOAP_TYPE_PointerTons2__Check (644)
#endif

/* ns2__Category * has binding name 'PointerTons2__Category' for type 'ns2:Category' */
#ifndef SOAP_TYPE_PointerTons2__Category
#define SOAP_TYPE_PointerTons2__Category (643)
#endif

/* ns2__Card * has binding name 'PointerTons2__Card' for type 'ns2:Card' */
#ifndef SOAP_TYPE_PointerTons2__Card
#define SOAP_TYPE_PointerTons2__Card (642)
#endif

/* ns2__Installment * has binding name 'PointerTons2__Installment' for type 'ns2:Installment' */
#ifndef SOAP_TYPE_PointerTons2__Installment
#define SOAP_TYPE_PointerTons2__Installment (641)
#endif

/* ns2__EncryptedPayment * has binding name 'PointerTons2__EncryptedPayment' for type 'ns2:EncryptedPayment' */
#ifndef SOAP_TYPE_PointerTons2__EncryptedPayment
#define SOAP_TYPE_PointerTons2__EncryptedPayment (640)
#endif

/* ns2__Pin * has binding name 'PointerTons2__Pin' for type 'ns2:Pin' */
#ifndef SOAP_TYPE_PointerTons2__Pin
#define SOAP_TYPE_PointerTons2__Pin (639)
#endif

/* ns2__Pos * has binding name 'PointerTons2__Pos' for type 'ns2:Pos' */
#ifndef SOAP_TYPE_PointerTons2__Pos
#define SOAP_TYPE_PointerTons2__Pos (638)
#endif

/* ns2__DCC * has binding name 'PointerTons2__DCC' for type 'ns2:DCC' */
#ifndef SOAP_TYPE_PointerTons2__DCC
#define SOAP_TYPE_PointerTons2__DCC (637)
#endif

/* ns2__FundingTotals * has binding name 'PointerTons2__FundingTotals' for type 'ns2:FundingTotals' */
#ifndef SOAP_TYPE_PointerTons2__FundingTotals
#define SOAP_TYPE_PointerTons2__FundingTotals (636)
#endif

/* ns2__PurchaseTotals * has binding name 'PointerTons2__PurchaseTotals' for type 'ns2:PurchaseTotals' */
#ifndef SOAP_TYPE_PointerTons2__PurchaseTotals
#define SOAP_TYPE_PointerTons2__PurchaseTotals (635)
#endif

/* ns2__ShipFrom * has binding name 'PointerTons2__ShipFrom' for type 'ns2:ShipFrom' */
#ifndef SOAP_TYPE_PointerTons2__ShipFrom
#define SOAP_TYPE_PointerTons2__ShipFrom (633)
#endif

/* ns2__PersonalID * has binding name 'PointerTons2__PersonalID' for type 'ns2:PersonalID' */
#ifndef SOAP_TYPE_PointerTons2__PersonalID
#define SOAP_TYPE_PointerTons2__PersonalID (632)
#endif

/* ns2__ShipTo * has binding name 'PointerTons2__ShipTo' for type 'ns2:ShipTo' */
#ifndef SOAP_TYPE_PointerTons2__ShipTo
#define SOAP_TYPE_PointerTons2__ShipTo (631)
#endif

/* ns2__BillTo * has binding name 'PointerTons2__BillTo' for type 'ns2:BillTo' */
#ifndef SOAP_TYPE_PointerTons2__BillTo
#define SOAP_TYPE_PointerTons2__BillTo (630)
#endif

/* ns2__InvoiceHeader * has binding name 'PointerTons2__InvoiceHeader' for type 'ns2:InvoiceHeader' */
#ifndef SOAP_TYPE_PointerTons2__InvoiceHeader
#define SOAP_TYPE_PointerTons2__InvoiceHeader (629)
#endif

/* ns2__APDevice * has binding name 'PointerTons2__APDevice' for type 'ns2:APDevice' */
#ifndef SOAP_TYPE_PointerTons2__APDevice
#define SOAP_TYPE_PointerTons2__APDevice (628)
#endif

/* ns2__DecisionManagerTravelData * has binding name 'PointerTons2__DecisionManagerTravelData' for type 'ns2:DecisionManagerTravelData' */
#ifndef SOAP_TYPE_PointerTons2__DecisionManagerTravelData
#define SOAP_TYPE_PointerTons2__DecisionManagerTravelData (625)
#endif

/* ns2__Authentication * has binding name 'PointerTons2__Authentication' for type 'ns2:Authentication' */
#ifndef SOAP_TYPE_PointerTons2__Authentication
#define SOAP_TYPE_PointerTons2__Authentication (624)
#endif

/* ns2__PaySubscriptionEvent * has binding name 'PointerTons2__PaySubscriptionEvent' for type 'ns2:PaySubscriptionEvent' */
#ifndef SOAP_TYPE_PointerTons2__PaySubscriptionEvent
#define SOAP_TYPE_PointerTons2__PaySubscriptionEvent (623)
#endif

/* ns2__Address * has binding name 'PointerTons2__Address' for type 'ns2:Address' */
#ifndef SOAP_TYPE_PointerTons2__Address
#define SOAP_TYPE_PointerTons2__Address (620)
#endif

/* std::string * has binding name 'PointerTons2__dateTime' for type 'ns2:dateTime' */
#ifndef SOAP_TYPE_PointerTons2__dateTime
#define SOAP_TYPE_PointerTons2__dateTime (619)
#endif

/* std::string * has binding name 'PointerToxsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_PointerToxsd__integer
#define SOAP_TYPE_PointerToxsd__integer (617)
#endif

/* std::string * has binding name 'PointerTons2__boolean' for type 'ns2:boolean' */
#ifndef SOAP_TYPE_PointerTons2__boolean
#define SOAP_TYPE_PointerTons2__boolean (616)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (615)
#endif

/* std::string * has binding name 'PointerTons2__amount' for type 'ns2:amount' */
#ifndef SOAP_TYPE_PointerTons2__amount
#define SOAP_TYPE_PointerTons2__amount (614)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerTounsignedByte
#define SOAP_TYPE_PointerTounsignedByte (279)
#endif

/* struct _wsse__Security * has binding name 'PointerTo_wsse__Security' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Security
#define SOAP_TYPE_PointerTo_wsse__Security (275)
#endif

/* struct ds__SignatureType * has binding name 'PointerTods__SignatureType' for type 'ds:SignatureType' */
#ifndef SOAP_TYPE_PointerTods__SignatureType
#define SOAP_TYPE_PointerTods__SignatureType (273)
#endif

/* struct wsc__SecurityContextTokenType * has binding name 'PointerTowsc__SecurityContextTokenType' for type 'wsc:SecurityContextTokenType' */
#ifndef SOAP_TYPE_PointerTowsc__SecurityContextTokenType
#define SOAP_TYPE_PointerTowsc__SecurityContextTokenType (272)
#endif

/* struct _wsse__BinarySecurityToken * has binding name 'PointerTo_wsse__BinarySecurityToken' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__BinarySecurityToken
#define SOAP_TYPE_PointerTo_wsse__BinarySecurityToken (271)
#endif

/* struct _wsse__UsernameToken * has binding name 'PointerTo_wsse__UsernameToken' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__UsernameToken
#define SOAP_TYPE_PointerTo_wsse__UsernameToken (270)
#endif

/* struct _wsu__Timestamp * has binding name 'PointerTo_wsu__Timestamp' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsu__Timestamp
#define SOAP_TYPE_PointerTo_wsu__Timestamp (269)
#endif

/* _saml2__AttributeValue has binding name '_saml2__AttributeValue' for type '' */
#ifndef SOAP_TYPE__saml2__AttributeValue
#define SOAP_TYPE__saml2__AttributeValue (266)
#endif

/* _saml2__AuthenticatingAuthority has binding name '_saml2__AuthenticatingAuthority' for type '' */
#ifndef SOAP_TYPE__saml2__AuthenticatingAuthority
#define SOAP_TYPE__saml2__AuthenticatingAuthority (260)
#endif

/* _saml2__AuthnContextDecl has binding name '_saml2__AuthnContextDecl' for type '' */
#ifndef SOAP_TYPE__saml2__AuthnContextDecl
#define SOAP_TYPE__saml2__AuthnContextDecl (259)
#endif

/* _saml2__AuthnContextDeclRef has binding name '_saml2__AuthnContextDeclRef' for type '' */
#ifndef SOAP_TYPE__saml2__AuthnContextDeclRef
#define SOAP_TYPE__saml2__AuthnContextDeclRef (258)
#endif

/* _saml2__AuthnContextClassRef has binding name '_saml2__AuthnContextClassRef' for type '' */
#ifndef SOAP_TYPE__saml2__AuthnContextClassRef
#define SOAP_TYPE__saml2__AuthnContextClassRef (257)
#endif

/* _saml2__Audience has binding name '_saml2__Audience' for type '' */
#ifndef SOAP_TYPE__saml2__Audience
#define SOAP_TYPE__saml2__Audience (248)
#endif

/* _saml2__AssertionURIRef has binding name '_saml2__AssertionURIRef' for type '' */
#ifndef SOAP_TYPE__saml2__AssertionURIRef
#define SOAP_TYPE__saml2__AssertionURIRef (240)
#endif

/* _saml2__AssertionIDRef has binding name '_saml2__AssertionIDRef' for type '' */
#ifndef SOAP_TYPE__saml2__AssertionIDRef
#define SOAP_TYPE__saml2__AssertionIDRef (239)
#endif

/* struct ds__KeyInfoType ** has binding name 'PointerToPointerTo_ds__KeyInfo' for type '' */
#ifndef SOAP_TYPE_PointerToPointerTo_ds__KeyInfo
#define SOAP_TYPE_PointerToPointerTo_ds__KeyInfo (234)
#endif

/* struct __saml2__union_AttributeStatementType * has binding name 'PointerTo__saml2__union_AttributeStatementType' for type '-saml2:union-AttributeStatementType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_AttributeStatementType
#define SOAP_TYPE_PointerTo__saml2__union_AttributeStatementType (233)
#endif

/* struct saml2__AttributeType * has binding name 'PointerTosaml2__AttributeType' for type 'saml2:AttributeType' */
#ifndef SOAP_TYPE_PointerTosaml2__AttributeType
#define SOAP_TYPE_PointerTosaml2__AttributeType (232)
#endif

/* struct saml2__EvidenceType * has binding name 'PointerTosaml2__EvidenceType' for type 'saml2:EvidenceType' */
#ifndef SOAP_TYPE_PointerTosaml2__EvidenceType
#define SOAP_TYPE_PointerTosaml2__EvidenceType (230)
#endif

/* struct saml2__ActionType * has binding name 'PointerTosaml2__ActionType' for type 'saml2:ActionType' */
#ifndef SOAP_TYPE_PointerTosaml2__ActionType
#define SOAP_TYPE_PointerTosaml2__ActionType (229)
#endif

/* struct saml2__AuthnContextType * has binding name 'PointerTosaml2__AuthnContextType' for type 'saml2:AuthnContextType' */
#ifndef SOAP_TYPE_PointerTosaml2__AuthnContextType
#define SOAP_TYPE_PointerTosaml2__AuthnContextType (228)
#endif

/* struct saml2__SubjectLocalityType * has binding name 'PointerTosaml2__SubjectLocalityType' for type 'saml2:SubjectLocalityType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectLocalityType
#define SOAP_TYPE_PointerTosaml2__SubjectLocalityType (227)
#endif

/* struct __saml2__union_EvidenceType * has binding name 'PointerTo__saml2__union_EvidenceType' for type '-saml2:union-EvidenceType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_EvidenceType
#define SOAP_TYPE_PointerTo__saml2__union_EvidenceType (226)
#endif

/* struct __saml2__union_AdviceType * has binding name 'PointerTo__saml2__union_AdviceType' for type '-saml2:union-AdviceType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_AdviceType
#define SOAP_TYPE_PointerTo__saml2__union_AdviceType (224)
#endif

/* struct saml2__AssertionType * has binding name 'PointerTosaml2__AssertionType' for type 'saml2:AssertionType' */
#ifndef SOAP_TYPE_PointerTosaml2__AssertionType
#define SOAP_TYPE_PointerTosaml2__AssertionType (223)
#endif

/* struct __saml2__union_ConditionsType * has binding name 'PointerTo__saml2__union_ConditionsType' for type '-saml2:union-ConditionsType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_ConditionsType
#define SOAP_TYPE_PointerTo__saml2__union_ConditionsType (221)
#endif

/* struct saml2__ProxyRestrictionType * has binding name 'PointerTosaml2__ProxyRestrictionType' for type 'saml2:ProxyRestrictionType' */
#ifndef SOAP_TYPE_PointerTosaml2__ProxyRestrictionType
#define SOAP_TYPE_PointerTosaml2__ProxyRestrictionType (220)
#endif

/* struct saml2__OneTimeUseType * has binding name 'PointerTosaml2__OneTimeUseType' for type 'saml2:OneTimeUseType' */
#ifndef SOAP_TYPE_PointerTosaml2__OneTimeUseType
#define SOAP_TYPE_PointerTosaml2__OneTimeUseType (219)
#endif

/* struct saml2__AudienceRestrictionType * has binding name 'PointerTosaml2__AudienceRestrictionType' for type 'saml2:AudienceRestrictionType' */
#ifndef SOAP_TYPE_PointerTosaml2__AudienceRestrictionType
#define SOAP_TYPE_PointerTosaml2__AudienceRestrictionType (218)
#endif

/* struct saml2__ConditionAbstractType * has binding name 'PointerTosaml2__ConditionAbstractType' for type 'saml2:ConditionAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml2__ConditionAbstractType
#define SOAP_TYPE_PointerTosaml2__ConditionAbstractType (217)
#endif

/* struct saml2__SubjectConfirmationDataType * has binding name 'PointerTosaml2__SubjectConfirmationDataType' for type 'saml2:SubjectConfirmationDataType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectConfirmationDataType
#define SOAP_TYPE_PointerTosaml2__SubjectConfirmationDataType (215)
#endif

/* struct saml2__SubjectConfirmationType * has binding name 'PointerTosaml2__SubjectConfirmationType' for type 'saml2:SubjectConfirmationType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectConfirmationType
#define SOAP_TYPE_PointerTosaml2__SubjectConfirmationType (214)
#endif

/* struct saml2__EncryptedElementType * has binding name 'PointerTosaml2__EncryptedElementType' for type 'saml2:EncryptedElementType' */
#ifndef SOAP_TYPE_PointerTosaml2__EncryptedElementType
#define SOAP_TYPE_PointerTosaml2__EncryptedElementType (213)
#endif

/* struct saml2__BaseIDAbstractType * has binding name 'PointerTosaml2__BaseIDAbstractType' for type 'saml2:BaseIDAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml2__BaseIDAbstractType
#define SOAP_TYPE_PointerTosaml2__BaseIDAbstractType (212)
#endif

/* struct __saml2__union_AssertionType * has binding name 'PointerTo__saml2__union_AssertionType' for type '-saml2:union-AssertionType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_AssertionType
#define SOAP_TYPE_PointerTo__saml2__union_AssertionType (211)
#endif

/* struct saml2__AttributeStatementType * has binding name 'PointerTosaml2__AttributeStatementType' for type 'saml2:AttributeStatementType' */
#ifndef SOAP_TYPE_PointerTosaml2__AttributeStatementType
#define SOAP_TYPE_PointerTosaml2__AttributeStatementType (210)
#endif

/* struct saml2__AuthzDecisionStatementType * has binding name 'PointerTosaml2__AuthzDecisionStatementType' for type 'saml2:AuthzDecisionStatementType' */
#ifndef SOAP_TYPE_PointerTosaml2__AuthzDecisionStatementType
#define SOAP_TYPE_PointerTosaml2__AuthzDecisionStatementType (209)
#endif

/* struct saml2__AuthnStatementType * has binding name 'PointerTosaml2__AuthnStatementType' for type 'saml2:AuthnStatementType' */
#ifndef SOAP_TYPE_PointerTosaml2__AuthnStatementType
#define SOAP_TYPE_PointerTosaml2__AuthnStatementType (208)
#endif

/* struct saml2__StatementAbstractType * has binding name 'PointerTosaml2__StatementAbstractType' for type 'saml2:StatementAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml2__StatementAbstractType
#define SOAP_TYPE_PointerTosaml2__StatementAbstractType (207)
#endif

/* struct saml2__AdviceType * has binding name 'PointerTosaml2__AdviceType' for type 'saml2:AdviceType' */
#ifndef SOAP_TYPE_PointerTosaml2__AdviceType
#define SOAP_TYPE_PointerTosaml2__AdviceType (205)
#endif

/* struct saml2__ConditionsType * has binding name 'PointerTosaml2__ConditionsType' for type 'saml2:ConditionsType' */
#ifndef SOAP_TYPE_PointerTosaml2__ConditionsType
#define SOAP_TYPE_PointerTosaml2__ConditionsType (204)
#endif

/* struct saml2__SubjectType * has binding name 'PointerTosaml2__SubjectType' for type 'saml2:SubjectType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectType
#define SOAP_TYPE_PointerTosaml2__SubjectType (203)
#endif

/* struct saml2__NameIDType * has binding name 'PointerTosaml2__NameIDType' for type 'saml2:NameIDType' */
#ifndef SOAP_TYPE_PointerTosaml2__NameIDType
#define SOAP_TYPE_PointerTosaml2__NameIDType (202)
#endif

/* struct xenc__EncryptedKeyType ** has binding name 'PointerToPointerToxenc__EncryptedKeyType' for type 'xenc:EncryptedKeyType' */
#ifndef SOAP_TYPE_PointerToPointerToxenc__EncryptedKeyType
#define SOAP_TYPE_PointerToPointerToxenc__EncryptedKeyType (201)
#endif

/* _saml1__AttributeValue has binding name '_saml1__AttributeValue' for type '' */
#ifndef SOAP_TYPE__saml1__AttributeValue
#define SOAP_TYPE__saml1__AttributeValue (176)
#endif

/* _saml1__ConfirmationMethod has binding name '_saml1__ConfirmationMethod' for type '' */
#ifndef SOAP_TYPE__saml1__ConfirmationMethod
#define SOAP_TYPE__saml1__ConfirmationMethod (166)
#endif

/* _saml1__SubjectConfirmationData has binding name '_saml1__SubjectConfirmationData' for type '' */
#ifndef SOAP_TYPE__saml1__SubjectConfirmationData
#define SOAP_TYPE__saml1__SubjectConfirmationData (165)
#endif

/* _saml1__Audience has binding name '_saml1__Audience' for type '' */
#ifndef SOAP_TYPE__saml1__Audience
#define SOAP_TYPE__saml1__Audience (157)
#endif

/* _saml1__AssertionIDReference has binding name '_saml1__AssertionIDReference' for type '' */
#ifndef SOAP_TYPE__saml1__AssertionIDReference
#define SOAP_TYPE__saml1__AssertionIDReference (152)
#endif

/* struct saml1__AttributeType * has binding name 'PointerTosaml1__AttributeType' for type 'saml1:AttributeType' */
#ifndef SOAP_TYPE_PointerTosaml1__AttributeType
#define SOAP_TYPE_PointerTosaml1__AttributeType (151)
#endif

/* struct saml1__EvidenceType * has binding name 'PointerTosaml1__EvidenceType' for type 'saml1:EvidenceType' */
#ifndef SOAP_TYPE_PointerTosaml1__EvidenceType
#define SOAP_TYPE_PointerTosaml1__EvidenceType (150)
#endif

/* struct saml1__ActionType * has binding name 'PointerTosaml1__ActionType' for type 'saml1:ActionType' */
#ifndef SOAP_TYPE_PointerTosaml1__ActionType
#define SOAP_TYPE_PointerTosaml1__ActionType (149)
#endif

/* struct saml1__AuthorityBindingType * has binding name 'PointerTosaml1__AuthorityBindingType' for type 'saml1:AuthorityBindingType' */
#ifndef SOAP_TYPE_PointerTosaml1__AuthorityBindingType
#define SOAP_TYPE_PointerTosaml1__AuthorityBindingType (148)
#endif

/* struct saml1__SubjectLocalityType * has binding name 'PointerTosaml1__SubjectLocalityType' for type 'saml1:SubjectLocalityType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectLocalityType
#define SOAP_TYPE_PointerTosaml1__SubjectLocalityType (147)
#endif

/* char ** has binding name 'PointerTo_XML' for type '' */
#ifndef SOAP_TYPE_PointerTo_XML
#define SOAP_TYPE_PointerTo_XML (146)
#endif

/* struct saml1__SubjectType * has binding name 'PointerTosaml1__SubjectType' for type 'saml1:SubjectType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectType
#define SOAP_TYPE_PointerTosaml1__SubjectType (145)
#endif

/* struct __saml1__union_EvidenceType * has binding name 'PointerTo__saml1__union_EvidenceType' for type '-saml1:union-EvidenceType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_EvidenceType
#define SOAP_TYPE_PointerTo__saml1__union_EvidenceType (144)
#endif

/* char ** has binding name 'PointerTostring' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostring
#define SOAP_TYPE_PointerTostring (142)
#endif

/* struct saml1__SubjectConfirmationType * has binding name 'PointerTosaml1__SubjectConfirmationType' for type 'saml1:SubjectConfirmationType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectConfirmationType
#define SOAP_TYPE_PointerTosaml1__SubjectConfirmationType (141)
#endif

/* struct saml1__NameIdentifierType * has binding name 'PointerTosaml1__NameIdentifierType' for type 'saml1:NameIdentifierType' */
#ifndef SOAP_TYPE_PointerTosaml1__NameIdentifierType
#define SOAP_TYPE_PointerTosaml1__NameIdentifierType (140)
#endif

/* struct __saml1__union_AdviceType * has binding name 'PointerTo__saml1__union_AdviceType' for type '-saml1:union-AdviceType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_AdviceType
#define SOAP_TYPE_PointerTo__saml1__union_AdviceType (139)
#endif

/* struct saml1__AssertionType * has binding name 'PointerTosaml1__AssertionType' for type 'saml1:AssertionType' */
#ifndef SOAP_TYPE_PointerTosaml1__AssertionType
#define SOAP_TYPE_PointerTosaml1__AssertionType (138)
#endif

/* struct timeval * has binding name 'PointerToxsd__dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_PointerToxsd__dateTime
#define SOAP_TYPE_PointerToxsd__dateTime (136)
#endif

/* struct __saml1__union_ConditionsType * has binding name 'PointerTo__saml1__union_ConditionsType' for type '-saml1:union-ConditionsType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_ConditionsType
#define SOAP_TYPE_PointerTo__saml1__union_ConditionsType (135)
#endif

/* struct saml1__ConditionAbstractType * has binding name 'PointerTosaml1__ConditionAbstractType' for type 'saml1:ConditionAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml1__ConditionAbstractType
#define SOAP_TYPE_PointerTosaml1__ConditionAbstractType (134)
#endif

/* struct saml1__DoNotCacheConditionType * has binding name 'PointerTosaml1__DoNotCacheConditionType' for type 'saml1:DoNotCacheConditionType' */
#ifndef SOAP_TYPE_PointerTosaml1__DoNotCacheConditionType
#define SOAP_TYPE_PointerTosaml1__DoNotCacheConditionType (133)
#endif

/* struct saml1__AudienceRestrictionConditionType * has binding name 'PointerTosaml1__AudienceRestrictionConditionType' for type 'saml1:AudienceRestrictionConditionType' */
#ifndef SOAP_TYPE_PointerTosaml1__AudienceRestrictionConditionType
#define SOAP_TYPE_PointerTosaml1__AudienceRestrictionConditionType (132)
#endif

/* struct ds__SignatureType * has binding name 'PointerTo_ds__Signature' for type '' */
#ifndef SOAP_TYPE_PointerTo_ds__Signature
#define SOAP_TYPE_PointerTo_ds__Signature (130)
#endif

/* struct __saml1__union_AssertionType * has binding name 'PointerTo__saml1__union_AssertionType' for type '-saml1:union-AssertionType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_AssertionType
#define SOAP_TYPE_PointerTo__saml1__union_AssertionType (129)
#endif

/* struct saml1__AttributeStatementType * has binding name 'PointerTosaml1__AttributeStatementType' for type 'saml1:AttributeStatementType' */
#ifndef SOAP_TYPE_PointerTosaml1__AttributeStatementType
#define SOAP_TYPE_PointerTosaml1__AttributeStatementType (128)
#endif

/* struct saml1__AuthorizationDecisionStatementType * has binding name 'PointerTosaml1__AuthorizationDecisionStatementType' for type 'saml1:AuthorizationDecisionStatementType' */
#ifndef SOAP_TYPE_PointerTosaml1__AuthorizationDecisionStatementType
#define SOAP_TYPE_PointerTosaml1__AuthorizationDecisionStatementType (127)
#endif

/* struct saml1__AuthenticationStatementType * has binding name 'PointerTosaml1__AuthenticationStatementType' for type 'saml1:AuthenticationStatementType' */
#ifndef SOAP_TYPE_PointerTosaml1__AuthenticationStatementType
#define SOAP_TYPE_PointerTosaml1__AuthenticationStatementType (126)
#endif

/* struct saml1__SubjectStatementAbstractType * has binding name 'PointerTosaml1__SubjectStatementAbstractType' for type 'saml1:SubjectStatementAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectStatementAbstractType
#define SOAP_TYPE_PointerTosaml1__SubjectStatementAbstractType (125)
#endif

/* struct saml1__StatementAbstractType * has binding name 'PointerTosaml1__StatementAbstractType' for type 'saml1:StatementAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml1__StatementAbstractType
#define SOAP_TYPE_PointerTosaml1__StatementAbstractType (124)
#endif

/* struct saml1__AdviceType * has binding name 'PointerTosaml1__AdviceType' for type 'saml1:AdviceType' */
#ifndef SOAP_TYPE_PointerTosaml1__AdviceType
#define SOAP_TYPE_PointerTosaml1__AdviceType (122)
#endif

/* struct saml1__ConditionsType * has binding name 'PointerTosaml1__ConditionsType' for type 'saml1:ConditionsType' */
#ifndef SOAP_TYPE_PointerTosaml1__ConditionsType
#define SOAP_TYPE_PointerTosaml1__ConditionsType (121)
#endif

/* struct __wsc__DerivedKeyTokenType_sequence * has binding name 'PointerTo__wsc__DerivedKeyTokenType_sequence' for type '-wsc:DerivedKeyTokenType-sequence' */
#ifndef SOAP_TYPE_PointerTo__wsc__DerivedKeyTokenType_sequence
#define SOAP_TYPE_PointerTo__wsc__DerivedKeyTokenType_sequence (97)
#endif

/* ULONG64 * has binding name 'PointerToULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_PointerToULONG64
#define SOAP_TYPE_PointerToULONG64 (96)
#endif

/* struct wsc__PropertiesType * has binding name 'PointerTowsc__PropertiesType' for type 'wsc:PropertiesType' */
#ifndef SOAP_TYPE_PointerTowsc__PropertiesType
#define SOAP_TYPE_PointerTowsc__PropertiesType (92)
#endif

/* wsc__FaultCodeOpenEnumType has binding name 'wsc__FaultCodeOpenEnumType' for type 'wsc:FaultCodeOpenEnumType' */
#ifndef SOAP_TYPE_wsc__FaultCodeOpenEnumType
#define SOAP_TYPE_wsc__FaultCodeOpenEnumType (87)
#endif

/* struct _xenc__ReferenceList * has binding name 'PointerTo_xenc__ReferenceList' for type '' */
#ifndef SOAP_TYPE_PointerTo_xenc__ReferenceList
#define SOAP_TYPE_PointerTo_xenc__ReferenceList (86)
#endif

/* struct __xenc__union_ReferenceList * has binding name 'PointerTo__xenc__union_ReferenceList' for type '-xenc:union-ReferenceList' */
#ifndef SOAP_TYPE_PointerTo__xenc__union_ReferenceList
#define SOAP_TYPE_PointerTo__xenc__union_ReferenceList (85)
#endif

/* struct xenc__ReferenceType * has binding name 'PointerToxenc__ReferenceType' for type 'xenc:ReferenceType' */
#ifndef SOAP_TYPE_PointerToxenc__ReferenceType
#define SOAP_TYPE_PointerToxenc__ReferenceType (84)
#endif

/* struct xenc__EncryptionPropertyType * has binding name 'PointerToxenc__EncryptionPropertyType' for type 'xenc:EncryptionPropertyType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptionPropertyType
#define SOAP_TYPE_PointerToxenc__EncryptionPropertyType (82)
#endif

/* struct xenc__TransformsType * has binding name 'PointerToxenc__TransformsType' for type 'xenc:TransformsType' */
#ifndef SOAP_TYPE_PointerToxenc__TransformsType
#define SOAP_TYPE_PointerToxenc__TransformsType (81)
#endif

/* struct xenc__CipherReferenceType * has binding name 'PointerToxenc__CipherReferenceType' for type 'xenc:CipherReferenceType' */
#ifndef SOAP_TYPE_PointerToxenc__CipherReferenceType
#define SOAP_TYPE_PointerToxenc__CipherReferenceType (80)
#endif

/* struct xenc__EncryptionPropertiesType * has binding name 'PointerToxenc__EncryptionPropertiesType' for type 'xenc:EncryptionPropertiesType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptionPropertiesType
#define SOAP_TYPE_PointerToxenc__EncryptionPropertiesType (79)
#endif

/* struct xenc__CipherDataType * has binding name 'PointerToxenc__CipherDataType' for type 'xenc:CipherDataType' */
#ifndef SOAP_TYPE_PointerToxenc__CipherDataType
#define SOAP_TYPE_PointerToxenc__CipherDataType (78)
#endif

/* struct ds__KeyInfoType * has binding name 'PointerTo_ds__KeyInfo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ds__KeyInfo
#define SOAP_TYPE_PointerTo_ds__KeyInfo (77)
#endif

/* struct xenc__EncryptionMethodType * has binding name 'PointerToxenc__EncryptionMethodType' for type 'xenc:EncryptionMethodType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptionMethodType
#define SOAP_TYPE_PointerToxenc__EncryptionMethodType (76)
#endif

/* struct ds__X509IssuerSerialType * has binding name 'PointerTods__X509IssuerSerialType' for type 'ds:X509IssuerSerialType' */
#ifndef SOAP_TYPE_PointerTods__X509IssuerSerialType
#define SOAP_TYPE_PointerTods__X509IssuerSerialType (64)
#endif

/* struct ds__RSAKeyValueType * has binding name 'PointerTods__RSAKeyValueType' for type 'ds:RSAKeyValueType' */
#ifndef SOAP_TYPE_PointerTods__RSAKeyValueType
#define SOAP_TYPE_PointerTods__RSAKeyValueType (63)
#endif

/* struct ds__DSAKeyValueType * has binding name 'PointerTods__DSAKeyValueType' for type 'ds:DSAKeyValueType' */
#ifndef SOAP_TYPE_PointerTods__DSAKeyValueType
#define SOAP_TYPE_PointerTods__DSAKeyValueType (62)
#endif

/* struct ds__TransformType * has binding name 'PointerTods__TransformType' for type 'ds:TransformType' */
#ifndef SOAP_TYPE_PointerTods__TransformType
#define SOAP_TYPE_PointerTods__TransformType (61)
#endif

/* struct ds__DigestMethodType * has binding name 'PointerTods__DigestMethodType' for type 'ds:DigestMethodType' */
#ifndef SOAP_TYPE_PointerTods__DigestMethodType
#define SOAP_TYPE_PointerTods__DigestMethodType (60)
#endif

/* struct ds__TransformsType * has binding name 'PointerTods__TransformsType' for type 'ds:TransformsType' */
#ifndef SOAP_TYPE_PointerTods__TransformsType
#define SOAP_TYPE_PointerTods__TransformsType (59)
#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_PointerToint
#define SOAP_TYPE_PointerToint (58)
#endif

/* struct ds__ReferenceType ** has binding name 'PointerToPointerTods__ReferenceType' for type 'ds:ReferenceType' */
#ifndef SOAP_TYPE_PointerToPointerTods__ReferenceType
#define SOAP_TYPE_PointerToPointerTods__ReferenceType (57)
#endif

/* struct ds__ReferenceType * has binding name 'PointerTods__ReferenceType' for type 'ds:ReferenceType' */
#ifndef SOAP_TYPE_PointerTods__ReferenceType
#define SOAP_TYPE_PointerTods__ReferenceType (56)
#endif

/* struct ds__SignatureMethodType * has binding name 'PointerTods__SignatureMethodType' for type 'ds:SignatureMethodType' */
#ifndef SOAP_TYPE_PointerTods__SignatureMethodType
#define SOAP_TYPE_PointerTods__SignatureMethodType (55)
#endif

/* struct ds__CanonicalizationMethodType * has binding name 'PointerTods__CanonicalizationMethodType' for type 'ds:CanonicalizationMethodType' */
#ifndef SOAP_TYPE_PointerTods__CanonicalizationMethodType
#define SOAP_TYPE_PointerTods__CanonicalizationMethodType (54)
#endif

/* struct _wsse__SecurityTokenReference * has binding name 'PointerTo_wsse__SecurityTokenReference' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__SecurityTokenReference
#define SOAP_TYPE_PointerTo_wsse__SecurityTokenReference (49)
#endif

/* struct ds__RetrievalMethodType * has binding name 'PointerTods__RetrievalMethodType' for type 'ds:RetrievalMethodType' */
#ifndef SOAP_TYPE_PointerTods__RetrievalMethodType
#define SOAP_TYPE_PointerTods__RetrievalMethodType (48)
#endif

/* struct ds__KeyValueType * has binding name 'PointerTods__KeyValueType' for type 'ds:KeyValueType' */
#ifndef SOAP_TYPE_PointerTods__KeyValueType
#define SOAP_TYPE_PointerTods__KeyValueType (46)
#endif

/* struct _c14n__InclusiveNamespaces * has binding name 'PointerTo_c14n__InclusiveNamespaces' for type '' */
#ifndef SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces
#define SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces (42)
#endif

/* struct ds__KeyInfoType * has binding name 'PointerTods__KeyInfoType' for type 'ds:KeyInfoType' */
#ifndef SOAP_TYPE_PointerTods__KeyInfoType
#define SOAP_TYPE_PointerTods__KeyInfoType (34)
#endif

/* struct ds__SignedInfoType * has binding name 'PointerTods__SignedInfoType' for type 'ds:SignedInfoType' */
#ifndef SOAP_TYPE_PointerTods__SignedInfoType
#define SOAP_TYPE_PointerTods__SignedInfoType (33)
#endif

/* _ds__SignatureValue has binding name '_ds__SignatureValue' for type '' */
#ifndef SOAP_TYPE__ds__SignatureValue
#define SOAP_TYPE__ds__SignatureValue (30)
#endif

/* struct xenc__EncryptedKeyType * has binding name 'PointerToxenc__EncryptedKeyType' for type 'xenc:EncryptedKeyType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptedKeyType
#define SOAP_TYPE_PointerToxenc__EncryptedKeyType (29)
#endif

/* struct ds__X509DataType * has binding name 'PointerTods__X509DataType' for type 'ds:X509DataType' */
#ifndef SOAP_TYPE_PointerTods__X509DataType
#define SOAP_TYPE_PointerTods__X509DataType (26)
#endif

/* struct _wsse__Embedded * has binding name 'PointerTo_wsse__Embedded' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Embedded
#define SOAP_TYPE_PointerTo_wsse__Embedded (24)
#endif

/* struct _wsse__KeyIdentifier * has binding name 'PointerTo_wsse__KeyIdentifier' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__KeyIdentifier
#define SOAP_TYPE_PointerTo_wsse__KeyIdentifier (23)
#endif

/* struct _wsse__Reference * has binding name 'PointerTo_wsse__Reference' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Reference
#define SOAP_TYPE_PointerTo_wsse__Reference (22)
#endif

/* unsigned int * has binding name 'PointerTounsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_PointerTounsignedInt
#define SOAP_TYPE_PointerTounsignedInt (16)
#endif

/* struct wsse__EncodedString * has binding name 'PointerTowsse__EncodedString' for type 'wsse:EncodedString' */
#ifndef SOAP_TYPE_PointerTowsse__EncodedString
#define SOAP_TYPE_PointerTowsse__EncodedString (14)
#endif

/* struct _wsse__Password * has binding name 'PointerTo_wsse__Password' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Password
#define SOAP_TYPE_PointerTo_wsse__Password (13)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<ns2__PauseRuleResultItem>  has binding name 'std__vectorTemplateOfns2__PauseRuleResultItem' for type 'ns2:PauseRuleResultItem' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__PauseRuleResultItem
#define SOAP_TYPE_std__vectorTemplateOfns2__PauseRuleResultItem (947)
#endif

/* std::vector<ns2__PaypalTransaction>  has binding name 'std__vectorTemplateOfns2__PaypalTransaction' for type 'ns2:PaypalTransaction' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__PaypalTransaction
#define SOAP_TYPE_std__vectorTemplateOfns2__PaypalTransaction (942)
#endif

/* std::vector<ns2__AuxiliaryField>  has binding name 'std__vectorTemplateOfns2__AuxiliaryField' for type 'ns2:AuxiliaryField' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__AuxiliaryField
#define SOAP_TYPE_std__vectorTemplateOfns2__AuxiliaryField (941)
#endif

/* std::vector<ns2__MDDField>  has binding name 'std__vectorTemplateOfns2__MDDField' for type 'ns2:MDDField' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__MDDField
#define SOAP_TYPE_std__vectorTemplateOfns2__MDDField (940)
#endif

/* std::vector<ns2__Service>  has binding name 'std__vectorTemplateOfns2__Service' for type 'ns2:Service' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__Service
#define SOAP_TYPE_std__vectorTemplateOfns2__Service (939)
#endif

/* std::vector<ns2__Leg>  has binding name 'std__vectorTemplateOfns2__Leg' for type 'ns2:Leg' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__Leg
#define SOAP_TYPE_std__vectorTemplateOfns2__Leg (938)
#endif

/* std::vector<ns2__Passenger>  has binding name 'std__vectorTemplateOfns2__Passenger' for type 'ns2:Passenger' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__Passenger
#define SOAP_TYPE_std__vectorTemplateOfns2__Passenger (937)
#endif

/* std::vector<ns2__BalanceInfo>  has binding name 'std__vectorTemplateOfns2__BalanceInfo' for type 'ns2:BalanceInfo' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__BalanceInfo
#define SOAP_TYPE_std__vectorTemplateOfns2__BalanceInfo (918)
#endif

/* std::vector<ns2__Network>  has binding name 'std__vectorTemplateOfns2__Network' for type 'ns2:Network' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__Network
#define SOAP_TYPE_std__vectorTemplateOfns2__Network (914)
#endif

/* std::vector<ns2__PromotionGroupReply>  has binding name 'std__vectorTemplateOfns2__PromotionGroupReply' for type 'ns2:PromotionGroupReply' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__PromotionGroupReply
#define SOAP_TYPE_std__vectorTemplateOfns2__PromotionGroupReply (902)
#endif

/* std::vector<ns2__DeniedPartiesMatch>  has binding name 'std__vectorTemplateOfns2__DeniedPartiesMatch' for type 'ns2:DeniedPartiesMatch' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__DeniedPartiesMatch
#define SOAP_TYPE_std__vectorTemplateOfns2__DeniedPartiesMatch (817)
#endif

/* std::vector<ns2__APOptionsOption>  has binding name 'std__vectorTemplateOfns2__APOptionsOption' for type 'ns2:APOptionsOption' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__APOptionsOption
#define SOAP_TYPE_std__vectorTemplateOfns2__APOptionsOption (816)
#endif

/* std::vector<ns2__paymentCurrencyOffer>  has binding name 'std__vectorTemplateOfns2__paymentCurrencyOffer' for type 'ns2:paymentCurrencyOffer' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__paymentCurrencyOffer
#define SOAP_TYPE_std__vectorTemplateOfns2__paymentCurrencyOffer (814)
#endif

/* std::vector<ns2__Element>  has binding name 'std__vectorTemplateOfns2__Element' for type 'ns2:Element' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__Element
#define SOAP_TYPE_std__vectorTemplateOfns2__Element (810)
#endif

/* std::vector<ns2__Field>  has binding name 'std__vectorTemplateOfns2__Field' for type 'ns2:Field' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__Field
#define SOAP_TYPE_std__vectorTemplateOfns2__Field (809)
#endif

/* std::vector<ns2__ProviderField>  has binding name 'std__vectorTemplateOfns2__ProviderField' for type 'ns2:ProviderField' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__ProviderField
#define SOAP_TYPE_std__vectorTemplateOfns2__ProviderField (808)
#endif

/* std::vector<ns2__Provider>  has binding name 'std__vectorTemplateOfns2__Provider' for type 'ns2:Provider' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__Provider
#define SOAP_TYPE_std__vectorTemplateOfns2__Provider (807)
#endif

/* std::vector<ns2__RuleResultItem>  has binding name 'std__vectorTemplateOfns2__RuleResultItem' for type 'ns2:RuleResultItem' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__RuleResultItem
#define SOAP_TYPE_std__vectorTemplateOfns2__RuleResultItem (801)
#endif

/* std::vector<ns2__FXQuote>  has binding name 'std__vectorTemplateOfns2__FXQuote' for type 'ns2:FXQuote' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__FXQuote
#define SOAP_TYPE_std__vectorTemplateOfns2__FXQuote (800)
#endif

/* std::vector<ns2__TaxReplyItem>  has binding name 'std__vectorTemplateOfns2__TaxReplyItem' for type 'ns2:TaxReplyItem' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__TaxReplyItem
#define SOAP_TYPE_std__vectorTemplateOfns2__TaxReplyItem (798)
#endif

/* std::vector<ns2__TaxReplyItemJurisdiction>  has binding name 'std__vectorTemplateOfns2__TaxReplyItemJurisdiction' for type 'ns2:TaxReplyItemJurisdiction' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__TaxReplyItemJurisdiction
#define SOAP_TYPE_std__vectorTemplateOfns2__TaxReplyItemJurisdiction (797)
#endif

/* std::vector<ns2__HealthCare>  has binding name 'std__vectorTemplateOfns2__HealthCare' for type 'ns2:HealthCare' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__HealthCare
#define SOAP_TYPE_std__vectorTemplateOfns2__HealthCare (794)
#endif

/* std::vector<ns2__PromotionGroup>  has binding name 'std__vectorTemplateOfns2__PromotionGroup' for type 'ns2:PromotionGroup' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__PromotionGroup
#define SOAP_TYPE_std__vectorTemplateOfns2__PromotionGroup (770)
#endif

/* std::vector<ns2__RequestReserved>  has binding name 'std__vectorTemplateOfns2__RequestReserved' for type 'ns2:RequestReserved' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__RequestReserved
#define SOAP_TYPE_std__vectorTemplateOfns2__RequestReserved (725)
#endif

/* std::vector<ns2__DeviceFingerprintData>  has binding name 'std__vectorTemplateOfns2__DeviceFingerprintData' for type 'ns2:DeviceFingerprintData' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__DeviceFingerprintData
#define SOAP_TYPE_std__vectorTemplateOfns2__DeviceFingerprintData (702)
#endif

/* std::vector<ns2__Item>  has binding name 'std__vectorTemplateOfns2__Item' for type 'ns2:Item' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__Item
#define SOAP_TYPE_std__vectorTemplateOfns2__Item (634)
#endif

/* std::vector<char *>  has binding name 'std__vectorTemplateOf_XML' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_XML
#define SOAP_TYPE_std__vectorTemplateOf_XML (627)
#endif

/* std::vector<ns2__DecisionManagerTravelLeg>  has binding name 'std__vectorTemplateOfns2__DecisionManagerTravelLeg' for type 'ns2:DecisionManagerTravelLeg' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__DecisionManagerTravelLeg
#define SOAP_TYPE_std__vectorTemplateOfns2__DecisionManagerTravelLeg (626)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__string
#define SOAP_TYPE_std__vectorTemplateOfstd__string (622)
#endif

/* std::vector<ns2__Brands>  has binding name 'std__vectorTemplateOfns2__Brands' for type 'ns2:Brands' */
#ifndef SOAP_TYPE_std__vectorTemplateOfns2__Brands
#define SOAP_TYPE_std__vectorTemplateOfns2__Brands (621)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
